/* automatically generated by rust-bindgen 0.71.1 */

pub const LIBXML_DOTTED_VERSION: &[u8; 7] = b"2.9.14\0";
pub const LIBXML_VERSION: u32 = 20914;
pub const LIBXML_VERSION_STRING: &[u8; 6] = b"20914\0";
pub const LIBXML_VERSION_EXTRA: &[u8; 1] = b"\0";
pub const LIBXML_MODULE_EXTENSION: &[u8; 4] = b".so\0";
pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 40;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const BASE_BUFFER_SIZE: u32 = 4096;
pub const XML_DEFAULT_VERSION: &[u8; 4] = b"1.0\0";
pub const XML_DETECT_IDS: u32 = 2;
pub const XML_COMPLETE_ATTRS: u32 = 4;
pub const XML_SKIP_IDS: u32 = 8;
pub const XML_SAX2_MAGIC: u32 = 3740122799;
pub const _ICONV_H: u32 = 1;
pub const U_DEBUG: u32 = 0;
pub const UCLN_NO_AUTO_CLEANUP: u32 = 1;
pub const U_DISABLE_RENAMING: u32 = 0;
pub const U_NO_DEFAULT_INCLUDE_UTF_HEADERS: u32 = 0;
pub const U_OVERRIDE_CXX_ALLOCATION: u32 = 1;
pub const U_ENABLE_TRACING: u32 = 0;
pub const UCONFIG_ENABLE_PLUGINS: u32 = 0;
pub const U_ENABLE_DYLOAD: u32 = 1;
pub const U_CHECK_DYLOAD: u32 = 1;
pub const U_DEFAULT_SHOW_DRAFT: u32 = 1;
pub const U_LIB_SUFFIX_C_NAME_STRING: &[u8; 1] = b"\0";
pub const UCONFIG_ONLY_COLLATION: u32 = 0;
pub const UCONFIG_NO_FILE_IO: u32 = 0;
pub const UCONFIG_NO_CONVERSION: u32 = 0;
pub const UCONFIG_ONLY_HTML_CONVERSION: u32 = 0;
pub const UCONFIG_NO_LEGACY_CONVERSION: u32 = 0;
pub const UCONFIG_NO_NORMALIZATION: u32 = 0;
pub const UCONFIG_NO_BREAK_ITERATION: u32 = 0;
pub const UCONFIG_NO_IDNA: u32 = 0;
pub const UCONFIG_USE_WINDOWS_LCID_MAPPING_API: u32 = 1;
pub const UCONFIG_NO_COLLATION: u32 = 0;
pub const UCONFIG_NO_FORMATTING: u32 = 0;
pub const UCONFIG_NO_TRANSLITERATION: u32 = 0;
pub const UCONFIG_NO_REGULAR_EXPRESSIONS: u32 = 0;
pub const UCONFIG_NO_SERVICE: u32 = 0;
pub const UCONFIG_HAVE_PARSEALLINPUT: u32 = 1;
pub const UCONFIG_NO_FILTERED_BREAK_ITERATION: u32 = 0;
pub const U_COPYRIGHT_STRING : & [u8 ; 120] = b" Copyright (C) 2016 and later: Unicode, Inc. and others. License & terms of use: http://www.unicode.org/copyright.html \0" ;
pub const U_ICU_VERSION_MAJOR_NUM: u32 = 72;
pub const U_ICU_VERSION_MINOR_NUM: u32 = 1;
pub const U_ICU_VERSION_PATCHLEVEL_NUM: u32 = 0;
pub const U_ICU_VERSION_BUILDLEVEL_NUM: u32 = 0;
pub const U_DISABLE_VERSION_SUFFIX: u32 = 0;
pub const U_ICU_VERSION: &[u8; 5] = b"72.1\0";
pub const U_ICU_VERSION_SHORT: &[u8; 3] = b"72\0";
pub const U_ICU_DATA_VERSION: &[u8; 5] = b"72.1\0";
pub const UCOL_RUNTIME_VERSION: u32 = 9;
pub const UCOL_BUILDER_VERSION: u32 = 9;
pub const UCOL_TAILORINGS_VERSION: u32 = 1;
pub const U_PF_UNKNOWN: u32 = 0;
pub const U_PF_WINDOWS: u32 = 1000;
pub const U_PF_MINGW: u32 = 1800;
pub const U_PF_CYGWIN: u32 = 1900;
pub const U_PF_HPUX: u32 = 2100;
pub const U_PF_SOLARIS: u32 = 2600;
pub const U_PF_BSD: u32 = 3000;
pub const U_PF_AIX: u32 = 3100;
pub const U_PF_IRIX: u32 = 3200;
pub const U_PF_DARWIN: u32 = 3500;
pub const U_PF_IPHONE: u32 = 3550;
pub const U_PF_QNX: u32 = 3700;
pub const U_PF_LINUX: u32 = 4000;
pub const U_PF_BROWSER_NATIVE_CLIENT: u32 = 4020;
pub const U_PF_ANDROID: u32 = 4050;
pub const U_PF_FUCHSIA: u32 = 4100;
pub const U_PF_EMSCRIPTEN: u32 = 5010;
pub const U_PF_OS390: u32 = 9000;
pub const U_PF_OS400: u32 = 9400;
pub const U_PLATFORM: u32 = 4000;
pub const U_PLATFORM_USES_ONLY_WIN32_API: u32 = 0;
pub const U_PLATFORM_HAS_WIN32_API: u32 = 0;
pub const U_PLATFORM_HAS_WINUWP_API: u32 = 0;
pub const U_PLATFORM_IMPLEMENTS_POSIX: u32 = 1;
pub const U_PLATFORM_IS_LINUX_BASED: u32 = 1;
pub const U_PLATFORM_IS_DARWIN_BASED: u32 = 0;
pub const U_HAVE_STDINT_H: u32 = 1;
pub const U_HAVE_INTTYPES_H: u32 = 1;
pub const U_HAVE_PLACEMENT_NEW: u32 = 1;
pub const U_HAVE_DEBUG_LOCATION_NEW: u32 = 0;
pub const U_CPLUSPLUS_VERSION: u32 = 0;
pub const U_ASCII_FAMILY: u32 = 0;
pub const U_EBCDIC_FAMILY: u32 = 1;
pub const U_CHARSET_FAMILY: u32 = 0;
pub const U_CHARSET_IS_UTF8: u32 = 1;
pub const U_HAVE_WCHAR_H: u32 = 1;
pub const U_SIZEOF_WCHAR_T: u32 = 4;
pub const U_HAVE_WCSCPY: u32 = 1;
pub const U_HAVE_CHAR16_T: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const U_DEFINE_FALSE_AND_TRUE: u32 = 0;
pub const U_SIZEOF_UCHAR: u32 = 2;
pub const U_CHAR16_IS_TYPEDEF: u32 = 0;
pub const U_SENTINEL: i32 = -1;
pub const U_COPYRIGHT_STRING_LENGTH: u32 = 128;
pub const U_MAX_VERSION_LENGTH: u32 = 4;
pub const U_VERSION_DELIMITER: u8 = 46u8;
pub const U_MAX_VERSION_STRING_LENGTH: u32 = 20;
pub const U8_LEAD3_T1_BITS: &[u8; 17] = b" 000000000000\x1000\0";
pub const U8_LEAD4_T1_BITS: &[u8; 17] = b"\0\0\0\0\0\0\0\0\x1E\x0F\x0F\x0F\0\0\0\0\0";
pub const U8_MAX_LENGTH: u32 = 4;
pub const U16_SURROGATE_OFFSET: u32 = 56613888;
pub const U16_MAX_LENGTH: u32 = 2;
pub const U_HIDE_OBSOLETE_UTF_OLD_H: u32 = 0;
pub const UTF_SIZE: u32 = 16;
pub const UTF8_ERROR_VALUE_1: u32 = 21;
pub const UTF8_ERROR_VALUE_2: u32 = 159;
pub const UTF_ERROR_VALUE: u32 = 65535;
pub const UTF8_MAX_CHAR_LENGTH: u32 = 4;
pub const UTF_SURROGATE_OFFSET: u32 = 56613888;
pub const UTF16_MAX_CHAR_LENGTH: u32 = 2;
pub const UTF32_MAX_CHAR_LENGTH: u32 = 1;
pub const UTF_MAX_CHAR_LENGTH: u32 = 2;
pub const U_SHOW_CPLUSPLUS_API: u32 = 0;
pub const U_ICUDATA_TYPE_LETTER: &[u8; 2] = b"l\0";
pub const U_ICUDATA_NAME: &[u8; 9] = b"icudt72l\0";
pub const U_USRDATA_NAME: &[u8; 9] = b"usrdt72l\0";
pub const U_USE_USRDATA: u32 = 0;
pub const U_MILLIS_PER_SECOND: u32 = 1000;
pub const U_MILLIS_PER_MINUTE: u32 = 60000;
pub const U_MILLIS_PER_HOUR: u32 = 3600000;
pub const U_MILLIS_PER_DAY: u32 = 86400000;
pub const UCNV_SUB_STOP_ON_ILLEGAL: &[u8; 2] = b"i\0";
pub const UCNV_SKIP_STOP_ON_ILLEGAL: &[u8; 2] = b"i\0";
pub const UCNV_ESCAPE_JAVA: &[u8; 2] = b"J\0";
pub const UCNV_ESCAPE_C: &[u8; 2] = b"C\0";
pub const UCNV_ESCAPE_XML_DEC: &[u8; 2] = b"D\0";
pub const UCNV_ESCAPE_XML_HEX: &[u8; 2] = b"X\0";
pub const UCNV_ESCAPE_UNICODE: &[u8; 2] = b"U\0";
pub const UCNV_ESCAPE_CSS2: &[u8; 2] = b"S\0";
pub const UCNV_MAX_CONVERTER_NAME_LENGTH: u32 = 60;
pub const UCNV_MAX_FULL_FILE_NAME_LENGTH: u32 = 660;
pub const UCNV_SI: u32 = 15;
pub const UCNV_SO: u32 = 14;
pub const UCNV_OPTION_SEP_CHAR: u8 = 44u8;
pub const UCNV_OPTION_SEP_STRING: &[u8; 2] = b",\0";
pub const UCNV_VALUE_SEP_CHAR: u8 = 61u8;
pub const UCNV_VALUE_SEP_STRING: &[u8; 2] = b"=\0";
pub const UCNV_LOCALE_OPTION_STRING: &[u8; 9] = b",locale=\0";
pub const UCNV_VERSION_OPTION_STRING: &[u8; 10] = b",version=\0";
pub const UCNV_SWAP_LFNL_OPTION_STRING: &[u8; 10] = b",swaplfnl\0";
pub const U_CNV_SAFECLONE_BUFFERSIZE: u32 = 1024;
pub const ICU_PIVOT_BUF_SIZE: u32 = 1024;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const XML_XPATH_CHECKNS: u32 = 1;
pub const XML_XPATH_NOVAR: u32 = 2;
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
unsafe extern "C" {
  pub fn xmlCheckVersion(version: ::std::os::raw::c_int);
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
  pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
  ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
  ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
  pub __count: ::std::os::raw::c_int,
  pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
  pub __wch: ::std::os::raw::c_uint,
  pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of __mbstate_t__bindgen_ty_1"]
    [::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
  ["Alignment of __mbstate_t__bindgen_ty_1"]
    [::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
  ["Offset of field: __mbstate_t__bindgen_ty_1::__wch"]
    [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wch) - 0usize];
  ["Offset of field: __mbstate_t__bindgen_ty_1::__wchb"]
    [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wchb) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 8usize];
  ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 4usize];
  ["Offset of field: __mbstate_t::__count"][::std::mem::offset_of!(__mbstate_t, __count) - 0usize];
  ["Offset of field: __mbstate_t::__value"][::std::mem::offset_of!(__mbstate_t, __value) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
  pub __pos: __off_t,
  pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _G_fpos_t"][::std::mem::size_of::<_G_fpos_t>() - 16usize];
  ["Alignment of _G_fpos_t"][::std::mem::align_of::<_G_fpos_t>() - 8usize];
  ["Offset of field: _G_fpos_t::__pos"][::std::mem::offset_of!(_G_fpos_t, __pos) - 0usize];
  ["Offset of field: _G_fpos_t::__state"][::std::mem::offset_of!(_G_fpos_t, __state) - 8usize];
};
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
  pub __pos: __off64_t,
  pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _G_fpos64_t"][::std::mem::size_of::<_G_fpos64_t>() - 16usize];
  ["Alignment of _G_fpos64_t"][::std::mem::align_of::<_G_fpos64_t>() - 8usize];
  ["Offset of field: _G_fpos64_t::__pos"][::std::mem::offset_of!(_G_fpos64_t, __pos) - 0usize];
  ["Offset of field: _G_fpos64_t::__state"][::std::mem::offset_of!(_G_fpos64_t, __state) - 8usize];
};
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
  _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
  _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
  pub _flags: ::std::os::raw::c_int,
  pub _IO_read_ptr: *mut ::std::os::raw::c_char,
  pub _IO_read_end: *mut ::std::os::raw::c_char,
  pub _IO_read_base: *mut ::std::os::raw::c_char,
  pub _IO_write_base: *mut ::std::os::raw::c_char,
  pub _IO_write_ptr: *mut ::std::os::raw::c_char,
  pub _IO_write_end: *mut ::std::os::raw::c_char,
  pub _IO_buf_base: *mut ::std::os::raw::c_char,
  pub _IO_buf_end: *mut ::std::os::raw::c_char,
  pub _IO_save_base: *mut ::std::os::raw::c_char,
  pub _IO_backup_base: *mut ::std::os::raw::c_char,
  pub _IO_save_end: *mut ::std::os::raw::c_char,
  pub _markers: *mut _IO_marker,
  pub _chain: *mut _IO_FILE,
  pub _fileno: ::std::os::raw::c_int,
  pub _flags2: ::std::os::raw::c_int,
  pub _old_offset: __off_t,
  pub _cur_column: ::std::os::raw::c_ushort,
  pub _vtable_offset: ::std::os::raw::c_schar,
  pub _shortbuf: [::std::os::raw::c_char; 1usize],
  pub _lock: *mut _IO_lock_t,
  pub _offset: __off64_t,
  pub _codecvt: *mut _IO_codecvt,
  pub _wide_data: *mut _IO_wide_data,
  pub _freeres_list: *mut _IO_FILE,
  pub _freeres_buf: *mut ::std::os::raw::c_void,
  pub _prevchain: *mut *mut _IO_FILE,
  pub _mode: ::std::os::raw::c_int,
  pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _IO_FILE"][::std::mem::size_of::<_IO_FILE>() - 216usize];
  ["Alignment of _IO_FILE"][::std::mem::align_of::<_IO_FILE>() - 8usize];
  ["Offset of field: _IO_FILE::_flags"][::std::mem::offset_of!(_IO_FILE, _flags) - 0usize];
  ["Offset of field: _IO_FILE::_IO_read_ptr"]
    [::std::mem::offset_of!(_IO_FILE, _IO_read_ptr) - 8usize];
  ["Offset of field: _IO_FILE::_IO_read_end"]
    [::std::mem::offset_of!(_IO_FILE, _IO_read_end) - 16usize];
  ["Offset of field: _IO_FILE::_IO_read_base"]
    [::std::mem::offset_of!(_IO_FILE, _IO_read_base) - 24usize];
  ["Offset of field: _IO_FILE::_IO_write_base"]
    [::std::mem::offset_of!(_IO_FILE, _IO_write_base) - 32usize];
  ["Offset of field: _IO_FILE::_IO_write_ptr"]
    [::std::mem::offset_of!(_IO_FILE, _IO_write_ptr) - 40usize];
  ["Offset of field: _IO_FILE::_IO_write_end"]
    [::std::mem::offset_of!(_IO_FILE, _IO_write_end) - 48usize];
  ["Offset of field: _IO_FILE::_IO_buf_base"]
    [::std::mem::offset_of!(_IO_FILE, _IO_buf_base) - 56usize];
  ["Offset of field: _IO_FILE::_IO_buf_end"]
    [::std::mem::offset_of!(_IO_FILE, _IO_buf_end) - 64usize];
  ["Offset of field: _IO_FILE::_IO_save_base"]
    [::std::mem::offset_of!(_IO_FILE, _IO_save_base) - 72usize];
  ["Offset of field: _IO_FILE::_IO_backup_base"]
    [::std::mem::offset_of!(_IO_FILE, _IO_backup_base) - 80usize];
  ["Offset of field: _IO_FILE::_IO_save_end"]
    [::std::mem::offset_of!(_IO_FILE, _IO_save_end) - 88usize];
  ["Offset of field: _IO_FILE::_markers"][::std::mem::offset_of!(_IO_FILE, _markers) - 96usize];
  ["Offset of field: _IO_FILE::_chain"][::std::mem::offset_of!(_IO_FILE, _chain) - 104usize];
  ["Offset of field: _IO_FILE::_fileno"][::std::mem::offset_of!(_IO_FILE, _fileno) - 112usize];
  ["Offset of field: _IO_FILE::_flags2"][::std::mem::offset_of!(_IO_FILE, _flags2) - 116usize];
  ["Offset of field: _IO_FILE::_old_offset"]
    [::std::mem::offset_of!(_IO_FILE, _old_offset) - 120usize];
  ["Offset of field: _IO_FILE::_cur_column"]
    [::std::mem::offset_of!(_IO_FILE, _cur_column) - 128usize];
  ["Offset of field: _IO_FILE::_vtable_offset"]
    [::std::mem::offset_of!(_IO_FILE, _vtable_offset) - 130usize];
  ["Offset of field: _IO_FILE::_shortbuf"][::std::mem::offset_of!(_IO_FILE, _shortbuf) - 131usize];
  ["Offset of field: _IO_FILE::_lock"][::std::mem::offset_of!(_IO_FILE, _lock) - 136usize];
  ["Offset of field: _IO_FILE::_offset"][::std::mem::offset_of!(_IO_FILE, _offset) - 144usize];
  ["Offset of field: _IO_FILE::_codecvt"][::std::mem::offset_of!(_IO_FILE, _codecvt) - 152usize];
  ["Offset of field: _IO_FILE::_wide_data"]
    [::std::mem::offset_of!(_IO_FILE, _wide_data) - 160usize];
  ["Offset of field: _IO_FILE::_freeres_list"]
    [::std::mem::offset_of!(_IO_FILE, _freeres_list) - 168usize];
  ["Offset of field: _IO_FILE::_freeres_buf"]
    [::std::mem::offset_of!(_IO_FILE, _freeres_buf) - 176usize];
  ["Offset of field: _IO_FILE::_prevchain"]
    [::std::mem::offset_of!(_IO_FILE, _prevchain) - 184usize];
  ["Offset of field: _IO_FILE::_mode"][::std::mem::offset_of!(_IO_FILE, _mode) - 192usize];
  ["Offset of field: _IO_FILE::_unused2"][::std::mem::offset_of!(_IO_FILE, _unused2) - 196usize];
};
pub type cookie_read_function_t = ::std::option::Option<
  unsafe extern "C" fn(
    __cookie: *mut ::std::os::raw::c_void,
    __buf: *mut ::std::os::raw::c_char,
    __nbytes: usize,
  ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
  unsafe extern "C" fn(
    __cookie: *mut ::std::os::raw::c_void,
    __buf: *const ::std::os::raw::c_char,
    __nbytes: usize,
  ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
  unsafe extern "C" fn(
    __cookie: *mut ::std::os::raw::c_void,
    __pos: *mut __off64_t,
    __w: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
  unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
  pub read: cookie_read_function_t,
  pub write: cookie_write_function_t,
  pub seek: cookie_seek_function_t,
  pub close: cookie_close_function_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _IO_cookie_io_functions_t"]
    [::std::mem::size_of::<_IO_cookie_io_functions_t>() - 32usize];
  ["Alignment of _IO_cookie_io_functions_t"]
    [::std::mem::align_of::<_IO_cookie_io_functions_t>() - 8usize];
  ["Offset of field: _IO_cookie_io_functions_t::read"]
    [::std::mem::offset_of!(_IO_cookie_io_functions_t, read) - 0usize];
  ["Offset of field: _IO_cookie_io_functions_t::write"]
    [::std::mem::offset_of!(_IO_cookie_io_functions_t, write) - 8usize];
  ["Offset of field: _IO_cookie_io_functions_t::seek"]
    [::std::mem::offset_of!(_IO_cookie_io_functions_t, seek) - 16usize];
  ["Offset of field: _IO_cookie_io_functions_t::close"]
    [::std::mem::offset_of!(_IO_cookie_io_functions_t, close) - 24usize];
};
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
unsafe extern "C" {
  pub static mut stdin: *mut FILE;
}
unsafe extern "C" {
  pub static mut stdout: *mut FILE;
}
unsafe extern "C" {
  pub static mut stderr: *mut FILE;
}
unsafe extern "C" {
  pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn rename(
    __old: *const ::std::os::raw::c_char,
    __new: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn renameat(
    __oldfd: ::std::os::raw::c_int,
    __old: *const ::std::os::raw::c_char,
    __newfd: ::std::os::raw::c_int,
    __new: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn tmpfile() -> *mut FILE;
}
unsafe extern "C" {
  pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn tempnam(
    __dir: *const ::std::os::raw::c_char,
    __pfx: *const ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn fopen(
    __filename: *const ::std::os::raw::c_char,
    __modes: *const ::std::os::raw::c_char,
  ) -> *mut FILE;
}
unsafe extern "C" {
  pub fn freopen(
    __filename: *const ::std::os::raw::c_char,
    __modes: *const ::std::os::raw::c_char,
    __stream: *mut FILE,
  ) -> *mut FILE;
}
unsafe extern "C" {
  pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
unsafe extern "C" {
  pub fn fopencookie(
    __magic_cookie: *mut ::std::os::raw::c_void,
    __modes: *const ::std::os::raw::c_char,
    __io_funcs: cookie_io_functions_t,
  ) -> *mut FILE;
}
unsafe extern "C" {
  pub fn fmemopen(
    __s: *mut ::std::os::raw::c_void,
    __len: usize,
    __modes: *const ::std::os::raw::c_char,
  ) -> *mut FILE;
}
unsafe extern "C" {
  pub fn open_memstream(
    __bufloc: *mut *mut ::std::os::raw::c_char,
    __sizeloc: *mut usize,
  ) -> *mut FILE;
}
unsafe extern "C" {
  pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
  pub fn setvbuf(
    __stream: *mut FILE,
    __buf: *mut ::std::os::raw::c_char,
    __modes: ::std::os::raw::c_int,
    __n: usize,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
unsafe extern "C" {
  pub fn setlinebuf(__stream: *mut FILE);
}
unsafe extern "C" {
  pub fn fprintf(
    __stream: *mut FILE,
    __format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn sprintf(
    __s: *mut ::std::os::raw::c_char,
    __format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn vfprintf(
    __s: *mut FILE,
    __format: *const ::std::os::raw::c_char,
    __arg: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn vprintf(
    __format: *const ::std::os::raw::c_char,
    __arg: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn vsprintf(
    __s: *mut ::std::os::raw::c_char,
    __format: *const ::std::os::raw::c_char,
    __arg: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn snprintf(
    __s: *mut ::std::os::raw::c_char,
    __maxlen: ::std::os::raw::c_ulong,
    __format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn vsnprintf(
    __s: *mut ::std::os::raw::c_char,
    __maxlen: ::std::os::raw::c_ulong,
    __format: *const ::std::os::raw::c_char,
    __arg: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn vasprintf(
    __ptr: *mut *mut ::std::os::raw::c_char,
    __f: *const ::std::os::raw::c_char,
    __arg: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn __asprintf(
    __ptr: *mut *mut ::std::os::raw::c_char,
    __fmt: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn asprintf(
    __ptr: *mut *mut ::std::os::raw::c_char,
    __fmt: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn vdprintf(
    __fd: ::std::os::raw::c_int,
    __fmt: *const ::std::os::raw::c_char,
    __arg: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn dprintf(
    __fd: ::std::os::raw::c_int,
    __fmt: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn fscanf(
    __stream: *mut FILE,
    __format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn sscanf(
    __s: *const ::std::os::raw::c_char,
    __format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
unsafe extern "C" {
  #[link_name = "\u{1}__isoc99_fscanf"]
  pub fn fscanf1(
    __stream: *mut FILE,
    __format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  #[link_name = "\u{1}__isoc99_scanf"]
  pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  #[link_name = "\u{1}__isoc99_sscanf"]
  pub fn sscanf1(
    __s: *const ::std::os::raw::c_char,
    __format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn vfscanf(
    __s: *mut FILE,
    __format: *const ::std::os::raw::c_char,
    __arg: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn vscanf(
    __format: *const ::std::os::raw::c_char,
    __arg: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn vsscanf(
    __s: *const ::std::os::raw::c_char,
    __format: *const ::std::os::raw::c_char,
    __arg: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  #[link_name = "\u{1}__isoc99_vfscanf"]
  pub fn vfscanf1(
    __s: *mut FILE,
    __format: *const ::std::os::raw::c_char,
    __arg: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  #[link_name = "\u{1}__isoc99_vscanf"]
  pub fn vscanf1(
    __format: *const ::std::os::raw::c_char,
    __arg: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  #[link_name = "\u{1}__isoc99_vsscanf"]
  pub fn vsscanf1(
    __s: *const ::std::os::raw::c_char,
    __format: *const ::std::os::raw::c_char,
    __arg: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn getchar() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn fgets(
    __s: *mut ::std::os::raw::c_char,
    __n: ::std::os::raw::c_int,
    __stream: *mut FILE,
  ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn __getdelim(
    __lineptr: *mut *mut ::std::os::raw::c_char,
    __n: *mut usize,
    __delimiter: ::std::os::raw::c_int,
    __stream: *mut FILE,
  ) -> __ssize_t;
}
unsafe extern "C" {
  pub fn getdelim(
    __lineptr: *mut *mut ::std::os::raw::c_char,
    __n: *mut usize,
    __delimiter: ::std::os::raw::c_int,
    __stream: *mut FILE,
  ) -> __ssize_t;
}
unsafe extern "C" {
  pub fn getline(
    __lineptr: *mut *mut ::std::os::raw::c_char,
    __n: *mut usize,
    __stream: *mut FILE,
  ) -> __ssize_t;
}
unsafe extern "C" {
  pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn fread(
    __ptr: *mut ::std::os::raw::c_void,
    __size: ::std::os::raw::c_ulong,
    __n: ::std::os::raw::c_ulong,
    __stream: *mut FILE,
  ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
  pub fn fwrite(
    __ptr: *const ::std::os::raw::c_void,
    __size: ::std::os::raw::c_ulong,
    __n: ::std::os::raw::c_ulong,
    __s: *mut FILE,
  ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
  pub fn fread_unlocked(
    __ptr: *mut ::std::os::raw::c_void,
    __size: usize,
    __n: usize,
    __stream: *mut FILE,
  ) -> usize;
}
unsafe extern "C" {
  pub fn fwrite_unlocked(
    __ptr: *const ::std::os::raw::c_void,
    __size: usize,
    __n: usize,
    __stream: *mut FILE,
  ) -> usize;
}
unsafe extern "C" {
  pub fn fseek(
    __stream: *mut FILE,
    __off: ::std::os::raw::c_long,
    __whence: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
  pub fn rewind(__stream: *mut FILE);
}
unsafe extern "C" {
  pub fn fseeko(
    __stream: *mut FILE,
    __off: __off_t,
    __whence: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn ftello(__stream: *mut FILE) -> __off_t;
}
unsafe extern "C" {
  pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn clearerr(__stream: *mut FILE);
}
unsafe extern "C" {
  pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn clearerr_unlocked(__stream: *mut FILE);
}
unsafe extern "C" {
  pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn perror(__s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
  pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn popen(
    __command: *const ::std::os::raw::c_char,
    __modes: *const ::std::os::raw::c_char,
  ) -> *mut FILE;
}
unsafe extern "C" {
  pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn flockfile(__stream: *mut FILE);
}
unsafe extern "C" {
  pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn funlockfile(__stream: *mut FILE);
}
unsafe extern "C" {
  pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = " xmlChar:\n\n This is a basic byte in an UTF-8 encoded string.\n It's unsigned allowing to pinpoint case where char * are assigned\n to xmlChar * (possibly making serialization back impossible)."]
pub type xmlChar = ::std::os::raw::c_uchar;
unsafe extern "C" {
  pub fn xmlStrdup(cur: *const xmlChar) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlStrndup(cur: *const xmlChar, len: ::std::os::raw::c_int) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlCharStrndup(
    cur: *const ::std::os::raw::c_char,
    len: ::std::os::raw::c_int,
  ) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlCharStrdup(cur: *const ::std::os::raw::c_char) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlStrsub(
    str_: *const xmlChar,
    start: ::std::os::raw::c_int,
    len: ::std::os::raw::c_int,
  ) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlStrchr(str_: *const xmlChar, val: xmlChar) -> *const xmlChar;
}
unsafe extern "C" {
  pub fn xmlStrstr(str_: *const xmlChar, val: *const xmlChar) -> *const xmlChar;
}
unsafe extern "C" {
  pub fn xmlStrcasestr(str_: *const xmlChar, val: *const xmlChar) -> *const xmlChar;
}
unsafe extern "C" {
  pub fn xmlStrcmp(str1: *const xmlChar, str2: *const xmlChar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlStrncmp(
    str1: *const xmlChar,
    str2: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlStrcasecmp(str1: *const xmlChar, str2: *const xmlChar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlStrncasecmp(
    str1: *const xmlChar,
    str2: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlStrEqual(str1: *const xmlChar, str2: *const xmlChar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlStrQEqual(
    pref: *const xmlChar,
    name: *const xmlChar,
    str_: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlStrlen(str_: *const xmlChar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlStrcat(cur: *mut xmlChar, add: *const xmlChar) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlStrncat(
    cur: *mut xmlChar,
    add: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlStrncatNew(
    str1: *const xmlChar,
    str2: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlStrPrintf(
    buf: *mut xmlChar,
    len: ::std::os::raw::c_int,
    msg: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlStrVPrintf(
    buf: *mut xmlChar,
    len: ::std::os::raw::c_int,
    msg: *const ::std::os::raw::c_char,
    ap: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlGetUTF8Char(
    utf: *const ::std::os::raw::c_uchar,
    len: *mut ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlCheckUTF8(utf: *const ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlUTF8Strsize(utf: *const xmlChar, len: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlUTF8Strndup(utf: *const xmlChar, len: ::std::os::raw::c_int) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlUTF8Strpos(utf: *const xmlChar, pos: ::std::os::raw::c_int) -> *const xmlChar;
}
unsafe extern "C" {
  pub fn xmlUTF8Strloc(utf: *const xmlChar, utfchar: *const xmlChar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlUTF8Strsub(
    utf: *const xmlChar,
    start: ::std::os::raw::c_int,
    len: ::std::os::raw::c_int,
  ) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlUTF8Strlen(utf: *const xmlChar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlUTF8Size(utf: *const xmlChar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlUTF8Charcmp(utf1: *const xmlChar, utf2: *const xmlChar) -> ::std::os::raw::c_int;
}
pub type xmlParserInputBuffer = _xmlParserInputBuffer;
pub type xmlParserInputBufferPtr = *mut xmlParserInputBuffer;
pub type xmlOutputBuffer = _xmlOutputBuffer;
pub type xmlOutputBufferPtr = *mut xmlOutputBuffer;
pub type xmlParserInput = _xmlParserInput;
pub type xmlParserInputPtr = *mut xmlParserInput;
#[doc = " xmlParserCtxt:\n\n The parser context.\n NOTE This doesn't completely define the parser state, the (current ?)\n      design of the parser uses recursive function calls since this allow\n      and easy mapping from the production rules of the specification\n      to the actual code. The drawback is that the actual function call\n      also reflect the parser state. However most of the parsing routines\n      takes as the only argument the parser context pointer, so migrating\n      to a state based parser for progressive parsing shouldn't be too hard."]
pub type xmlParserCtxt = _xmlParserCtxt;
pub type xmlParserCtxtPtr = *mut xmlParserCtxt;
#[doc = " xmlSAXLocator:\n\n A SAX Locator."]
pub type xmlSAXLocator = _xmlSAXLocator;
pub type xmlSAXLocatorPtr = *mut xmlSAXLocator;
pub type xmlSAXHandler = _xmlSAXHandler;
pub type xmlSAXHandlerPtr = *mut xmlSAXHandler;
pub type xmlEntity = _xmlEntity;
pub type xmlEntityPtr = *mut xmlEntity;
pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_DOUBLEIT: xmlBufferAllocationScheme = 0;
pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_EXACT: xmlBufferAllocationScheme = 1;
pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_IMMUTABLE: xmlBufferAllocationScheme = 2;
pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_IO: xmlBufferAllocationScheme = 3;
pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_HYBRID: xmlBufferAllocationScheme = 4;
pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_BOUNDED: xmlBufferAllocationScheme = 5;
#[doc = " xmlBufferAllocationScheme:\n\n A buffer allocation scheme can be defined to either match exactly the\n need or double it's allocated size each time it is found too small."]
pub type xmlBufferAllocationScheme = ::std::os::raw::c_uint;
#[doc = " xmlBuffer:\n\n A buffer structure, this old construct is limited to 2GB and\n is being deprecated, use API with xmlBuf instead"]
pub type xmlBuffer = _xmlBuffer;
pub type xmlBufferPtr = *mut xmlBuffer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlBuffer {
  pub content: *mut xmlChar,
  pub use_: ::std::os::raw::c_uint,
  pub size: ::std::os::raw::c_uint,
  pub alloc: xmlBufferAllocationScheme,
  pub contentIO: *mut xmlChar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlBuffer"][::std::mem::size_of::<_xmlBuffer>() - 32usize];
  ["Alignment of _xmlBuffer"][::std::mem::align_of::<_xmlBuffer>() - 8usize];
  ["Offset of field: _xmlBuffer::content"][::std::mem::offset_of!(_xmlBuffer, content) - 0usize];
  ["Offset of field: _xmlBuffer::use_"][::std::mem::offset_of!(_xmlBuffer, use_) - 8usize];
  ["Offset of field: _xmlBuffer::size"][::std::mem::offset_of!(_xmlBuffer, size) - 12usize];
  ["Offset of field: _xmlBuffer::alloc"][::std::mem::offset_of!(_xmlBuffer, alloc) - 16usize];
  ["Offset of field: _xmlBuffer::contentIO"]
    [::std::mem::offset_of!(_xmlBuffer, contentIO) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlBuf {
  _unused: [u8; 0],
}
#[doc = " xmlBuf:\n\n A buffer structure, new one, the actual structure internals are not public"]
pub type xmlBuf = _xmlBuf;
#[doc = " xmlBufPtr:\n\n A pointer to a buffer structure, the actual structure internals are not\n public"]
pub type xmlBufPtr = *mut xmlBuf;
unsafe extern "C" {
  pub fn xmlBufContent(buf: *const xmlBuf) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlBufEnd(buf: xmlBufPtr) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlBufUse(buf: xmlBufPtr) -> usize;
}
unsafe extern "C" {
  pub fn xmlBufShrink(buf: xmlBufPtr, len: usize) -> usize;
}
pub const xmlElementType_XML_ELEMENT_NODE: xmlElementType = 1;
pub const xmlElementType_XML_ATTRIBUTE_NODE: xmlElementType = 2;
pub const xmlElementType_XML_TEXT_NODE: xmlElementType = 3;
pub const xmlElementType_XML_CDATA_SECTION_NODE: xmlElementType = 4;
pub const xmlElementType_XML_ENTITY_REF_NODE: xmlElementType = 5;
pub const xmlElementType_XML_ENTITY_NODE: xmlElementType = 6;
pub const xmlElementType_XML_PI_NODE: xmlElementType = 7;
pub const xmlElementType_XML_COMMENT_NODE: xmlElementType = 8;
pub const xmlElementType_XML_DOCUMENT_NODE: xmlElementType = 9;
pub const xmlElementType_XML_DOCUMENT_TYPE_NODE: xmlElementType = 10;
pub const xmlElementType_XML_DOCUMENT_FRAG_NODE: xmlElementType = 11;
pub const xmlElementType_XML_NOTATION_NODE: xmlElementType = 12;
pub const xmlElementType_XML_HTML_DOCUMENT_NODE: xmlElementType = 13;
pub const xmlElementType_XML_DTD_NODE: xmlElementType = 14;
pub const xmlElementType_XML_ELEMENT_DECL: xmlElementType = 15;
pub const xmlElementType_XML_ATTRIBUTE_DECL: xmlElementType = 16;
pub const xmlElementType_XML_ENTITY_DECL: xmlElementType = 17;
pub const xmlElementType_XML_NAMESPACE_DECL: xmlElementType = 18;
pub const xmlElementType_XML_XINCLUDE_START: xmlElementType = 19;
pub const xmlElementType_XML_XINCLUDE_END: xmlElementType = 20;
pub const xmlElementType_XML_DOCB_DOCUMENT_NODE: xmlElementType = 21;
pub type xmlElementType = ::std::os::raw::c_uint;
#[doc = " xmlNotation:\n\n A DTD Notation definition."]
pub type xmlNotation = _xmlNotation;
pub type xmlNotationPtr = *mut xmlNotation;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlNotation {
  pub name: *const xmlChar,
  pub PublicID: *const xmlChar,
  pub SystemID: *const xmlChar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlNotation"][::std::mem::size_of::<_xmlNotation>() - 24usize];
  ["Alignment of _xmlNotation"][::std::mem::align_of::<_xmlNotation>() - 8usize];
  ["Offset of field: _xmlNotation::name"][::std::mem::offset_of!(_xmlNotation, name) - 0usize];
  ["Offset of field: _xmlNotation::PublicID"]
    [::std::mem::offset_of!(_xmlNotation, PublicID) - 8usize];
  ["Offset of field: _xmlNotation::SystemID"]
    [::std::mem::offset_of!(_xmlNotation, SystemID) - 16usize];
};
pub const xmlAttributeType_XML_ATTRIBUTE_CDATA: xmlAttributeType = 1;
pub const xmlAttributeType_XML_ATTRIBUTE_ID: xmlAttributeType = 2;
pub const xmlAttributeType_XML_ATTRIBUTE_IDREF: xmlAttributeType = 3;
pub const xmlAttributeType_XML_ATTRIBUTE_IDREFS: xmlAttributeType = 4;
pub const xmlAttributeType_XML_ATTRIBUTE_ENTITY: xmlAttributeType = 5;
pub const xmlAttributeType_XML_ATTRIBUTE_ENTITIES: xmlAttributeType = 6;
pub const xmlAttributeType_XML_ATTRIBUTE_NMTOKEN: xmlAttributeType = 7;
pub const xmlAttributeType_XML_ATTRIBUTE_NMTOKENS: xmlAttributeType = 8;
pub const xmlAttributeType_XML_ATTRIBUTE_ENUMERATION: xmlAttributeType = 9;
pub const xmlAttributeType_XML_ATTRIBUTE_NOTATION: xmlAttributeType = 10;
#[doc = " xmlAttributeType:\n\n A DTD Attribute type definition."]
pub type xmlAttributeType = ::std::os::raw::c_uint;
pub const xmlAttributeDefault_XML_ATTRIBUTE_NONE: xmlAttributeDefault = 1;
pub const xmlAttributeDefault_XML_ATTRIBUTE_REQUIRED: xmlAttributeDefault = 2;
pub const xmlAttributeDefault_XML_ATTRIBUTE_IMPLIED: xmlAttributeDefault = 3;
pub const xmlAttributeDefault_XML_ATTRIBUTE_FIXED: xmlAttributeDefault = 4;
#[doc = " xmlAttributeDefault:\n\n A DTD Attribute default definition."]
pub type xmlAttributeDefault = ::std::os::raw::c_uint;
#[doc = " xmlEnumeration:\n\n List structure used when there is an enumeration in DTDs."]
pub type xmlEnumeration = _xmlEnumeration;
pub type xmlEnumerationPtr = *mut xmlEnumeration;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlEnumeration {
  pub next: *mut _xmlEnumeration,
  pub name: *const xmlChar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlEnumeration"][::std::mem::size_of::<_xmlEnumeration>() - 16usize];
  ["Alignment of _xmlEnumeration"][::std::mem::align_of::<_xmlEnumeration>() - 8usize];
  ["Offset of field: _xmlEnumeration::next"]
    [::std::mem::offset_of!(_xmlEnumeration, next) - 0usize];
  ["Offset of field: _xmlEnumeration::name"]
    [::std::mem::offset_of!(_xmlEnumeration, name) - 8usize];
};
#[doc = " xmlAttribute:\n\n An Attribute declaration in a DTD."]
pub type xmlAttribute = _xmlAttribute;
pub type xmlAttributePtr = *mut xmlAttribute;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlAttribute {
  pub _private: *mut ::std::os::raw::c_void,
  pub type_: xmlElementType,
  pub name: *const xmlChar,
  pub children: *mut _xmlNode,
  pub last: *mut _xmlNode,
  pub parent: *mut _xmlDtd,
  pub next: *mut _xmlNode,
  pub prev: *mut _xmlNode,
  pub doc: *mut _xmlDoc,
  pub nexth: *mut _xmlAttribute,
  pub atype: xmlAttributeType,
  pub def: xmlAttributeDefault,
  pub defaultValue: *const xmlChar,
  pub tree: xmlEnumerationPtr,
  pub prefix: *const xmlChar,
  pub elem: *const xmlChar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlAttribute"][::std::mem::size_of::<_xmlAttribute>() - 120usize];
  ["Alignment of _xmlAttribute"][::std::mem::align_of::<_xmlAttribute>() - 8usize];
  ["Offset of field: _xmlAttribute::_private"]
    [::std::mem::offset_of!(_xmlAttribute, _private) - 0usize];
  ["Offset of field: _xmlAttribute::type_"][::std::mem::offset_of!(_xmlAttribute, type_) - 8usize];
  ["Offset of field: _xmlAttribute::name"][::std::mem::offset_of!(_xmlAttribute, name) - 16usize];
  ["Offset of field: _xmlAttribute::children"]
    [::std::mem::offset_of!(_xmlAttribute, children) - 24usize];
  ["Offset of field: _xmlAttribute::last"][::std::mem::offset_of!(_xmlAttribute, last) - 32usize];
  ["Offset of field: _xmlAttribute::parent"]
    [::std::mem::offset_of!(_xmlAttribute, parent) - 40usize];
  ["Offset of field: _xmlAttribute::next"][::std::mem::offset_of!(_xmlAttribute, next) - 48usize];
  ["Offset of field: _xmlAttribute::prev"][::std::mem::offset_of!(_xmlAttribute, prev) - 56usize];
  ["Offset of field: _xmlAttribute::doc"][::std::mem::offset_of!(_xmlAttribute, doc) - 64usize];
  ["Offset of field: _xmlAttribute::nexth"][::std::mem::offset_of!(_xmlAttribute, nexth) - 72usize];
  ["Offset of field: _xmlAttribute::atype"][::std::mem::offset_of!(_xmlAttribute, atype) - 80usize];
  ["Offset of field: _xmlAttribute::def"][::std::mem::offset_of!(_xmlAttribute, def) - 84usize];
  ["Offset of field: _xmlAttribute::defaultValue"]
    [::std::mem::offset_of!(_xmlAttribute, defaultValue) - 88usize];
  ["Offset of field: _xmlAttribute::tree"][::std::mem::offset_of!(_xmlAttribute, tree) - 96usize];
  ["Offset of field: _xmlAttribute::prefix"]
    [::std::mem::offset_of!(_xmlAttribute, prefix) - 104usize];
  ["Offset of field: _xmlAttribute::elem"][::std::mem::offset_of!(_xmlAttribute, elem) - 112usize];
};
pub const xmlElementContentType_XML_ELEMENT_CONTENT_PCDATA: xmlElementContentType = 1;
pub const xmlElementContentType_XML_ELEMENT_CONTENT_ELEMENT: xmlElementContentType = 2;
pub const xmlElementContentType_XML_ELEMENT_CONTENT_SEQ: xmlElementContentType = 3;
pub const xmlElementContentType_XML_ELEMENT_CONTENT_OR: xmlElementContentType = 4;
#[doc = " xmlElementContentType:\n\n Possible definitions of element content types."]
pub type xmlElementContentType = ::std::os::raw::c_uint;
pub const xmlElementContentOccur_XML_ELEMENT_CONTENT_ONCE: xmlElementContentOccur = 1;
pub const xmlElementContentOccur_XML_ELEMENT_CONTENT_OPT: xmlElementContentOccur = 2;
pub const xmlElementContentOccur_XML_ELEMENT_CONTENT_MULT: xmlElementContentOccur = 3;
pub const xmlElementContentOccur_XML_ELEMENT_CONTENT_PLUS: xmlElementContentOccur = 4;
#[doc = " xmlElementContentOccur:\n\n Possible definitions of element content occurrences."]
pub type xmlElementContentOccur = ::std::os::raw::c_uint;
#[doc = " xmlElementContent:\n\n An XML Element content as stored after parsing an element definition\n in a DTD."]
pub type xmlElementContent = _xmlElementContent;
pub type xmlElementContentPtr = *mut xmlElementContent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlElementContent {
  pub type_: xmlElementContentType,
  pub ocur: xmlElementContentOccur,
  pub name: *const xmlChar,
  pub c1: *mut _xmlElementContent,
  pub c2: *mut _xmlElementContent,
  pub parent: *mut _xmlElementContent,
  pub prefix: *const xmlChar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlElementContent"][::std::mem::size_of::<_xmlElementContent>() - 48usize];
  ["Alignment of _xmlElementContent"][::std::mem::align_of::<_xmlElementContent>() - 8usize];
  ["Offset of field: _xmlElementContent::type_"]
    [::std::mem::offset_of!(_xmlElementContent, type_) - 0usize];
  ["Offset of field: _xmlElementContent::ocur"]
    [::std::mem::offset_of!(_xmlElementContent, ocur) - 4usize];
  ["Offset of field: _xmlElementContent::name"]
    [::std::mem::offset_of!(_xmlElementContent, name) - 8usize];
  ["Offset of field: _xmlElementContent::c1"]
    [::std::mem::offset_of!(_xmlElementContent, c1) - 16usize];
  ["Offset of field: _xmlElementContent::c2"]
    [::std::mem::offset_of!(_xmlElementContent, c2) - 24usize];
  ["Offset of field: _xmlElementContent::parent"]
    [::std::mem::offset_of!(_xmlElementContent, parent) - 32usize];
  ["Offset of field: _xmlElementContent::prefix"]
    [::std::mem::offset_of!(_xmlElementContent, prefix) - 40usize];
};
pub const xmlElementTypeVal_XML_ELEMENT_TYPE_UNDEFINED: xmlElementTypeVal = 0;
pub const xmlElementTypeVal_XML_ELEMENT_TYPE_EMPTY: xmlElementTypeVal = 1;
pub const xmlElementTypeVal_XML_ELEMENT_TYPE_ANY: xmlElementTypeVal = 2;
pub const xmlElementTypeVal_XML_ELEMENT_TYPE_MIXED: xmlElementTypeVal = 3;
pub const xmlElementTypeVal_XML_ELEMENT_TYPE_ELEMENT: xmlElementTypeVal = 4;
#[doc = " xmlElementTypeVal:\n\n The different possibilities for an element content type."]
pub type xmlElementTypeVal = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlRegexp {
  _unused: [u8; 0],
}
#[doc = " xmlRegexpPtr:\n\n A libxml regular expression, they can actually be far more complex\n thank the POSIX regex expressions."]
pub type xmlRegexp = _xmlRegexp;
pub type xmlRegexpPtr = *mut xmlRegexp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlRegExecCtxt {
  _unused: [u8; 0],
}
#[doc = " xmlRegExecCtxtPtr:\n\n A libxml progressive regular expression evaluation context"]
pub type xmlRegExecCtxt = _xmlRegExecCtxt;
pub type xmlRegExecCtxtPtr = *mut xmlRegExecCtxt;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
  pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
  pub __bindgen_padding_0: u64,
  pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
  ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
  ["Offset of field: max_align_t::__clang_max_align_nonce1"]
    [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
  ["Offset of field: max_align_t::__clang_max_align_nonce2"]
    [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlDict {
  _unused: [u8; 0],
}
pub type xmlDict = _xmlDict;
pub type xmlDictPtr = *mut xmlDict;
unsafe extern "C" {
  pub fn xmlInitializeDict() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlDictCreate() -> xmlDictPtr;
}
unsafe extern "C" {
  pub fn xmlDictSetLimit(dict: xmlDictPtr, limit: usize) -> usize;
}
unsafe extern "C" {
  pub fn xmlDictGetUsage(dict: xmlDictPtr) -> usize;
}
unsafe extern "C" {
  pub fn xmlDictCreateSub(sub: xmlDictPtr) -> xmlDictPtr;
}
unsafe extern "C" {
  pub fn xmlDictReference(dict: xmlDictPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlDictFree(dict: xmlDictPtr);
}
unsafe extern "C" {
  pub fn xmlDictLookup(
    dict: xmlDictPtr,
    name: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> *const xmlChar;
}
unsafe extern "C" {
  pub fn xmlDictExists(
    dict: xmlDictPtr,
    name: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> *const xmlChar;
}
unsafe extern "C" {
  pub fn xmlDictQLookup(
    dict: xmlDictPtr,
    prefix: *const xmlChar,
    name: *const xmlChar,
  ) -> *const xmlChar;
}
unsafe extern "C" {
  pub fn xmlDictOwns(dict: xmlDictPtr, str_: *const xmlChar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlDictSize(dict: xmlDictPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlDictCleanup();
}
unsafe extern "C" {
  pub fn xmlRegexpCompile(regexp: *const xmlChar) -> xmlRegexpPtr;
}
unsafe extern "C" {
  pub fn xmlRegFreeRegexp(regexp: xmlRegexpPtr);
}
unsafe extern "C" {
  pub fn xmlRegexpExec(comp: xmlRegexpPtr, value: *const xmlChar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlRegexpPrint(output: *mut FILE, regexp: xmlRegexpPtr);
}
unsafe extern "C" {
  pub fn xmlRegexpIsDeterminist(comp: xmlRegexpPtr) -> ::std::os::raw::c_int;
}
#[doc = " xmlRegExecCallbacks:\n @exec: the regular expression context\n @token: the current token string\n @transdata: transition data\n @inputdata: input data\n\n Callback function when doing a transition in the automata"]
pub type xmlRegExecCallbacks = ::std::option::Option<
  unsafe extern "C" fn(
    exec: xmlRegExecCtxtPtr,
    token: *const xmlChar,
    transdata: *mut ::std::os::raw::c_void,
    inputdata: *mut ::std::os::raw::c_void,
  ),
>;
unsafe extern "C" {
  pub fn xmlRegNewExecCtxt(
    comp: xmlRegexpPtr,
    callback: xmlRegExecCallbacks,
    data: *mut ::std::os::raw::c_void,
  ) -> xmlRegExecCtxtPtr;
}
unsafe extern "C" {
  pub fn xmlRegFreeExecCtxt(exec: xmlRegExecCtxtPtr);
}
unsafe extern "C" {
  pub fn xmlRegExecPushString(
    exec: xmlRegExecCtxtPtr,
    value: *const xmlChar,
    data: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlRegExecPushString2(
    exec: xmlRegExecCtxtPtr,
    value: *const xmlChar,
    value2: *const xmlChar,
    data: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlRegExecNextValues(
    exec: xmlRegExecCtxtPtr,
    nbval: *mut ::std::os::raw::c_int,
    nbneg: *mut ::std::os::raw::c_int,
    values: *mut *mut xmlChar,
    terminal: *mut ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlRegExecErrInfo(
    exec: xmlRegExecCtxtPtr,
    string: *mut *const xmlChar,
    nbval: *mut ::std::os::raw::c_int,
    nbneg: *mut ::std::os::raw::c_int,
    values: *mut *mut xmlChar,
    terminal: *mut ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
#[doc = " xmlElement:\n\n An XML Element declaration from a DTD."]
pub type xmlElement = _xmlElement;
pub type xmlElementPtr = *mut xmlElement;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlElement {
  pub _private: *mut ::std::os::raw::c_void,
  pub type_: xmlElementType,
  pub name: *const xmlChar,
  pub children: *mut _xmlNode,
  pub last: *mut _xmlNode,
  pub parent: *mut _xmlDtd,
  pub next: *mut _xmlNode,
  pub prev: *mut _xmlNode,
  pub doc: *mut _xmlDoc,
  pub etype: xmlElementTypeVal,
  pub content: xmlElementContentPtr,
  pub attributes: xmlAttributePtr,
  pub prefix: *const xmlChar,
  pub contModel: xmlRegexpPtr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlElement"][::std::mem::size_of::<_xmlElement>() - 112usize];
  ["Alignment of _xmlElement"][::std::mem::align_of::<_xmlElement>() - 8usize];
  ["Offset of field: _xmlElement::_private"]
    [::std::mem::offset_of!(_xmlElement, _private) - 0usize];
  ["Offset of field: _xmlElement::type_"][::std::mem::offset_of!(_xmlElement, type_) - 8usize];
  ["Offset of field: _xmlElement::name"][::std::mem::offset_of!(_xmlElement, name) - 16usize];
  ["Offset of field: _xmlElement::children"]
    [::std::mem::offset_of!(_xmlElement, children) - 24usize];
  ["Offset of field: _xmlElement::last"][::std::mem::offset_of!(_xmlElement, last) - 32usize];
  ["Offset of field: _xmlElement::parent"][::std::mem::offset_of!(_xmlElement, parent) - 40usize];
  ["Offset of field: _xmlElement::next"][::std::mem::offset_of!(_xmlElement, next) - 48usize];
  ["Offset of field: _xmlElement::prev"][::std::mem::offset_of!(_xmlElement, prev) - 56usize];
  ["Offset of field: _xmlElement::doc"][::std::mem::offset_of!(_xmlElement, doc) - 64usize];
  ["Offset of field: _xmlElement::etype"][::std::mem::offset_of!(_xmlElement, etype) - 72usize];
  ["Offset of field: _xmlElement::content"][::std::mem::offset_of!(_xmlElement, content) - 80usize];
  ["Offset of field: _xmlElement::attributes"]
    [::std::mem::offset_of!(_xmlElement, attributes) - 88usize];
  ["Offset of field: _xmlElement::prefix"][::std::mem::offset_of!(_xmlElement, prefix) - 96usize];
  ["Offset of field: _xmlElement::contModel"]
    [::std::mem::offset_of!(_xmlElement, contModel) - 104usize];
};
pub use self::xmlElementType as xmlNsType;
#[doc = " xmlNs:\n\n An XML namespace.\n Note that prefix == NULL is valid, it defines the default namespace\n within the subtree (until overridden).\n\n xmlNsType is unified with xmlElementType."]
pub type xmlNs = _xmlNs;
pub type xmlNsPtr = *mut xmlNs;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlNs {
  pub next: *mut _xmlNs,
  pub type_: xmlNsType,
  pub href: *const xmlChar,
  pub prefix: *const xmlChar,
  pub _private: *mut ::std::os::raw::c_void,
  pub context: *mut _xmlDoc,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlNs"][::std::mem::size_of::<_xmlNs>() - 48usize];
  ["Alignment of _xmlNs"][::std::mem::align_of::<_xmlNs>() - 8usize];
  ["Offset of field: _xmlNs::next"][::std::mem::offset_of!(_xmlNs, next) - 0usize];
  ["Offset of field: _xmlNs::type_"][::std::mem::offset_of!(_xmlNs, type_) - 8usize];
  ["Offset of field: _xmlNs::href"][::std::mem::offset_of!(_xmlNs, href) - 16usize];
  ["Offset of field: _xmlNs::prefix"][::std::mem::offset_of!(_xmlNs, prefix) - 24usize];
  ["Offset of field: _xmlNs::_private"][::std::mem::offset_of!(_xmlNs, _private) - 32usize];
  ["Offset of field: _xmlNs::context"][::std::mem::offset_of!(_xmlNs, context) - 40usize];
};
#[doc = " xmlDtd:\n\n An XML DTD, as defined by <!DOCTYPE ... There is actually one for\n the internal subset and for the external subset."]
pub type xmlDtd = _xmlDtd;
pub type xmlDtdPtr = *mut xmlDtd;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlDtd {
  pub _private: *mut ::std::os::raw::c_void,
  pub type_: xmlElementType,
  pub name: *const xmlChar,
  pub children: *mut _xmlNode,
  pub last: *mut _xmlNode,
  pub parent: *mut _xmlDoc,
  pub next: *mut _xmlNode,
  pub prev: *mut _xmlNode,
  pub doc: *mut _xmlDoc,
  pub notations: *mut ::std::os::raw::c_void,
  pub elements: *mut ::std::os::raw::c_void,
  pub attributes: *mut ::std::os::raw::c_void,
  pub entities: *mut ::std::os::raw::c_void,
  pub ExternalID: *const xmlChar,
  pub SystemID: *const xmlChar,
  pub pentities: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlDtd"][::std::mem::size_of::<_xmlDtd>() - 128usize];
  ["Alignment of _xmlDtd"][::std::mem::align_of::<_xmlDtd>() - 8usize];
  ["Offset of field: _xmlDtd::_private"][::std::mem::offset_of!(_xmlDtd, _private) - 0usize];
  ["Offset of field: _xmlDtd::type_"][::std::mem::offset_of!(_xmlDtd, type_) - 8usize];
  ["Offset of field: _xmlDtd::name"][::std::mem::offset_of!(_xmlDtd, name) - 16usize];
  ["Offset of field: _xmlDtd::children"][::std::mem::offset_of!(_xmlDtd, children) - 24usize];
  ["Offset of field: _xmlDtd::last"][::std::mem::offset_of!(_xmlDtd, last) - 32usize];
  ["Offset of field: _xmlDtd::parent"][::std::mem::offset_of!(_xmlDtd, parent) - 40usize];
  ["Offset of field: _xmlDtd::next"][::std::mem::offset_of!(_xmlDtd, next) - 48usize];
  ["Offset of field: _xmlDtd::prev"][::std::mem::offset_of!(_xmlDtd, prev) - 56usize];
  ["Offset of field: _xmlDtd::doc"][::std::mem::offset_of!(_xmlDtd, doc) - 64usize];
  ["Offset of field: _xmlDtd::notations"][::std::mem::offset_of!(_xmlDtd, notations) - 72usize];
  ["Offset of field: _xmlDtd::elements"][::std::mem::offset_of!(_xmlDtd, elements) - 80usize];
  ["Offset of field: _xmlDtd::attributes"][::std::mem::offset_of!(_xmlDtd, attributes) - 88usize];
  ["Offset of field: _xmlDtd::entities"][::std::mem::offset_of!(_xmlDtd, entities) - 96usize];
  ["Offset of field: _xmlDtd::ExternalID"][::std::mem::offset_of!(_xmlDtd, ExternalID) - 104usize];
  ["Offset of field: _xmlDtd::SystemID"][::std::mem::offset_of!(_xmlDtd, SystemID) - 112usize];
  ["Offset of field: _xmlDtd::pentities"][::std::mem::offset_of!(_xmlDtd, pentities) - 120usize];
};
#[doc = " xmlAttr:\n\n An attribute on an XML node."]
pub type xmlAttr = _xmlAttr;
pub type xmlAttrPtr = *mut xmlAttr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlAttr {
  pub _private: *mut ::std::os::raw::c_void,
  pub type_: xmlElementType,
  pub name: *const xmlChar,
  pub children: *mut _xmlNode,
  pub last: *mut _xmlNode,
  pub parent: *mut _xmlNode,
  pub next: *mut _xmlAttr,
  pub prev: *mut _xmlAttr,
  pub doc: *mut _xmlDoc,
  pub ns: *mut xmlNs,
  pub atype: xmlAttributeType,
  pub psvi: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlAttr"][::std::mem::size_of::<_xmlAttr>() - 96usize];
  ["Alignment of _xmlAttr"][::std::mem::align_of::<_xmlAttr>() - 8usize];
  ["Offset of field: _xmlAttr::_private"][::std::mem::offset_of!(_xmlAttr, _private) - 0usize];
  ["Offset of field: _xmlAttr::type_"][::std::mem::offset_of!(_xmlAttr, type_) - 8usize];
  ["Offset of field: _xmlAttr::name"][::std::mem::offset_of!(_xmlAttr, name) - 16usize];
  ["Offset of field: _xmlAttr::children"][::std::mem::offset_of!(_xmlAttr, children) - 24usize];
  ["Offset of field: _xmlAttr::last"][::std::mem::offset_of!(_xmlAttr, last) - 32usize];
  ["Offset of field: _xmlAttr::parent"][::std::mem::offset_of!(_xmlAttr, parent) - 40usize];
  ["Offset of field: _xmlAttr::next"][::std::mem::offset_of!(_xmlAttr, next) - 48usize];
  ["Offset of field: _xmlAttr::prev"][::std::mem::offset_of!(_xmlAttr, prev) - 56usize];
  ["Offset of field: _xmlAttr::doc"][::std::mem::offset_of!(_xmlAttr, doc) - 64usize];
  ["Offset of field: _xmlAttr::ns"][::std::mem::offset_of!(_xmlAttr, ns) - 72usize];
  ["Offset of field: _xmlAttr::atype"][::std::mem::offset_of!(_xmlAttr, atype) - 80usize];
  ["Offset of field: _xmlAttr::psvi"][::std::mem::offset_of!(_xmlAttr, psvi) - 88usize];
};
#[doc = " xmlID:\n\n An XML ID instance."]
pub type xmlID = _xmlID;
pub type xmlIDPtr = *mut xmlID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlID {
  pub next: *mut _xmlID,
  pub value: *const xmlChar,
  pub attr: xmlAttrPtr,
  pub name: *const xmlChar,
  pub lineno: ::std::os::raw::c_int,
  pub doc: *mut _xmlDoc,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlID"][::std::mem::size_of::<_xmlID>() - 48usize];
  ["Alignment of _xmlID"][::std::mem::align_of::<_xmlID>() - 8usize];
  ["Offset of field: _xmlID::next"][::std::mem::offset_of!(_xmlID, next) - 0usize];
  ["Offset of field: _xmlID::value"][::std::mem::offset_of!(_xmlID, value) - 8usize];
  ["Offset of field: _xmlID::attr"][::std::mem::offset_of!(_xmlID, attr) - 16usize];
  ["Offset of field: _xmlID::name"][::std::mem::offset_of!(_xmlID, name) - 24usize];
  ["Offset of field: _xmlID::lineno"][::std::mem::offset_of!(_xmlID, lineno) - 32usize];
  ["Offset of field: _xmlID::doc"][::std::mem::offset_of!(_xmlID, doc) - 40usize];
};
#[doc = " xmlRef:\n\n An XML IDREF instance."]
pub type xmlRef = _xmlRef;
pub type xmlRefPtr = *mut xmlRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlRef {
  pub next: *mut _xmlRef,
  pub value: *const xmlChar,
  pub attr: xmlAttrPtr,
  pub name: *const xmlChar,
  pub lineno: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlRef"][::std::mem::size_of::<_xmlRef>() - 40usize];
  ["Alignment of _xmlRef"][::std::mem::align_of::<_xmlRef>() - 8usize];
  ["Offset of field: _xmlRef::next"][::std::mem::offset_of!(_xmlRef, next) - 0usize];
  ["Offset of field: _xmlRef::value"][::std::mem::offset_of!(_xmlRef, value) - 8usize];
  ["Offset of field: _xmlRef::attr"][::std::mem::offset_of!(_xmlRef, attr) - 16usize];
  ["Offset of field: _xmlRef::name"][::std::mem::offset_of!(_xmlRef, name) - 24usize];
  ["Offset of field: _xmlRef::lineno"][::std::mem::offset_of!(_xmlRef, lineno) - 32usize];
};
#[doc = " xmlNode:\n\n A node in an XML tree."]
pub type xmlNode = _xmlNode;
pub type xmlNodePtr = *mut xmlNode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlNode {
  pub _private: *mut ::std::os::raw::c_void,
  pub type_: xmlElementType,
  pub name: *const xmlChar,
  pub children: *mut _xmlNode,
  pub last: *mut _xmlNode,
  pub parent: *mut _xmlNode,
  pub next: *mut _xmlNode,
  pub prev: *mut _xmlNode,
  pub doc: *mut _xmlDoc,
  pub ns: *mut xmlNs,
  pub content: *mut xmlChar,
  pub properties: *mut _xmlAttr,
  pub nsDef: *mut xmlNs,
  pub psvi: *mut ::std::os::raw::c_void,
  pub line: ::std::os::raw::c_ushort,
  pub extra: ::std::os::raw::c_ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlNode"][::std::mem::size_of::<_xmlNode>() - 120usize];
  ["Alignment of _xmlNode"][::std::mem::align_of::<_xmlNode>() - 8usize];
  ["Offset of field: _xmlNode::_private"][::std::mem::offset_of!(_xmlNode, _private) - 0usize];
  ["Offset of field: _xmlNode::type_"][::std::mem::offset_of!(_xmlNode, type_) - 8usize];
  ["Offset of field: _xmlNode::name"][::std::mem::offset_of!(_xmlNode, name) - 16usize];
  ["Offset of field: _xmlNode::children"][::std::mem::offset_of!(_xmlNode, children) - 24usize];
  ["Offset of field: _xmlNode::last"][::std::mem::offset_of!(_xmlNode, last) - 32usize];
  ["Offset of field: _xmlNode::parent"][::std::mem::offset_of!(_xmlNode, parent) - 40usize];
  ["Offset of field: _xmlNode::next"][::std::mem::offset_of!(_xmlNode, next) - 48usize];
  ["Offset of field: _xmlNode::prev"][::std::mem::offset_of!(_xmlNode, prev) - 56usize];
  ["Offset of field: _xmlNode::doc"][::std::mem::offset_of!(_xmlNode, doc) - 64usize];
  ["Offset of field: _xmlNode::ns"][::std::mem::offset_of!(_xmlNode, ns) - 72usize];
  ["Offset of field: _xmlNode::content"][::std::mem::offset_of!(_xmlNode, content) - 80usize];
  ["Offset of field: _xmlNode::properties"][::std::mem::offset_of!(_xmlNode, properties) - 88usize];
  ["Offset of field: _xmlNode::nsDef"][::std::mem::offset_of!(_xmlNode, nsDef) - 96usize];
  ["Offset of field: _xmlNode::psvi"][::std::mem::offset_of!(_xmlNode, psvi) - 104usize];
  ["Offset of field: _xmlNode::line"][::std::mem::offset_of!(_xmlNode, line) - 112usize];
  ["Offset of field: _xmlNode::extra"][::std::mem::offset_of!(_xmlNode, extra) - 114usize];
};
pub const xmlDocProperties_XML_DOC_WELLFORMED: xmlDocProperties = 1;
pub const xmlDocProperties_XML_DOC_NSVALID: xmlDocProperties = 2;
pub const xmlDocProperties_XML_DOC_OLD10: xmlDocProperties = 4;
pub const xmlDocProperties_XML_DOC_DTDVALID: xmlDocProperties = 8;
pub const xmlDocProperties_XML_DOC_XINCLUDE: xmlDocProperties = 16;
pub const xmlDocProperties_XML_DOC_USERBUILT: xmlDocProperties = 32;
pub const xmlDocProperties_XML_DOC_INTERNAL: xmlDocProperties = 64;
pub const xmlDocProperties_XML_DOC_HTML: xmlDocProperties = 128;
#[doc = " xmlDocProperty\n\n Set of properties of the document as found by the parser\n Some of them are linked to similarly named xmlParserOption"]
pub type xmlDocProperties = ::std::os::raw::c_uint;
#[doc = " xmlDoc:\n\n An XML document."]
pub type xmlDoc = _xmlDoc;
pub type xmlDocPtr = *mut xmlDoc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlDoc {
  pub _private: *mut ::std::os::raw::c_void,
  pub type_: xmlElementType,
  pub name: *mut ::std::os::raw::c_char,
  pub children: *mut _xmlNode,
  pub last: *mut _xmlNode,
  pub parent: *mut _xmlNode,
  pub next: *mut _xmlNode,
  pub prev: *mut _xmlNode,
  pub doc: *mut _xmlDoc,
  pub compression: ::std::os::raw::c_int,
  pub standalone: ::std::os::raw::c_int,
  pub intSubset: *mut _xmlDtd,
  pub extSubset: *mut _xmlDtd,
  pub oldNs: *mut _xmlNs,
  pub version: *const xmlChar,
  pub encoding: *const xmlChar,
  pub ids: *mut ::std::os::raw::c_void,
  pub refs: *mut ::std::os::raw::c_void,
  pub URL: *const xmlChar,
  pub charset: ::std::os::raw::c_int,
  pub dict: *mut _xmlDict,
  pub psvi: *mut ::std::os::raw::c_void,
  pub parseFlags: ::std::os::raw::c_int,
  pub properties: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlDoc"][::std::mem::size_of::<_xmlDoc>() - 176usize];
  ["Alignment of _xmlDoc"][::std::mem::align_of::<_xmlDoc>() - 8usize];
  ["Offset of field: _xmlDoc::_private"][::std::mem::offset_of!(_xmlDoc, _private) - 0usize];
  ["Offset of field: _xmlDoc::type_"][::std::mem::offset_of!(_xmlDoc, type_) - 8usize];
  ["Offset of field: _xmlDoc::name"][::std::mem::offset_of!(_xmlDoc, name) - 16usize];
  ["Offset of field: _xmlDoc::children"][::std::mem::offset_of!(_xmlDoc, children) - 24usize];
  ["Offset of field: _xmlDoc::last"][::std::mem::offset_of!(_xmlDoc, last) - 32usize];
  ["Offset of field: _xmlDoc::parent"][::std::mem::offset_of!(_xmlDoc, parent) - 40usize];
  ["Offset of field: _xmlDoc::next"][::std::mem::offset_of!(_xmlDoc, next) - 48usize];
  ["Offset of field: _xmlDoc::prev"][::std::mem::offset_of!(_xmlDoc, prev) - 56usize];
  ["Offset of field: _xmlDoc::doc"][::std::mem::offset_of!(_xmlDoc, doc) - 64usize];
  ["Offset of field: _xmlDoc::compression"][::std::mem::offset_of!(_xmlDoc, compression) - 72usize];
  ["Offset of field: _xmlDoc::standalone"][::std::mem::offset_of!(_xmlDoc, standalone) - 76usize];
  ["Offset of field: _xmlDoc::intSubset"][::std::mem::offset_of!(_xmlDoc, intSubset) - 80usize];
  ["Offset of field: _xmlDoc::extSubset"][::std::mem::offset_of!(_xmlDoc, extSubset) - 88usize];
  ["Offset of field: _xmlDoc::oldNs"][::std::mem::offset_of!(_xmlDoc, oldNs) - 96usize];
  ["Offset of field: _xmlDoc::version"][::std::mem::offset_of!(_xmlDoc, version) - 104usize];
  ["Offset of field: _xmlDoc::encoding"][::std::mem::offset_of!(_xmlDoc, encoding) - 112usize];
  ["Offset of field: _xmlDoc::ids"][::std::mem::offset_of!(_xmlDoc, ids) - 120usize];
  ["Offset of field: _xmlDoc::refs"][::std::mem::offset_of!(_xmlDoc, refs) - 128usize];
  ["Offset of field: _xmlDoc::URL"][::std::mem::offset_of!(_xmlDoc, URL) - 136usize];
  ["Offset of field: _xmlDoc::charset"][::std::mem::offset_of!(_xmlDoc, charset) - 144usize];
  ["Offset of field: _xmlDoc::dict"][::std::mem::offset_of!(_xmlDoc, dict) - 152usize];
  ["Offset of field: _xmlDoc::psvi"][::std::mem::offset_of!(_xmlDoc, psvi) - 160usize];
  ["Offset of field: _xmlDoc::parseFlags"][::std::mem::offset_of!(_xmlDoc, parseFlags) - 168usize];
  ["Offset of field: _xmlDoc::properties"][::std::mem::offset_of!(_xmlDoc, properties) - 172usize];
};
#[doc = " xmlDOMWrapCtxt:\n\n Context for DOM wrapper-operations."]
pub type xmlDOMWrapCtxt = _xmlDOMWrapCtxt;
pub type xmlDOMWrapCtxtPtr = *mut xmlDOMWrapCtxt;
#[doc = " xmlDOMWrapAcquireNsFunction:\n @ctxt:  a DOM wrapper context\n @node:  the context node (element or attribute)\n @nsName:  the requested namespace name\n @nsPrefix:  the requested namespace prefix\n\n A function called to acquire namespaces (xmlNs) from the wrapper.\n\n Returns an xmlNsPtr or NULL in case of an error."]
pub type xmlDOMWrapAcquireNsFunction = ::std::option::Option<
  unsafe extern "C" fn(
    ctxt: xmlDOMWrapCtxtPtr,
    node: xmlNodePtr,
    nsName: *const xmlChar,
    nsPrefix: *const xmlChar,
  ) -> xmlNsPtr,
>;
#[doc = " xmlDOMWrapCtxt:\n\n Context for DOM wrapper-operations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlDOMWrapCtxt {
  pub _private: *mut ::std::os::raw::c_void,
  pub type_: ::std::os::raw::c_int,
  pub namespaceMap: *mut ::std::os::raw::c_void,
  pub getNsForNodeFunc: xmlDOMWrapAcquireNsFunction,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlDOMWrapCtxt"][::std::mem::size_of::<_xmlDOMWrapCtxt>() - 32usize];
  ["Alignment of _xmlDOMWrapCtxt"][::std::mem::align_of::<_xmlDOMWrapCtxt>() - 8usize];
  ["Offset of field: _xmlDOMWrapCtxt::_private"]
    [::std::mem::offset_of!(_xmlDOMWrapCtxt, _private) - 0usize];
  ["Offset of field: _xmlDOMWrapCtxt::type_"]
    [::std::mem::offset_of!(_xmlDOMWrapCtxt, type_) - 8usize];
  ["Offset of field: _xmlDOMWrapCtxt::namespaceMap"]
    [::std::mem::offset_of!(_xmlDOMWrapCtxt, namespaceMap) - 16usize];
  ["Offset of field: _xmlDOMWrapCtxt::getNsForNodeFunc"]
    [::std::mem::offset_of!(_xmlDOMWrapCtxt, getNsForNodeFunc) - 24usize];
};
unsafe extern "C" {
  pub fn xmlValidateNCName(
    value: *const xmlChar,
    space: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidateQName(
    value: *const xmlChar,
    space: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidateName(
    value: *const xmlChar,
    space: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidateNMToken(
    value: *const xmlChar,
    space: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlBuildQName(
    ncname: *const xmlChar,
    prefix: *const xmlChar,
    memory: *mut xmlChar,
    len: ::std::os::raw::c_int,
  ) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlSplitQName2(name: *const xmlChar, prefix: *mut *mut xmlChar) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlSplitQName3(name: *const xmlChar, len: *mut ::std::os::raw::c_int) -> *const xmlChar;
}
unsafe extern "C" {
  pub fn xmlSetBufferAllocationScheme(scheme: xmlBufferAllocationScheme);
}
unsafe extern "C" {
  pub fn xmlGetBufferAllocationScheme() -> xmlBufferAllocationScheme;
}
unsafe extern "C" {
  pub fn xmlBufferCreate() -> xmlBufferPtr;
}
unsafe extern "C" {
  pub fn xmlBufferCreateSize(size: usize) -> xmlBufferPtr;
}
unsafe extern "C" {
  pub fn xmlBufferCreateStatic(mem: *mut ::std::os::raw::c_void, size: usize) -> xmlBufferPtr;
}
unsafe extern "C" {
  pub fn xmlBufferResize(buf: xmlBufferPtr, size: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlBufferFree(buf: xmlBufferPtr);
}
unsafe extern "C" {
  pub fn xmlBufferDump(file: *mut FILE, buf: xmlBufferPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlBufferAdd(
    buf: xmlBufferPtr,
    str_: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlBufferAddHead(
    buf: xmlBufferPtr,
    str_: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlBufferCat(buf: xmlBufferPtr, str_: *const xmlChar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlBufferCCat(
    buf: xmlBufferPtr,
    str_: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlBufferShrink(buf: xmlBufferPtr, len: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlBufferGrow(buf: xmlBufferPtr, len: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlBufferEmpty(buf: xmlBufferPtr);
}
unsafe extern "C" {
  pub fn xmlBufferContent(buf: *const xmlBuffer) -> *const xmlChar;
}
unsafe extern "C" {
  pub fn xmlBufferDetach(buf: xmlBufferPtr) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlBufferSetAllocationScheme(buf: xmlBufferPtr, scheme: xmlBufferAllocationScheme);
}
unsafe extern "C" {
  pub fn xmlBufferLength(buf: *const xmlBuffer) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlCreateIntSubset(
    doc: xmlDocPtr,
    name: *const xmlChar,
    ExternalID: *const xmlChar,
    SystemID: *const xmlChar,
  ) -> xmlDtdPtr;
}
unsafe extern "C" {
  pub fn xmlNewDtd(
    doc: xmlDocPtr,
    name: *const xmlChar,
    ExternalID: *const xmlChar,
    SystemID: *const xmlChar,
  ) -> xmlDtdPtr;
}
unsafe extern "C" {
  pub fn xmlGetIntSubset(doc: *const xmlDoc) -> xmlDtdPtr;
}
unsafe extern "C" {
  pub fn xmlFreeDtd(cur: xmlDtdPtr);
}
unsafe extern "C" {
  pub fn xmlNewGlobalNs(doc: xmlDocPtr, href: *const xmlChar, prefix: *const xmlChar) -> xmlNsPtr;
}
unsafe extern "C" {
  pub fn xmlNewNs(node: xmlNodePtr, href: *const xmlChar, prefix: *const xmlChar) -> xmlNsPtr;
}
unsafe extern "C" {
  pub fn xmlFreeNs(cur: xmlNsPtr);
}
unsafe extern "C" {
  pub fn xmlFreeNsList(cur: xmlNsPtr);
}
unsafe extern "C" {
  pub fn xmlNewDoc(version: *const xmlChar) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlFreeDoc(cur: xmlDocPtr);
}
unsafe extern "C" {
  pub fn xmlNewDocProp(doc: xmlDocPtr, name: *const xmlChar, value: *const xmlChar) -> xmlAttrPtr;
}
unsafe extern "C" {
  pub fn xmlNewProp(node: xmlNodePtr, name: *const xmlChar, value: *const xmlChar) -> xmlAttrPtr;
}
unsafe extern "C" {
  pub fn xmlNewNsProp(
    node: xmlNodePtr,
    ns: xmlNsPtr,
    name: *const xmlChar,
    value: *const xmlChar,
  ) -> xmlAttrPtr;
}
unsafe extern "C" {
  pub fn xmlNewNsPropEatName(
    node: xmlNodePtr,
    ns: xmlNsPtr,
    name: *mut xmlChar,
    value: *const xmlChar,
  ) -> xmlAttrPtr;
}
unsafe extern "C" {
  pub fn xmlFreePropList(cur: xmlAttrPtr);
}
unsafe extern "C" {
  pub fn xmlFreeProp(cur: xmlAttrPtr);
}
unsafe extern "C" {
  pub fn xmlCopyProp(target: xmlNodePtr, cur: xmlAttrPtr) -> xmlAttrPtr;
}
unsafe extern "C" {
  pub fn xmlCopyPropList(target: xmlNodePtr, cur: xmlAttrPtr) -> xmlAttrPtr;
}
unsafe extern "C" {
  pub fn xmlCopyDtd(dtd: xmlDtdPtr) -> xmlDtdPtr;
}
unsafe extern "C" {
  pub fn xmlCopyDoc(doc: xmlDocPtr, recursive: ::std::os::raw::c_int) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlNewDocNode(
    doc: xmlDocPtr,
    ns: xmlNsPtr,
    name: *const xmlChar,
    content: *const xmlChar,
  ) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlNewDocNodeEatName(
    doc: xmlDocPtr,
    ns: xmlNsPtr,
    name: *mut xmlChar,
    content: *const xmlChar,
  ) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlNewNode(ns: xmlNsPtr, name: *const xmlChar) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlNewNodeEatName(ns: xmlNsPtr, name: *mut xmlChar) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlNewChild(
    parent: xmlNodePtr,
    ns: xmlNsPtr,
    name: *const xmlChar,
    content: *const xmlChar,
  ) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlNewDocText(doc: *const xmlDoc, content: *const xmlChar) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlNewText(content: *const xmlChar) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlNewDocPI(doc: xmlDocPtr, name: *const xmlChar, content: *const xmlChar) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlNewPI(name: *const xmlChar, content: *const xmlChar) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlNewDocTextLen(
    doc: xmlDocPtr,
    content: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlNewTextLen(content: *const xmlChar, len: ::std::os::raw::c_int) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlNewDocComment(doc: xmlDocPtr, content: *const xmlChar) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlNewComment(content: *const xmlChar) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlNewCDataBlock(
    doc: xmlDocPtr,
    content: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlNewCharRef(doc: xmlDocPtr, name: *const xmlChar) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlNewReference(doc: *const xmlDoc, name: *const xmlChar) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlCopyNode(node: xmlNodePtr, recursive: ::std::os::raw::c_int) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlDocCopyNode(
    node: xmlNodePtr,
    doc: xmlDocPtr,
    recursive: ::std::os::raw::c_int,
  ) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlDocCopyNodeList(doc: xmlDocPtr, node: xmlNodePtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlCopyNodeList(node: xmlNodePtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlNewTextChild(
    parent: xmlNodePtr,
    ns: xmlNsPtr,
    name: *const xmlChar,
    content: *const xmlChar,
  ) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlNewDocRawNode(
    doc: xmlDocPtr,
    ns: xmlNsPtr,
    name: *const xmlChar,
    content: *const xmlChar,
  ) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlNewDocFragment(doc: xmlDocPtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlGetLineNo(node: *const xmlNode) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
  pub fn xmlGetNodePath(node: *const xmlNode) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlDocGetRootElement(doc: *const xmlDoc) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlGetLastChild(parent: *const xmlNode) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlNodeIsText(node: *const xmlNode) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlIsBlankNode(node: *const xmlNode) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlDocSetRootElement(doc: xmlDocPtr, root: xmlNodePtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlNodeSetName(cur: xmlNodePtr, name: *const xmlChar);
}
unsafe extern "C" {
  pub fn xmlAddChild(parent: xmlNodePtr, cur: xmlNodePtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlAddChildList(parent: xmlNodePtr, cur: xmlNodePtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlReplaceNode(old: xmlNodePtr, cur: xmlNodePtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlAddPrevSibling(cur: xmlNodePtr, elem: xmlNodePtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlAddSibling(cur: xmlNodePtr, elem: xmlNodePtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlAddNextSibling(cur: xmlNodePtr, elem: xmlNodePtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlUnlinkNode(cur: xmlNodePtr);
}
unsafe extern "C" {
  pub fn xmlTextMerge(first: xmlNodePtr, second: xmlNodePtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlTextConcat(
    node: xmlNodePtr,
    content: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlFreeNodeList(cur: xmlNodePtr);
}
unsafe extern "C" {
  pub fn xmlFreeNode(cur: xmlNodePtr);
}
unsafe extern "C" {
  pub fn xmlSetTreeDoc(tree: xmlNodePtr, doc: xmlDocPtr);
}
unsafe extern "C" {
  pub fn xmlSetListDoc(list: xmlNodePtr, doc: xmlDocPtr);
}
unsafe extern "C" {
  pub fn xmlSearchNs(doc: xmlDocPtr, node: xmlNodePtr, nameSpace: *const xmlChar) -> xmlNsPtr;
}
unsafe extern "C" {
  pub fn xmlSearchNsByHref(doc: xmlDocPtr, node: xmlNodePtr, href: *const xmlChar) -> xmlNsPtr;
}
unsafe extern "C" {
  pub fn xmlGetNsList(doc: *const xmlDoc, node: *const xmlNode) -> *mut xmlNsPtr;
}
unsafe extern "C" {
  pub fn xmlSetNs(node: xmlNodePtr, ns: xmlNsPtr);
}
unsafe extern "C" {
  pub fn xmlCopyNamespace(cur: xmlNsPtr) -> xmlNsPtr;
}
unsafe extern "C" {
  pub fn xmlCopyNamespaceList(cur: xmlNsPtr) -> xmlNsPtr;
}
unsafe extern "C" {
  pub fn xmlSetProp(node: xmlNodePtr, name: *const xmlChar, value: *const xmlChar) -> xmlAttrPtr;
}
unsafe extern "C" {
  pub fn xmlSetNsProp(
    node: xmlNodePtr,
    ns: xmlNsPtr,
    name: *const xmlChar,
    value: *const xmlChar,
  ) -> xmlAttrPtr;
}
unsafe extern "C" {
  pub fn xmlGetNoNsProp(node: *const xmlNode, name: *const xmlChar) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlGetProp(node: *const xmlNode, name: *const xmlChar) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlHasProp(node: *const xmlNode, name: *const xmlChar) -> xmlAttrPtr;
}
unsafe extern "C" {
  pub fn xmlHasNsProp(
    node: *const xmlNode,
    name: *const xmlChar,
    nameSpace: *const xmlChar,
  ) -> xmlAttrPtr;
}
unsafe extern "C" {
  pub fn xmlGetNsProp(
    node: *const xmlNode,
    name: *const xmlChar,
    nameSpace: *const xmlChar,
  ) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlStringGetNodeList(doc: *const xmlDoc, value: *const xmlChar) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlStringLenGetNodeList(
    doc: *const xmlDoc,
    value: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlNodeListGetString(
    doc: xmlDocPtr,
    list: *const xmlNode,
    inLine: ::std::os::raw::c_int,
  ) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlNodeListGetRawString(
    doc: *const xmlDoc,
    list: *const xmlNode,
    inLine: ::std::os::raw::c_int,
  ) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlNodeSetContent(cur: xmlNodePtr, content: *const xmlChar);
}
unsafe extern "C" {
  pub fn xmlNodeSetContentLen(cur: xmlNodePtr, content: *const xmlChar, len: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlNodeAddContent(cur: xmlNodePtr, content: *const xmlChar);
}
unsafe extern "C" {
  pub fn xmlNodeAddContentLen(cur: xmlNodePtr, content: *const xmlChar, len: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlNodeGetContent(cur: *const xmlNode) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlNodeBufGetContent(buffer: xmlBufferPtr, cur: *const xmlNode) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlBufGetNodeContent(buf: xmlBufPtr, cur: *const xmlNode) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlNodeGetLang(cur: *const xmlNode) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlNodeGetSpacePreserve(cur: *const xmlNode) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlNodeSetLang(cur: xmlNodePtr, lang: *const xmlChar);
}
unsafe extern "C" {
  pub fn xmlNodeSetSpacePreserve(cur: xmlNodePtr, val: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlNodeGetBase(doc: *const xmlDoc, cur: *const xmlNode) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlNodeSetBase(cur: xmlNodePtr, uri: *const xmlChar);
}
unsafe extern "C" {
  pub fn xmlRemoveProp(cur: xmlAttrPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlUnsetNsProp(
    node: xmlNodePtr,
    ns: xmlNsPtr,
    name: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlUnsetProp(node: xmlNodePtr, name: *const xmlChar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlBufferWriteCHAR(buf: xmlBufferPtr, string: *const xmlChar);
}
unsafe extern "C" {
  pub fn xmlBufferWriteChar(buf: xmlBufferPtr, string: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
  pub fn xmlBufferWriteQuotedString(buf: xmlBufferPtr, string: *const xmlChar);
}
unsafe extern "C" {
  pub fn xmlAttrSerializeTxtContent(
    buf: xmlBufferPtr,
    doc: xmlDocPtr,
    attr: xmlAttrPtr,
    string: *const xmlChar,
  );
}
unsafe extern "C" {
  pub fn xmlReconciliateNs(doc: xmlDocPtr, tree: xmlNodePtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlDocDumpFormatMemory(
    cur: xmlDocPtr,
    mem: *mut *mut xmlChar,
    size: *mut ::std::os::raw::c_int,
    format: ::std::os::raw::c_int,
  );
}
unsafe extern "C" {
  pub fn xmlDocDumpMemory(cur: xmlDocPtr, mem: *mut *mut xmlChar, size: *mut ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlDocDumpMemoryEnc(
    out_doc: xmlDocPtr,
    doc_txt_ptr: *mut *mut xmlChar,
    doc_txt_len: *mut ::std::os::raw::c_int,
    txt_encoding: *const ::std::os::raw::c_char,
  );
}
unsafe extern "C" {
  pub fn xmlDocDumpFormatMemoryEnc(
    out_doc: xmlDocPtr,
    doc_txt_ptr: *mut *mut xmlChar,
    doc_txt_len: *mut ::std::os::raw::c_int,
    txt_encoding: *const ::std::os::raw::c_char,
    format: ::std::os::raw::c_int,
  );
}
unsafe extern "C" {
  pub fn xmlDocFormatDump(
    f: *mut FILE,
    cur: xmlDocPtr,
    format: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlDocDump(f: *mut FILE, cur: xmlDocPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlElemDump(f: *mut FILE, doc: xmlDocPtr, cur: xmlNodePtr);
}
unsafe extern "C" {
  pub fn xmlSaveFile(
    filename: *const ::std::os::raw::c_char,
    cur: xmlDocPtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSaveFormatFile(
    filename: *const ::std::os::raw::c_char,
    cur: xmlDocPtr,
    format: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlBufNodeDump(
    buf: xmlBufPtr,
    doc: xmlDocPtr,
    cur: xmlNodePtr,
    level: ::std::os::raw::c_int,
    format: ::std::os::raw::c_int,
  ) -> usize;
}
unsafe extern "C" {
  pub fn xmlNodeDump(
    buf: xmlBufferPtr,
    doc: xmlDocPtr,
    cur: xmlNodePtr,
    level: ::std::os::raw::c_int,
    format: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSaveFileTo(
    buf: xmlOutputBufferPtr,
    cur: xmlDocPtr,
    encoding: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSaveFormatFileTo(
    buf: xmlOutputBufferPtr,
    cur: xmlDocPtr,
    encoding: *const ::std::os::raw::c_char,
    format: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlNodeDumpOutput(
    buf: xmlOutputBufferPtr,
    doc: xmlDocPtr,
    cur: xmlNodePtr,
    level: ::std::os::raw::c_int,
    format: ::std::os::raw::c_int,
    encoding: *const ::std::os::raw::c_char,
  );
}
unsafe extern "C" {
  pub fn xmlSaveFormatFileEnc(
    filename: *const ::std::os::raw::c_char,
    cur: xmlDocPtr,
    encoding: *const ::std::os::raw::c_char,
    format: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSaveFileEnc(
    filename: *const ::std::os::raw::c_char,
    cur: xmlDocPtr,
    encoding: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlIsXHTML(systemID: *const xmlChar, publicID: *const xmlChar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlGetDocCompressMode(doc: *const xmlDoc) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSetDocCompressMode(doc: xmlDocPtr, mode: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlGetCompressMode() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSetCompressMode(mode: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlDOMWrapNewCtxt() -> xmlDOMWrapCtxtPtr;
}
unsafe extern "C" {
  pub fn xmlDOMWrapFreeCtxt(ctxt: xmlDOMWrapCtxtPtr);
}
unsafe extern "C" {
  pub fn xmlDOMWrapReconcileNamespaces(
    ctxt: xmlDOMWrapCtxtPtr,
    elem: xmlNodePtr,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlDOMWrapAdoptNode(
    ctxt: xmlDOMWrapCtxtPtr,
    sourceDoc: xmlDocPtr,
    node: xmlNodePtr,
    destDoc: xmlDocPtr,
    destParent: xmlNodePtr,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlDOMWrapRemoveNode(
    ctxt: xmlDOMWrapCtxtPtr,
    doc: xmlDocPtr,
    node: xmlNodePtr,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlDOMWrapCloneNode(
    ctxt: xmlDOMWrapCtxtPtr,
    sourceDoc: xmlDocPtr,
    node: xmlNodePtr,
    clonedNode: *mut xmlNodePtr,
    destDoc: xmlDocPtr,
    destParent: xmlNodePtr,
    deep: ::std::os::raw::c_int,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlChildElementCount(parent: xmlNodePtr) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
  pub fn xmlNextElementSibling(node: xmlNodePtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlFirstElementChild(parent: xmlNodePtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlLastElementChild(parent: xmlNodePtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlPreviousElementSibling(node: xmlNodePtr) -> xmlNodePtr;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlHashTable {
  _unused: [u8; 0],
}
pub type xmlHashTable = _xmlHashTable;
pub type xmlHashTablePtr = *mut xmlHashTable;
#[doc = " xmlHashDeallocator:\n @payload:  the data in the hash\n @name:  the name associated\n\n Callback to free data from a hash."]
pub type xmlHashDeallocator = ::std::option::Option<
  unsafe extern "C" fn(payload: *mut ::std::os::raw::c_void, name: *const xmlChar),
>;
#[doc = " xmlHashCopier:\n @payload:  the data in the hash\n @name:  the name associated\n\n Callback to copy data from a hash.\n\n Returns a copy of the data or NULL in case of error."]
pub type xmlHashCopier = ::std::option::Option<
  unsafe extern "C" fn(
    payload: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
  ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " xmlHashScanner:\n @payload:  the data in the hash\n @data:  extra scanner data\n @name:  the name associated\n\n Callback when scanning data in a hash with the simple scanner."]
pub type xmlHashScanner = ::std::option::Option<
  unsafe extern "C" fn(
    payload: *mut ::std::os::raw::c_void,
    data: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
  ),
>;
#[doc = " xmlHashScannerFull:\n @payload:  the data in the hash\n @data:  extra scanner data\n @name:  the name associated\n @name2:  the second name associated\n @name3:  the third name associated\n\n Callback when scanning data in a hash with the full scanner."]
pub type xmlHashScannerFull = ::std::option::Option<
  unsafe extern "C" fn(
    payload: *mut ::std::os::raw::c_void,
    data: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    name2: *const xmlChar,
    name3: *const xmlChar,
  ),
>;
unsafe extern "C" {
  pub fn xmlHashCreate(size: ::std::os::raw::c_int) -> xmlHashTablePtr;
}
unsafe extern "C" {
  pub fn xmlHashCreateDict(size: ::std::os::raw::c_int, dict: xmlDictPtr) -> xmlHashTablePtr;
}
unsafe extern "C" {
  pub fn xmlHashFree(table: xmlHashTablePtr, f: xmlHashDeallocator);
}
unsafe extern "C" {
  pub fn xmlHashDefaultDeallocator(entry: *mut ::std::os::raw::c_void, name: *const xmlChar);
}
unsafe extern "C" {
  pub fn xmlHashAddEntry(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    userdata: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlHashUpdateEntry(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    userdata: *mut ::std::os::raw::c_void,
    f: xmlHashDeallocator,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlHashAddEntry2(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    name2: *const xmlChar,
    userdata: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlHashUpdateEntry2(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    name2: *const xmlChar,
    userdata: *mut ::std::os::raw::c_void,
    f: xmlHashDeallocator,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlHashAddEntry3(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    name2: *const xmlChar,
    name3: *const xmlChar,
    userdata: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlHashUpdateEntry3(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    name2: *const xmlChar,
    name3: *const xmlChar,
    userdata: *mut ::std::os::raw::c_void,
    f: xmlHashDeallocator,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlHashRemoveEntry(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    f: xmlHashDeallocator,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlHashRemoveEntry2(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    name2: *const xmlChar,
    f: xmlHashDeallocator,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlHashRemoveEntry3(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    name2: *const xmlChar,
    name3: *const xmlChar,
    f: xmlHashDeallocator,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlHashLookup(table: xmlHashTablePtr, name: *const xmlChar)
    -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn xmlHashLookup2(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    name2: *const xmlChar,
  ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn xmlHashLookup3(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    name2: *const xmlChar,
    name3: *const xmlChar,
  ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn xmlHashQLookup(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    prefix: *const xmlChar,
  ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn xmlHashQLookup2(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    prefix: *const xmlChar,
    name2: *const xmlChar,
    prefix2: *const xmlChar,
  ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn xmlHashQLookup3(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    prefix: *const xmlChar,
    name2: *const xmlChar,
    prefix2: *const xmlChar,
    name3: *const xmlChar,
    prefix3: *const xmlChar,
  ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn xmlHashCopy(table: xmlHashTablePtr, f: xmlHashCopier) -> xmlHashTablePtr;
}
unsafe extern "C" {
  pub fn xmlHashSize(table: xmlHashTablePtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlHashScan(table: xmlHashTablePtr, f: xmlHashScanner, data: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
  pub fn xmlHashScan3(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    name2: *const xmlChar,
    name3: *const xmlChar,
    f: xmlHashScanner,
    data: *mut ::std::os::raw::c_void,
  );
}
unsafe extern "C" {
  pub fn xmlHashScanFull(
    table: xmlHashTablePtr,
    f: xmlHashScannerFull,
    data: *mut ::std::os::raw::c_void,
  );
}
unsafe extern "C" {
  pub fn xmlHashScanFull3(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    name2: *const xmlChar,
    name3: *const xmlChar,
    f: xmlHashScannerFull,
    data: *mut ::std::os::raw::c_void,
  );
}
pub const xmlErrorLevel_XML_ERR_NONE: xmlErrorLevel = 0;
pub const xmlErrorLevel_XML_ERR_WARNING: xmlErrorLevel = 1;
pub const xmlErrorLevel_XML_ERR_ERROR: xmlErrorLevel = 2;
pub const xmlErrorLevel_XML_ERR_FATAL: xmlErrorLevel = 3;
#[doc = " xmlErrorLevel:\n\n Indicates the level of an error"]
pub type xmlErrorLevel = ::std::os::raw::c_uint;
pub const xmlErrorDomain_XML_FROM_NONE: xmlErrorDomain = 0;
pub const xmlErrorDomain_XML_FROM_PARSER: xmlErrorDomain = 1;
pub const xmlErrorDomain_XML_FROM_TREE: xmlErrorDomain = 2;
pub const xmlErrorDomain_XML_FROM_NAMESPACE: xmlErrorDomain = 3;
pub const xmlErrorDomain_XML_FROM_DTD: xmlErrorDomain = 4;
pub const xmlErrorDomain_XML_FROM_HTML: xmlErrorDomain = 5;
pub const xmlErrorDomain_XML_FROM_MEMORY: xmlErrorDomain = 6;
pub const xmlErrorDomain_XML_FROM_OUTPUT: xmlErrorDomain = 7;
pub const xmlErrorDomain_XML_FROM_IO: xmlErrorDomain = 8;
pub const xmlErrorDomain_XML_FROM_FTP: xmlErrorDomain = 9;
pub const xmlErrorDomain_XML_FROM_HTTP: xmlErrorDomain = 10;
pub const xmlErrorDomain_XML_FROM_XINCLUDE: xmlErrorDomain = 11;
pub const xmlErrorDomain_XML_FROM_XPATH: xmlErrorDomain = 12;
pub const xmlErrorDomain_XML_FROM_XPOINTER: xmlErrorDomain = 13;
pub const xmlErrorDomain_XML_FROM_REGEXP: xmlErrorDomain = 14;
pub const xmlErrorDomain_XML_FROM_DATATYPE: xmlErrorDomain = 15;
pub const xmlErrorDomain_XML_FROM_SCHEMASP: xmlErrorDomain = 16;
pub const xmlErrorDomain_XML_FROM_SCHEMASV: xmlErrorDomain = 17;
pub const xmlErrorDomain_XML_FROM_RELAXNGP: xmlErrorDomain = 18;
pub const xmlErrorDomain_XML_FROM_RELAXNGV: xmlErrorDomain = 19;
pub const xmlErrorDomain_XML_FROM_CATALOG: xmlErrorDomain = 20;
pub const xmlErrorDomain_XML_FROM_C14N: xmlErrorDomain = 21;
pub const xmlErrorDomain_XML_FROM_XSLT: xmlErrorDomain = 22;
pub const xmlErrorDomain_XML_FROM_VALID: xmlErrorDomain = 23;
pub const xmlErrorDomain_XML_FROM_CHECK: xmlErrorDomain = 24;
pub const xmlErrorDomain_XML_FROM_WRITER: xmlErrorDomain = 25;
pub const xmlErrorDomain_XML_FROM_MODULE: xmlErrorDomain = 26;
pub const xmlErrorDomain_XML_FROM_I18N: xmlErrorDomain = 27;
pub const xmlErrorDomain_XML_FROM_SCHEMATRONV: xmlErrorDomain = 28;
pub const xmlErrorDomain_XML_FROM_BUFFER: xmlErrorDomain = 29;
pub const xmlErrorDomain_XML_FROM_URI: xmlErrorDomain = 30;
#[doc = " xmlErrorDomain:\n\n Indicates where an error may have come from"]
pub type xmlErrorDomain = ::std::os::raw::c_uint;
#[doc = " xmlError:\n\n An XML Error instance."]
pub type xmlError = _xmlError;
pub type xmlErrorPtr = *mut xmlError;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlError {
  pub domain: ::std::os::raw::c_int,
  pub code: ::std::os::raw::c_int,
  pub message: *mut ::std::os::raw::c_char,
  pub level: xmlErrorLevel,
  pub file: *mut ::std::os::raw::c_char,
  pub line: ::std::os::raw::c_int,
  pub str1: *mut ::std::os::raw::c_char,
  pub str2: *mut ::std::os::raw::c_char,
  pub str3: *mut ::std::os::raw::c_char,
  pub int1: ::std::os::raw::c_int,
  pub int2: ::std::os::raw::c_int,
  pub ctxt: *mut ::std::os::raw::c_void,
  pub node: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlError"][::std::mem::size_of::<_xmlError>() - 88usize];
  ["Alignment of _xmlError"][::std::mem::align_of::<_xmlError>() - 8usize];
  ["Offset of field: _xmlError::domain"][::std::mem::offset_of!(_xmlError, domain) - 0usize];
  ["Offset of field: _xmlError::code"][::std::mem::offset_of!(_xmlError, code) - 4usize];
  ["Offset of field: _xmlError::message"][::std::mem::offset_of!(_xmlError, message) - 8usize];
  ["Offset of field: _xmlError::level"][::std::mem::offset_of!(_xmlError, level) - 16usize];
  ["Offset of field: _xmlError::file"][::std::mem::offset_of!(_xmlError, file) - 24usize];
  ["Offset of field: _xmlError::line"][::std::mem::offset_of!(_xmlError, line) - 32usize];
  ["Offset of field: _xmlError::str1"][::std::mem::offset_of!(_xmlError, str1) - 40usize];
  ["Offset of field: _xmlError::str2"][::std::mem::offset_of!(_xmlError, str2) - 48usize];
  ["Offset of field: _xmlError::str3"][::std::mem::offset_of!(_xmlError, str3) - 56usize];
  ["Offset of field: _xmlError::int1"][::std::mem::offset_of!(_xmlError, int1) - 64usize];
  ["Offset of field: _xmlError::int2"][::std::mem::offset_of!(_xmlError, int2) - 68usize];
  ["Offset of field: _xmlError::ctxt"][::std::mem::offset_of!(_xmlError, ctxt) - 72usize];
  ["Offset of field: _xmlError::node"][::std::mem::offset_of!(_xmlError, node) - 80usize];
};
pub const xmlParserErrors_XML_ERR_OK: xmlParserErrors = 0;
pub const xmlParserErrors_XML_ERR_INTERNAL_ERROR: xmlParserErrors = 1;
pub const xmlParserErrors_XML_ERR_NO_MEMORY: xmlParserErrors = 2;
pub const xmlParserErrors_XML_ERR_DOCUMENT_START: xmlParserErrors = 3;
pub const xmlParserErrors_XML_ERR_DOCUMENT_EMPTY: xmlParserErrors = 4;
pub const xmlParserErrors_XML_ERR_DOCUMENT_END: xmlParserErrors = 5;
pub const xmlParserErrors_XML_ERR_INVALID_HEX_CHARREF: xmlParserErrors = 6;
pub const xmlParserErrors_XML_ERR_INVALID_DEC_CHARREF: xmlParserErrors = 7;
pub const xmlParserErrors_XML_ERR_INVALID_CHARREF: xmlParserErrors = 8;
pub const xmlParserErrors_XML_ERR_INVALID_CHAR: xmlParserErrors = 9;
pub const xmlParserErrors_XML_ERR_CHARREF_AT_EOF: xmlParserErrors = 10;
pub const xmlParserErrors_XML_ERR_CHARREF_IN_PROLOG: xmlParserErrors = 11;
pub const xmlParserErrors_XML_ERR_CHARREF_IN_EPILOG: xmlParserErrors = 12;
pub const xmlParserErrors_XML_ERR_CHARREF_IN_DTD: xmlParserErrors = 13;
pub const xmlParserErrors_XML_ERR_ENTITYREF_AT_EOF: xmlParserErrors = 14;
pub const xmlParserErrors_XML_ERR_ENTITYREF_IN_PROLOG: xmlParserErrors = 15;
pub const xmlParserErrors_XML_ERR_ENTITYREF_IN_EPILOG: xmlParserErrors = 16;
pub const xmlParserErrors_XML_ERR_ENTITYREF_IN_DTD: xmlParserErrors = 17;
pub const xmlParserErrors_XML_ERR_PEREF_AT_EOF: xmlParserErrors = 18;
pub const xmlParserErrors_XML_ERR_PEREF_IN_PROLOG: xmlParserErrors = 19;
pub const xmlParserErrors_XML_ERR_PEREF_IN_EPILOG: xmlParserErrors = 20;
pub const xmlParserErrors_XML_ERR_PEREF_IN_INT_SUBSET: xmlParserErrors = 21;
pub const xmlParserErrors_XML_ERR_ENTITYREF_NO_NAME: xmlParserErrors = 22;
pub const xmlParserErrors_XML_ERR_ENTITYREF_SEMICOL_MISSING: xmlParserErrors = 23;
pub const xmlParserErrors_XML_ERR_PEREF_NO_NAME: xmlParserErrors = 24;
pub const xmlParserErrors_XML_ERR_PEREF_SEMICOL_MISSING: xmlParserErrors = 25;
pub const xmlParserErrors_XML_ERR_UNDECLARED_ENTITY: xmlParserErrors = 26;
pub const xmlParserErrors_XML_WAR_UNDECLARED_ENTITY: xmlParserErrors = 27;
pub const xmlParserErrors_XML_ERR_UNPARSED_ENTITY: xmlParserErrors = 28;
pub const xmlParserErrors_XML_ERR_ENTITY_IS_EXTERNAL: xmlParserErrors = 29;
pub const xmlParserErrors_XML_ERR_ENTITY_IS_PARAMETER: xmlParserErrors = 30;
pub const xmlParserErrors_XML_ERR_UNKNOWN_ENCODING: xmlParserErrors = 31;
pub const xmlParserErrors_XML_ERR_UNSUPPORTED_ENCODING: xmlParserErrors = 32;
pub const xmlParserErrors_XML_ERR_STRING_NOT_STARTED: xmlParserErrors = 33;
pub const xmlParserErrors_XML_ERR_STRING_NOT_CLOSED: xmlParserErrors = 34;
pub const xmlParserErrors_XML_ERR_NS_DECL_ERROR: xmlParserErrors = 35;
pub const xmlParserErrors_XML_ERR_ENTITY_NOT_STARTED: xmlParserErrors = 36;
pub const xmlParserErrors_XML_ERR_ENTITY_NOT_FINISHED: xmlParserErrors = 37;
pub const xmlParserErrors_XML_ERR_LT_IN_ATTRIBUTE: xmlParserErrors = 38;
pub const xmlParserErrors_XML_ERR_ATTRIBUTE_NOT_STARTED: xmlParserErrors = 39;
pub const xmlParserErrors_XML_ERR_ATTRIBUTE_NOT_FINISHED: xmlParserErrors = 40;
pub const xmlParserErrors_XML_ERR_ATTRIBUTE_WITHOUT_VALUE: xmlParserErrors = 41;
pub const xmlParserErrors_XML_ERR_ATTRIBUTE_REDEFINED: xmlParserErrors = 42;
pub const xmlParserErrors_XML_ERR_LITERAL_NOT_STARTED: xmlParserErrors = 43;
pub const xmlParserErrors_XML_ERR_LITERAL_NOT_FINISHED: xmlParserErrors = 44;
pub const xmlParserErrors_XML_ERR_COMMENT_NOT_FINISHED: xmlParserErrors = 45;
pub const xmlParserErrors_XML_ERR_PI_NOT_STARTED: xmlParserErrors = 46;
pub const xmlParserErrors_XML_ERR_PI_NOT_FINISHED: xmlParserErrors = 47;
pub const xmlParserErrors_XML_ERR_NOTATION_NOT_STARTED: xmlParserErrors = 48;
pub const xmlParserErrors_XML_ERR_NOTATION_NOT_FINISHED: xmlParserErrors = 49;
pub const xmlParserErrors_XML_ERR_ATTLIST_NOT_STARTED: xmlParserErrors = 50;
pub const xmlParserErrors_XML_ERR_ATTLIST_NOT_FINISHED: xmlParserErrors = 51;
pub const xmlParserErrors_XML_ERR_MIXED_NOT_STARTED: xmlParserErrors = 52;
pub const xmlParserErrors_XML_ERR_MIXED_NOT_FINISHED: xmlParserErrors = 53;
pub const xmlParserErrors_XML_ERR_ELEMCONTENT_NOT_STARTED: xmlParserErrors = 54;
pub const xmlParserErrors_XML_ERR_ELEMCONTENT_NOT_FINISHED: xmlParserErrors = 55;
pub const xmlParserErrors_XML_ERR_XMLDECL_NOT_STARTED: xmlParserErrors = 56;
pub const xmlParserErrors_XML_ERR_XMLDECL_NOT_FINISHED: xmlParserErrors = 57;
pub const xmlParserErrors_XML_ERR_CONDSEC_NOT_STARTED: xmlParserErrors = 58;
pub const xmlParserErrors_XML_ERR_CONDSEC_NOT_FINISHED: xmlParserErrors = 59;
pub const xmlParserErrors_XML_ERR_EXT_SUBSET_NOT_FINISHED: xmlParserErrors = 60;
pub const xmlParserErrors_XML_ERR_DOCTYPE_NOT_FINISHED: xmlParserErrors = 61;
pub const xmlParserErrors_XML_ERR_MISPLACED_CDATA_END: xmlParserErrors = 62;
pub const xmlParserErrors_XML_ERR_CDATA_NOT_FINISHED: xmlParserErrors = 63;
pub const xmlParserErrors_XML_ERR_RESERVED_XML_NAME: xmlParserErrors = 64;
pub const xmlParserErrors_XML_ERR_SPACE_REQUIRED: xmlParserErrors = 65;
pub const xmlParserErrors_XML_ERR_SEPARATOR_REQUIRED: xmlParserErrors = 66;
pub const xmlParserErrors_XML_ERR_NMTOKEN_REQUIRED: xmlParserErrors = 67;
pub const xmlParserErrors_XML_ERR_NAME_REQUIRED: xmlParserErrors = 68;
pub const xmlParserErrors_XML_ERR_PCDATA_REQUIRED: xmlParserErrors = 69;
pub const xmlParserErrors_XML_ERR_URI_REQUIRED: xmlParserErrors = 70;
pub const xmlParserErrors_XML_ERR_PUBID_REQUIRED: xmlParserErrors = 71;
pub const xmlParserErrors_XML_ERR_LT_REQUIRED: xmlParserErrors = 72;
pub const xmlParserErrors_XML_ERR_GT_REQUIRED: xmlParserErrors = 73;
pub const xmlParserErrors_XML_ERR_LTSLASH_REQUIRED: xmlParserErrors = 74;
pub const xmlParserErrors_XML_ERR_EQUAL_REQUIRED: xmlParserErrors = 75;
pub const xmlParserErrors_XML_ERR_TAG_NAME_MISMATCH: xmlParserErrors = 76;
pub const xmlParserErrors_XML_ERR_TAG_NOT_FINISHED: xmlParserErrors = 77;
pub const xmlParserErrors_XML_ERR_STANDALONE_VALUE: xmlParserErrors = 78;
pub const xmlParserErrors_XML_ERR_ENCODING_NAME: xmlParserErrors = 79;
pub const xmlParserErrors_XML_ERR_HYPHEN_IN_COMMENT: xmlParserErrors = 80;
pub const xmlParserErrors_XML_ERR_INVALID_ENCODING: xmlParserErrors = 81;
pub const xmlParserErrors_XML_ERR_EXT_ENTITY_STANDALONE: xmlParserErrors = 82;
pub const xmlParserErrors_XML_ERR_CONDSEC_INVALID: xmlParserErrors = 83;
pub const xmlParserErrors_XML_ERR_VALUE_REQUIRED: xmlParserErrors = 84;
pub const xmlParserErrors_XML_ERR_NOT_WELL_BALANCED: xmlParserErrors = 85;
pub const xmlParserErrors_XML_ERR_EXTRA_CONTENT: xmlParserErrors = 86;
pub const xmlParserErrors_XML_ERR_ENTITY_CHAR_ERROR: xmlParserErrors = 87;
pub const xmlParserErrors_XML_ERR_ENTITY_PE_INTERNAL: xmlParserErrors = 88;
pub const xmlParserErrors_XML_ERR_ENTITY_LOOP: xmlParserErrors = 89;
pub const xmlParserErrors_XML_ERR_ENTITY_BOUNDARY: xmlParserErrors = 90;
pub const xmlParserErrors_XML_ERR_INVALID_URI: xmlParserErrors = 91;
pub const xmlParserErrors_XML_ERR_URI_FRAGMENT: xmlParserErrors = 92;
pub const xmlParserErrors_XML_WAR_CATALOG_PI: xmlParserErrors = 93;
pub const xmlParserErrors_XML_ERR_NO_DTD: xmlParserErrors = 94;
pub const xmlParserErrors_XML_ERR_CONDSEC_INVALID_KEYWORD: xmlParserErrors = 95;
pub const xmlParserErrors_XML_ERR_VERSION_MISSING: xmlParserErrors = 96;
pub const xmlParserErrors_XML_WAR_UNKNOWN_VERSION: xmlParserErrors = 97;
pub const xmlParserErrors_XML_WAR_LANG_VALUE: xmlParserErrors = 98;
pub const xmlParserErrors_XML_WAR_NS_URI: xmlParserErrors = 99;
pub const xmlParserErrors_XML_WAR_NS_URI_RELATIVE: xmlParserErrors = 100;
pub const xmlParserErrors_XML_ERR_MISSING_ENCODING: xmlParserErrors = 101;
pub const xmlParserErrors_XML_WAR_SPACE_VALUE: xmlParserErrors = 102;
pub const xmlParserErrors_XML_ERR_NOT_STANDALONE: xmlParserErrors = 103;
pub const xmlParserErrors_XML_ERR_ENTITY_PROCESSING: xmlParserErrors = 104;
pub const xmlParserErrors_XML_ERR_NOTATION_PROCESSING: xmlParserErrors = 105;
pub const xmlParserErrors_XML_WAR_NS_COLUMN: xmlParserErrors = 106;
pub const xmlParserErrors_XML_WAR_ENTITY_REDEFINED: xmlParserErrors = 107;
pub const xmlParserErrors_XML_ERR_UNKNOWN_VERSION: xmlParserErrors = 108;
pub const xmlParserErrors_XML_ERR_VERSION_MISMATCH: xmlParserErrors = 109;
pub const xmlParserErrors_XML_ERR_NAME_TOO_LONG: xmlParserErrors = 110;
pub const xmlParserErrors_XML_ERR_USER_STOP: xmlParserErrors = 111;
pub const xmlParserErrors_XML_NS_ERR_XML_NAMESPACE: xmlParserErrors = 200;
pub const xmlParserErrors_XML_NS_ERR_UNDEFINED_NAMESPACE: xmlParserErrors = 201;
pub const xmlParserErrors_XML_NS_ERR_QNAME: xmlParserErrors = 202;
pub const xmlParserErrors_XML_NS_ERR_ATTRIBUTE_REDEFINED: xmlParserErrors = 203;
pub const xmlParserErrors_XML_NS_ERR_EMPTY: xmlParserErrors = 204;
pub const xmlParserErrors_XML_NS_ERR_COLON: xmlParserErrors = 205;
pub const xmlParserErrors_XML_DTD_ATTRIBUTE_DEFAULT: xmlParserErrors = 500;
pub const xmlParserErrors_XML_DTD_ATTRIBUTE_REDEFINED: xmlParserErrors = 501;
pub const xmlParserErrors_XML_DTD_ATTRIBUTE_VALUE: xmlParserErrors = 502;
pub const xmlParserErrors_XML_DTD_CONTENT_ERROR: xmlParserErrors = 503;
pub const xmlParserErrors_XML_DTD_CONTENT_MODEL: xmlParserErrors = 504;
pub const xmlParserErrors_XML_DTD_CONTENT_NOT_DETERMINIST: xmlParserErrors = 505;
pub const xmlParserErrors_XML_DTD_DIFFERENT_PREFIX: xmlParserErrors = 506;
pub const xmlParserErrors_XML_DTD_ELEM_DEFAULT_NAMESPACE: xmlParserErrors = 507;
pub const xmlParserErrors_XML_DTD_ELEM_NAMESPACE: xmlParserErrors = 508;
pub const xmlParserErrors_XML_DTD_ELEM_REDEFINED: xmlParserErrors = 509;
pub const xmlParserErrors_XML_DTD_EMPTY_NOTATION: xmlParserErrors = 510;
pub const xmlParserErrors_XML_DTD_ENTITY_TYPE: xmlParserErrors = 511;
pub const xmlParserErrors_XML_DTD_ID_FIXED: xmlParserErrors = 512;
pub const xmlParserErrors_XML_DTD_ID_REDEFINED: xmlParserErrors = 513;
pub const xmlParserErrors_XML_DTD_ID_SUBSET: xmlParserErrors = 514;
pub const xmlParserErrors_XML_DTD_INVALID_CHILD: xmlParserErrors = 515;
pub const xmlParserErrors_XML_DTD_INVALID_DEFAULT: xmlParserErrors = 516;
pub const xmlParserErrors_XML_DTD_LOAD_ERROR: xmlParserErrors = 517;
pub const xmlParserErrors_XML_DTD_MISSING_ATTRIBUTE: xmlParserErrors = 518;
pub const xmlParserErrors_XML_DTD_MIXED_CORRUPT: xmlParserErrors = 519;
pub const xmlParserErrors_XML_DTD_MULTIPLE_ID: xmlParserErrors = 520;
pub const xmlParserErrors_XML_DTD_NO_DOC: xmlParserErrors = 521;
pub const xmlParserErrors_XML_DTD_NO_DTD: xmlParserErrors = 522;
pub const xmlParserErrors_XML_DTD_NO_ELEM_NAME: xmlParserErrors = 523;
pub const xmlParserErrors_XML_DTD_NO_PREFIX: xmlParserErrors = 524;
pub const xmlParserErrors_XML_DTD_NO_ROOT: xmlParserErrors = 525;
pub const xmlParserErrors_XML_DTD_NOTATION_REDEFINED: xmlParserErrors = 526;
pub const xmlParserErrors_XML_DTD_NOTATION_VALUE: xmlParserErrors = 527;
pub const xmlParserErrors_XML_DTD_NOT_EMPTY: xmlParserErrors = 528;
pub const xmlParserErrors_XML_DTD_NOT_PCDATA: xmlParserErrors = 529;
pub const xmlParserErrors_XML_DTD_NOT_STANDALONE: xmlParserErrors = 530;
pub const xmlParserErrors_XML_DTD_ROOT_NAME: xmlParserErrors = 531;
pub const xmlParserErrors_XML_DTD_STANDALONE_WHITE_SPACE: xmlParserErrors = 532;
pub const xmlParserErrors_XML_DTD_UNKNOWN_ATTRIBUTE: xmlParserErrors = 533;
pub const xmlParserErrors_XML_DTD_UNKNOWN_ELEM: xmlParserErrors = 534;
pub const xmlParserErrors_XML_DTD_UNKNOWN_ENTITY: xmlParserErrors = 535;
pub const xmlParserErrors_XML_DTD_UNKNOWN_ID: xmlParserErrors = 536;
pub const xmlParserErrors_XML_DTD_UNKNOWN_NOTATION: xmlParserErrors = 537;
pub const xmlParserErrors_XML_DTD_STANDALONE_DEFAULTED: xmlParserErrors = 538;
pub const xmlParserErrors_XML_DTD_XMLID_VALUE: xmlParserErrors = 539;
pub const xmlParserErrors_XML_DTD_XMLID_TYPE: xmlParserErrors = 540;
pub const xmlParserErrors_XML_DTD_DUP_TOKEN: xmlParserErrors = 541;
pub const xmlParserErrors_XML_HTML_STRUCURE_ERROR: xmlParserErrors = 800;
pub const xmlParserErrors_XML_HTML_UNKNOWN_TAG: xmlParserErrors = 801;
pub const xmlParserErrors_XML_RNGP_ANYNAME_ATTR_ANCESTOR: xmlParserErrors = 1000;
pub const xmlParserErrors_XML_RNGP_ATTR_CONFLICT: xmlParserErrors = 1001;
pub const xmlParserErrors_XML_RNGP_ATTRIBUTE_CHILDREN: xmlParserErrors = 1002;
pub const xmlParserErrors_XML_RNGP_ATTRIBUTE_CONTENT: xmlParserErrors = 1003;
pub const xmlParserErrors_XML_RNGP_ATTRIBUTE_EMPTY: xmlParserErrors = 1004;
pub const xmlParserErrors_XML_RNGP_ATTRIBUTE_NOOP: xmlParserErrors = 1005;
pub const xmlParserErrors_XML_RNGP_CHOICE_CONTENT: xmlParserErrors = 1006;
pub const xmlParserErrors_XML_RNGP_CHOICE_EMPTY: xmlParserErrors = 1007;
pub const xmlParserErrors_XML_RNGP_CREATE_FAILURE: xmlParserErrors = 1008;
pub const xmlParserErrors_XML_RNGP_DATA_CONTENT: xmlParserErrors = 1009;
pub const xmlParserErrors_XML_RNGP_DEF_CHOICE_AND_INTERLEAVE: xmlParserErrors = 1010;
pub const xmlParserErrors_XML_RNGP_DEFINE_CREATE_FAILED: xmlParserErrors = 1011;
pub const xmlParserErrors_XML_RNGP_DEFINE_EMPTY: xmlParserErrors = 1012;
pub const xmlParserErrors_XML_RNGP_DEFINE_MISSING: xmlParserErrors = 1013;
pub const xmlParserErrors_XML_RNGP_DEFINE_NAME_MISSING: xmlParserErrors = 1014;
pub const xmlParserErrors_XML_RNGP_ELEM_CONTENT_EMPTY: xmlParserErrors = 1015;
pub const xmlParserErrors_XML_RNGP_ELEM_CONTENT_ERROR: xmlParserErrors = 1016;
pub const xmlParserErrors_XML_RNGP_ELEMENT_EMPTY: xmlParserErrors = 1017;
pub const xmlParserErrors_XML_RNGP_ELEMENT_CONTENT: xmlParserErrors = 1018;
pub const xmlParserErrors_XML_RNGP_ELEMENT_NAME: xmlParserErrors = 1019;
pub const xmlParserErrors_XML_RNGP_ELEMENT_NO_CONTENT: xmlParserErrors = 1020;
pub const xmlParserErrors_XML_RNGP_ELEM_TEXT_CONFLICT: xmlParserErrors = 1021;
pub const xmlParserErrors_XML_RNGP_EMPTY: xmlParserErrors = 1022;
pub const xmlParserErrors_XML_RNGP_EMPTY_CONSTRUCT: xmlParserErrors = 1023;
pub const xmlParserErrors_XML_RNGP_EMPTY_CONTENT: xmlParserErrors = 1024;
pub const xmlParserErrors_XML_RNGP_EMPTY_NOT_EMPTY: xmlParserErrors = 1025;
pub const xmlParserErrors_XML_RNGP_ERROR_TYPE_LIB: xmlParserErrors = 1026;
pub const xmlParserErrors_XML_RNGP_EXCEPT_EMPTY: xmlParserErrors = 1027;
pub const xmlParserErrors_XML_RNGP_EXCEPT_MISSING: xmlParserErrors = 1028;
pub const xmlParserErrors_XML_RNGP_EXCEPT_MULTIPLE: xmlParserErrors = 1029;
pub const xmlParserErrors_XML_RNGP_EXCEPT_NO_CONTENT: xmlParserErrors = 1030;
pub const xmlParserErrors_XML_RNGP_EXTERNALREF_EMTPY: xmlParserErrors = 1031;
pub const xmlParserErrors_XML_RNGP_EXTERNAL_REF_FAILURE: xmlParserErrors = 1032;
pub const xmlParserErrors_XML_RNGP_EXTERNALREF_RECURSE: xmlParserErrors = 1033;
pub const xmlParserErrors_XML_RNGP_FORBIDDEN_ATTRIBUTE: xmlParserErrors = 1034;
pub const xmlParserErrors_XML_RNGP_FOREIGN_ELEMENT: xmlParserErrors = 1035;
pub const xmlParserErrors_XML_RNGP_GRAMMAR_CONTENT: xmlParserErrors = 1036;
pub const xmlParserErrors_XML_RNGP_GRAMMAR_EMPTY: xmlParserErrors = 1037;
pub const xmlParserErrors_XML_RNGP_GRAMMAR_MISSING: xmlParserErrors = 1038;
pub const xmlParserErrors_XML_RNGP_GRAMMAR_NO_START: xmlParserErrors = 1039;
pub const xmlParserErrors_XML_RNGP_GROUP_ATTR_CONFLICT: xmlParserErrors = 1040;
pub const xmlParserErrors_XML_RNGP_HREF_ERROR: xmlParserErrors = 1041;
pub const xmlParserErrors_XML_RNGP_INCLUDE_EMPTY: xmlParserErrors = 1042;
pub const xmlParserErrors_XML_RNGP_INCLUDE_FAILURE: xmlParserErrors = 1043;
pub const xmlParserErrors_XML_RNGP_INCLUDE_RECURSE: xmlParserErrors = 1044;
pub const xmlParserErrors_XML_RNGP_INTERLEAVE_ADD: xmlParserErrors = 1045;
pub const xmlParserErrors_XML_RNGP_INTERLEAVE_CREATE_FAILED: xmlParserErrors = 1046;
pub const xmlParserErrors_XML_RNGP_INTERLEAVE_EMPTY: xmlParserErrors = 1047;
pub const xmlParserErrors_XML_RNGP_INTERLEAVE_NO_CONTENT: xmlParserErrors = 1048;
pub const xmlParserErrors_XML_RNGP_INVALID_DEFINE_NAME: xmlParserErrors = 1049;
pub const xmlParserErrors_XML_RNGP_INVALID_URI: xmlParserErrors = 1050;
pub const xmlParserErrors_XML_RNGP_INVALID_VALUE: xmlParserErrors = 1051;
pub const xmlParserErrors_XML_RNGP_MISSING_HREF: xmlParserErrors = 1052;
pub const xmlParserErrors_XML_RNGP_NAME_MISSING: xmlParserErrors = 1053;
pub const xmlParserErrors_XML_RNGP_NEED_COMBINE: xmlParserErrors = 1054;
pub const xmlParserErrors_XML_RNGP_NOTALLOWED_NOT_EMPTY: xmlParserErrors = 1055;
pub const xmlParserErrors_XML_RNGP_NSNAME_ATTR_ANCESTOR: xmlParserErrors = 1056;
pub const xmlParserErrors_XML_RNGP_NSNAME_NO_NS: xmlParserErrors = 1057;
pub const xmlParserErrors_XML_RNGP_PARAM_FORBIDDEN: xmlParserErrors = 1058;
pub const xmlParserErrors_XML_RNGP_PARAM_NAME_MISSING: xmlParserErrors = 1059;
pub const xmlParserErrors_XML_RNGP_PARENTREF_CREATE_FAILED: xmlParserErrors = 1060;
pub const xmlParserErrors_XML_RNGP_PARENTREF_NAME_INVALID: xmlParserErrors = 1061;
pub const xmlParserErrors_XML_RNGP_PARENTREF_NO_NAME: xmlParserErrors = 1062;
pub const xmlParserErrors_XML_RNGP_PARENTREF_NO_PARENT: xmlParserErrors = 1063;
pub const xmlParserErrors_XML_RNGP_PARENTREF_NOT_EMPTY: xmlParserErrors = 1064;
pub const xmlParserErrors_XML_RNGP_PARSE_ERROR: xmlParserErrors = 1065;
pub const xmlParserErrors_XML_RNGP_PAT_ANYNAME_EXCEPT_ANYNAME: xmlParserErrors = 1066;
pub const xmlParserErrors_XML_RNGP_PAT_ATTR_ATTR: xmlParserErrors = 1067;
pub const xmlParserErrors_XML_RNGP_PAT_ATTR_ELEM: xmlParserErrors = 1068;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_ATTR: xmlParserErrors = 1069;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_ELEM: xmlParserErrors = 1070;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_EMPTY: xmlParserErrors = 1071;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_GROUP: xmlParserErrors = 1072;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_INTERLEAVE: xmlParserErrors = 1073;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_LIST: xmlParserErrors = 1074;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_ONEMORE: xmlParserErrors = 1075;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_REF: xmlParserErrors = 1076;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_TEXT: xmlParserErrors = 1077;
pub const xmlParserErrors_XML_RNGP_PAT_LIST_ATTR: xmlParserErrors = 1078;
pub const xmlParserErrors_XML_RNGP_PAT_LIST_ELEM: xmlParserErrors = 1079;
pub const xmlParserErrors_XML_RNGP_PAT_LIST_INTERLEAVE: xmlParserErrors = 1080;
pub const xmlParserErrors_XML_RNGP_PAT_LIST_LIST: xmlParserErrors = 1081;
pub const xmlParserErrors_XML_RNGP_PAT_LIST_REF: xmlParserErrors = 1082;
pub const xmlParserErrors_XML_RNGP_PAT_LIST_TEXT: xmlParserErrors = 1083;
pub const xmlParserErrors_XML_RNGP_PAT_NSNAME_EXCEPT_ANYNAME: xmlParserErrors = 1084;
pub const xmlParserErrors_XML_RNGP_PAT_NSNAME_EXCEPT_NSNAME: xmlParserErrors = 1085;
pub const xmlParserErrors_XML_RNGP_PAT_ONEMORE_GROUP_ATTR: xmlParserErrors = 1086;
pub const xmlParserErrors_XML_RNGP_PAT_ONEMORE_INTERLEAVE_ATTR: xmlParserErrors = 1087;
pub const xmlParserErrors_XML_RNGP_PAT_START_ATTR: xmlParserErrors = 1088;
pub const xmlParserErrors_XML_RNGP_PAT_START_DATA: xmlParserErrors = 1089;
pub const xmlParserErrors_XML_RNGP_PAT_START_EMPTY: xmlParserErrors = 1090;
pub const xmlParserErrors_XML_RNGP_PAT_START_GROUP: xmlParserErrors = 1091;
pub const xmlParserErrors_XML_RNGP_PAT_START_INTERLEAVE: xmlParserErrors = 1092;
pub const xmlParserErrors_XML_RNGP_PAT_START_LIST: xmlParserErrors = 1093;
pub const xmlParserErrors_XML_RNGP_PAT_START_ONEMORE: xmlParserErrors = 1094;
pub const xmlParserErrors_XML_RNGP_PAT_START_TEXT: xmlParserErrors = 1095;
pub const xmlParserErrors_XML_RNGP_PAT_START_VALUE: xmlParserErrors = 1096;
pub const xmlParserErrors_XML_RNGP_PREFIX_UNDEFINED: xmlParserErrors = 1097;
pub const xmlParserErrors_XML_RNGP_REF_CREATE_FAILED: xmlParserErrors = 1098;
pub const xmlParserErrors_XML_RNGP_REF_CYCLE: xmlParserErrors = 1099;
pub const xmlParserErrors_XML_RNGP_REF_NAME_INVALID: xmlParserErrors = 1100;
pub const xmlParserErrors_XML_RNGP_REF_NO_DEF: xmlParserErrors = 1101;
pub const xmlParserErrors_XML_RNGP_REF_NO_NAME: xmlParserErrors = 1102;
pub const xmlParserErrors_XML_RNGP_REF_NOT_EMPTY: xmlParserErrors = 1103;
pub const xmlParserErrors_XML_RNGP_START_CHOICE_AND_INTERLEAVE: xmlParserErrors = 1104;
pub const xmlParserErrors_XML_RNGP_START_CONTENT: xmlParserErrors = 1105;
pub const xmlParserErrors_XML_RNGP_START_EMPTY: xmlParserErrors = 1106;
pub const xmlParserErrors_XML_RNGP_START_MISSING: xmlParserErrors = 1107;
pub const xmlParserErrors_XML_RNGP_TEXT_EXPECTED: xmlParserErrors = 1108;
pub const xmlParserErrors_XML_RNGP_TEXT_HAS_CHILD: xmlParserErrors = 1109;
pub const xmlParserErrors_XML_RNGP_TYPE_MISSING: xmlParserErrors = 1110;
pub const xmlParserErrors_XML_RNGP_TYPE_NOT_FOUND: xmlParserErrors = 1111;
pub const xmlParserErrors_XML_RNGP_TYPE_VALUE: xmlParserErrors = 1112;
pub const xmlParserErrors_XML_RNGP_UNKNOWN_ATTRIBUTE: xmlParserErrors = 1113;
pub const xmlParserErrors_XML_RNGP_UNKNOWN_COMBINE: xmlParserErrors = 1114;
pub const xmlParserErrors_XML_RNGP_UNKNOWN_CONSTRUCT: xmlParserErrors = 1115;
pub const xmlParserErrors_XML_RNGP_UNKNOWN_TYPE_LIB: xmlParserErrors = 1116;
pub const xmlParserErrors_XML_RNGP_URI_FRAGMENT: xmlParserErrors = 1117;
pub const xmlParserErrors_XML_RNGP_URI_NOT_ABSOLUTE: xmlParserErrors = 1118;
pub const xmlParserErrors_XML_RNGP_VALUE_EMPTY: xmlParserErrors = 1119;
pub const xmlParserErrors_XML_RNGP_VALUE_NO_CONTENT: xmlParserErrors = 1120;
pub const xmlParserErrors_XML_RNGP_XMLNS_NAME: xmlParserErrors = 1121;
pub const xmlParserErrors_XML_RNGP_XML_NS: xmlParserErrors = 1122;
pub const xmlParserErrors_XML_XPATH_EXPRESSION_OK: xmlParserErrors = 1200;
pub const xmlParserErrors_XML_XPATH_NUMBER_ERROR: xmlParserErrors = 1201;
pub const xmlParserErrors_XML_XPATH_UNFINISHED_LITERAL_ERROR: xmlParserErrors = 1202;
pub const xmlParserErrors_XML_XPATH_START_LITERAL_ERROR: xmlParserErrors = 1203;
pub const xmlParserErrors_XML_XPATH_VARIABLE_REF_ERROR: xmlParserErrors = 1204;
pub const xmlParserErrors_XML_XPATH_UNDEF_VARIABLE_ERROR: xmlParserErrors = 1205;
pub const xmlParserErrors_XML_XPATH_INVALID_PREDICATE_ERROR: xmlParserErrors = 1206;
pub const xmlParserErrors_XML_XPATH_EXPR_ERROR: xmlParserErrors = 1207;
pub const xmlParserErrors_XML_XPATH_UNCLOSED_ERROR: xmlParserErrors = 1208;
pub const xmlParserErrors_XML_XPATH_UNKNOWN_FUNC_ERROR: xmlParserErrors = 1209;
pub const xmlParserErrors_XML_XPATH_INVALID_OPERAND: xmlParserErrors = 1210;
pub const xmlParserErrors_XML_XPATH_INVALID_TYPE: xmlParserErrors = 1211;
pub const xmlParserErrors_XML_XPATH_INVALID_ARITY: xmlParserErrors = 1212;
pub const xmlParserErrors_XML_XPATH_INVALID_CTXT_SIZE: xmlParserErrors = 1213;
pub const xmlParserErrors_XML_XPATH_INVALID_CTXT_POSITION: xmlParserErrors = 1214;
pub const xmlParserErrors_XML_XPATH_MEMORY_ERROR: xmlParserErrors = 1215;
pub const xmlParserErrors_XML_XPTR_SYNTAX_ERROR: xmlParserErrors = 1216;
pub const xmlParserErrors_XML_XPTR_RESOURCE_ERROR: xmlParserErrors = 1217;
pub const xmlParserErrors_XML_XPTR_SUB_RESOURCE_ERROR: xmlParserErrors = 1218;
pub const xmlParserErrors_XML_XPATH_UNDEF_PREFIX_ERROR: xmlParserErrors = 1219;
pub const xmlParserErrors_XML_XPATH_ENCODING_ERROR: xmlParserErrors = 1220;
pub const xmlParserErrors_XML_XPATH_INVALID_CHAR_ERROR: xmlParserErrors = 1221;
pub const xmlParserErrors_XML_TREE_INVALID_HEX: xmlParserErrors = 1300;
pub const xmlParserErrors_XML_TREE_INVALID_DEC: xmlParserErrors = 1301;
pub const xmlParserErrors_XML_TREE_UNTERMINATED_ENTITY: xmlParserErrors = 1302;
pub const xmlParserErrors_XML_TREE_NOT_UTF8: xmlParserErrors = 1303;
pub const xmlParserErrors_XML_SAVE_NOT_UTF8: xmlParserErrors = 1400;
pub const xmlParserErrors_XML_SAVE_CHAR_INVALID: xmlParserErrors = 1401;
pub const xmlParserErrors_XML_SAVE_NO_DOCTYPE: xmlParserErrors = 1402;
pub const xmlParserErrors_XML_SAVE_UNKNOWN_ENCODING: xmlParserErrors = 1403;
pub const xmlParserErrors_XML_REGEXP_COMPILE_ERROR: xmlParserErrors = 1450;
pub const xmlParserErrors_XML_IO_UNKNOWN: xmlParserErrors = 1500;
pub const xmlParserErrors_XML_IO_EACCES: xmlParserErrors = 1501;
pub const xmlParserErrors_XML_IO_EAGAIN: xmlParserErrors = 1502;
pub const xmlParserErrors_XML_IO_EBADF: xmlParserErrors = 1503;
pub const xmlParserErrors_XML_IO_EBADMSG: xmlParserErrors = 1504;
pub const xmlParserErrors_XML_IO_EBUSY: xmlParserErrors = 1505;
pub const xmlParserErrors_XML_IO_ECANCELED: xmlParserErrors = 1506;
pub const xmlParserErrors_XML_IO_ECHILD: xmlParserErrors = 1507;
pub const xmlParserErrors_XML_IO_EDEADLK: xmlParserErrors = 1508;
pub const xmlParserErrors_XML_IO_EDOM: xmlParserErrors = 1509;
pub const xmlParserErrors_XML_IO_EEXIST: xmlParserErrors = 1510;
pub const xmlParserErrors_XML_IO_EFAULT: xmlParserErrors = 1511;
pub const xmlParserErrors_XML_IO_EFBIG: xmlParserErrors = 1512;
pub const xmlParserErrors_XML_IO_EINPROGRESS: xmlParserErrors = 1513;
pub const xmlParserErrors_XML_IO_EINTR: xmlParserErrors = 1514;
pub const xmlParserErrors_XML_IO_EINVAL: xmlParserErrors = 1515;
pub const xmlParserErrors_XML_IO_EIO: xmlParserErrors = 1516;
pub const xmlParserErrors_XML_IO_EISDIR: xmlParserErrors = 1517;
pub const xmlParserErrors_XML_IO_EMFILE: xmlParserErrors = 1518;
pub const xmlParserErrors_XML_IO_EMLINK: xmlParserErrors = 1519;
pub const xmlParserErrors_XML_IO_EMSGSIZE: xmlParserErrors = 1520;
pub const xmlParserErrors_XML_IO_ENAMETOOLONG: xmlParserErrors = 1521;
pub const xmlParserErrors_XML_IO_ENFILE: xmlParserErrors = 1522;
pub const xmlParserErrors_XML_IO_ENODEV: xmlParserErrors = 1523;
pub const xmlParserErrors_XML_IO_ENOENT: xmlParserErrors = 1524;
pub const xmlParserErrors_XML_IO_ENOEXEC: xmlParserErrors = 1525;
pub const xmlParserErrors_XML_IO_ENOLCK: xmlParserErrors = 1526;
pub const xmlParserErrors_XML_IO_ENOMEM: xmlParserErrors = 1527;
pub const xmlParserErrors_XML_IO_ENOSPC: xmlParserErrors = 1528;
pub const xmlParserErrors_XML_IO_ENOSYS: xmlParserErrors = 1529;
pub const xmlParserErrors_XML_IO_ENOTDIR: xmlParserErrors = 1530;
pub const xmlParserErrors_XML_IO_ENOTEMPTY: xmlParserErrors = 1531;
pub const xmlParserErrors_XML_IO_ENOTSUP: xmlParserErrors = 1532;
pub const xmlParserErrors_XML_IO_ENOTTY: xmlParserErrors = 1533;
pub const xmlParserErrors_XML_IO_ENXIO: xmlParserErrors = 1534;
pub const xmlParserErrors_XML_IO_EPERM: xmlParserErrors = 1535;
pub const xmlParserErrors_XML_IO_EPIPE: xmlParserErrors = 1536;
pub const xmlParserErrors_XML_IO_ERANGE: xmlParserErrors = 1537;
pub const xmlParserErrors_XML_IO_EROFS: xmlParserErrors = 1538;
pub const xmlParserErrors_XML_IO_ESPIPE: xmlParserErrors = 1539;
pub const xmlParserErrors_XML_IO_ESRCH: xmlParserErrors = 1540;
pub const xmlParserErrors_XML_IO_ETIMEDOUT: xmlParserErrors = 1541;
pub const xmlParserErrors_XML_IO_EXDEV: xmlParserErrors = 1542;
pub const xmlParserErrors_XML_IO_NETWORK_ATTEMPT: xmlParserErrors = 1543;
pub const xmlParserErrors_XML_IO_ENCODER: xmlParserErrors = 1544;
pub const xmlParserErrors_XML_IO_FLUSH: xmlParserErrors = 1545;
pub const xmlParserErrors_XML_IO_WRITE: xmlParserErrors = 1546;
pub const xmlParserErrors_XML_IO_NO_INPUT: xmlParserErrors = 1547;
pub const xmlParserErrors_XML_IO_BUFFER_FULL: xmlParserErrors = 1548;
pub const xmlParserErrors_XML_IO_LOAD_ERROR: xmlParserErrors = 1549;
pub const xmlParserErrors_XML_IO_ENOTSOCK: xmlParserErrors = 1550;
pub const xmlParserErrors_XML_IO_EISCONN: xmlParserErrors = 1551;
pub const xmlParserErrors_XML_IO_ECONNREFUSED: xmlParserErrors = 1552;
pub const xmlParserErrors_XML_IO_ENETUNREACH: xmlParserErrors = 1553;
pub const xmlParserErrors_XML_IO_EADDRINUSE: xmlParserErrors = 1554;
pub const xmlParserErrors_XML_IO_EALREADY: xmlParserErrors = 1555;
pub const xmlParserErrors_XML_IO_EAFNOSUPPORT: xmlParserErrors = 1556;
pub const xmlParserErrors_XML_XINCLUDE_RECURSION: xmlParserErrors = 1600;
pub const xmlParserErrors_XML_XINCLUDE_PARSE_VALUE: xmlParserErrors = 1601;
pub const xmlParserErrors_XML_XINCLUDE_ENTITY_DEF_MISMATCH: xmlParserErrors = 1602;
pub const xmlParserErrors_XML_XINCLUDE_NO_HREF: xmlParserErrors = 1603;
pub const xmlParserErrors_XML_XINCLUDE_NO_FALLBACK: xmlParserErrors = 1604;
pub const xmlParserErrors_XML_XINCLUDE_HREF_URI: xmlParserErrors = 1605;
pub const xmlParserErrors_XML_XINCLUDE_TEXT_FRAGMENT: xmlParserErrors = 1606;
pub const xmlParserErrors_XML_XINCLUDE_TEXT_DOCUMENT: xmlParserErrors = 1607;
pub const xmlParserErrors_XML_XINCLUDE_INVALID_CHAR: xmlParserErrors = 1608;
pub const xmlParserErrors_XML_XINCLUDE_BUILD_FAILED: xmlParserErrors = 1609;
pub const xmlParserErrors_XML_XINCLUDE_UNKNOWN_ENCODING: xmlParserErrors = 1610;
pub const xmlParserErrors_XML_XINCLUDE_MULTIPLE_ROOT: xmlParserErrors = 1611;
pub const xmlParserErrors_XML_XINCLUDE_XPTR_FAILED: xmlParserErrors = 1612;
pub const xmlParserErrors_XML_XINCLUDE_XPTR_RESULT: xmlParserErrors = 1613;
pub const xmlParserErrors_XML_XINCLUDE_INCLUDE_IN_INCLUDE: xmlParserErrors = 1614;
pub const xmlParserErrors_XML_XINCLUDE_FALLBACKS_IN_INCLUDE: xmlParserErrors = 1615;
pub const xmlParserErrors_XML_XINCLUDE_FALLBACK_NOT_IN_INCLUDE: xmlParserErrors = 1616;
pub const xmlParserErrors_XML_XINCLUDE_DEPRECATED_NS: xmlParserErrors = 1617;
pub const xmlParserErrors_XML_XINCLUDE_FRAGMENT_ID: xmlParserErrors = 1618;
pub const xmlParserErrors_XML_CATALOG_MISSING_ATTR: xmlParserErrors = 1650;
pub const xmlParserErrors_XML_CATALOG_ENTRY_BROKEN: xmlParserErrors = 1651;
pub const xmlParserErrors_XML_CATALOG_PREFER_VALUE: xmlParserErrors = 1652;
pub const xmlParserErrors_XML_CATALOG_NOT_CATALOG: xmlParserErrors = 1653;
pub const xmlParserErrors_XML_CATALOG_RECURSION: xmlParserErrors = 1654;
pub const xmlParserErrors_XML_SCHEMAP_PREFIX_UNDEFINED: xmlParserErrors = 1700;
pub const xmlParserErrors_XML_SCHEMAP_ATTRFORMDEFAULT_VALUE: xmlParserErrors = 1701;
pub const xmlParserErrors_XML_SCHEMAP_ATTRGRP_NONAME_NOREF: xmlParserErrors = 1702;
pub const xmlParserErrors_XML_SCHEMAP_ATTR_NONAME_NOREF: xmlParserErrors = 1703;
pub const xmlParserErrors_XML_SCHEMAP_COMPLEXTYPE_NONAME_NOREF: xmlParserErrors = 1704;
pub const xmlParserErrors_XML_SCHEMAP_ELEMFORMDEFAULT_VALUE: xmlParserErrors = 1705;
pub const xmlParserErrors_XML_SCHEMAP_ELEM_NONAME_NOREF: xmlParserErrors = 1706;
pub const xmlParserErrors_XML_SCHEMAP_EXTENSION_NO_BASE: xmlParserErrors = 1707;
pub const xmlParserErrors_XML_SCHEMAP_FACET_NO_VALUE: xmlParserErrors = 1708;
pub const xmlParserErrors_XML_SCHEMAP_FAILED_BUILD_IMPORT: xmlParserErrors = 1709;
pub const xmlParserErrors_XML_SCHEMAP_GROUP_NONAME_NOREF: xmlParserErrors = 1710;
pub const xmlParserErrors_XML_SCHEMAP_IMPORT_NAMESPACE_NOT_URI: xmlParserErrors = 1711;
pub const xmlParserErrors_XML_SCHEMAP_IMPORT_REDEFINE_NSNAME: xmlParserErrors = 1712;
pub const xmlParserErrors_XML_SCHEMAP_IMPORT_SCHEMA_NOT_URI: xmlParserErrors = 1713;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_BOOLEAN: xmlParserErrors = 1714;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_ENUM: xmlParserErrors = 1715;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_FACET: xmlParserErrors = 1716;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_FACET_VALUE: xmlParserErrors = 1717;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_MAXOCCURS: xmlParserErrors = 1718;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_MINOCCURS: xmlParserErrors = 1719;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_REF_AND_SUBTYPE: xmlParserErrors = 1720;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_WHITE_SPACE: xmlParserErrors = 1721;
pub const xmlParserErrors_XML_SCHEMAP_NOATTR_NOREF: xmlParserErrors = 1722;
pub const xmlParserErrors_XML_SCHEMAP_NOTATION_NO_NAME: xmlParserErrors = 1723;
pub const xmlParserErrors_XML_SCHEMAP_NOTYPE_NOREF: xmlParserErrors = 1724;
pub const xmlParserErrors_XML_SCHEMAP_REF_AND_SUBTYPE: xmlParserErrors = 1725;
pub const xmlParserErrors_XML_SCHEMAP_RESTRICTION_NONAME_NOREF: xmlParserErrors = 1726;
pub const xmlParserErrors_XML_SCHEMAP_SIMPLETYPE_NONAME: xmlParserErrors = 1727;
pub const xmlParserErrors_XML_SCHEMAP_TYPE_AND_SUBTYPE: xmlParserErrors = 1728;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ALL_CHILD: xmlParserErrors = 1729;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ANYATTRIBUTE_CHILD: xmlParserErrors = 1730;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ATTR_CHILD: xmlParserErrors = 1731;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ATTRGRP_CHILD: xmlParserErrors = 1732;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ATTRIBUTE_GROUP: xmlParserErrors = 1733;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_BASE_TYPE: xmlParserErrors = 1734;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_CHOICE_CHILD: xmlParserErrors = 1735;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_COMPLEXCONTENT_CHILD: xmlParserErrors = 1736;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_COMPLEXTYPE_CHILD: xmlParserErrors = 1737;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ELEM_CHILD: xmlParserErrors = 1738;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_EXTENSION_CHILD: xmlParserErrors = 1739;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_FACET_CHILD: xmlParserErrors = 1740;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_FACET_TYPE: xmlParserErrors = 1741;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_GROUP_CHILD: xmlParserErrors = 1742;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_IMPORT_CHILD: xmlParserErrors = 1743;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_LIST_CHILD: xmlParserErrors = 1744;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_NOTATION_CHILD: xmlParserErrors = 1745;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_PROCESSCONTENT_CHILD: xmlParserErrors = 1746;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_REF: xmlParserErrors = 1747;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_RESTRICTION_CHILD: xmlParserErrors = 1748;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_SCHEMAS_CHILD: xmlParserErrors = 1749;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_SEQUENCE_CHILD: xmlParserErrors = 1750;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_SIMPLECONTENT_CHILD: xmlParserErrors = 1751;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_SIMPLETYPE_CHILD: xmlParserErrors = 1752;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_TYPE: xmlParserErrors = 1753;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_UNION_CHILD: xmlParserErrors = 1754;
pub const xmlParserErrors_XML_SCHEMAP_ELEM_DEFAULT_FIXED: xmlParserErrors = 1755;
pub const xmlParserErrors_XML_SCHEMAP_REGEXP_INVALID: xmlParserErrors = 1756;
pub const xmlParserErrors_XML_SCHEMAP_FAILED_LOAD: xmlParserErrors = 1757;
pub const xmlParserErrors_XML_SCHEMAP_NOTHING_TO_PARSE: xmlParserErrors = 1758;
pub const xmlParserErrors_XML_SCHEMAP_NOROOT: xmlParserErrors = 1759;
pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_GROUP: xmlParserErrors = 1760;
pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_TYPE: xmlParserErrors = 1761;
pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_ELEMENT: xmlParserErrors = 1762;
pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_ATTRGROUP: xmlParserErrors = 1763;
pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_ATTR: xmlParserErrors = 1764;
pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_NOTATION: xmlParserErrors = 1765;
pub const xmlParserErrors_XML_SCHEMAP_FAILED_PARSE: xmlParserErrors = 1766;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_PREFIX: xmlParserErrors = 1767;
pub const xmlParserErrors_XML_SCHEMAP_DEF_AND_PREFIX: xmlParserErrors = 1768;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_INCLUDE_CHILD: xmlParserErrors = 1769;
pub const xmlParserErrors_XML_SCHEMAP_INCLUDE_SCHEMA_NOT_URI: xmlParserErrors = 1770;
pub const xmlParserErrors_XML_SCHEMAP_INCLUDE_SCHEMA_NO_URI: xmlParserErrors = 1771;
pub const xmlParserErrors_XML_SCHEMAP_NOT_SCHEMA: xmlParserErrors = 1772;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_MEMBER_TYPE: xmlParserErrors = 1773;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_ATTR_USE: xmlParserErrors = 1774;
pub const xmlParserErrors_XML_SCHEMAP_RECURSIVE: xmlParserErrors = 1775;
pub const xmlParserErrors_XML_SCHEMAP_SUPERNUMEROUS_LIST_ITEM_TYPE: xmlParserErrors = 1776;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_ATTR_COMBINATION: xmlParserErrors = 1777;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_ATTR_INLINE_COMBINATION: xmlParserErrors = 1778;
pub const xmlParserErrors_XML_SCHEMAP_MISSING_SIMPLETYPE_CHILD: xmlParserErrors = 1779;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_ATTR_NAME: xmlParserErrors = 1780;
pub const xmlParserErrors_XML_SCHEMAP_REF_AND_CONTENT: xmlParserErrors = 1781;
pub const xmlParserErrors_XML_SCHEMAP_CT_PROPS_CORRECT_1: xmlParserErrors = 1782;
pub const xmlParserErrors_XML_SCHEMAP_CT_PROPS_CORRECT_2: xmlParserErrors = 1783;
pub const xmlParserErrors_XML_SCHEMAP_CT_PROPS_CORRECT_3: xmlParserErrors = 1784;
pub const xmlParserErrors_XML_SCHEMAP_CT_PROPS_CORRECT_4: xmlParserErrors = 1785;
pub const xmlParserErrors_XML_SCHEMAP_CT_PROPS_CORRECT_5: xmlParserErrors = 1786;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1: xmlParserErrors = 1787;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1: xmlParserErrors = 1788;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2: xmlParserErrors = 1789;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2: xmlParserErrors = 1790;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3: xmlParserErrors = 1791;
pub const xmlParserErrors_XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER: xmlParserErrors = 1792;
pub const xmlParserErrors_XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE: xmlParserErrors = 1793;
pub const xmlParserErrors_XML_SCHEMAP_UNION_NOT_EXPRESSIBLE: xmlParserErrors = 1794;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_3_1: xmlParserErrors = 1795;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_3_2: xmlParserErrors = 1796;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1: xmlParserErrors = 1797;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2: xmlParserErrors = 1798;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3: xmlParserErrors = 1799;
pub const xmlParserErrors_XML_SCHEMAP_COS_CT_EXTENDS_1_3: xmlParserErrors = 1800;
pub const xmlParserErrors_XML_SCHEMAV_NOROOT: xmlParserErrors = 1801;
pub const xmlParserErrors_XML_SCHEMAV_UNDECLAREDELEM: xmlParserErrors = 1802;
pub const xmlParserErrors_XML_SCHEMAV_NOTTOPLEVEL: xmlParserErrors = 1803;
pub const xmlParserErrors_XML_SCHEMAV_MISSING: xmlParserErrors = 1804;
pub const xmlParserErrors_XML_SCHEMAV_WRONGELEM: xmlParserErrors = 1805;
pub const xmlParserErrors_XML_SCHEMAV_NOTYPE: xmlParserErrors = 1806;
pub const xmlParserErrors_XML_SCHEMAV_NOROLLBACK: xmlParserErrors = 1807;
pub const xmlParserErrors_XML_SCHEMAV_ISABSTRACT: xmlParserErrors = 1808;
pub const xmlParserErrors_XML_SCHEMAV_NOTEMPTY: xmlParserErrors = 1809;
pub const xmlParserErrors_XML_SCHEMAV_ELEMCONT: xmlParserErrors = 1810;
pub const xmlParserErrors_XML_SCHEMAV_HAVEDEFAULT: xmlParserErrors = 1811;
pub const xmlParserErrors_XML_SCHEMAV_NOTNILLABLE: xmlParserErrors = 1812;
pub const xmlParserErrors_XML_SCHEMAV_EXTRACONTENT: xmlParserErrors = 1813;
pub const xmlParserErrors_XML_SCHEMAV_INVALIDATTR: xmlParserErrors = 1814;
pub const xmlParserErrors_XML_SCHEMAV_INVALIDELEM: xmlParserErrors = 1815;
pub const xmlParserErrors_XML_SCHEMAV_NOTDETERMINIST: xmlParserErrors = 1816;
pub const xmlParserErrors_XML_SCHEMAV_CONSTRUCT: xmlParserErrors = 1817;
pub const xmlParserErrors_XML_SCHEMAV_INTERNAL: xmlParserErrors = 1818;
pub const xmlParserErrors_XML_SCHEMAV_NOTSIMPLE: xmlParserErrors = 1819;
pub const xmlParserErrors_XML_SCHEMAV_ATTRUNKNOWN: xmlParserErrors = 1820;
pub const xmlParserErrors_XML_SCHEMAV_ATTRINVALID: xmlParserErrors = 1821;
pub const xmlParserErrors_XML_SCHEMAV_VALUE: xmlParserErrors = 1822;
pub const xmlParserErrors_XML_SCHEMAV_FACET: xmlParserErrors = 1823;
pub const xmlParserErrors_XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1: xmlParserErrors = 1824;
pub const xmlParserErrors_XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2: xmlParserErrors = 1825;
pub const xmlParserErrors_XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3: xmlParserErrors = 1826;
pub const xmlParserErrors_XML_SCHEMAV_CVC_TYPE_3_1_1: xmlParserErrors = 1827;
pub const xmlParserErrors_XML_SCHEMAV_CVC_TYPE_3_1_2: xmlParserErrors = 1828;
pub const xmlParserErrors_XML_SCHEMAV_CVC_FACET_VALID: xmlParserErrors = 1829;
pub const xmlParserErrors_XML_SCHEMAV_CVC_LENGTH_VALID: xmlParserErrors = 1830;
pub const xmlParserErrors_XML_SCHEMAV_CVC_MINLENGTH_VALID: xmlParserErrors = 1831;
pub const xmlParserErrors_XML_SCHEMAV_CVC_MAXLENGTH_VALID: xmlParserErrors = 1832;
pub const xmlParserErrors_XML_SCHEMAV_CVC_MININCLUSIVE_VALID: xmlParserErrors = 1833;
pub const xmlParserErrors_XML_SCHEMAV_CVC_MAXINCLUSIVE_VALID: xmlParserErrors = 1834;
pub const xmlParserErrors_XML_SCHEMAV_CVC_MINEXCLUSIVE_VALID: xmlParserErrors = 1835;
pub const xmlParserErrors_XML_SCHEMAV_CVC_MAXEXCLUSIVE_VALID: xmlParserErrors = 1836;
pub const xmlParserErrors_XML_SCHEMAV_CVC_TOTALDIGITS_VALID: xmlParserErrors = 1837;
pub const xmlParserErrors_XML_SCHEMAV_CVC_FRACTIONDIGITS_VALID: xmlParserErrors = 1838;
pub const xmlParserErrors_XML_SCHEMAV_CVC_PATTERN_VALID: xmlParserErrors = 1839;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ENUMERATION_VALID: xmlParserErrors = 1840;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1: xmlParserErrors = 1841;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2: xmlParserErrors = 1842;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3: xmlParserErrors = 1843;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_2_4: xmlParserErrors = 1844;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_1: xmlParserErrors = 1845;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_2: xmlParserErrors = 1846;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_3_1: xmlParserErrors = 1847;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_3_2_1: xmlParserErrors = 1848;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_3_2_2: xmlParserErrors = 1849;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_4_1: xmlParserErrors = 1850;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_4_2: xmlParserErrors = 1851;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_4_3: xmlParserErrors = 1852;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_1_1: xmlParserErrors = 1853;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_1_2: xmlParserErrors = 1854;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_2_1: xmlParserErrors = 1855;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_2_2_1: xmlParserErrors = 1856;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_2_2_2_1: xmlParserErrors = 1857;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_2_2_2_2: xmlParserErrors = 1858;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_6: xmlParserErrors = 1859;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_7: xmlParserErrors = 1860;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ATTRIBUTE_1: xmlParserErrors = 1861;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ATTRIBUTE_2: xmlParserErrors = 1862;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ATTRIBUTE_3: xmlParserErrors = 1863;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ATTRIBUTE_4: xmlParserErrors = 1864;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_3_1: xmlParserErrors = 1865;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1: xmlParserErrors = 1866;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2: xmlParserErrors = 1867;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_4: xmlParserErrors = 1868;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_5_1: xmlParserErrors = 1869;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_5_2: xmlParserErrors = 1870;
pub const xmlParserErrors_XML_SCHEMAV_ELEMENT_CONTENT: xmlParserErrors = 1871;
pub const xmlParserErrors_XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING: xmlParserErrors = 1872;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_1: xmlParserErrors = 1873;
pub const xmlParserErrors_XML_SCHEMAV_CVC_AU: xmlParserErrors = 1874;
pub const xmlParserErrors_XML_SCHEMAV_CVC_TYPE_1: xmlParserErrors = 1875;
pub const xmlParserErrors_XML_SCHEMAV_CVC_TYPE_2: xmlParserErrors = 1876;
pub const xmlParserErrors_XML_SCHEMAV_CVC_IDC: xmlParserErrors = 1877;
pub const xmlParserErrors_XML_SCHEMAV_CVC_WILDCARD: xmlParserErrors = 1878;
pub const xmlParserErrors_XML_SCHEMAV_MISC: xmlParserErrors = 1879;
pub const xmlParserErrors_XML_XPTR_UNKNOWN_SCHEME: xmlParserErrors = 1900;
pub const xmlParserErrors_XML_XPTR_CHILDSEQ_START: xmlParserErrors = 1901;
pub const xmlParserErrors_XML_XPTR_EVAL_FAILED: xmlParserErrors = 1902;
pub const xmlParserErrors_XML_XPTR_EXTRA_OBJECTS: xmlParserErrors = 1903;
pub const xmlParserErrors_XML_C14N_CREATE_CTXT: xmlParserErrors = 1950;
pub const xmlParserErrors_XML_C14N_REQUIRES_UTF8: xmlParserErrors = 1951;
pub const xmlParserErrors_XML_C14N_CREATE_STACK: xmlParserErrors = 1952;
pub const xmlParserErrors_XML_C14N_INVALID_NODE: xmlParserErrors = 1953;
pub const xmlParserErrors_XML_C14N_UNKNOW_NODE: xmlParserErrors = 1954;
pub const xmlParserErrors_XML_C14N_RELATIVE_NAMESPACE: xmlParserErrors = 1955;
pub const xmlParserErrors_XML_FTP_PASV_ANSWER: xmlParserErrors = 2000;
pub const xmlParserErrors_XML_FTP_EPSV_ANSWER: xmlParserErrors = 2001;
pub const xmlParserErrors_XML_FTP_ACCNT: xmlParserErrors = 2002;
pub const xmlParserErrors_XML_FTP_URL_SYNTAX: xmlParserErrors = 2003;
pub const xmlParserErrors_XML_HTTP_URL_SYNTAX: xmlParserErrors = 2020;
pub const xmlParserErrors_XML_HTTP_USE_IP: xmlParserErrors = 2021;
pub const xmlParserErrors_XML_HTTP_UNKNOWN_HOST: xmlParserErrors = 2022;
pub const xmlParserErrors_XML_SCHEMAP_SRC_SIMPLE_TYPE_1: xmlParserErrors = 3000;
pub const xmlParserErrors_XML_SCHEMAP_SRC_SIMPLE_TYPE_2: xmlParserErrors = 3001;
pub const xmlParserErrors_XML_SCHEMAP_SRC_SIMPLE_TYPE_3: xmlParserErrors = 3002;
pub const xmlParserErrors_XML_SCHEMAP_SRC_SIMPLE_TYPE_4: xmlParserErrors = 3003;
pub const xmlParserErrors_XML_SCHEMAP_SRC_RESOLVE: xmlParserErrors = 3004;
pub const xmlParserErrors_XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE: xmlParserErrors = 3005;
pub const xmlParserErrors_XML_SCHEMAP_SRC_LIST_ITEMTYPE_OR_SIMPLETYPE: xmlParserErrors = 3006;
pub const xmlParserErrors_XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES: xmlParserErrors = 3007;
pub const xmlParserErrors_XML_SCHEMAP_ST_PROPS_CORRECT_1: xmlParserErrors = 3008;
pub const xmlParserErrors_XML_SCHEMAP_ST_PROPS_CORRECT_2: xmlParserErrors = 3009;
pub const xmlParserErrors_XML_SCHEMAP_ST_PROPS_CORRECT_3: xmlParserErrors = 3010;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_1_1: xmlParserErrors = 3011;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_1_2: xmlParserErrors = 3012;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1: xmlParserErrors = 3013;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_1_3_2: xmlParserErrors = 3014;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_1: xmlParserErrors = 3015;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1: xmlParserErrors = 3016;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2: xmlParserErrors = 3017;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1: xmlParserErrors = 3018;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2: xmlParserErrors = 3019;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3: xmlParserErrors = 3020;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4: xmlParserErrors = 3021;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_5: xmlParserErrors = 3022;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_1: xmlParserErrors = 3023;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1: xmlParserErrors = 3024;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2: xmlParserErrors = 3025;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2: xmlParserErrors = 3026;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1: xmlParserErrors = 3027;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3: xmlParserErrors = 3028;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4: xmlParserErrors = 3029;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_5: xmlParserErrors = 3030;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_DERIVED_OK_2_1: xmlParserErrors = 3031;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_DERIVED_OK_2_2: xmlParserErrors = 3032;
pub const xmlParserErrors_XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED: xmlParserErrors = 3033;
pub const xmlParserErrors_XML_SCHEMAP_S4S_ELEM_MISSING: xmlParserErrors = 3034;
pub const xmlParserErrors_XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED: xmlParserErrors = 3035;
pub const xmlParserErrors_XML_SCHEMAP_S4S_ATTR_MISSING: xmlParserErrors = 3036;
pub const xmlParserErrors_XML_SCHEMAP_S4S_ATTR_INVALID_VALUE: xmlParserErrors = 3037;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ELEMENT_1: xmlParserErrors = 3038;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ELEMENT_2_1: xmlParserErrors = 3039;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ELEMENT_2_2: xmlParserErrors = 3040;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ELEMENT_3: xmlParserErrors = 3041;
pub const xmlParserErrors_XML_SCHEMAP_P_PROPS_CORRECT_1: xmlParserErrors = 3042;
pub const xmlParserErrors_XML_SCHEMAP_P_PROPS_CORRECT_2_1: xmlParserErrors = 3043;
pub const xmlParserErrors_XML_SCHEMAP_P_PROPS_CORRECT_2_2: xmlParserErrors = 3044;
pub const xmlParserErrors_XML_SCHEMAP_E_PROPS_CORRECT_2: xmlParserErrors = 3045;
pub const xmlParserErrors_XML_SCHEMAP_E_PROPS_CORRECT_3: xmlParserErrors = 3046;
pub const xmlParserErrors_XML_SCHEMAP_E_PROPS_CORRECT_4: xmlParserErrors = 3047;
pub const xmlParserErrors_XML_SCHEMAP_E_PROPS_CORRECT_5: xmlParserErrors = 3048;
pub const xmlParserErrors_XML_SCHEMAP_E_PROPS_CORRECT_6: xmlParserErrors = 3049;
pub const xmlParserErrors_XML_SCHEMAP_SRC_INCLUDE: xmlParserErrors = 3050;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_1: xmlParserErrors = 3051;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_2: xmlParserErrors = 3052;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_3_1: xmlParserErrors = 3053;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_3_2: xmlParserErrors = 3054;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_4: xmlParserErrors = 3055;
pub const xmlParserErrors_XML_SCHEMAP_NO_XMLNS: xmlParserErrors = 3056;
pub const xmlParserErrors_XML_SCHEMAP_NO_XSI: xmlParserErrors = 3057;
pub const xmlParserErrors_XML_SCHEMAP_COS_VALID_DEFAULT_1: xmlParserErrors = 3058;
pub const xmlParserErrors_XML_SCHEMAP_COS_VALID_DEFAULT_2_1: xmlParserErrors = 3059;
pub const xmlParserErrors_XML_SCHEMAP_COS_VALID_DEFAULT_2_2_1: xmlParserErrors = 3060;
pub const xmlParserErrors_XML_SCHEMAP_COS_VALID_DEFAULT_2_2_2: xmlParserErrors = 3061;
pub const xmlParserErrors_XML_SCHEMAP_CVC_SIMPLE_TYPE: xmlParserErrors = 3062;
pub const xmlParserErrors_XML_SCHEMAP_COS_CT_EXTENDS_1_1: xmlParserErrors = 3063;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_1_1: xmlParserErrors = 3064;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_1_2: xmlParserErrors = 3065;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_2: xmlParserErrors = 3066;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_2_1: xmlParserErrors = 3067;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_2_2: xmlParserErrors = 3068;
pub const xmlParserErrors_XML_SCHEMAP_INTERNAL: xmlParserErrors = 3069;
pub const xmlParserErrors_XML_SCHEMAP_NOT_DETERMINISTIC: xmlParserErrors = 3070;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_1: xmlParserErrors = 3071;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_2: xmlParserErrors = 3072;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3: xmlParserErrors = 3073;
pub const xmlParserErrors_XML_SCHEMAP_MG_PROPS_CORRECT_1: xmlParserErrors = 3074;
pub const xmlParserErrors_XML_SCHEMAP_MG_PROPS_CORRECT_2: xmlParserErrors = 3075;
pub const xmlParserErrors_XML_SCHEMAP_SRC_CT_1: xmlParserErrors = 3076;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3: xmlParserErrors = 3077;
pub const xmlParserErrors_XML_SCHEMAP_AU_PROPS_CORRECT_2: xmlParserErrors = 3078;
pub const xmlParserErrors_XML_SCHEMAP_A_PROPS_CORRECT_2: xmlParserErrors = 3079;
pub const xmlParserErrors_XML_SCHEMAP_C_PROPS_CORRECT: xmlParserErrors = 3080;
pub const xmlParserErrors_XML_SCHEMAP_SRC_REDEFINE: xmlParserErrors = 3081;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT: xmlParserErrors = 3082;
pub const xmlParserErrors_XML_SCHEMAP_WARN_SKIP_SCHEMA: xmlParserErrors = 3083;
pub const xmlParserErrors_XML_SCHEMAP_WARN_UNLOCATED_SCHEMA: xmlParserErrors = 3084;
pub const xmlParserErrors_XML_SCHEMAP_WARN_ATTR_REDECL_PROH: xmlParserErrors = 3085;
pub const xmlParserErrors_XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH: xmlParserErrors = 3086;
pub const xmlParserErrors_XML_SCHEMAP_AG_PROPS_CORRECT: xmlParserErrors = 3087;
pub const xmlParserErrors_XML_SCHEMAP_COS_CT_EXTENDS_1_2: xmlParserErrors = 3088;
pub const xmlParserErrors_XML_SCHEMAP_AU_PROPS_CORRECT: xmlParserErrors = 3089;
pub const xmlParserErrors_XML_SCHEMAP_A_PROPS_CORRECT_3: xmlParserErrors = 3090;
pub const xmlParserErrors_XML_SCHEMAP_COS_ALL_LIMITED: xmlParserErrors = 3091;
pub const xmlParserErrors_XML_SCHEMATRONV_ASSERT: xmlParserErrors = 4000;
pub const xmlParserErrors_XML_SCHEMATRONV_REPORT: xmlParserErrors = 4001;
pub const xmlParserErrors_XML_MODULE_OPEN: xmlParserErrors = 4900;
pub const xmlParserErrors_XML_MODULE_CLOSE: xmlParserErrors = 4901;
pub const xmlParserErrors_XML_CHECK_FOUND_ELEMENT: xmlParserErrors = 5000;
pub const xmlParserErrors_XML_CHECK_FOUND_ATTRIBUTE: xmlParserErrors = 5001;
pub const xmlParserErrors_XML_CHECK_FOUND_TEXT: xmlParserErrors = 5002;
pub const xmlParserErrors_XML_CHECK_FOUND_CDATA: xmlParserErrors = 5003;
pub const xmlParserErrors_XML_CHECK_FOUND_ENTITYREF: xmlParserErrors = 5004;
pub const xmlParserErrors_XML_CHECK_FOUND_ENTITY: xmlParserErrors = 5005;
pub const xmlParserErrors_XML_CHECK_FOUND_PI: xmlParserErrors = 5006;
pub const xmlParserErrors_XML_CHECK_FOUND_COMMENT: xmlParserErrors = 5007;
pub const xmlParserErrors_XML_CHECK_FOUND_DOCTYPE: xmlParserErrors = 5008;
pub const xmlParserErrors_XML_CHECK_FOUND_FRAGMENT: xmlParserErrors = 5009;
pub const xmlParserErrors_XML_CHECK_FOUND_NOTATION: xmlParserErrors = 5010;
pub const xmlParserErrors_XML_CHECK_UNKNOWN_NODE: xmlParserErrors = 5011;
pub const xmlParserErrors_XML_CHECK_ENTITY_TYPE: xmlParserErrors = 5012;
pub const xmlParserErrors_XML_CHECK_NO_PARENT: xmlParserErrors = 5013;
pub const xmlParserErrors_XML_CHECK_NO_DOC: xmlParserErrors = 5014;
pub const xmlParserErrors_XML_CHECK_NO_NAME: xmlParserErrors = 5015;
pub const xmlParserErrors_XML_CHECK_NO_ELEM: xmlParserErrors = 5016;
pub const xmlParserErrors_XML_CHECK_WRONG_DOC: xmlParserErrors = 5017;
pub const xmlParserErrors_XML_CHECK_NO_PREV: xmlParserErrors = 5018;
pub const xmlParserErrors_XML_CHECK_WRONG_PREV: xmlParserErrors = 5019;
pub const xmlParserErrors_XML_CHECK_NO_NEXT: xmlParserErrors = 5020;
pub const xmlParserErrors_XML_CHECK_WRONG_NEXT: xmlParserErrors = 5021;
pub const xmlParserErrors_XML_CHECK_NOT_DTD: xmlParserErrors = 5022;
pub const xmlParserErrors_XML_CHECK_NOT_ATTR: xmlParserErrors = 5023;
pub const xmlParserErrors_XML_CHECK_NOT_ATTR_DECL: xmlParserErrors = 5024;
pub const xmlParserErrors_XML_CHECK_NOT_ELEM_DECL: xmlParserErrors = 5025;
pub const xmlParserErrors_XML_CHECK_NOT_ENTITY_DECL: xmlParserErrors = 5026;
pub const xmlParserErrors_XML_CHECK_NOT_NS_DECL: xmlParserErrors = 5027;
pub const xmlParserErrors_XML_CHECK_NO_HREF: xmlParserErrors = 5028;
pub const xmlParserErrors_XML_CHECK_WRONG_PARENT: xmlParserErrors = 5029;
pub const xmlParserErrors_XML_CHECK_NS_SCOPE: xmlParserErrors = 5030;
pub const xmlParserErrors_XML_CHECK_NS_ANCESTOR: xmlParserErrors = 5031;
pub const xmlParserErrors_XML_CHECK_NOT_UTF8: xmlParserErrors = 5032;
pub const xmlParserErrors_XML_CHECK_NO_DICT: xmlParserErrors = 5033;
pub const xmlParserErrors_XML_CHECK_NOT_NCNAME: xmlParserErrors = 5034;
pub const xmlParserErrors_XML_CHECK_OUTSIDE_DICT: xmlParserErrors = 5035;
pub const xmlParserErrors_XML_CHECK_WRONG_NAME: xmlParserErrors = 5036;
pub const xmlParserErrors_XML_CHECK_NAME_NOT_NULL: xmlParserErrors = 5037;
pub const xmlParserErrors_XML_I18N_NO_NAME: xmlParserErrors = 6000;
pub const xmlParserErrors_XML_I18N_NO_HANDLER: xmlParserErrors = 6001;
pub const xmlParserErrors_XML_I18N_EXCESS_HANDLER: xmlParserErrors = 6002;
pub const xmlParserErrors_XML_I18N_CONV_FAILED: xmlParserErrors = 6003;
pub const xmlParserErrors_XML_I18N_NO_OUTPUT: xmlParserErrors = 6004;
pub const xmlParserErrors_XML_BUF_OVERFLOW: xmlParserErrors = 7000;
#[doc = " xmlParserError:\n\n This is an error that the XML (or HTML) parser can generate"]
pub type xmlParserErrors = ::std::os::raw::c_uint;
#[doc = " xmlGenericErrorFunc:\n @ctx:  a parsing context\n @msg:  the message\n @...:  the extra arguments of the varargs to format the message\n\n Signature of the function to use when there is an error and\n no parsing or validity context available ."]
pub type xmlGenericErrorFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
#[doc = " xmlStructuredErrorFunc:\n @userData:  user provided data for the error callback\n @error:  the error being raised.\n\n Signature of the function to use when there is an error and\n the module handles the new error reporting mechanism."]
pub type xmlStructuredErrorFunc = ::std::option::Option<
  unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void, error: xmlErrorPtr),
>;
unsafe extern "C" {
  pub fn xmlSetGenericErrorFunc(ctx: *mut ::std::os::raw::c_void, handler: xmlGenericErrorFunc);
}

unsafe extern "C" {
  pub fn xmlSetStructuredErrorFunc(
    ctx: *mut ::std::os::raw::c_void,
    handler: xmlStructuredErrorFunc,
  );
}
unsafe extern "C" {
  pub fn xmlParserError(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
  pub fn xmlParserWarning(
    ctx: *mut ::std::os::raw::c_void,
    msg: *const ::std::os::raw::c_char,
    ...
  );
}
unsafe extern "C" {
  pub fn xmlParserValidityError(
    ctx: *mut ::std::os::raw::c_void,
    msg: *const ::std::os::raw::c_char,
    ...
  );
}
unsafe extern "C" {
  pub fn xmlParserValidityWarning(
    ctx: *mut ::std::os::raw::c_void,
    msg: *const ::std::os::raw::c_char,
    ...
  );
}
unsafe extern "C" {
  pub fn xmlParserPrintFileInfo(input: xmlParserInputPtr);
}
unsafe extern "C" {
  pub fn xmlParserPrintFileContext(input: xmlParserInputPtr);
}
unsafe extern "C" {
  pub fn xmlGetLastError() -> xmlErrorPtr;
}
unsafe extern "C" {
  pub fn xmlResetLastError();
}
unsafe extern "C" {
  pub fn xmlCtxtGetLastError(ctx: *mut ::std::os::raw::c_void) -> xmlErrorPtr;
}
unsafe extern "C" {
  pub fn xmlCtxtResetLastError(ctx: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
  pub fn xmlResetError(err: xmlErrorPtr);
}
unsafe extern "C" {
  pub fn xmlCopyError(from: xmlErrorPtr, to: xmlErrorPtr) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlLink {
  _unused: [u8; 0],
}
pub type xmlLink = _xmlLink;
pub type xmlLinkPtr = *mut xmlLink;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlList {
  _unused: [u8; 0],
}
pub type xmlList = _xmlList;
pub type xmlListPtr = *mut xmlList;
#[doc = " xmlListDeallocator:\n @lk:  the data to deallocate\n\n Callback function used to free data from a list."]
pub type xmlListDeallocator = ::std::option::Option<unsafe extern "C" fn(lk: xmlLinkPtr)>;
#[doc = " xmlListDataCompare:\n @data0: the first data\n @data1: the second data\n\n Callback function used to compare 2 data.\n\n Returns 0 is equality, -1 or 1 otherwise depending on the ordering."]
pub type xmlListDataCompare = ::std::option::Option<
  unsafe extern "C" fn(
    data0: *const ::std::os::raw::c_void,
    data1: *const ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int,
>;
#[doc = " xmlListWalker:\n @data: the data found in the list\n @user: extra user provided data to the walker\n\n Callback function used when walking a list with xmlListWalk().\n\n Returns 0 to stop walking the list, 1 otherwise."]
pub type xmlListWalker = ::std::option::Option<
  unsafe extern "C" fn(
    data: *const ::std::os::raw::c_void,
    user: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
  pub fn xmlListCreate(deallocator: xmlListDeallocator, compare: xmlListDataCompare) -> xmlListPtr;
}
unsafe extern "C" {
  pub fn xmlListDelete(l: xmlListPtr);
}
unsafe extern "C" {
  pub fn xmlListSearch(
    l: xmlListPtr,
    data: *mut ::std::os::raw::c_void,
  ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn xmlListReverseSearch(
    l: xmlListPtr,
    data: *mut ::std::os::raw::c_void,
  ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn xmlListInsert(l: xmlListPtr, data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlListAppend(l: xmlListPtr, data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlListRemoveFirst(
    l: xmlListPtr,
    data: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlListRemoveLast(
    l: xmlListPtr,
    data: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlListRemoveAll(
    l: xmlListPtr,
    data: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlListClear(l: xmlListPtr);
}
unsafe extern "C" {
  pub fn xmlListEmpty(l: xmlListPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlListFront(l: xmlListPtr) -> xmlLinkPtr;
}
unsafe extern "C" {
  pub fn xmlListEnd(l: xmlListPtr) -> xmlLinkPtr;
}
unsafe extern "C" {
  pub fn xmlListSize(l: xmlListPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlListPopFront(l: xmlListPtr);
}
unsafe extern "C" {
  pub fn xmlListPopBack(l: xmlListPtr);
}
unsafe extern "C" {
  pub fn xmlListPushFront(
    l: xmlListPtr,
    data: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlListPushBack(l: xmlListPtr, data: *mut ::std::os::raw::c_void)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlListReverse(l: xmlListPtr);
}
unsafe extern "C" {
  pub fn xmlListSort(l: xmlListPtr);
}
unsafe extern "C" {
  pub fn xmlListWalk(l: xmlListPtr, walker: xmlListWalker, user: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
  pub fn xmlListReverseWalk(
    l: xmlListPtr,
    walker: xmlListWalker,
    user: *mut ::std::os::raw::c_void,
  );
}
unsafe extern "C" {
  pub fn xmlListMerge(l1: xmlListPtr, l2: xmlListPtr);
}
unsafe extern "C" {
  pub fn xmlListDup(old: xmlListPtr) -> xmlListPtr;
}
unsafe extern "C" {
  pub fn xmlListCopy(cur: xmlListPtr, old: xmlListPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlLinkGetData(lk: xmlLinkPtr) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlAutomata {
  _unused: [u8; 0],
}
#[doc = " xmlAutomataPtr:\n\n A libxml automata description, It can be compiled into a regexp"]
pub type xmlAutomata = _xmlAutomata;
pub type xmlAutomataPtr = *mut xmlAutomata;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlAutomataState {
  _unused: [u8; 0],
}
#[doc = " xmlAutomataStatePtr:\n\n A state int the automata description,"]
pub type xmlAutomataState = _xmlAutomataState;
pub type xmlAutomataStatePtr = *mut xmlAutomataState;
unsafe extern "C" {
  pub fn xmlNewAutomata() -> xmlAutomataPtr;
}
unsafe extern "C" {
  pub fn xmlFreeAutomata(am: xmlAutomataPtr);
}
unsafe extern "C" {
  pub fn xmlAutomataGetInitState(am: xmlAutomataPtr) -> xmlAutomataStatePtr;
}
unsafe extern "C" {
  pub fn xmlAutomataSetFinalState(
    am: xmlAutomataPtr,
    state: xmlAutomataStatePtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlAutomataNewState(am: xmlAutomataPtr) -> xmlAutomataStatePtr;
}
unsafe extern "C" {
  pub fn xmlAutomataNewTransition(
    am: xmlAutomataPtr,
    from: xmlAutomataStatePtr,
    to: xmlAutomataStatePtr,
    token: *const xmlChar,
    data: *mut ::std::os::raw::c_void,
  ) -> xmlAutomataStatePtr;
}
unsafe extern "C" {
  pub fn xmlAutomataNewTransition2(
    am: xmlAutomataPtr,
    from: xmlAutomataStatePtr,
    to: xmlAutomataStatePtr,
    token: *const xmlChar,
    token2: *const xmlChar,
    data: *mut ::std::os::raw::c_void,
  ) -> xmlAutomataStatePtr;
}
unsafe extern "C" {
  pub fn xmlAutomataNewNegTrans(
    am: xmlAutomataPtr,
    from: xmlAutomataStatePtr,
    to: xmlAutomataStatePtr,
    token: *const xmlChar,
    token2: *const xmlChar,
    data: *mut ::std::os::raw::c_void,
  ) -> xmlAutomataStatePtr;
}
unsafe extern "C" {
  pub fn xmlAutomataNewCountTrans(
    am: xmlAutomataPtr,
    from: xmlAutomataStatePtr,
    to: xmlAutomataStatePtr,
    token: *const xmlChar,
    min: ::std::os::raw::c_int,
    max: ::std::os::raw::c_int,
    data: *mut ::std::os::raw::c_void,
  ) -> xmlAutomataStatePtr;
}
unsafe extern "C" {
  pub fn xmlAutomataNewCountTrans2(
    am: xmlAutomataPtr,
    from: xmlAutomataStatePtr,
    to: xmlAutomataStatePtr,
    token: *const xmlChar,
    token2: *const xmlChar,
    min: ::std::os::raw::c_int,
    max: ::std::os::raw::c_int,
    data: *mut ::std::os::raw::c_void,
  ) -> xmlAutomataStatePtr;
}
unsafe extern "C" {
  pub fn xmlAutomataNewOnceTrans(
    am: xmlAutomataPtr,
    from: xmlAutomataStatePtr,
    to: xmlAutomataStatePtr,
    token: *const xmlChar,
    min: ::std::os::raw::c_int,
    max: ::std::os::raw::c_int,
    data: *mut ::std::os::raw::c_void,
  ) -> xmlAutomataStatePtr;
}
unsafe extern "C" {
  pub fn xmlAutomataNewOnceTrans2(
    am: xmlAutomataPtr,
    from: xmlAutomataStatePtr,
    to: xmlAutomataStatePtr,
    token: *const xmlChar,
    token2: *const xmlChar,
    min: ::std::os::raw::c_int,
    max: ::std::os::raw::c_int,
    data: *mut ::std::os::raw::c_void,
  ) -> xmlAutomataStatePtr;
}
unsafe extern "C" {
  pub fn xmlAutomataNewAllTrans(
    am: xmlAutomataPtr,
    from: xmlAutomataStatePtr,
    to: xmlAutomataStatePtr,
    lax: ::std::os::raw::c_int,
  ) -> xmlAutomataStatePtr;
}
unsafe extern "C" {
  pub fn xmlAutomataNewEpsilon(
    am: xmlAutomataPtr,
    from: xmlAutomataStatePtr,
    to: xmlAutomataStatePtr,
  ) -> xmlAutomataStatePtr;
}
unsafe extern "C" {
  pub fn xmlAutomataNewCountedTrans(
    am: xmlAutomataPtr,
    from: xmlAutomataStatePtr,
    to: xmlAutomataStatePtr,
    counter: ::std::os::raw::c_int,
  ) -> xmlAutomataStatePtr;
}
unsafe extern "C" {
  pub fn xmlAutomataNewCounterTrans(
    am: xmlAutomataPtr,
    from: xmlAutomataStatePtr,
    to: xmlAutomataStatePtr,
    counter: ::std::os::raw::c_int,
  ) -> xmlAutomataStatePtr;
}
unsafe extern "C" {
  pub fn xmlAutomataNewCounter(
    am: xmlAutomataPtr,
    min: ::std::os::raw::c_int,
    max: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlAutomataCompile(am: xmlAutomataPtr) -> xmlRegexpPtr;
}
unsafe extern "C" {
  pub fn xmlAutomataIsDeterminist(am: xmlAutomataPtr) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlValidState {
  _unused: [u8; 0],
}
pub type xmlValidState = _xmlValidState;
pub type xmlValidStatePtr = *mut xmlValidState;
#[doc = " xmlValidityErrorFunc:\n @ctx:  usually an xmlValidCtxtPtr to a validity error context,\n        but comes from ctxt->userData (which normally contains such\n        a pointer); ctxt->userData can be changed by the user.\n @msg:  the string to format *printf like vararg\n @...:  remaining arguments to the format\n\n Callback called when a validity error is found. This is a message\n oriented function similar to an *printf function."]
pub type xmlValidityErrorFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
#[doc = " xmlValidityWarningFunc:\n @ctx:  usually an xmlValidCtxtPtr to a validity error context,\n        but comes from ctxt->userData (which normally contains such\n        a pointer); ctxt->userData can be changed by the user.\n @msg:  the string to format *printf like vararg\n @...:  remaining arguments to the format\n\n Callback called when a validity warning is found. This is a message\n oriented function similar to an *printf function."]
pub type xmlValidityWarningFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
pub type xmlValidCtxt = _xmlValidCtxt;
pub type xmlValidCtxtPtr = *mut xmlValidCtxt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlValidCtxt {
  pub userData: *mut ::std::os::raw::c_void,
  pub error: xmlValidityErrorFunc,
  pub warning: xmlValidityWarningFunc,
  pub node: xmlNodePtr,
  pub nodeNr: ::std::os::raw::c_int,
  pub nodeMax: ::std::os::raw::c_int,
  pub nodeTab: *mut xmlNodePtr,
  pub finishDtd: ::std::os::raw::c_uint,
  pub doc: xmlDocPtr,
  pub valid: ::std::os::raw::c_int,
  pub vstate: *mut xmlValidState,
  pub vstateNr: ::std::os::raw::c_int,
  pub vstateMax: ::std::os::raw::c_int,
  pub vstateTab: *mut xmlValidState,
  pub am: xmlAutomataPtr,
  pub state: xmlAutomataStatePtr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlValidCtxt"][::std::mem::size_of::<_xmlValidCtxt>() - 112usize];
  ["Alignment of _xmlValidCtxt"][::std::mem::align_of::<_xmlValidCtxt>() - 8usize];
  ["Offset of field: _xmlValidCtxt::userData"]
    [::std::mem::offset_of!(_xmlValidCtxt, userData) - 0usize];
  ["Offset of field: _xmlValidCtxt::error"][::std::mem::offset_of!(_xmlValidCtxt, error) - 8usize];
  ["Offset of field: _xmlValidCtxt::warning"]
    [::std::mem::offset_of!(_xmlValidCtxt, warning) - 16usize];
  ["Offset of field: _xmlValidCtxt::node"][::std::mem::offset_of!(_xmlValidCtxt, node) - 24usize];
  ["Offset of field: _xmlValidCtxt::nodeNr"]
    [::std::mem::offset_of!(_xmlValidCtxt, nodeNr) - 32usize];
  ["Offset of field: _xmlValidCtxt::nodeMax"]
    [::std::mem::offset_of!(_xmlValidCtxt, nodeMax) - 36usize];
  ["Offset of field: _xmlValidCtxt::nodeTab"]
    [::std::mem::offset_of!(_xmlValidCtxt, nodeTab) - 40usize];
  ["Offset of field: _xmlValidCtxt::finishDtd"]
    [::std::mem::offset_of!(_xmlValidCtxt, finishDtd) - 48usize];
  ["Offset of field: _xmlValidCtxt::doc"][::std::mem::offset_of!(_xmlValidCtxt, doc) - 56usize];
  ["Offset of field: _xmlValidCtxt::valid"][::std::mem::offset_of!(_xmlValidCtxt, valid) - 64usize];
  ["Offset of field: _xmlValidCtxt::vstate"]
    [::std::mem::offset_of!(_xmlValidCtxt, vstate) - 72usize];
  ["Offset of field: _xmlValidCtxt::vstateNr"]
    [::std::mem::offset_of!(_xmlValidCtxt, vstateNr) - 80usize];
  ["Offset of field: _xmlValidCtxt::vstateMax"]
    [::std::mem::offset_of!(_xmlValidCtxt, vstateMax) - 84usize];
  ["Offset of field: _xmlValidCtxt::vstateTab"]
    [::std::mem::offset_of!(_xmlValidCtxt, vstateTab) - 88usize];
  ["Offset of field: _xmlValidCtxt::am"][::std::mem::offset_of!(_xmlValidCtxt, am) - 96usize];
  ["Offset of field: _xmlValidCtxt::state"]
    [::std::mem::offset_of!(_xmlValidCtxt, state) - 104usize];
};
pub type xmlNotationTable = _xmlHashTable;
pub type xmlNotationTablePtr = *mut xmlNotationTable;
pub type xmlElementTable = _xmlHashTable;
pub type xmlElementTablePtr = *mut xmlElementTable;
pub type xmlAttributeTable = _xmlHashTable;
pub type xmlAttributeTablePtr = *mut xmlAttributeTable;
pub type xmlIDTable = _xmlHashTable;
pub type xmlIDTablePtr = *mut xmlIDTable;
pub type xmlRefTable = _xmlHashTable;
pub type xmlRefTablePtr = *mut xmlRefTable;
unsafe extern "C" {
  pub fn xmlAddNotationDecl(
    ctxt: xmlValidCtxtPtr,
    dtd: xmlDtdPtr,
    name: *const xmlChar,
    PublicID: *const xmlChar,
    SystemID: *const xmlChar,
  ) -> xmlNotationPtr;
}
unsafe extern "C" {
  pub fn xmlCopyNotationTable(table: xmlNotationTablePtr) -> xmlNotationTablePtr;
}
unsafe extern "C" {
  pub fn xmlFreeNotationTable(table: xmlNotationTablePtr);
}
unsafe extern "C" {
  pub fn xmlDumpNotationDecl(buf: xmlBufferPtr, nota: xmlNotationPtr);
}
unsafe extern "C" {
  pub fn xmlDumpNotationTable(buf: xmlBufferPtr, table: xmlNotationTablePtr);
}
unsafe extern "C" {
  pub fn xmlNewElementContent(
    name: *const xmlChar,
    type_: xmlElementContentType,
  ) -> xmlElementContentPtr;
}
unsafe extern "C" {
  pub fn xmlCopyElementContent(content: xmlElementContentPtr) -> xmlElementContentPtr;
}
unsafe extern "C" {
  pub fn xmlFreeElementContent(cur: xmlElementContentPtr);
}
unsafe extern "C" {
  pub fn xmlNewDocElementContent(
    doc: xmlDocPtr,
    name: *const xmlChar,
    type_: xmlElementContentType,
  ) -> xmlElementContentPtr;
}
unsafe extern "C" {
  pub fn xmlCopyDocElementContent(
    doc: xmlDocPtr,
    content: xmlElementContentPtr,
  ) -> xmlElementContentPtr;
}
unsafe extern "C" {
  pub fn xmlFreeDocElementContent(doc: xmlDocPtr, cur: xmlElementContentPtr);
}
unsafe extern "C" {
  pub fn xmlSnprintfElementContent(
    buf: *mut ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    content: xmlElementContentPtr,
    englob: ::std::os::raw::c_int,
  );
}
unsafe extern "C" {
  pub fn xmlSprintfElementContent(
    buf: *mut ::std::os::raw::c_char,
    content: xmlElementContentPtr,
    englob: ::std::os::raw::c_int,
  );
}
unsafe extern "C" {
  pub fn xmlAddElementDecl(
    ctxt: xmlValidCtxtPtr,
    dtd: xmlDtdPtr,
    name: *const xmlChar,
    type_: xmlElementTypeVal,
    content: xmlElementContentPtr,
  ) -> xmlElementPtr;
}
unsafe extern "C" {
  pub fn xmlCopyElementTable(table: xmlElementTablePtr) -> xmlElementTablePtr;
}
unsafe extern "C" {
  pub fn xmlFreeElementTable(table: xmlElementTablePtr);
}
unsafe extern "C" {
  pub fn xmlDumpElementTable(buf: xmlBufferPtr, table: xmlElementTablePtr);
}
unsafe extern "C" {
  pub fn xmlDumpElementDecl(buf: xmlBufferPtr, elem: xmlElementPtr);
}
unsafe extern "C" {
  pub fn xmlCreateEnumeration(name: *const xmlChar) -> xmlEnumerationPtr;
}
unsafe extern "C" {
  pub fn xmlFreeEnumeration(cur: xmlEnumerationPtr);
}
unsafe extern "C" {
  pub fn xmlCopyEnumeration(cur: xmlEnumerationPtr) -> xmlEnumerationPtr;
}
unsafe extern "C" {
  pub fn xmlAddAttributeDecl(
    ctxt: xmlValidCtxtPtr,
    dtd: xmlDtdPtr,
    elem: *const xmlChar,
    name: *const xmlChar,
    ns: *const xmlChar,
    type_: xmlAttributeType,
    def: xmlAttributeDefault,
    defaultValue: *const xmlChar,
    tree: xmlEnumerationPtr,
  ) -> xmlAttributePtr;
}
unsafe extern "C" {
  pub fn xmlCopyAttributeTable(table: xmlAttributeTablePtr) -> xmlAttributeTablePtr;
}
unsafe extern "C" {
  pub fn xmlFreeAttributeTable(table: xmlAttributeTablePtr);
}
unsafe extern "C" {
  pub fn xmlDumpAttributeTable(buf: xmlBufferPtr, table: xmlAttributeTablePtr);
}
unsafe extern "C" {
  pub fn xmlDumpAttributeDecl(buf: xmlBufferPtr, attr: xmlAttributePtr);
}
unsafe extern "C" {
  pub fn xmlAddID(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    value: *const xmlChar,
    attr: xmlAttrPtr,
  ) -> xmlIDPtr;
}
unsafe extern "C" {
  pub fn xmlFreeIDTable(table: xmlIDTablePtr);
}
unsafe extern "C" {
  pub fn xmlGetID(doc: xmlDocPtr, ID: *const xmlChar) -> xmlAttrPtr;
}
unsafe extern "C" {
  pub fn xmlIsID(doc: xmlDocPtr, elem: xmlNodePtr, attr: xmlAttrPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlRemoveID(doc: xmlDocPtr, attr: xmlAttrPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlAddRef(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    value: *const xmlChar,
    attr: xmlAttrPtr,
  ) -> xmlRefPtr;
}
unsafe extern "C" {
  pub fn xmlFreeRefTable(table: xmlRefTablePtr);
}
unsafe extern "C" {
  pub fn xmlIsRef(doc: xmlDocPtr, elem: xmlNodePtr, attr: xmlAttrPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlRemoveRef(doc: xmlDocPtr, attr: xmlAttrPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlGetRefs(doc: xmlDocPtr, ID: *const xmlChar) -> xmlListPtr;
}
unsafe extern "C" {
  pub fn xmlNewValidCtxt() -> xmlValidCtxtPtr;
}
unsafe extern "C" {
  pub fn xmlFreeValidCtxt(arg1: xmlValidCtxtPtr);
}
unsafe extern "C" {
  pub fn xmlValidateRoot(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidateElementDecl(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    elem: xmlElementPtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidNormalizeAttributeValue(
    doc: xmlDocPtr,
    elem: xmlNodePtr,
    name: *const xmlChar,
    value: *const xmlChar,
  ) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlValidCtxtNormalizeAttributeValue(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    elem: xmlNodePtr,
    name: *const xmlChar,
    value: *const xmlChar,
  ) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlValidateAttributeDecl(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    attr: xmlAttributePtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidateAttributeValue(
    type_: xmlAttributeType,
    value: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidateNotationDecl(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    nota: xmlNotationPtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidateDtd(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    dtd: xmlDtdPtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidateDtdFinal(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidateDocument(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidateElement(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    elem: xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidateOneElement(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    elem: xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidateOneAttribute(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    elem: xmlNodePtr,
    attr: xmlAttrPtr,
    value: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidateOneNamespace(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    elem: xmlNodePtr,
    prefix: *const xmlChar,
    ns: xmlNsPtr,
    value: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidateDocumentFinal(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidateNotationUse(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    notationName: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlIsMixedElement(doc: xmlDocPtr, name: *const xmlChar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlGetDtdAttrDesc(
    dtd: xmlDtdPtr,
    elem: *const xmlChar,
    name: *const xmlChar,
  ) -> xmlAttributePtr;
}
unsafe extern "C" {
  pub fn xmlGetDtdQAttrDesc(
    dtd: xmlDtdPtr,
    elem: *const xmlChar,
    name: *const xmlChar,
    prefix: *const xmlChar,
  ) -> xmlAttributePtr;
}
unsafe extern "C" {
  pub fn xmlGetDtdNotationDesc(dtd: xmlDtdPtr, name: *const xmlChar) -> xmlNotationPtr;
}
unsafe extern "C" {
  pub fn xmlGetDtdQElementDesc(
    dtd: xmlDtdPtr,
    name: *const xmlChar,
    prefix: *const xmlChar,
  ) -> xmlElementPtr;
}
unsafe extern "C" {
  pub fn xmlGetDtdElementDesc(dtd: xmlDtdPtr, name: *const xmlChar) -> xmlElementPtr;
}
unsafe extern "C" {
  pub fn xmlValidGetPotentialChildren(
    ctree: *mut xmlElementContent,
    names: *mut *const xmlChar,
    len: *mut ::std::os::raw::c_int,
    max: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidGetValidElements(
    prev: *mut xmlNode,
    next: *mut xmlNode,
    names: *mut *const xmlChar,
    max: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidateNameValue(value: *const xmlChar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidateNamesValue(value: *const xmlChar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidateNmtokenValue(value: *const xmlChar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidateNmtokensValue(value: *const xmlChar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidBuildContentModel(
    ctxt: xmlValidCtxtPtr,
    elem: xmlElementPtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidatePushElement(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    elem: xmlNodePtr,
    qname: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidatePushCData(
    ctxt: xmlValidCtxtPtr,
    data: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlValidatePopElement(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    elem: xmlNodePtr,
    qname: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
pub const xmlEntityType_XML_INTERNAL_GENERAL_ENTITY: xmlEntityType = 1;
pub const xmlEntityType_XML_EXTERNAL_GENERAL_PARSED_ENTITY: xmlEntityType = 2;
pub const xmlEntityType_XML_EXTERNAL_GENERAL_UNPARSED_ENTITY: xmlEntityType = 3;
pub const xmlEntityType_XML_INTERNAL_PARAMETER_ENTITY: xmlEntityType = 4;
pub const xmlEntityType_XML_EXTERNAL_PARAMETER_ENTITY: xmlEntityType = 5;
pub const xmlEntityType_XML_INTERNAL_PREDEFINED_ENTITY: xmlEntityType = 6;
pub type xmlEntityType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlEntity {
  pub _private: *mut ::std::os::raw::c_void,
  pub type_: xmlElementType,
  pub name: *const xmlChar,
  pub children: *mut _xmlNode,
  pub last: *mut _xmlNode,
  pub parent: *mut _xmlDtd,
  pub next: *mut _xmlNode,
  pub prev: *mut _xmlNode,
  pub doc: *mut _xmlDoc,
  pub orig: *mut xmlChar,
  pub content: *mut xmlChar,
  pub length: ::std::os::raw::c_int,
  pub etype: xmlEntityType,
  pub ExternalID: *const xmlChar,
  pub SystemID: *const xmlChar,
  pub nexte: *mut _xmlEntity,
  pub URI: *const xmlChar,
  pub owner: ::std::os::raw::c_int,
  pub checked: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlEntity"][::std::mem::size_of::<_xmlEntity>() - 136usize];
  ["Alignment of _xmlEntity"][::std::mem::align_of::<_xmlEntity>() - 8usize];
  ["Offset of field: _xmlEntity::_private"][::std::mem::offset_of!(_xmlEntity, _private) - 0usize];
  ["Offset of field: _xmlEntity::type_"][::std::mem::offset_of!(_xmlEntity, type_) - 8usize];
  ["Offset of field: _xmlEntity::name"][::std::mem::offset_of!(_xmlEntity, name) - 16usize];
  ["Offset of field: _xmlEntity::children"][::std::mem::offset_of!(_xmlEntity, children) - 24usize];
  ["Offset of field: _xmlEntity::last"][::std::mem::offset_of!(_xmlEntity, last) - 32usize];
  ["Offset of field: _xmlEntity::parent"][::std::mem::offset_of!(_xmlEntity, parent) - 40usize];
  ["Offset of field: _xmlEntity::next"][::std::mem::offset_of!(_xmlEntity, next) - 48usize];
  ["Offset of field: _xmlEntity::prev"][::std::mem::offset_of!(_xmlEntity, prev) - 56usize];
  ["Offset of field: _xmlEntity::doc"][::std::mem::offset_of!(_xmlEntity, doc) - 64usize];
  ["Offset of field: _xmlEntity::orig"][::std::mem::offset_of!(_xmlEntity, orig) - 72usize];
  ["Offset of field: _xmlEntity::content"][::std::mem::offset_of!(_xmlEntity, content) - 80usize];
  ["Offset of field: _xmlEntity::length"][::std::mem::offset_of!(_xmlEntity, length) - 88usize];
  ["Offset of field: _xmlEntity::etype"][::std::mem::offset_of!(_xmlEntity, etype) - 92usize];
  ["Offset of field: _xmlEntity::ExternalID"]
    [::std::mem::offset_of!(_xmlEntity, ExternalID) - 96usize];
  ["Offset of field: _xmlEntity::SystemID"]
    [::std::mem::offset_of!(_xmlEntity, SystemID) - 104usize];
  ["Offset of field: _xmlEntity::nexte"][::std::mem::offset_of!(_xmlEntity, nexte) - 112usize];
  ["Offset of field: _xmlEntity::URI"][::std::mem::offset_of!(_xmlEntity, URI) - 120usize];
  ["Offset of field: _xmlEntity::owner"][::std::mem::offset_of!(_xmlEntity, owner) - 128usize];
  ["Offset of field: _xmlEntity::checked"][::std::mem::offset_of!(_xmlEntity, checked) - 132usize];
};
pub type xmlEntitiesTable = _xmlHashTable;
pub type xmlEntitiesTablePtr = *mut xmlEntitiesTable;
unsafe extern "C" {
  pub fn xmlInitializePredefinedEntities();
}
unsafe extern "C" {
  pub fn xmlNewEntity(
    doc: xmlDocPtr,
    name: *const xmlChar,
    type_: ::std::os::raw::c_int,
    ExternalID: *const xmlChar,
    SystemID: *const xmlChar,
    content: *const xmlChar,
  ) -> xmlEntityPtr;
}
unsafe extern "C" {
  pub fn xmlAddDocEntity(
    doc: xmlDocPtr,
    name: *const xmlChar,
    type_: ::std::os::raw::c_int,
    ExternalID: *const xmlChar,
    SystemID: *const xmlChar,
    content: *const xmlChar,
  ) -> xmlEntityPtr;
}
unsafe extern "C" {
  pub fn xmlAddDtdEntity(
    doc: xmlDocPtr,
    name: *const xmlChar,
    type_: ::std::os::raw::c_int,
    ExternalID: *const xmlChar,
    SystemID: *const xmlChar,
    content: *const xmlChar,
  ) -> xmlEntityPtr;
}
unsafe extern "C" {
  pub fn xmlGetPredefinedEntity(name: *const xmlChar) -> xmlEntityPtr;
}
unsafe extern "C" {
  pub fn xmlGetDocEntity(doc: *const xmlDoc, name: *const xmlChar) -> xmlEntityPtr;
}
unsafe extern "C" {
  pub fn xmlGetDtdEntity(doc: xmlDocPtr, name: *const xmlChar) -> xmlEntityPtr;
}
unsafe extern "C" {
  pub fn xmlGetParameterEntity(doc: xmlDocPtr, name: *const xmlChar) -> xmlEntityPtr;
}
unsafe extern "C" {
  pub fn xmlEncodeEntities(doc: xmlDocPtr, input: *const xmlChar) -> *const xmlChar;
}
unsafe extern "C" {
  pub fn xmlEncodeEntitiesReentrant(doc: xmlDocPtr, input: *const xmlChar) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlEncodeSpecialChars(doc: *const xmlDoc, input: *const xmlChar) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlCreateEntitiesTable() -> xmlEntitiesTablePtr;
}
unsafe extern "C" {
  pub fn xmlCopyEntitiesTable(table: xmlEntitiesTablePtr) -> xmlEntitiesTablePtr;
}
unsafe extern "C" {
  pub fn xmlFreeEntitiesTable(table: xmlEntitiesTablePtr);
}
unsafe extern "C" {
  pub fn xmlDumpEntitiesTable(buf: xmlBufferPtr, table: xmlEntitiesTablePtr);
}
unsafe extern "C" {
  pub fn xmlDumpEntityDecl(buf: xmlBufferPtr, ent: xmlEntityPtr);
}
unsafe extern "C" {
  pub fn xmlCleanupPredefinedEntities();
}
#[doc = " xmlParserInputDeallocate:\n @str:  the string to deallocate\n\n Callback for freeing some parser input allocations."]
pub type xmlParserInputDeallocate = ::std::option::Option<unsafe extern "C" fn(str_: *mut xmlChar)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlParserInput {
  pub buf: xmlParserInputBufferPtr,
  pub filename: *const ::std::os::raw::c_char,
  pub directory: *const ::std::os::raw::c_char,
  pub base: *const xmlChar,
  pub cur: *const xmlChar,
  pub end: *const xmlChar,
  pub length: ::std::os::raw::c_int,
  pub line: ::std::os::raw::c_int,
  pub col: ::std::os::raw::c_int,
  pub consumed: ::std::os::raw::c_ulong,
  pub free: xmlParserInputDeallocate,
  pub encoding: *const xmlChar,
  pub version: *const xmlChar,
  pub standalone: ::std::os::raw::c_int,
  pub id: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlParserInput"][::std::mem::size_of::<_xmlParserInput>() - 104usize];
  ["Alignment of _xmlParserInput"][::std::mem::align_of::<_xmlParserInput>() - 8usize];
  ["Offset of field: _xmlParserInput::buf"][::std::mem::offset_of!(_xmlParserInput, buf) - 0usize];
  ["Offset of field: _xmlParserInput::filename"]
    [::std::mem::offset_of!(_xmlParserInput, filename) - 8usize];
  ["Offset of field: _xmlParserInput::directory"]
    [::std::mem::offset_of!(_xmlParserInput, directory) - 16usize];
  ["Offset of field: _xmlParserInput::base"]
    [::std::mem::offset_of!(_xmlParserInput, base) - 24usize];
  ["Offset of field: _xmlParserInput::cur"][::std::mem::offset_of!(_xmlParserInput, cur) - 32usize];
  ["Offset of field: _xmlParserInput::end"][::std::mem::offset_of!(_xmlParserInput, end) - 40usize];
  ["Offset of field: _xmlParserInput::length"]
    [::std::mem::offset_of!(_xmlParserInput, length) - 48usize];
  ["Offset of field: _xmlParserInput::line"]
    [::std::mem::offset_of!(_xmlParserInput, line) - 52usize];
  ["Offset of field: _xmlParserInput::col"][::std::mem::offset_of!(_xmlParserInput, col) - 56usize];
  ["Offset of field: _xmlParserInput::consumed"]
    [::std::mem::offset_of!(_xmlParserInput, consumed) - 64usize];
  ["Offset of field: _xmlParserInput::free"]
    [::std::mem::offset_of!(_xmlParserInput, free) - 72usize];
  ["Offset of field: _xmlParserInput::encoding"]
    [::std::mem::offset_of!(_xmlParserInput, encoding) - 80usize];
  ["Offset of field: _xmlParserInput::version"]
    [::std::mem::offset_of!(_xmlParserInput, version) - 88usize];
  ["Offset of field: _xmlParserInput::standalone"]
    [::std::mem::offset_of!(_xmlParserInput, standalone) - 96usize];
  ["Offset of field: _xmlParserInput::id"][::std::mem::offset_of!(_xmlParserInput, id) - 100usize];
};
#[doc = " xmlParserNodeInfo:\n\n The parser can be asked to collect Node information, i.e. at what\n place in the file they were detected.\n NOTE: This is off by default and not very well tested."]
pub type xmlParserNodeInfo = _xmlParserNodeInfo;
pub type xmlParserNodeInfoPtr = *mut xmlParserNodeInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlParserNodeInfo {
  pub node: *const _xmlNode,
  pub begin_pos: ::std::os::raw::c_ulong,
  pub begin_line: ::std::os::raw::c_ulong,
  pub end_pos: ::std::os::raw::c_ulong,
  pub end_line: ::std::os::raw::c_ulong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlParserNodeInfo"][::std::mem::size_of::<_xmlParserNodeInfo>() - 40usize];
  ["Alignment of _xmlParserNodeInfo"][::std::mem::align_of::<_xmlParserNodeInfo>() - 8usize];
  ["Offset of field: _xmlParserNodeInfo::node"]
    [::std::mem::offset_of!(_xmlParserNodeInfo, node) - 0usize];
  ["Offset of field: _xmlParserNodeInfo::begin_pos"]
    [::std::mem::offset_of!(_xmlParserNodeInfo, begin_pos) - 8usize];
  ["Offset of field: _xmlParserNodeInfo::begin_line"]
    [::std::mem::offset_of!(_xmlParserNodeInfo, begin_line) - 16usize];
  ["Offset of field: _xmlParserNodeInfo::end_pos"]
    [::std::mem::offset_of!(_xmlParserNodeInfo, end_pos) - 24usize];
  ["Offset of field: _xmlParserNodeInfo::end_line"]
    [::std::mem::offset_of!(_xmlParserNodeInfo, end_line) - 32usize];
};
pub type xmlParserNodeInfoSeq = _xmlParserNodeInfoSeq;
pub type xmlParserNodeInfoSeqPtr = *mut xmlParserNodeInfoSeq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlParserNodeInfoSeq {
  pub maximum: ::std::os::raw::c_ulong,
  pub length: ::std::os::raw::c_ulong,
  pub buffer: *mut xmlParserNodeInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlParserNodeInfoSeq"][::std::mem::size_of::<_xmlParserNodeInfoSeq>() - 24usize];
  ["Alignment of _xmlParserNodeInfoSeq"][::std::mem::align_of::<_xmlParserNodeInfoSeq>() - 8usize];
  ["Offset of field: _xmlParserNodeInfoSeq::maximum"]
    [::std::mem::offset_of!(_xmlParserNodeInfoSeq, maximum) - 0usize];
  ["Offset of field: _xmlParserNodeInfoSeq::length"]
    [::std::mem::offset_of!(_xmlParserNodeInfoSeq, length) - 8usize];
  ["Offset of field: _xmlParserNodeInfoSeq::buffer"]
    [::std::mem::offset_of!(_xmlParserNodeInfoSeq, buffer) - 16usize];
};
pub const xmlParserInputState_XML_PARSER_EOF: xmlParserInputState = -1;
pub const xmlParserInputState_XML_PARSER_START: xmlParserInputState = 0;
pub const xmlParserInputState_XML_PARSER_MISC: xmlParserInputState = 1;
pub const xmlParserInputState_XML_PARSER_PI: xmlParserInputState = 2;
pub const xmlParserInputState_XML_PARSER_DTD: xmlParserInputState = 3;
pub const xmlParserInputState_XML_PARSER_PROLOG: xmlParserInputState = 4;
pub const xmlParserInputState_XML_PARSER_COMMENT: xmlParserInputState = 5;
pub const xmlParserInputState_XML_PARSER_START_TAG: xmlParserInputState = 6;
pub const xmlParserInputState_XML_PARSER_CONTENT: xmlParserInputState = 7;
pub const xmlParserInputState_XML_PARSER_CDATA_SECTION: xmlParserInputState = 8;
pub const xmlParserInputState_XML_PARSER_END_TAG: xmlParserInputState = 9;
pub const xmlParserInputState_XML_PARSER_ENTITY_DECL: xmlParserInputState = 10;
pub const xmlParserInputState_XML_PARSER_ENTITY_VALUE: xmlParserInputState = 11;
pub const xmlParserInputState_XML_PARSER_ATTRIBUTE_VALUE: xmlParserInputState = 12;
pub const xmlParserInputState_XML_PARSER_SYSTEM_LITERAL: xmlParserInputState = 13;
pub const xmlParserInputState_XML_PARSER_EPILOG: xmlParserInputState = 14;
pub const xmlParserInputState_XML_PARSER_IGNORE: xmlParserInputState = 15;
pub const xmlParserInputState_XML_PARSER_PUBLIC_LITERAL: xmlParserInputState = 16;
#[doc = " xmlParserInputState:\n\n The parser is now working also as a state based parser.\n The recursive one use the state info for entities processing."]
pub type xmlParserInputState = ::std::os::raw::c_int;
pub const xmlParserMode_XML_PARSE_UNKNOWN: xmlParserMode = 0;
pub const xmlParserMode_XML_PARSE_DOM: xmlParserMode = 1;
pub const xmlParserMode_XML_PARSE_SAX: xmlParserMode = 2;
pub const xmlParserMode_XML_PARSE_PUSH_DOM: xmlParserMode = 3;
pub const xmlParserMode_XML_PARSE_PUSH_SAX: xmlParserMode = 4;
pub const xmlParserMode_XML_PARSE_READER: xmlParserMode = 5;
#[doc = " xmlParserMode:\n\n A parser can operate in various modes"]
pub type xmlParserMode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlStartTag {
  _unused: [u8; 0],
}
pub type xmlStartTag = _xmlStartTag;
#[doc = " xmlParserCtxt:\n\n The parser context.\n NOTE This doesn't completely define the parser state, the (current ?)\n      design of the parser uses recursive function calls since this allow\n      and easy mapping from the production rules of the specification\n      to the actual code. The drawback is that the actual function call\n      also reflect the parser state. However most of the parsing routines\n      takes as the only argument the parser context pointer, so migrating\n      to a state based parser for progressive parsing shouldn't be too hard."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlParserCtxt {
  pub sax: *mut _xmlSAXHandler,
  pub userData: *mut ::std::os::raw::c_void,
  pub myDoc: xmlDocPtr,
  pub wellFormed: ::std::os::raw::c_int,
  pub replaceEntities: ::std::os::raw::c_int,
  pub version: *const xmlChar,
  pub encoding: *const xmlChar,
  pub standalone: ::std::os::raw::c_int,
  pub html: ::std::os::raw::c_int,
  pub input: xmlParserInputPtr,
  pub inputNr: ::std::os::raw::c_int,
  pub inputMax: ::std::os::raw::c_int,
  pub inputTab: *mut xmlParserInputPtr,
  pub node: xmlNodePtr,
  pub nodeNr: ::std::os::raw::c_int,
  pub nodeMax: ::std::os::raw::c_int,
  pub nodeTab: *mut xmlNodePtr,
  pub record_info: ::std::os::raw::c_int,
  pub node_seq: xmlParserNodeInfoSeq,
  pub errNo: ::std::os::raw::c_int,
  pub hasExternalSubset: ::std::os::raw::c_int,
  pub hasPErefs: ::std::os::raw::c_int,
  pub external: ::std::os::raw::c_int,
  pub valid: ::std::os::raw::c_int,
  pub validate: ::std::os::raw::c_int,
  pub vctxt: xmlValidCtxt,
  pub instate: xmlParserInputState,
  pub token: ::std::os::raw::c_int,
  pub directory: *mut ::std::os::raw::c_char,
  pub name: *const xmlChar,
  pub nameNr: ::std::os::raw::c_int,
  pub nameMax: ::std::os::raw::c_int,
  pub nameTab: *mut *const xmlChar,
  pub nbChars: ::std::os::raw::c_long,
  pub checkIndex: ::std::os::raw::c_long,
  pub keepBlanks: ::std::os::raw::c_int,
  pub disableSAX: ::std::os::raw::c_int,
  pub inSubset: ::std::os::raw::c_int,
  pub intSubName: *const xmlChar,
  pub extSubURI: *mut xmlChar,
  pub extSubSystem: *mut xmlChar,
  pub space: *mut ::std::os::raw::c_int,
  pub spaceNr: ::std::os::raw::c_int,
  pub spaceMax: ::std::os::raw::c_int,
  pub spaceTab: *mut ::std::os::raw::c_int,
  pub depth: ::std::os::raw::c_int,
  pub entity: xmlParserInputPtr,
  pub charset: ::std::os::raw::c_int,
  pub nodelen: ::std::os::raw::c_int,
  pub nodemem: ::std::os::raw::c_int,
  pub pedantic: ::std::os::raw::c_int,
  pub _private: *mut ::std::os::raw::c_void,
  pub loadsubset: ::std::os::raw::c_int,
  pub linenumbers: ::std::os::raw::c_int,
  pub catalogs: *mut ::std::os::raw::c_void,
  pub recovery: ::std::os::raw::c_int,
  pub progressive: ::std::os::raw::c_int,
  pub dict: xmlDictPtr,
  pub atts: *mut *const xmlChar,
  pub maxatts: ::std::os::raw::c_int,
  pub docdict: ::std::os::raw::c_int,
  pub str_xml: *const xmlChar,
  pub str_xmlns: *const xmlChar,
  pub str_xml_ns: *const xmlChar,
  pub sax2: ::std::os::raw::c_int,
  pub nsNr: ::std::os::raw::c_int,
  pub nsMax: ::std::os::raw::c_int,
  pub nsTab: *mut *const xmlChar,
  pub attallocs: *mut ::std::os::raw::c_int,
  pub pushTab: *mut xmlStartTag,
  pub attsDefault: xmlHashTablePtr,
  pub attsSpecial: xmlHashTablePtr,
  pub nsWellFormed: ::std::os::raw::c_int,
  pub options: ::std::os::raw::c_int,
  pub dictNames: ::std::os::raw::c_int,
  pub freeElemsNr: ::std::os::raw::c_int,
  pub freeElems: xmlNodePtr,
  pub freeAttrsNr: ::std::os::raw::c_int,
  pub freeAttrs: xmlAttrPtr,
  pub lastError: xmlError,
  pub parseMode: xmlParserMode,
  pub nbentities: ::std::os::raw::c_ulong,
  pub sizeentities: ::std::os::raw::c_ulong,
  pub nodeInfo: *mut xmlParserNodeInfo,
  pub nodeInfoNr: ::std::os::raw::c_int,
  pub nodeInfoMax: ::std::os::raw::c_int,
  pub nodeInfoTab: *mut xmlParserNodeInfo,
  pub input_id: ::std::os::raw::c_int,
  pub sizeentcopy: ::std::os::raw::c_ulong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlParserCtxt"][::std::mem::size_of::<_xmlParserCtxt>() - 752usize];
  ["Alignment of _xmlParserCtxt"][::std::mem::align_of::<_xmlParserCtxt>() - 8usize];
  ["Offset of field: _xmlParserCtxt::sax"][::std::mem::offset_of!(_xmlParserCtxt, sax) - 0usize];
  ["Offset of field: _xmlParserCtxt::userData"]
    [::std::mem::offset_of!(_xmlParserCtxt, userData) - 8usize];
  ["Offset of field: _xmlParserCtxt::myDoc"]
    [::std::mem::offset_of!(_xmlParserCtxt, myDoc) - 16usize];
  ["Offset of field: _xmlParserCtxt::wellFormed"]
    [::std::mem::offset_of!(_xmlParserCtxt, wellFormed) - 24usize];
  ["Offset of field: _xmlParserCtxt::replaceEntities"]
    [::std::mem::offset_of!(_xmlParserCtxt, replaceEntities) - 28usize];
  ["Offset of field: _xmlParserCtxt::version"]
    [::std::mem::offset_of!(_xmlParserCtxt, version) - 32usize];
  ["Offset of field: _xmlParserCtxt::encoding"]
    [::std::mem::offset_of!(_xmlParserCtxt, encoding) - 40usize];
  ["Offset of field: _xmlParserCtxt::standalone"]
    [::std::mem::offset_of!(_xmlParserCtxt, standalone) - 48usize];
  ["Offset of field: _xmlParserCtxt::html"][::std::mem::offset_of!(_xmlParserCtxt, html) - 52usize];
  ["Offset of field: _xmlParserCtxt::input"]
    [::std::mem::offset_of!(_xmlParserCtxt, input) - 56usize];
  ["Offset of field: _xmlParserCtxt::inputNr"]
    [::std::mem::offset_of!(_xmlParserCtxt, inputNr) - 64usize];
  ["Offset of field: _xmlParserCtxt::inputMax"]
    [::std::mem::offset_of!(_xmlParserCtxt, inputMax) - 68usize];
  ["Offset of field: _xmlParserCtxt::inputTab"]
    [::std::mem::offset_of!(_xmlParserCtxt, inputTab) - 72usize];
  ["Offset of field: _xmlParserCtxt::node"][::std::mem::offset_of!(_xmlParserCtxt, node) - 80usize];
  ["Offset of field: _xmlParserCtxt::nodeNr"]
    [::std::mem::offset_of!(_xmlParserCtxt, nodeNr) - 88usize];
  ["Offset of field: _xmlParserCtxt::nodeMax"]
    [::std::mem::offset_of!(_xmlParserCtxt, nodeMax) - 92usize];
  ["Offset of field: _xmlParserCtxt::nodeTab"]
    [::std::mem::offset_of!(_xmlParserCtxt, nodeTab) - 96usize];
  ["Offset of field: _xmlParserCtxt::record_info"]
    [::std::mem::offset_of!(_xmlParserCtxt, record_info) - 104usize];
  ["Offset of field: _xmlParserCtxt::node_seq"]
    [::std::mem::offset_of!(_xmlParserCtxt, node_seq) - 112usize];
  ["Offset of field: _xmlParserCtxt::errNo"]
    [::std::mem::offset_of!(_xmlParserCtxt, errNo) - 136usize];
  ["Offset of field: _xmlParserCtxt::hasExternalSubset"]
    [::std::mem::offset_of!(_xmlParserCtxt, hasExternalSubset) - 140usize];
  ["Offset of field: _xmlParserCtxt::hasPErefs"]
    [::std::mem::offset_of!(_xmlParserCtxt, hasPErefs) - 144usize];
  ["Offset of field: _xmlParserCtxt::external"]
    [::std::mem::offset_of!(_xmlParserCtxt, external) - 148usize];
  ["Offset of field: _xmlParserCtxt::valid"]
    [::std::mem::offset_of!(_xmlParserCtxt, valid) - 152usize];
  ["Offset of field: _xmlParserCtxt::validate"]
    [::std::mem::offset_of!(_xmlParserCtxt, validate) - 156usize];
  ["Offset of field: _xmlParserCtxt::vctxt"]
    [::std::mem::offset_of!(_xmlParserCtxt, vctxt) - 160usize];
  ["Offset of field: _xmlParserCtxt::instate"]
    [::std::mem::offset_of!(_xmlParserCtxt, instate) - 272usize];
  ["Offset of field: _xmlParserCtxt::token"]
    [::std::mem::offset_of!(_xmlParserCtxt, token) - 276usize];
  ["Offset of field: _xmlParserCtxt::directory"]
    [::std::mem::offset_of!(_xmlParserCtxt, directory) - 280usize];
  ["Offset of field: _xmlParserCtxt::name"]
    [::std::mem::offset_of!(_xmlParserCtxt, name) - 288usize];
  ["Offset of field: _xmlParserCtxt::nameNr"]
    [::std::mem::offset_of!(_xmlParserCtxt, nameNr) - 296usize];
  ["Offset of field: _xmlParserCtxt::nameMax"]
    [::std::mem::offset_of!(_xmlParserCtxt, nameMax) - 300usize];
  ["Offset of field: _xmlParserCtxt::nameTab"]
    [::std::mem::offset_of!(_xmlParserCtxt, nameTab) - 304usize];
  ["Offset of field: _xmlParserCtxt::nbChars"]
    [::std::mem::offset_of!(_xmlParserCtxt, nbChars) - 312usize];
  ["Offset of field: _xmlParserCtxt::checkIndex"]
    [::std::mem::offset_of!(_xmlParserCtxt, checkIndex) - 320usize];
  ["Offset of field: _xmlParserCtxt::keepBlanks"]
    [::std::mem::offset_of!(_xmlParserCtxt, keepBlanks) - 328usize];
  ["Offset of field: _xmlParserCtxt::disableSAX"]
    [::std::mem::offset_of!(_xmlParserCtxt, disableSAX) - 332usize];
  ["Offset of field: _xmlParserCtxt::inSubset"]
    [::std::mem::offset_of!(_xmlParserCtxt, inSubset) - 336usize];
  ["Offset of field: _xmlParserCtxt::intSubName"]
    [::std::mem::offset_of!(_xmlParserCtxt, intSubName) - 344usize];
  ["Offset of field: _xmlParserCtxt::extSubURI"]
    [::std::mem::offset_of!(_xmlParserCtxt, extSubURI) - 352usize];
  ["Offset of field: _xmlParserCtxt::extSubSystem"]
    [::std::mem::offset_of!(_xmlParserCtxt, extSubSystem) - 360usize];
  ["Offset of field: _xmlParserCtxt::space"]
    [::std::mem::offset_of!(_xmlParserCtxt, space) - 368usize];
  ["Offset of field: _xmlParserCtxt::spaceNr"]
    [::std::mem::offset_of!(_xmlParserCtxt, spaceNr) - 376usize];
  ["Offset of field: _xmlParserCtxt::spaceMax"]
    [::std::mem::offset_of!(_xmlParserCtxt, spaceMax) - 380usize];
  ["Offset of field: _xmlParserCtxt::spaceTab"]
    [::std::mem::offset_of!(_xmlParserCtxt, spaceTab) - 384usize];
  ["Offset of field: _xmlParserCtxt::depth"]
    [::std::mem::offset_of!(_xmlParserCtxt, depth) - 392usize];
  ["Offset of field: _xmlParserCtxt::entity"]
    [::std::mem::offset_of!(_xmlParserCtxt, entity) - 400usize];
  ["Offset of field: _xmlParserCtxt::charset"]
    [::std::mem::offset_of!(_xmlParserCtxt, charset) - 408usize];
  ["Offset of field: _xmlParserCtxt::nodelen"]
    [::std::mem::offset_of!(_xmlParserCtxt, nodelen) - 412usize];
  ["Offset of field: _xmlParserCtxt::nodemem"]
    [::std::mem::offset_of!(_xmlParserCtxt, nodemem) - 416usize];
  ["Offset of field: _xmlParserCtxt::pedantic"]
    [::std::mem::offset_of!(_xmlParserCtxt, pedantic) - 420usize];
  ["Offset of field: _xmlParserCtxt::_private"]
    [::std::mem::offset_of!(_xmlParserCtxt, _private) - 424usize];
  ["Offset of field: _xmlParserCtxt::loadsubset"]
    [::std::mem::offset_of!(_xmlParserCtxt, loadsubset) - 432usize];
  ["Offset of field: _xmlParserCtxt::linenumbers"]
    [::std::mem::offset_of!(_xmlParserCtxt, linenumbers) - 436usize];
  ["Offset of field: _xmlParserCtxt::catalogs"]
    [::std::mem::offset_of!(_xmlParserCtxt, catalogs) - 440usize];
  ["Offset of field: _xmlParserCtxt::recovery"]
    [::std::mem::offset_of!(_xmlParserCtxt, recovery) - 448usize];
  ["Offset of field: _xmlParserCtxt::progressive"]
    [::std::mem::offset_of!(_xmlParserCtxt, progressive) - 452usize];
  ["Offset of field: _xmlParserCtxt::dict"]
    [::std::mem::offset_of!(_xmlParserCtxt, dict) - 456usize];
  ["Offset of field: _xmlParserCtxt::atts"]
    [::std::mem::offset_of!(_xmlParserCtxt, atts) - 464usize];
  ["Offset of field: _xmlParserCtxt::maxatts"]
    [::std::mem::offset_of!(_xmlParserCtxt, maxatts) - 472usize];
  ["Offset of field: _xmlParserCtxt::docdict"]
    [::std::mem::offset_of!(_xmlParserCtxt, docdict) - 476usize];
  ["Offset of field: _xmlParserCtxt::str_xml"]
    [::std::mem::offset_of!(_xmlParserCtxt, str_xml) - 480usize];
  ["Offset of field: _xmlParserCtxt::str_xmlns"]
    [::std::mem::offset_of!(_xmlParserCtxt, str_xmlns) - 488usize];
  ["Offset of field: _xmlParserCtxt::str_xml_ns"]
    [::std::mem::offset_of!(_xmlParserCtxt, str_xml_ns) - 496usize];
  ["Offset of field: _xmlParserCtxt::sax2"]
    [::std::mem::offset_of!(_xmlParserCtxt, sax2) - 504usize];
  ["Offset of field: _xmlParserCtxt::nsNr"]
    [::std::mem::offset_of!(_xmlParserCtxt, nsNr) - 508usize];
  ["Offset of field: _xmlParserCtxt::nsMax"]
    [::std::mem::offset_of!(_xmlParserCtxt, nsMax) - 512usize];
  ["Offset of field: _xmlParserCtxt::nsTab"]
    [::std::mem::offset_of!(_xmlParserCtxt, nsTab) - 520usize];
  ["Offset of field: _xmlParserCtxt::attallocs"]
    [::std::mem::offset_of!(_xmlParserCtxt, attallocs) - 528usize];
  ["Offset of field: _xmlParserCtxt::pushTab"]
    [::std::mem::offset_of!(_xmlParserCtxt, pushTab) - 536usize];
  ["Offset of field: _xmlParserCtxt::attsDefault"]
    [::std::mem::offset_of!(_xmlParserCtxt, attsDefault) - 544usize];
  ["Offset of field: _xmlParserCtxt::attsSpecial"]
    [::std::mem::offset_of!(_xmlParserCtxt, attsSpecial) - 552usize];
  ["Offset of field: _xmlParserCtxt::nsWellFormed"]
    [::std::mem::offset_of!(_xmlParserCtxt, nsWellFormed) - 560usize];
  ["Offset of field: _xmlParserCtxt::options"]
    [::std::mem::offset_of!(_xmlParserCtxt, options) - 564usize];
  ["Offset of field: _xmlParserCtxt::dictNames"]
    [::std::mem::offset_of!(_xmlParserCtxt, dictNames) - 568usize];
  ["Offset of field: _xmlParserCtxt::freeElemsNr"]
    [::std::mem::offset_of!(_xmlParserCtxt, freeElemsNr) - 572usize];
  ["Offset of field: _xmlParserCtxt::freeElems"]
    [::std::mem::offset_of!(_xmlParserCtxt, freeElems) - 576usize];
  ["Offset of field: _xmlParserCtxt::freeAttrsNr"]
    [::std::mem::offset_of!(_xmlParserCtxt, freeAttrsNr) - 584usize];
  ["Offset of field: _xmlParserCtxt::freeAttrs"]
    [::std::mem::offset_of!(_xmlParserCtxt, freeAttrs) - 592usize];
  ["Offset of field: _xmlParserCtxt::lastError"]
    [::std::mem::offset_of!(_xmlParserCtxt, lastError) - 600usize];
  ["Offset of field: _xmlParserCtxt::parseMode"]
    [::std::mem::offset_of!(_xmlParserCtxt, parseMode) - 688usize];
  ["Offset of field: _xmlParserCtxt::nbentities"]
    [::std::mem::offset_of!(_xmlParserCtxt, nbentities) - 696usize];
  ["Offset of field: _xmlParserCtxt::sizeentities"]
    [::std::mem::offset_of!(_xmlParserCtxt, sizeentities) - 704usize];
  ["Offset of field: _xmlParserCtxt::nodeInfo"]
    [::std::mem::offset_of!(_xmlParserCtxt, nodeInfo) - 712usize];
  ["Offset of field: _xmlParserCtxt::nodeInfoNr"]
    [::std::mem::offset_of!(_xmlParserCtxt, nodeInfoNr) - 720usize];
  ["Offset of field: _xmlParserCtxt::nodeInfoMax"]
    [::std::mem::offset_of!(_xmlParserCtxt, nodeInfoMax) - 724usize];
  ["Offset of field: _xmlParserCtxt::nodeInfoTab"]
    [::std::mem::offset_of!(_xmlParserCtxt, nodeInfoTab) - 728usize];
  ["Offset of field: _xmlParserCtxt::input_id"]
    [::std::mem::offset_of!(_xmlParserCtxt, input_id) - 736usize];
  ["Offset of field: _xmlParserCtxt::sizeentcopy"]
    [::std::mem::offset_of!(_xmlParserCtxt, sizeentcopy) - 744usize];
};
#[doc = " xmlSAXLocator:\n\n A SAX Locator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSAXLocator {
  pub getPublicId:
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> *const xmlChar>,
  pub getSystemId:
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> *const xmlChar>,
  pub getLineNumber: ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
  >,
  pub getColumnNumber: ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
  >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlSAXLocator"][::std::mem::size_of::<_xmlSAXLocator>() - 32usize];
  ["Alignment of _xmlSAXLocator"][::std::mem::align_of::<_xmlSAXLocator>() - 8usize];
  ["Offset of field: _xmlSAXLocator::getPublicId"]
    [::std::mem::offset_of!(_xmlSAXLocator, getPublicId) - 0usize];
  ["Offset of field: _xmlSAXLocator::getSystemId"]
    [::std::mem::offset_of!(_xmlSAXLocator, getSystemId) - 8usize];
  ["Offset of field: _xmlSAXLocator::getLineNumber"]
    [::std::mem::offset_of!(_xmlSAXLocator, getLineNumber) - 16usize];
  ["Offset of field: _xmlSAXLocator::getColumnNumber"]
    [::std::mem::offset_of!(_xmlSAXLocator, getColumnNumber) - 24usize];
};
#[doc = " resolveEntitySAXFunc:\n @ctx:  the user data (XML parser context)\n @publicId: The public ID of the entity\n @systemId: The system ID of the entity\n\n Callback:\n The entity loader, to control the loading of external entities,\n the application can either:\n    - override this resolveEntity() callback in the SAX block\n    - or better use the xmlSetExternalEntityLoader() function to\n      set up it's own entity resolution routine\n\n Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour."]
pub type resolveEntitySAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    publicId: *const xmlChar,
    systemId: *const xmlChar,
  ) -> xmlParserInputPtr,
>;
#[doc = " internalSubsetSAXFunc:\n @ctx:  the user data (XML parser context)\n @name:  the root element name\n @ExternalID:  the external ID\n @SystemID:  the SYSTEM ID (e.g. filename or URL)\n\n Callback on internal subset declaration."]
pub type internalSubsetSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    ExternalID: *const xmlChar,
    SystemID: *const xmlChar,
  ),
>;
#[doc = " externalSubsetSAXFunc:\n @ctx:  the user data (XML parser context)\n @name:  the root element name\n @ExternalID:  the external ID\n @SystemID:  the SYSTEM ID (e.g. filename or URL)\n\n Callback on external subset declaration."]
pub type externalSubsetSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    ExternalID: *const xmlChar,
    SystemID: *const xmlChar,
  ),
>;
#[doc = " getEntitySAXFunc:\n @ctx:  the user data (XML parser context)\n @name: The entity name\n\n Get an entity by name.\n\n Returns the xmlEntityPtr if found."]
pub type getEntitySAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar) -> xmlEntityPtr,
>;
#[doc = " getParameterEntitySAXFunc:\n @ctx:  the user data (XML parser context)\n @name: The entity name\n\n Get a parameter entity by name.\n\n Returns the xmlEntityPtr if found."]
pub type getParameterEntitySAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar) -> xmlEntityPtr,
>;
#[doc = " entityDeclSAXFunc:\n @ctx:  the user data (XML parser context)\n @name:  the entity name\n @type:  the entity type\n @publicId: The public ID of the entity\n @systemId: The system ID of the entity\n @content: the entity value (without processing).\n\n An entity definition has been parsed."]
pub type entityDeclSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    type_: ::std::os::raw::c_int,
    publicId: *const xmlChar,
    systemId: *const xmlChar,
    content: *mut xmlChar,
  ),
>;
#[doc = " notationDeclSAXFunc:\n @ctx:  the user data (XML parser context)\n @name: The name of the notation\n @publicId: The public ID of the entity\n @systemId: The system ID of the entity\n\n What to do when a notation declaration has been parsed."]
pub type notationDeclSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    publicId: *const xmlChar,
    systemId: *const xmlChar,
  ),
>;
#[doc = " attributeDeclSAXFunc:\n @ctx:  the user data (XML parser context)\n @elem:  the name of the element\n @fullname:  the attribute name\n @type:  the attribute type\n @def:  the type of default value\n @defaultValue: the attribute default value\n @tree:  the tree of enumerated value set\n\n An attribute definition has been parsed."]
pub type attributeDeclSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    elem: *const xmlChar,
    fullname: *const xmlChar,
    type_: ::std::os::raw::c_int,
    def: ::std::os::raw::c_int,
    defaultValue: *const xmlChar,
    tree: xmlEnumerationPtr,
  ),
>;
#[doc = " elementDeclSAXFunc:\n @ctx:  the user data (XML parser context)\n @name:  the element name\n @type:  the element type\n @content: the element value tree\n\n An element definition has been parsed."]
pub type elementDeclSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    type_: ::std::os::raw::c_int,
    content: xmlElementContentPtr,
  ),
>;
#[doc = " unparsedEntityDeclSAXFunc:\n @ctx:  the user data (XML parser context)\n @name: The name of the entity\n @publicId: The public ID of the entity\n @systemId: The system ID of the entity\n @notationName: the name of the notation\n\n What to do when an unparsed entity declaration is parsed."]
pub type unparsedEntityDeclSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    publicId: *const xmlChar,
    systemId: *const xmlChar,
    notationName: *const xmlChar,
  ),
>;
#[doc = " setDocumentLocatorSAXFunc:\n @ctx:  the user data (XML parser context)\n @loc: A SAX Locator\n\n Receive the document locator at startup, actually xmlDefaultSAXLocator.\n Everything is available on the context, so this is useless in our case."]
pub type setDocumentLocatorSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, loc: xmlSAXLocatorPtr),
>;
#[doc = " startDocumentSAXFunc:\n @ctx:  the user data (XML parser context)\n\n Called when the document start being processed."]
pub type startDocumentSAXFunc =
  ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>;
#[doc = " endDocumentSAXFunc:\n @ctx:  the user data (XML parser context)\n\n Called when the document end has been detected."]
pub type endDocumentSAXFunc =
  ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>;
#[doc = " startElementSAXFunc:\n @ctx:  the user data (XML parser context)\n @name:  The element name, including namespace prefix\n @atts:  An array of name/value attributes pairs, NULL terminated\n\n Called when an opening tag has been processed."]
pub type startElementSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    atts: *mut *const xmlChar,
  ),
>;
#[doc = " endElementSAXFunc:\n @ctx:  the user data (XML parser context)\n @name:  The element name\n\n Called when the end of an element has been detected."]
pub type endElementSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar),
>;
#[doc = " attributeSAXFunc:\n @ctx:  the user data (XML parser context)\n @name:  The attribute name, including namespace prefix\n @value:  The attribute value\n\n Handle an attribute that has been read by the parser.\n The default handling is to convert the attribute into an\n DOM subtree and past it in a new xmlAttr element added to\n the element."]
pub type attributeSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    value: *const xmlChar,
  ),
>;
#[doc = " referenceSAXFunc:\n @ctx:  the user data (XML parser context)\n @name:  The entity name\n\n Called when an entity reference is detected."]
pub type referenceSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar),
>;
#[doc = " charactersSAXFunc:\n @ctx:  the user data (XML parser context)\n @ch:  a xmlChar string\n @len: the number of xmlChar\n\n Receiving some chars from the parser."]
pub type charactersSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    ch: *const xmlChar,
    len: ::std::os::raw::c_int,
  ),
>;
#[doc = " ignorableWhitespaceSAXFunc:\n @ctx:  the user data (XML parser context)\n @ch:  a xmlChar string\n @len: the number of xmlChar\n\n Receiving some ignorable whitespaces from the parser.\n UNUSED: by default the DOM building will use characters."]
pub type ignorableWhitespaceSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    ch: *const xmlChar,
    len: ::std::os::raw::c_int,
  ),
>;
#[doc = " processingInstructionSAXFunc:\n @ctx:  the user data (XML parser context)\n @target:  the target name\n @data: the PI data's\n\n A processing instruction has been parsed."]
pub type processingInstructionSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    target: *const xmlChar,
    data: *const xmlChar,
  ),
>;
#[doc = " commentSAXFunc:\n @ctx:  the user data (XML parser context)\n @value:  the comment content\n\n A comment has been parsed."]
pub type commentSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, value: *const xmlChar),
>;
#[doc = " cdataBlockSAXFunc:\n @ctx:  the user data (XML parser context)\n @value:  The pcdata content\n @len:  the block length\n\n Called when a pcdata block has been parsed."]
pub type cdataBlockSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    value: *const xmlChar,
    len: ::std::os::raw::c_int,
  ),
>;
#[doc = " warningSAXFunc:\n @ctx:  an XML parser context\n @msg:  the message to display/transmit\n @...:  extra parameters for the message display\n\n Display and format a warning messages, callback."]
pub type warningSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
#[doc = " errorSAXFunc:\n @ctx:  an XML parser context\n @msg:  the message to display/transmit\n @...:  extra parameters for the message display\n\n Display and format an error messages, callback."]
pub type errorSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
#[doc = " fatalErrorSAXFunc:\n @ctx:  an XML parser context\n @msg:  the message to display/transmit\n @...:  extra parameters for the message display\n\n Display and format fatal error messages, callback.\n Note: so far fatalError() SAX callbacks are not used, error()\n       get all the callbacks for errors."]
pub type fatalErrorSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
#[doc = " isStandaloneSAXFunc:\n @ctx:  the user data (XML parser context)\n\n Is this document tagged standalone?\n\n Returns 1 if true"]
pub type isStandaloneSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " hasInternalSubsetSAXFunc:\n @ctx:  the user data (XML parser context)\n\n Does this document has an internal subset.\n\n Returns 1 if true"]
pub type hasInternalSubsetSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " hasExternalSubsetSAXFunc:\n @ctx:  the user data (XML parser context)\n\n Does this document has an external subset?\n\n Returns 1 if true"]
pub type hasExternalSubsetSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " startElementNsSAX2Func:\n @ctx:  the user data (XML parser context)\n @localname:  the local name of the element\n @prefix:  the element namespace prefix if available\n @URI:  the element namespace name if available\n @nb_namespaces:  number of namespace definitions on that node\n @namespaces:  pointer to the array of prefix/URI pairs namespace definitions\n @nb_attributes:  the number of attributes on that node\n @nb_defaulted:  the number of defaulted attributes. The defaulted\n                  ones are at the end of the array\n @attributes:  pointer to the array of (localname/prefix/URI/value/end)\n               attribute values.\n\n SAX2 callback when an element start has been detected by the parser.\n It provides the namespace information for the element, as well as\n the new namespace declarations on the element."]
pub type startElementNsSAX2Func = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    localname: *const xmlChar,
    prefix: *const xmlChar,
    URI: *const xmlChar,
    nb_namespaces: ::std::os::raw::c_int,
    namespaces: *mut *const xmlChar,
    nb_attributes: ::std::os::raw::c_int,
    nb_defaulted: ::std::os::raw::c_int,
    attributes: *mut *const xmlChar,
  ),
>;
#[doc = " endElementNsSAX2Func:\n @ctx:  the user data (XML parser context)\n @localname:  the local name of the element\n @prefix:  the element namespace prefix if available\n @URI:  the element namespace name if available\n\n SAX2 callback when an element end has been detected by the parser.\n It provides the namespace information for the element."]
pub type endElementNsSAX2Func = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    localname: *const xmlChar,
    prefix: *const xmlChar,
    URI: *const xmlChar,
  ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSAXHandler {
  pub internalSubset: internalSubsetSAXFunc,
  pub isStandalone: isStandaloneSAXFunc,
  pub hasInternalSubset: hasInternalSubsetSAXFunc,
  pub hasExternalSubset: hasExternalSubsetSAXFunc,
  pub resolveEntity: resolveEntitySAXFunc,
  pub getEntity: getEntitySAXFunc,
  pub entityDecl: entityDeclSAXFunc,
  pub notationDecl: notationDeclSAXFunc,
  pub attributeDecl: attributeDeclSAXFunc,
  pub elementDecl: elementDeclSAXFunc,
  pub unparsedEntityDecl: unparsedEntityDeclSAXFunc,
  pub setDocumentLocator: setDocumentLocatorSAXFunc,
  pub startDocument: startDocumentSAXFunc,
  pub endDocument: endDocumentSAXFunc,
  pub startElement: startElementSAXFunc,
  pub endElement: endElementSAXFunc,
  pub reference: referenceSAXFunc,
  pub characters: charactersSAXFunc,
  pub ignorableWhitespace: ignorableWhitespaceSAXFunc,
  pub processingInstruction: processingInstructionSAXFunc,
  pub comment: commentSAXFunc,
  pub warning: warningSAXFunc,
  pub error: errorSAXFunc,
  pub fatalError: fatalErrorSAXFunc,
  pub getParameterEntity: getParameterEntitySAXFunc,
  pub cdataBlock: cdataBlockSAXFunc,
  pub externalSubset: externalSubsetSAXFunc,
  pub initialized: ::std::os::raw::c_uint,
  pub _private: *mut ::std::os::raw::c_void,
  pub startElementNs: startElementNsSAX2Func,
  pub endElementNs: endElementNsSAX2Func,
  pub serror: xmlStructuredErrorFunc,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlSAXHandler"][::std::mem::size_of::<_xmlSAXHandler>() - 256usize];
  ["Alignment of _xmlSAXHandler"][::std::mem::align_of::<_xmlSAXHandler>() - 8usize];
  ["Offset of field: _xmlSAXHandler::internalSubset"]
    [::std::mem::offset_of!(_xmlSAXHandler, internalSubset) - 0usize];
  ["Offset of field: _xmlSAXHandler::isStandalone"]
    [::std::mem::offset_of!(_xmlSAXHandler, isStandalone) - 8usize];
  ["Offset of field: _xmlSAXHandler::hasInternalSubset"]
    [::std::mem::offset_of!(_xmlSAXHandler, hasInternalSubset) - 16usize];
  ["Offset of field: _xmlSAXHandler::hasExternalSubset"]
    [::std::mem::offset_of!(_xmlSAXHandler, hasExternalSubset) - 24usize];
  ["Offset of field: _xmlSAXHandler::resolveEntity"]
    [::std::mem::offset_of!(_xmlSAXHandler, resolveEntity) - 32usize];
  ["Offset of field: _xmlSAXHandler::getEntity"]
    [::std::mem::offset_of!(_xmlSAXHandler, getEntity) - 40usize];
  ["Offset of field: _xmlSAXHandler::entityDecl"]
    [::std::mem::offset_of!(_xmlSAXHandler, entityDecl) - 48usize];
  ["Offset of field: _xmlSAXHandler::notationDecl"]
    [::std::mem::offset_of!(_xmlSAXHandler, notationDecl) - 56usize];
  ["Offset of field: _xmlSAXHandler::attributeDecl"]
    [::std::mem::offset_of!(_xmlSAXHandler, attributeDecl) - 64usize];
  ["Offset of field: _xmlSAXHandler::elementDecl"]
    [::std::mem::offset_of!(_xmlSAXHandler, elementDecl) - 72usize];
  ["Offset of field: _xmlSAXHandler::unparsedEntityDecl"]
    [::std::mem::offset_of!(_xmlSAXHandler, unparsedEntityDecl) - 80usize];
  ["Offset of field: _xmlSAXHandler::setDocumentLocator"]
    [::std::mem::offset_of!(_xmlSAXHandler, setDocumentLocator) - 88usize];
  ["Offset of field: _xmlSAXHandler::startDocument"]
    [::std::mem::offset_of!(_xmlSAXHandler, startDocument) - 96usize];
  ["Offset of field: _xmlSAXHandler::endDocument"]
    [::std::mem::offset_of!(_xmlSAXHandler, endDocument) - 104usize];
  ["Offset of field: _xmlSAXHandler::startElement"]
    [::std::mem::offset_of!(_xmlSAXHandler, startElement) - 112usize];
  ["Offset of field: _xmlSAXHandler::endElement"]
    [::std::mem::offset_of!(_xmlSAXHandler, endElement) - 120usize];
  ["Offset of field: _xmlSAXHandler::reference"]
    [::std::mem::offset_of!(_xmlSAXHandler, reference) - 128usize];
  ["Offset of field: _xmlSAXHandler::characters"]
    [::std::mem::offset_of!(_xmlSAXHandler, characters) - 136usize];
  ["Offset of field: _xmlSAXHandler::ignorableWhitespace"]
    [::std::mem::offset_of!(_xmlSAXHandler, ignorableWhitespace) - 144usize];
  ["Offset of field: _xmlSAXHandler::processingInstruction"]
    [::std::mem::offset_of!(_xmlSAXHandler, processingInstruction) - 152usize];
  ["Offset of field: _xmlSAXHandler::comment"]
    [::std::mem::offset_of!(_xmlSAXHandler, comment) - 160usize];
  ["Offset of field: _xmlSAXHandler::warning"]
    [::std::mem::offset_of!(_xmlSAXHandler, warning) - 168usize];
  ["Offset of field: _xmlSAXHandler::error"]
    [::std::mem::offset_of!(_xmlSAXHandler, error) - 176usize];
  ["Offset of field: _xmlSAXHandler::fatalError"]
    [::std::mem::offset_of!(_xmlSAXHandler, fatalError) - 184usize];
  ["Offset of field: _xmlSAXHandler::getParameterEntity"]
    [::std::mem::offset_of!(_xmlSAXHandler, getParameterEntity) - 192usize];
  ["Offset of field: _xmlSAXHandler::cdataBlock"]
    [::std::mem::offset_of!(_xmlSAXHandler, cdataBlock) - 200usize];
  ["Offset of field: _xmlSAXHandler::externalSubset"]
    [::std::mem::offset_of!(_xmlSAXHandler, externalSubset) - 208usize];
  ["Offset of field: _xmlSAXHandler::initialized"]
    [::std::mem::offset_of!(_xmlSAXHandler, initialized) - 216usize];
  ["Offset of field: _xmlSAXHandler::_private"]
    [::std::mem::offset_of!(_xmlSAXHandler, _private) - 224usize];
  ["Offset of field: _xmlSAXHandler::startElementNs"]
    [::std::mem::offset_of!(_xmlSAXHandler, startElementNs) - 232usize];
  ["Offset of field: _xmlSAXHandler::endElementNs"]
    [::std::mem::offset_of!(_xmlSAXHandler, endElementNs) - 240usize];
  ["Offset of field: _xmlSAXHandler::serror"]
    [::std::mem::offset_of!(_xmlSAXHandler, serror) - 248usize];
};
pub type xmlSAXHandlerV1 = _xmlSAXHandlerV1;
pub type xmlSAXHandlerV1Ptr = *mut xmlSAXHandlerV1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSAXHandlerV1 {
  pub internalSubset: internalSubsetSAXFunc,
  pub isStandalone: isStandaloneSAXFunc,
  pub hasInternalSubset: hasInternalSubsetSAXFunc,
  pub hasExternalSubset: hasExternalSubsetSAXFunc,
  pub resolveEntity: resolveEntitySAXFunc,
  pub getEntity: getEntitySAXFunc,
  pub entityDecl: entityDeclSAXFunc,
  pub notationDecl: notationDeclSAXFunc,
  pub attributeDecl: attributeDeclSAXFunc,
  pub elementDecl: elementDeclSAXFunc,
  pub unparsedEntityDecl: unparsedEntityDeclSAXFunc,
  pub setDocumentLocator: setDocumentLocatorSAXFunc,
  pub startDocument: startDocumentSAXFunc,
  pub endDocument: endDocumentSAXFunc,
  pub startElement: startElementSAXFunc,
  pub endElement: endElementSAXFunc,
  pub reference: referenceSAXFunc,
  pub characters: charactersSAXFunc,
  pub ignorableWhitespace: ignorableWhitespaceSAXFunc,
  pub processingInstruction: processingInstructionSAXFunc,
  pub comment: commentSAXFunc,
  pub warning: warningSAXFunc,
  pub error: errorSAXFunc,
  pub fatalError: fatalErrorSAXFunc,
  pub getParameterEntity: getParameterEntitySAXFunc,
  pub cdataBlock: cdataBlockSAXFunc,
  pub externalSubset: externalSubsetSAXFunc,
  pub initialized: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlSAXHandlerV1"][::std::mem::size_of::<_xmlSAXHandlerV1>() - 224usize];
  ["Alignment of _xmlSAXHandlerV1"][::std::mem::align_of::<_xmlSAXHandlerV1>() - 8usize];
  ["Offset of field: _xmlSAXHandlerV1::internalSubset"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, internalSubset) - 0usize];
  ["Offset of field: _xmlSAXHandlerV1::isStandalone"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, isStandalone) - 8usize];
  ["Offset of field: _xmlSAXHandlerV1::hasInternalSubset"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, hasInternalSubset) - 16usize];
  ["Offset of field: _xmlSAXHandlerV1::hasExternalSubset"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, hasExternalSubset) - 24usize];
  ["Offset of field: _xmlSAXHandlerV1::resolveEntity"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, resolveEntity) - 32usize];
  ["Offset of field: _xmlSAXHandlerV1::getEntity"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, getEntity) - 40usize];
  ["Offset of field: _xmlSAXHandlerV1::entityDecl"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, entityDecl) - 48usize];
  ["Offset of field: _xmlSAXHandlerV1::notationDecl"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, notationDecl) - 56usize];
  ["Offset of field: _xmlSAXHandlerV1::attributeDecl"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, attributeDecl) - 64usize];
  ["Offset of field: _xmlSAXHandlerV1::elementDecl"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, elementDecl) - 72usize];
  ["Offset of field: _xmlSAXHandlerV1::unparsedEntityDecl"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, unparsedEntityDecl) - 80usize];
  ["Offset of field: _xmlSAXHandlerV1::setDocumentLocator"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, setDocumentLocator) - 88usize];
  ["Offset of field: _xmlSAXHandlerV1::startDocument"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, startDocument) - 96usize];
  ["Offset of field: _xmlSAXHandlerV1::endDocument"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, endDocument) - 104usize];
  ["Offset of field: _xmlSAXHandlerV1::startElement"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, startElement) - 112usize];
  ["Offset of field: _xmlSAXHandlerV1::endElement"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, endElement) - 120usize];
  ["Offset of field: _xmlSAXHandlerV1::reference"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, reference) - 128usize];
  ["Offset of field: _xmlSAXHandlerV1::characters"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, characters) - 136usize];
  ["Offset of field: _xmlSAXHandlerV1::ignorableWhitespace"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, ignorableWhitespace) - 144usize];
  ["Offset of field: _xmlSAXHandlerV1::processingInstruction"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, processingInstruction) - 152usize];
  ["Offset of field: _xmlSAXHandlerV1::comment"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, comment) - 160usize];
  ["Offset of field: _xmlSAXHandlerV1::warning"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, warning) - 168usize];
  ["Offset of field: _xmlSAXHandlerV1::error"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, error) - 176usize];
  ["Offset of field: _xmlSAXHandlerV1::fatalError"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, fatalError) - 184usize];
  ["Offset of field: _xmlSAXHandlerV1::getParameterEntity"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, getParameterEntity) - 192usize];
  ["Offset of field: _xmlSAXHandlerV1::cdataBlock"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, cdataBlock) - 200usize];
  ["Offset of field: _xmlSAXHandlerV1::externalSubset"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, externalSubset) - 208usize];
  ["Offset of field: _xmlSAXHandlerV1::initialized"]
    [::std::mem::offset_of!(_xmlSAXHandlerV1, initialized) - 216usize];
};
#[doc = " xmlExternalEntityLoader:\n @URL: The System ID of the resource requested\n @ID: The Public ID of the resource requested\n @context: the XML parser context\n\n External entity loaders types.\n\n Returns the entity input parser."]
pub type xmlExternalEntityLoader = ::std::option::Option<
  unsafe extern "C" fn(
    URL: *const ::std::os::raw::c_char,
    ID: *const ::std::os::raw::c_char,
    context: xmlParserCtxtPtr,
  ) -> xmlParserInputPtr,
>;
pub type iconv_t = *mut ::std::os::raw::c_void;
unsafe extern "C" {
  pub fn iconv_close(__cd: iconv_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn iconv_open(
    __tocode: *const ::std::os::raw::c_char,
    __fromcode: *const ::std::os::raw::c_char,
  ) -> iconv_t;
}
unsafe extern "C" {
  pub fn iconv(
    __cd: iconv_t,
    __inbuf: *mut *mut ::std::os::raw::c_char,
    __inbytesleft: *mut usize,
    __outbuf: *mut *mut ::std::os::raw::c_char,
    __outbytesleft: *mut usize,
  ) -> usize;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type UBool = i8;
pub type UChar = u16;
pub type OldUChar = ::std::os::raw::c_ushort;
pub type UChar32 = i32;
pub type UVersionInfo = [u8; 4usize];
unsafe extern "C" {
  pub fn u_versionFromString_72(
    versionArray: *mut u8,
    versionString: *const ::std::os::raw::c_char,
  );
}
unsafe extern "C" {
  pub fn u_versionFromUString_72(versionArray: *mut u8, versionString: *const UChar);
}
unsafe extern "C" {
  pub fn u_versionToString_72(versionArray: *const u8, versionString: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
  pub fn u_getVersion_72(versionArray: *mut u8);
}
unsafe extern "C" {
  pub fn utf8_nextCharSafeBody_72(
    s: *const u8,
    pi: *mut i32,
    length: i32,
    c: UChar32,
    strict: UBool,
  ) -> UChar32;
}
unsafe extern "C" {
  pub fn utf8_appendCharSafeBody_72(
    s: *mut u8,
    i: i32,
    length: i32,
    c: UChar32,
    pIsError: *mut UBool,
  ) -> i32;
}
unsafe extern "C" {
  pub fn utf8_prevCharSafeBody_72(
    s: *const u8,
    start: i32,
    pi: *mut i32,
    c: UChar32,
    strict: UBool,
  ) -> UChar32;
}
unsafe extern "C" {
  pub fn utf8_back1SafeBody_72(s: *const u8, start: i32, i: i32) -> i32;
}
unsafe extern "C" {
  pub static utf8_countTrailBytes_72: [u8; 0usize];
}
pub type UDate = f64;
pub const UErrorCode_U_USING_FALLBACK_WARNING: UErrorCode = -128;
pub const UErrorCode_U_ERROR_WARNING_START: UErrorCode = -128;
pub const UErrorCode_U_USING_DEFAULT_WARNING: UErrorCode = -127;
pub const UErrorCode_U_SAFECLONE_ALLOCATED_WARNING: UErrorCode = -126;
pub const UErrorCode_U_STATE_OLD_WARNING: UErrorCode = -125;
pub const UErrorCode_U_STRING_NOT_TERMINATED_WARNING: UErrorCode = -124;
pub const UErrorCode_U_SORT_KEY_TOO_SHORT_WARNING: UErrorCode = -123;
pub const UErrorCode_U_AMBIGUOUS_ALIAS_WARNING: UErrorCode = -122;
pub const UErrorCode_U_DIFFERENT_UCA_VERSION: UErrorCode = -121;
pub const UErrorCode_U_PLUGIN_CHANGED_LEVEL_WARNING: UErrorCode = -120;
pub const UErrorCode_U_ERROR_WARNING_LIMIT: UErrorCode = -119;
pub const UErrorCode_U_ZERO_ERROR: UErrorCode = 0;
pub const UErrorCode_U_ILLEGAL_ARGUMENT_ERROR: UErrorCode = 1;
pub const UErrorCode_U_MISSING_RESOURCE_ERROR: UErrorCode = 2;
pub const UErrorCode_U_INVALID_FORMAT_ERROR: UErrorCode = 3;
pub const UErrorCode_U_FILE_ACCESS_ERROR: UErrorCode = 4;
pub const UErrorCode_U_INTERNAL_PROGRAM_ERROR: UErrorCode = 5;
pub const UErrorCode_U_MESSAGE_PARSE_ERROR: UErrorCode = 6;
pub const UErrorCode_U_MEMORY_ALLOCATION_ERROR: UErrorCode = 7;
pub const UErrorCode_U_INDEX_OUTOFBOUNDS_ERROR: UErrorCode = 8;
pub const UErrorCode_U_PARSE_ERROR: UErrorCode = 9;
pub const UErrorCode_U_INVALID_CHAR_FOUND: UErrorCode = 10;
pub const UErrorCode_U_TRUNCATED_CHAR_FOUND: UErrorCode = 11;
pub const UErrorCode_U_ILLEGAL_CHAR_FOUND: UErrorCode = 12;
pub const UErrorCode_U_INVALID_TABLE_FORMAT: UErrorCode = 13;
pub const UErrorCode_U_INVALID_TABLE_FILE: UErrorCode = 14;
pub const UErrorCode_U_BUFFER_OVERFLOW_ERROR: UErrorCode = 15;
pub const UErrorCode_U_UNSUPPORTED_ERROR: UErrorCode = 16;
pub const UErrorCode_U_RESOURCE_TYPE_MISMATCH: UErrorCode = 17;
pub const UErrorCode_U_ILLEGAL_ESCAPE_SEQUENCE: UErrorCode = 18;
pub const UErrorCode_U_UNSUPPORTED_ESCAPE_SEQUENCE: UErrorCode = 19;
pub const UErrorCode_U_NO_SPACE_AVAILABLE: UErrorCode = 20;
pub const UErrorCode_U_CE_NOT_FOUND_ERROR: UErrorCode = 21;
pub const UErrorCode_U_PRIMARY_TOO_LONG_ERROR: UErrorCode = 22;
pub const UErrorCode_U_STATE_TOO_OLD_ERROR: UErrorCode = 23;
pub const UErrorCode_U_TOO_MANY_ALIASES_ERROR: UErrorCode = 24;
pub const UErrorCode_U_ENUM_OUT_OF_SYNC_ERROR: UErrorCode = 25;
pub const UErrorCode_U_INVARIANT_CONVERSION_ERROR: UErrorCode = 26;
pub const UErrorCode_U_INVALID_STATE_ERROR: UErrorCode = 27;
pub const UErrorCode_U_COLLATOR_VERSION_MISMATCH: UErrorCode = 28;
pub const UErrorCode_U_USELESS_COLLATOR_ERROR: UErrorCode = 29;
pub const UErrorCode_U_NO_WRITE_PERMISSION: UErrorCode = 30;
pub const UErrorCode_U_INPUT_TOO_LONG_ERROR: UErrorCode = 31;
pub const UErrorCode_U_STANDARD_ERROR_LIMIT: UErrorCode = 32;
pub const UErrorCode_U_BAD_VARIABLE_DEFINITION: UErrorCode = 65536;
pub const UErrorCode_U_PARSE_ERROR_START: UErrorCode = 65536;
pub const UErrorCode_U_MALFORMED_RULE: UErrorCode = 65537;
pub const UErrorCode_U_MALFORMED_SET: UErrorCode = 65538;
pub const UErrorCode_U_MALFORMED_SYMBOL_REFERENCE: UErrorCode = 65539;
pub const UErrorCode_U_MALFORMED_UNICODE_ESCAPE: UErrorCode = 65540;
pub const UErrorCode_U_MALFORMED_VARIABLE_DEFINITION: UErrorCode = 65541;
pub const UErrorCode_U_MALFORMED_VARIABLE_REFERENCE: UErrorCode = 65542;
pub const UErrorCode_U_MISMATCHED_SEGMENT_DELIMITERS: UErrorCode = 65543;
pub const UErrorCode_U_MISPLACED_ANCHOR_START: UErrorCode = 65544;
pub const UErrorCode_U_MISPLACED_CURSOR_OFFSET: UErrorCode = 65545;
pub const UErrorCode_U_MISPLACED_QUANTIFIER: UErrorCode = 65546;
pub const UErrorCode_U_MISSING_OPERATOR: UErrorCode = 65547;
pub const UErrorCode_U_MISSING_SEGMENT_CLOSE: UErrorCode = 65548;
pub const UErrorCode_U_MULTIPLE_ANTE_CONTEXTS: UErrorCode = 65549;
pub const UErrorCode_U_MULTIPLE_CURSORS: UErrorCode = 65550;
pub const UErrorCode_U_MULTIPLE_POST_CONTEXTS: UErrorCode = 65551;
pub const UErrorCode_U_TRAILING_BACKSLASH: UErrorCode = 65552;
pub const UErrorCode_U_UNDEFINED_SEGMENT_REFERENCE: UErrorCode = 65553;
pub const UErrorCode_U_UNDEFINED_VARIABLE: UErrorCode = 65554;
pub const UErrorCode_U_UNQUOTED_SPECIAL: UErrorCode = 65555;
pub const UErrorCode_U_UNTERMINATED_QUOTE: UErrorCode = 65556;
pub const UErrorCode_U_RULE_MASK_ERROR: UErrorCode = 65557;
pub const UErrorCode_U_MISPLACED_COMPOUND_FILTER: UErrorCode = 65558;
pub const UErrorCode_U_MULTIPLE_COMPOUND_FILTERS: UErrorCode = 65559;
pub const UErrorCode_U_INVALID_RBT_SYNTAX: UErrorCode = 65560;
pub const UErrorCode_U_INVALID_PROPERTY_PATTERN: UErrorCode = 65561;
pub const UErrorCode_U_MALFORMED_PRAGMA: UErrorCode = 65562;
pub const UErrorCode_U_UNCLOSED_SEGMENT: UErrorCode = 65563;
pub const UErrorCode_U_ILLEGAL_CHAR_IN_SEGMENT: UErrorCode = 65564;
pub const UErrorCode_U_VARIABLE_RANGE_EXHAUSTED: UErrorCode = 65565;
pub const UErrorCode_U_VARIABLE_RANGE_OVERLAP: UErrorCode = 65566;
pub const UErrorCode_U_ILLEGAL_CHARACTER: UErrorCode = 65567;
pub const UErrorCode_U_INTERNAL_TRANSLITERATOR_ERROR: UErrorCode = 65568;
pub const UErrorCode_U_INVALID_ID: UErrorCode = 65569;
pub const UErrorCode_U_INVALID_FUNCTION: UErrorCode = 65570;
pub const UErrorCode_U_PARSE_ERROR_LIMIT: UErrorCode = 65571;
pub const UErrorCode_U_UNEXPECTED_TOKEN: UErrorCode = 65792;
pub const UErrorCode_U_FMT_PARSE_ERROR_START: UErrorCode = 65792;
pub const UErrorCode_U_MULTIPLE_DECIMAL_SEPARATORS: UErrorCode = 65793;
pub const UErrorCode_U_MULTIPLE_DECIMAL_SEPERATORS: UErrorCode = 65793;
pub const UErrorCode_U_MULTIPLE_EXPONENTIAL_SYMBOLS: UErrorCode = 65794;
pub const UErrorCode_U_MALFORMED_EXPONENTIAL_PATTERN: UErrorCode = 65795;
pub const UErrorCode_U_MULTIPLE_PERCENT_SYMBOLS: UErrorCode = 65796;
pub const UErrorCode_U_MULTIPLE_PERMILL_SYMBOLS: UErrorCode = 65797;
pub const UErrorCode_U_MULTIPLE_PAD_SPECIFIERS: UErrorCode = 65798;
pub const UErrorCode_U_PATTERN_SYNTAX_ERROR: UErrorCode = 65799;
pub const UErrorCode_U_ILLEGAL_PAD_POSITION: UErrorCode = 65800;
pub const UErrorCode_U_UNMATCHED_BRACES: UErrorCode = 65801;
pub const UErrorCode_U_UNSUPPORTED_PROPERTY: UErrorCode = 65802;
pub const UErrorCode_U_UNSUPPORTED_ATTRIBUTE: UErrorCode = 65803;
pub const UErrorCode_U_ARGUMENT_TYPE_MISMATCH: UErrorCode = 65804;
pub const UErrorCode_U_DUPLICATE_KEYWORD: UErrorCode = 65805;
pub const UErrorCode_U_UNDEFINED_KEYWORD: UErrorCode = 65806;
pub const UErrorCode_U_DEFAULT_KEYWORD_MISSING: UErrorCode = 65807;
pub const UErrorCode_U_DECIMAL_NUMBER_SYNTAX_ERROR: UErrorCode = 65808;
pub const UErrorCode_U_FORMAT_INEXACT_ERROR: UErrorCode = 65809;
pub const UErrorCode_U_NUMBER_ARG_OUTOFBOUNDS_ERROR: UErrorCode = 65810;
pub const UErrorCode_U_NUMBER_SKELETON_SYNTAX_ERROR: UErrorCode = 65811;
pub const UErrorCode_U_FMT_PARSE_ERROR_LIMIT: UErrorCode = 65812;
pub const UErrorCode_U_BRK_INTERNAL_ERROR: UErrorCode = 66048;
pub const UErrorCode_U_BRK_ERROR_START: UErrorCode = 66048;
pub const UErrorCode_U_BRK_HEX_DIGITS_EXPECTED: UErrorCode = 66049;
pub const UErrorCode_U_BRK_SEMICOLON_EXPECTED: UErrorCode = 66050;
pub const UErrorCode_U_BRK_RULE_SYNTAX: UErrorCode = 66051;
pub const UErrorCode_U_BRK_UNCLOSED_SET: UErrorCode = 66052;
pub const UErrorCode_U_BRK_ASSIGN_ERROR: UErrorCode = 66053;
pub const UErrorCode_U_BRK_VARIABLE_REDFINITION: UErrorCode = 66054;
pub const UErrorCode_U_BRK_MISMATCHED_PAREN: UErrorCode = 66055;
pub const UErrorCode_U_BRK_NEW_LINE_IN_QUOTED_STRING: UErrorCode = 66056;
pub const UErrorCode_U_BRK_UNDEFINED_VARIABLE: UErrorCode = 66057;
pub const UErrorCode_U_BRK_INIT_ERROR: UErrorCode = 66058;
pub const UErrorCode_U_BRK_RULE_EMPTY_SET: UErrorCode = 66059;
pub const UErrorCode_U_BRK_UNRECOGNIZED_OPTION: UErrorCode = 66060;
pub const UErrorCode_U_BRK_MALFORMED_RULE_TAG: UErrorCode = 66061;
pub const UErrorCode_U_BRK_ERROR_LIMIT: UErrorCode = 66062;
pub const UErrorCode_U_REGEX_INTERNAL_ERROR: UErrorCode = 66304;
pub const UErrorCode_U_REGEX_ERROR_START: UErrorCode = 66304;
pub const UErrorCode_U_REGEX_RULE_SYNTAX: UErrorCode = 66305;
pub const UErrorCode_U_REGEX_INVALID_STATE: UErrorCode = 66306;
pub const UErrorCode_U_REGEX_BAD_ESCAPE_SEQUENCE: UErrorCode = 66307;
pub const UErrorCode_U_REGEX_PROPERTY_SYNTAX: UErrorCode = 66308;
pub const UErrorCode_U_REGEX_UNIMPLEMENTED: UErrorCode = 66309;
pub const UErrorCode_U_REGEX_MISMATCHED_PAREN: UErrorCode = 66310;
pub const UErrorCode_U_REGEX_NUMBER_TOO_BIG: UErrorCode = 66311;
pub const UErrorCode_U_REGEX_BAD_INTERVAL: UErrorCode = 66312;
pub const UErrorCode_U_REGEX_MAX_LT_MIN: UErrorCode = 66313;
pub const UErrorCode_U_REGEX_INVALID_BACK_REF: UErrorCode = 66314;
pub const UErrorCode_U_REGEX_INVALID_FLAG: UErrorCode = 66315;
pub const UErrorCode_U_REGEX_LOOK_BEHIND_LIMIT: UErrorCode = 66316;
pub const UErrorCode_U_REGEX_SET_CONTAINS_STRING: UErrorCode = 66317;
pub const UErrorCode_U_REGEX_OCTAL_TOO_BIG: UErrorCode = 66318;
pub const UErrorCode_U_REGEX_MISSING_CLOSE_BRACKET: UErrorCode = 66319;
pub const UErrorCode_U_REGEX_INVALID_RANGE: UErrorCode = 66320;
pub const UErrorCode_U_REGEX_STACK_OVERFLOW: UErrorCode = 66321;
pub const UErrorCode_U_REGEX_TIME_OUT: UErrorCode = 66322;
pub const UErrorCode_U_REGEX_STOPPED_BY_CALLER: UErrorCode = 66323;
pub const UErrorCode_U_REGEX_PATTERN_TOO_BIG: UErrorCode = 66324;
pub const UErrorCode_U_REGEX_INVALID_CAPTURE_GROUP_NAME: UErrorCode = 66325;
pub const UErrorCode_U_REGEX_ERROR_LIMIT: UErrorCode = 66326;
pub const UErrorCode_U_IDNA_PROHIBITED_ERROR: UErrorCode = 66560;
pub const UErrorCode_U_IDNA_ERROR_START: UErrorCode = 66560;
pub const UErrorCode_U_IDNA_UNASSIGNED_ERROR: UErrorCode = 66561;
pub const UErrorCode_U_IDNA_CHECK_BIDI_ERROR: UErrorCode = 66562;
pub const UErrorCode_U_IDNA_STD3_ASCII_RULES_ERROR: UErrorCode = 66563;
pub const UErrorCode_U_IDNA_ACE_PREFIX_ERROR: UErrorCode = 66564;
pub const UErrorCode_U_IDNA_VERIFICATION_ERROR: UErrorCode = 66565;
pub const UErrorCode_U_IDNA_LABEL_TOO_LONG_ERROR: UErrorCode = 66566;
pub const UErrorCode_U_IDNA_ZERO_LENGTH_LABEL_ERROR: UErrorCode = 66567;
pub const UErrorCode_U_IDNA_DOMAIN_NAME_TOO_LONG_ERROR: UErrorCode = 66568;
pub const UErrorCode_U_IDNA_ERROR_LIMIT: UErrorCode = 66569;
pub const UErrorCode_U_STRINGPREP_PROHIBITED_ERROR: UErrorCode = 66560;
pub const UErrorCode_U_STRINGPREP_UNASSIGNED_ERROR: UErrorCode = 66561;
pub const UErrorCode_U_STRINGPREP_CHECK_BIDI_ERROR: UErrorCode = 66562;
pub const UErrorCode_U_PLUGIN_ERROR_START: UErrorCode = 66816;
pub const UErrorCode_U_PLUGIN_TOO_HIGH: UErrorCode = 66816;
pub const UErrorCode_U_PLUGIN_DIDNT_SET_LEVEL: UErrorCode = 66817;
pub const UErrorCode_U_PLUGIN_ERROR_LIMIT: UErrorCode = 66818;
pub const UErrorCode_U_ERROR_LIMIT: UErrorCode = 66818;
pub type UErrorCode = ::std::os::raw::c_int;
unsafe extern "C" {
  pub fn u_errorName_72(code: UErrorCode) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UConverter {
  _unused: [u8; 0],
}
pub const UConverterCallbackReason_UCNV_UNASSIGNED: UConverterCallbackReason = 0;
pub const UConverterCallbackReason_UCNV_ILLEGAL: UConverterCallbackReason = 1;
pub const UConverterCallbackReason_UCNV_IRREGULAR: UConverterCallbackReason = 2;
pub const UConverterCallbackReason_UCNV_RESET: UConverterCallbackReason = 3;
pub const UConverterCallbackReason_UCNV_CLOSE: UConverterCallbackReason = 4;
pub const UConverterCallbackReason_UCNV_CLONE: UConverterCallbackReason = 5;
pub type UConverterCallbackReason = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UConverterFromUnicodeArgs {
  pub size: u16,
  pub flush: UBool,
  pub converter: *mut UConverter,
  pub source: *const UChar,
  pub sourceLimit: *const UChar,
  pub target: *mut ::std::os::raw::c_char,
  pub targetLimit: *const ::std::os::raw::c_char,
  pub offsets: *mut i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of UConverterFromUnicodeArgs"]
    [::std::mem::size_of::<UConverterFromUnicodeArgs>() - 56usize];
  ["Alignment of UConverterFromUnicodeArgs"]
    [::std::mem::align_of::<UConverterFromUnicodeArgs>() - 8usize];
  ["Offset of field: UConverterFromUnicodeArgs::size"]
    [::std::mem::offset_of!(UConverterFromUnicodeArgs, size) - 0usize];
  ["Offset of field: UConverterFromUnicodeArgs::flush"]
    [::std::mem::offset_of!(UConverterFromUnicodeArgs, flush) - 2usize];
  ["Offset of field: UConverterFromUnicodeArgs::converter"]
    [::std::mem::offset_of!(UConverterFromUnicodeArgs, converter) - 8usize];
  ["Offset of field: UConverterFromUnicodeArgs::source"]
    [::std::mem::offset_of!(UConverterFromUnicodeArgs, source) - 16usize];
  ["Offset of field: UConverterFromUnicodeArgs::sourceLimit"]
    [::std::mem::offset_of!(UConverterFromUnicodeArgs, sourceLimit) - 24usize];
  ["Offset of field: UConverterFromUnicodeArgs::target"]
    [::std::mem::offset_of!(UConverterFromUnicodeArgs, target) - 32usize];
  ["Offset of field: UConverterFromUnicodeArgs::targetLimit"]
    [::std::mem::offset_of!(UConverterFromUnicodeArgs, targetLimit) - 40usize];
  ["Offset of field: UConverterFromUnicodeArgs::offsets"]
    [::std::mem::offset_of!(UConverterFromUnicodeArgs, offsets) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UConverterToUnicodeArgs {
  pub size: u16,
  pub flush: UBool,
  pub converter: *mut UConverter,
  pub source: *const ::std::os::raw::c_char,
  pub sourceLimit: *const ::std::os::raw::c_char,
  pub target: *mut UChar,
  pub targetLimit: *const UChar,
  pub offsets: *mut i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of UConverterToUnicodeArgs"][::std::mem::size_of::<UConverterToUnicodeArgs>() - 56usize];
  ["Alignment of UConverterToUnicodeArgs"]
    [::std::mem::align_of::<UConverterToUnicodeArgs>() - 8usize];
  ["Offset of field: UConverterToUnicodeArgs::size"]
    [::std::mem::offset_of!(UConverterToUnicodeArgs, size) - 0usize];
  ["Offset of field: UConverterToUnicodeArgs::flush"]
    [::std::mem::offset_of!(UConverterToUnicodeArgs, flush) - 2usize];
  ["Offset of field: UConverterToUnicodeArgs::converter"]
    [::std::mem::offset_of!(UConverterToUnicodeArgs, converter) - 8usize];
  ["Offset of field: UConverterToUnicodeArgs::source"]
    [::std::mem::offset_of!(UConverterToUnicodeArgs, source) - 16usize];
  ["Offset of field: UConverterToUnicodeArgs::sourceLimit"]
    [::std::mem::offset_of!(UConverterToUnicodeArgs, sourceLimit) - 24usize];
  ["Offset of field: UConverterToUnicodeArgs::target"]
    [::std::mem::offset_of!(UConverterToUnicodeArgs, target) - 32usize];
  ["Offset of field: UConverterToUnicodeArgs::targetLimit"]
    [::std::mem::offset_of!(UConverterToUnicodeArgs, targetLimit) - 40usize];
  ["Offset of field: UConverterToUnicodeArgs::offsets"]
    [::std::mem::offset_of!(UConverterToUnicodeArgs, offsets) - 48usize];
};
unsafe extern "C" {
  pub fn UCNV_FROM_U_CALLBACK_STOP_72(
    context: *const ::std::os::raw::c_void,
    fromUArgs: *mut UConverterFromUnicodeArgs,
    codeUnits: *const UChar,
    length: i32,
    codePoint: UChar32,
    reason: UConverterCallbackReason,
    err: *mut UErrorCode,
  );
}
unsafe extern "C" {
  pub fn UCNV_TO_U_CALLBACK_STOP_72(
    context: *const ::std::os::raw::c_void,
    toUArgs: *mut UConverterToUnicodeArgs,
    codeUnits: *const ::std::os::raw::c_char,
    length: i32,
    reason: UConverterCallbackReason,
    err: *mut UErrorCode,
  );
}
unsafe extern "C" {
  pub fn UCNV_FROM_U_CALLBACK_SKIP_72(
    context: *const ::std::os::raw::c_void,
    fromUArgs: *mut UConverterFromUnicodeArgs,
    codeUnits: *const UChar,
    length: i32,
    codePoint: UChar32,
    reason: UConverterCallbackReason,
    err: *mut UErrorCode,
  );
}
unsafe extern "C" {
  pub fn UCNV_FROM_U_CALLBACK_SUBSTITUTE_72(
    context: *const ::std::os::raw::c_void,
    fromUArgs: *mut UConverterFromUnicodeArgs,
    codeUnits: *const UChar,
    length: i32,
    codePoint: UChar32,
    reason: UConverterCallbackReason,
    err: *mut UErrorCode,
  );
}
unsafe extern "C" {
  pub fn UCNV_FROM_U_CALLBACK_ESCAPE_72(
    context: *const ::std::os::raw::c_void,
    fromUArgs: *mut UConverterFromUnicodeArgs,
    codeUnits: *const UChar,
    length: i32,
    codePoint: UChar32,
    reason: UConverterCallbackReason,
    err: *mut UErrorCode,
  );
}
unsafe extern "C" {
  pub fn UCNV_TO_U_CALLBACK_SKIP_72(
    context: *const ::std::os::raw::c_void,
    toUArgs: *mut UConverterToUnicodeArgs,
    codeUnits: *const ::std::os::raw::c_char,
    length: i32,
    reason: UConverterCallbackReason,
    err: *mut UErrorCode,
  );
}
unsafe extern "C" {
  pub fn UCNV_TO_U_CALLBACK_SUBSTITUTE_72(
    context: *const ::std::os::raw::c_void,
    toUArgs: *mut UConverterToUnicodeArgs,
    codeUnits: *const ::std::os::raw::c_char,
    length: i32,
    reason: UConverterCallbackReason,
    err: *mut UErrorCode,
  );
}
unsafe extern "C" {
  pub fn UCNV_TO_U_CALLBACK_ESCAPE_72(
    context: *const ::std::os::raw::c_void,
    toUArgs: *mut UConverterToUnicodeArgs,
    codeUnits: *const ::std::os::raw::c_char,
    length: i32,
    reason: UConverterCallbackReason,
    err: *mut UErrorCode,
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UEnumeration {
  _unused: [u8; 0],
}
unsafe extern "C" {
  pub fn uenum_close_72(en: *mut UEnumeration);
}
unsafe extern "C" {
  pub fn uenum_count_72(en: *mut UEnumeration, status: *mut UErrorCode) -> i32;
}
unsafe extern "C" {
  pub fn uenum_unext_72(
    en: *mut UEnumeration,
    resultLength: *mut i32,
    status: *mut UErrorCode,
  ) -> *const UChar;
}
unsafe extern "C" {
  pub fn uenum_next_72(
    en: *mut UEnumeration,
    resultLength: *mut i32,
    status: *mut UErrorCode,
  ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn uenum_reset_72(en: *mut UEnumeration, status: *mut UErrorCode);
}
unsafe extern "C" {
  pub fn uenum_openUCharStringsEnumeration_72(
    strings: *const *const UChar,
    count: i32,
    ec: *mut UErrorCode,
  ) -> *mut UEnumeration;
}
unsafe extern "C" {
  pub fn uenum_openCharStringsEnumeration_72(
    strings: *const *const ::std::os::raw::c_char,
    count: i32,
    ec: *mut UErrorCode,
  ) -> *mut UEnumeration;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USet {
  _unused: [u8; 0],
}
pub const UConverterType_UCNV_UNSUPPORTED_CONVERTER: UConverterType = -1;
pub const UConverterType_UCNV_SBCS: UConverterType = 0;
pub const UConverterType_UCNV_DBCS: UConverterType = 1;
pub const UConverterType_UCNV_MBCS: UConverterType = 2;
pub const UConverterType_UCNV_LATIN_1: UConverterType = 3;
pub const UConverterType_UCNV_UTF8: UConverterType = 4;
pub const UConverterType_UCNV_UTF16_BigEndian: UConverterType = 5;
pub const UConverterType_UCNV_UTF16_LittleEndian: UConverterType = 6;
pub const UConverterType_UCNV_UTF32_BigEndian: UConverterType = 7;
pub const UConverterType_UCNV_UTF32_LittleEndian: UConverterType = 8;
pub const UConverterType_UCNV_EBCDIC_STATEFUL: UConverterType = 9;
pub const UConverterType_UCNV_ISO_2022: UConverterType = 10;
pub const UConverterType_UCNV_LMBCS_1: UConverterType = 11;
pub const UConverterType_UCNV_LMBCS_2: UConverterType = 12;
pub const UConverterType_UCNV_LMBCS_3: UConverterType = 13;
pub const UConverterType_UCNV_LMBCS_4: UConverterType = 14;
pub const UConverterType_UCNV_LMBCS_5: UConverterType = 15;
pub const UConverterType_UCNV_LMBCS_6: UConverterType = 16;
pub const UConverterType_UCNV_LMBCS_8: UConverterType = 17;
pub const UConverterType_UCNV_LMBCS_11: UConverterType = 18;
pub const UConverterType_UCNV_LMBCS_16: UConverterType = 19;
pub const UConverterType_UCNV_LMBCS_17: UConverterType = 20;
pub const UConverterType_UCNV_LMBCS_18: UConverterType = 21;
pub const UConverterType_UCNV_LMBCS_19: UConverterType = 22;
pub const UConverterType_UCNV_LMBCS_LAST: UConverterType = 22;
pub const UConverterType_UCNV_HZ: UConverterType = 23;
pub const UConverterType_UCNV_SCSU: UConverterType = 24;
pub const UConverterType_UCNV_ISCII: UConverterType = 25;
pub const UConverterType_UCNV_US_ASCII: UConverterType = 26;
pub const UConverterType_UCNV_UTF7: UConverterType = 27;
pub const UConverterType_UCNV_BOCU1: UConverterType = 28;
pub const UConverterType_UCNV_UTF16: UConverterType = 29;
pub const UConverterType_UCNV_UTF32: UConverterType = 30;
pub const UConverterType_UCNV_CESU8: UConverterType = 31;
pub const UConverterType_UCNV_IMAP_MAILBOX: UConverterType = 32;
pub const UConverterType_UCNV_COMPOUND_TEXT: UConverterType = 33;
pub const UConverterType_UCNV_NUMBER_OF_SUPPORTED_CONVERTER_TYPES: UConverterType = 34;
pub type UConverterType = ::std::os::raw::c_int;
pub const UConverterPlatform_UCNV_UNKNOWN: UConverterPlatform = -1;
pub const UConverterPlatform_UCNV_IBM: UConverterPlatform = 0;
pub type UConverterPlatform = ::std::os::raw::c_int;
pub type UConverterToUCallback = ::std::option::Option<
  unsafe extern "C" fn(
    context: *const ::std::os::raw::c_void,
    args: *mut UConverterToUnicodeArgs,
    codeUnits: *const ::std::os::raw::c_char,
    length: i32,
    reason: UConverterCallbackReason,
    pErrorCode: *mut UErrorCode,
  ),
>;
pub type UConverterFromUCallback = ::std::option::Option<
  unsafe extern "C" fn(
    context: *const ::std::os::raw::c_void,
    args: *mut UConverterFromUnicodeArgs,
    codeUnits: *const UChar,
    length: i32,
    codePoint: UChar32,
    reason: UConverterCallbackReason,
    pErrorCode: *mut UErrorCode,
  ),
>;
unsafe extern "C" {
  pub fn ucnv_compareNames_72(
    name1: *const ::std::os::raw::c_char,
    name2: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn ucnv_open_72(
    converterName: *const ::std::os::raw::c_char,
    err: *mut UErrorCode,
  ) -> *mut UConverter;
}
unsafe extern "C" {
  pub fn ucnv_openU_72(name: *const UChar, err: *mut UErrorCode) -> *mut UConverter;
}
unsafe extern "C" {
  pub fn ucnv_openCCSID_72(
    codepage: i32,
    platform: UConverterPlatform,
    err: *mut UErrorCode,
  ) -> *mut UConverter;
}
unsafe extern "C" {
  pub fn ucnv_openPackage_72(
    packageName: *const ::std::os::raw::c_char,
    converterName: *const ::std::os::raw::c_char,
    err: *mut UErrorCode,
  ) -> *mut UConverter;
}
unsafe extern "C" {
  pub fn ucnv_clone_72(cnv: *const UConverter, status: *mut UErrorCode) -> *mut UConverter;
}
unsafe extern "C" {
  pub fn ucnv_safeClone_72(
    cnv: *const UConverter,
    stackBuffer: *mut ::std::os::raw::c_void,
    pBufferSize: *mut i32,
    status: *mut UErrorCode,
  ) -> *mut UConverter;
}
unsafe extern "C" {
  pub fn ucnv_close_72(converter: *mut UConverter);
}
unsafe extern "C" {
  pub fn ucnv_getSubstChars_72(
    converter: *const UConverter,
    subChars: *mut ::std::os::raw::c_char,
    len: *mut i8,
    err: *mut UErrorCode,
  );
}
unsafe extern "C" {
  pub fn ucnv_setSubstChars_72(
    converter: *mut UConverter,
    subChars: *const ::std::os::raw::c_char,
    len: i8,
    err: *mut UErrorCode,
  );
}
unsafe extern "C" {
  pub fn ucnv_setSubstString_72(
    cnv: *mut UConverter,
    s: *const UChar,
    length: i32,
    err: *mut UErrorCode,
  );
}
unsafe extern "C" {
  pub fn ucnv_getInvalidChars_72(
    converter: *const UConverter,
    errBytes: *mut ::std::os::raw::c_char,
    len: *mut i8,
    err: *mut UErrorCode,
  );
}
unsafe extern "C" {
  pub fn ucnv_getInvalidUChars_72(
    converter: *const UConverter,
    errUChars: *mut UChar,
    len: *mut i8,
    err: *mut UErrorCode,
  );
}
unsafe extern "C" {
  pub fn ucnv_reset_72(converter: *mut UConverter);
}
unsafe extern "C" {
  pub fn ucnv_resetToUnicode_72(converter: *mut UConverter);
}
unsafe extern "C" {
  pub fn ucnv_resetFromUnicode_72(converter: *mut UConverter);
}
unsafe extern "C" {
  pub fn ucnv_getMaxCharSize_72(converter: *const UConverter) -> i8;
}
unsafe extern "C" {
  pub fn ucnv_getMinCharSize_72(converter: *const UConverter) -> i8;
}
unsafe extern "C" {
  pub fn ucnv_getDisplayName_72(
    converter: *const UConverter,
    displayLocale: *const ::std::os::raw::c_char,
    displayName: *mut UChar,
    displayNameCapacity: i32,
    err: *mut UErrorCode,
  ) -> i32;
}
unsafe extern "C" {
  pub fn ucnv_getName_72(
    converter: *const UConverter,
    err: *mut UErrorCode,
  ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn ucnv_getCCSID_72(converter: *const UConverter, err: *mut UErrorCode) -> i32;
}
unsafe extern "C" {
  pub fn ucnv_getPlatform_72(
    converter: *const UConverter,
    err: *mut UErrorCode,
  ) -> UConverterPlatform;
}
unsafe extern "C" {
  pub fn ucnv_getType_72(converter: *const UConverter) -> UConverterType;
}
unsafe extern "C" {
  pub fn ucnv_getStarters_72(
    converter: *const UConverter,
    starters: *mut UBool,
    err: *mut UErrorCode,
  );
}
pub const UConverterUnicodeSet_UCNV_ROUNDTRIP_SET: UConverterUnicodeSet = 0;
pub const UConverterUnicodeSet_UCNV_ROUNDTRIP_AND_FALLBACK_SET: UConverterUnicodeSet = 1;
pub const UConverterUnicodeSet_UCNV_SET_COUNT: UConverterUnicodeSet = 2;
pub type UConverterUnicodeSet = ::std::os::raw::c_uint;
unsafe extern "C" {
  pub fn ucnv_getUnicodeSet_72(
    cnv: *const UConverter,
    setFillIn: *mut USet,
    whichSet: UConverterUnicodeSet,
    pErrorCode: *mut UErrorCode,
  );
}
unsafe extern "C" {
  pub fn ucnv_getToUCallBack_72(
    converter: *const UConverter,
    action: *mut UConverterToUCallback,
    context: *mut *const ::std::os::raw::c_void,
  );
}
unsafe extern "C" {
  pub fn ucnv_getFromUCallBack_72(
    converter: *const UConverter,
    action: *mut UConverterFromUCallback,
    context: *mut *const ::std::os::raw::c_void,
  );
}
unsafe extern "C" {
  pub fn ucnv_setToUCallBack_72(
    converter: *mut UConverter,
    newAction: UConverterToUCallback,
    newContext: *const ::std::os::raw::c_void,
    oldAction: *mut UConverterToUCallback,
    oldContext: *mut *const ::std::os::raw::c_void,
    err: *mut UErrorCode,
  );
}
unsafe extern "C" {
  pub fn ucnv_setFromUCallBack_72(
    converter: *mut UConverter,
    newAction: UConverterFromUCallback,
    newContext: *const ::std::os::raw::c_void,
    oldAction: *mut UConverterFromUCallback,
    oldContext: *mut *const ::std::os::raw::c_void,
    err: *mut UErrorCode,
  );
}
unsafe extern "C" {
  pub fn ucnv_fromUnicode_72(
    converter: *mut UConverter,
    target: *mut *mut ::std::os::raw::c_char,
    targetLimit: *const ::std::os::raw::c_char,
    source: *mut *const UChar,
    sourceLimit: *const UChar,
    offsets: *mut i32,
    flush: UBool,
    err: *mut UErrorCode,
  );
}
unsafe extern "C" {
  pub fn ucnv_toUnicode_72(
    converter: *mut UConverter,
    target: *mut *mut UChar,
    targetLimit: *const UChar,
    source: *mut *const ::std::os::raw::c_char,
    sourceLimit: *const ::std::os::raw::c_char,
    offsets: *mut i32,
    flush: UBool,
    err: *mut UErrorCode,
  );
}
unsafe extern "C" {
  pub fn ucnv_fromUChars_72(
    cnv: *mut UConverter,
    dest: *mut ::std::os::raw::c_char,
    destCapacity: i32,
    src: *const UChar,
    srcLength: i32,
    pErrorCode: *mut UErrorCode,
  ) -> i32;
}
unsafe extern "C" {
  pub fn ucnv_toUChars_72(
    cnv: *mut UConverter,
    dest: *mut UChar,
    destCapacity: i32,
    src: *const ::std::os::raw::c_char,
    srcLength: i32,
    pErrorCode: *mut UErrorCode,
  ) -> i32;
}
unsafe extern "C" {
  pub fn ucnv_getNextUChar_72(
    converter: *mut UConverter,
    source: *mut *const ::std::os::raw::c_char,
    sourceLimit: *const ::std::os::raw::c_char,
    err: *mut UErrorCode,
  ) -> UChar32;
}
unsafe extern "C" {
  pub fn ucnv_convertEx_72(
    targetCnv: *mut UConverter,
    sourceCnv: *mut UConverter,
    target: *mut *mut ::std::os::raw::c_char,
    targetLimit: *const ::std::os::raw::c_char,
    source: *mut *const ::std::os::raw::c_char,
    sourceLimit: *const ::std::os::raw::c_char,
    pivotStart: *mut UChar,
    pivotSource: *mut *mut UChar,
    pivotTarget: *mut *mut UChar,
    pivotLimit: *const UChar,
    reset: UBool,
    flush: UBool,
    pErrorCode: *mut UErrorCode,
  );
}
unsafe extern "C" {
  pub fn ucnv_convert_72(
    toConverterName: *const ::std::os::raw::c_char,
    fromConverterName: *const ::std::os::raw::c_char,
    target: *mut ::std::os::raw::c_char,
    targetCapacity: i32,
    source: *const ::std::os::raw::c_char,
    sourceLength: i32,
    pErrorCode: *mut UErrorCode,
  ) -> i32;
}
unsafe extern "C" {
  pub fn ucnv_toAlgorithmic_72(
    algorithmicType: UConverterType,
    cnv: *mut UConverter,
    target: *mut ::std::os::raw::c_char,
    targetCapacity: i32,
    source: *const ::std::os::raw::c_char,
    sourceLength: i32,
    pErrorCode: *mut UErrorCode,
  ) -> i32;
}
unsafe extern "C" {
  pub fn ucnv_fromAlgorithmic_72(
    cnv: *mut UConverter,
    algorithmicType: UConverterType,
    target: *mut ::std::os::raw::c_char,
    targetCapacity: i32,
    source: *const ::std::os::raw::c_char,
    sourceLength: i32,
    pErrorCode: *mut UErrorCode,
  ) -> i32;
}
unsafe extern "C" {
  pub fn ucnv_flushCache_72() -> i32;
}
unsafe extern "C" {
  pub fn ucnv_countAvailable_72() -> i32;
}
unsafe extern "C" {
  pub fn ucnv_getAvailableName_72(n: i32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn ucnv_openAllNames_72(pErrorCode: *mut UErrorCode) -> *mut UEnumeration;
}
unsafe extern "C" {
  pub fn ucnv_countAliases_72(
    alias: *const ::std::os::raw::c_char,
    pErrorCode: *mut UErrorCode,
  ) -> u16;
}
unsafe extern "C" {
  pub fn ucnv_getAlias_72(
    alias: *const ::std::os::raw::c_char,
    n: u16,
    pErrorCode: *mut UErrorCode,
  ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn ucnv_getAliases_72(
    alias: *const ::std::os::raw::c_char,
    aliases: *mut *const ::std::os::raw::c_char,
    pErrorCode: *mut UErrorCode,
  );
}
unsafe extern "C" {
  pub fn ucnv_openStandardNames_72(
    convName: *const ::std::os::raw::c_char,
    standard: *const ::std::os::raw::c_char,
    pErrorCode: *mut UErrorCode,
  ) -> *mut UEnumeration;
}
unsafe extern "C" {
  pub fn ucnv_countStandards_72() -> u16;
}
unsafe extern "C" {
  pub fn ucnv_getStandard_72(n: u16, pErrorCode: *mut UErrorCode) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn ucnv_getStandardName_72(
    name: *const ::std::os::raw::c_char,
    standard: *const ::std::os::raw::c_char,
    pErrorCode: *mut UErrorCode,
  ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn ucnv_getCanonicalName_72(
    alias: *const ::std::os::raw::c_char,
    standard: *const ::std::os::raw::c_char,
    pErrorCode: *mut UErrorCode,
  ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn ucnv_getDefaultName_72() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn ucnv_setDefaultName_72(name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
  pub fn ucnv_fixFileSeparator_72(cnv: *const UConverter, source: *mut UChar, sourceLen: i32);
}
unsafe extern "C" {
  pub fn ucnv_isAmbiguous_72(cnv: *const UConverter) -> UBool;
}
unsafe extern "C" {
  pub fn ucnv_setFallback_72(cnv: *mut UConverter, usesFallback: UBool);
}
unsafe extern "C" {
  pub fn ucnv_usesFallback_72(cnv: *const UConverter) -> UBool;
}
unsafe extern "C" {
  pub fn ucnv_detectUnicodeSignature_72(
    source: *const ::std::os::raw::c_char,
    sourceLength: i32,
    signatureLength: *mut i32,
    pErrorCode: *mut UErrorCode,
  ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn ucnv_fromUCountPending_72(cnv: *const UConverter, status: *mut UErrorCode) -> i32;
}
unsafe extern "C" {
  pub fn ucnv_toUCountPending_72(cnv: *const UConverter, status: *mut UErrorCode) -> i32;
}
unsafe extern "C" {
  pub fn ucnv_isFixedWidth_72(cnv: *mut UConverter, status: *mut UErrorCode) -> UBool;
}
pub const xmlCharEncoding_XML_CHAR_ENCODING_ERROR: xmlCharEncoding = -1;
pub const xmlCharEncoding_XML_CHAR_ENCODING_NONE: xmlCharEncoding = 0;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UTF8: xmlCharEncoding = 1;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UTF16LE: xmlCharEncoding = 2;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UTF16BE: xmlCharEncoding = 3;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UCS4LE: xmlCharEncoding = 4;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UCS4BE: xmlCharEncoding = 5;
pub const xmlCharEncoding_XML_CHAR_ENCODING_EBCDIC: xmlCharEncoding = 6;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UCS4_2143: xmlCharEncoding = 7;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UCS4_3412: xmlCharEncoding = 8;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UCS2: xmlCharEncoding = 9;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_1: xmlCharEncoding = 10;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_2: xmlCharEncoding = 11;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_3: xmlCharEncoding = 12;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_4: xmlCharEncoding = 13;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_5: xmlCharEncoding = 14;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_6: xmlCharEncoding = 15;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_7: xmlCharEncoding = 16;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_8: xmlCharEncoding = 17;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_9: xmlCharEncoding = 18;
pub const xmlCharEncoding_XML_CHAR_ENCODING_2022_JP: xmlCharEncoding = 19;
pub const xmlCharEncoding_XML_CHAR_ENCODING_SHIFT_JIS: xmlCharEncoding = 20;
pub const xmlCharEncoding_XML_CHAR_ENCODING_EUC_JP: xmlCharEncoding = 21;
pub const xmlCharEncoding_XML_CHAR_ENCODING_ASCII: xmlCharEncoding = 22;
pub type xmlCharEncoding = ::std::os::raw::c_int;
#[doc = " xmlCharEncodingInputFunc:\n @out:  a pointer to an array of bytes to store the UTF-8 result\n @outlen:  the length of @out\n @in:  a pointer to an array of chars in the original encoding\n @inlen:  the length of @in\n\n Take a block of chars in the original encoding and try to convert\n it to an UTF-8 block of chars out.\n\n Returns the number of bytes written, -1 if lack of space, or -2\n     if the transcoding failed.\n The value of @inlen after return is the number of octets consumed\n     if the return value is positive, else unpredictiable.\n The value of @outlen after return is the number of octets consumed."]
pub type xmlCharEncodingInputFunc = ::std::option::Option<
  unsafe extern "C" fn(
    out: *mut ::std::os::raw::c_uchar,
    outlen: *mut ::std::os::raw::c_int,
    in_: *const ::std::os::raw::c_uchar,
    inlen: *mut ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int,
>;
#[doc = " xmlCharEncodingOutputFunc:\n @out:  a pointer to an array of bytes to store the result\n @outlen:  the length of @out\n @in:  a pointer to an array of UTF-8 chars\n @inlen:  the length of @in\n\n Take a block of UTF-8 chars in and try to convert it to another\n encoding.\n Note: a first call designed to produce heading info is called with\n in = NULL. If stateful this should also initialize the encoder state.\n\n Returns the number of bytes written, -1 if lack of space, or -2\n     if the transcoding failed.\n The value of @inlen after return is the number of octets consumed\n     if the return value is positive, else unpredictiable.\n The value of @outlen after return is the number of octets produced."]
pub type xmlCharEncodingOutputFunc = ::std::option::Option<
  unsafe extern "C" fn(
    out: *mut ::std::os::raw::c_uchar,
    outlen: *mut ::std::os::raw::c_int,
    in_: *const ::std::os::raw::c_uchar,
    inlen: *mut ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _uconv_t {
  pub uconv: *mut UConverter,
  pub utf8: *mut UConverter,
  pub pivot_buf: [UChar; 1024usize],
  pub pivot_source: *mut UChar,
  pub pivot_target: *mut UChar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _uconv_t"][::std::mem::size_of::<_uconv_t>() - 2080usize];
  ["Alignment of _uconv_t"][::std::mem::align_of::<_uconv_t>() - 8usize];
  ["Offset of field: _uconv_t::uconv"][::std::mem::offset_of!(_uconv_t, uconv) - 0usize];
  ["Offset of field: _uconv_t::utf8"][::std::mem::offset_of!(_uconv_t, utf8) - 8usize];
  ["Offset of field: _uconv_t::pivot_buf"][::std::mem::offset_of!(_uconv_t, pivot_buf) - 16usize];
  ["Offset of field: _uconv_t::pivot_source"]
    [::std::mem::offset_of!(_uconv_t, pivot_source) - 2064usize];
  ["Offset of field: _uconv_t::pivot_target"]
    [::std::mem::offset_of!(_uconv_t, pivot_target) - 2072usize];
};
pub type uconv_t = _uconv_t;
pub type xmlCharEncodingHandler = _xmlCharEncodingHandler;
pub type xmlCharEncodingHandlerPtr = *mut xmlCharEncodingHandler;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlCharEncodingHandler {
  pub name: *mut ::std::os::raw::c_char,
  pub input: xmlCharEncodingInputFunc,
  pub output: xmlCharEncodingOutputFunc,
  pub iconv_in: iconv_t,
  pub iconv_out: iconv_t,
  pub uconv_in: *mut uconv_t,
  pub uconv_out: *mut uconv_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlCharEncodingHandler"][::std::mem::size_of::<_xmlCharEncodingHandler>() - 56usize];
  ["Alignment of _xmlCharEncodingHandler"]
    [::std::mem::align_of::<_xmlCharEncodingHandler>() - 8usize];
  ["Offset of field: _xmlCharEncodingHandler::name"]
    [::std::mem::offset_of!(_xmlCharEncodingHandler, name) - 0usize];
  ["Offset of field: _xmlCharEncodingHandler::input"]
    [::std::mem::offset_of!(_xmlCharEncodingHandler, input) - 8usize];
  ["Offset of field: _xmlCharEncodingHandler::output"]
    [::std::mem::offset_of!(_xmlCharEncodingHandler, output) - 16usize];
  ["Offset of field: _xmlCharEncodingHandler::iconv_in"]
    [::std::mem::offset_of!(_xmlCharEncodingHandler, iconv_in) - 24usize];
  ["Offset of field: _xmlCharEncodingHandler::iconv_out"]
    [::std::mem::offset_of!(_xmlCharEncodingHandler, iconv_out) - 32usize];
  ["Offset of field: _xmlCharEncodingHandler::uconv_in"]
    [::std::mem::offset_of!(_xmlCharEncodingHandler, uconv_in) - 40usize];
  ["Offset of field: _xmlCharEncodingHandler::uconv_out"]
    [::std::mem::offset_of!(_xmlCharEncodingHandler, uconv_out) - 48usize];
};
unsafe extern "C" {
  pub fn xmlInitCharEncodingHandlers();
}
unsafe extern "C" {
  pub fn xmlCleanupCharEncodingHandlers();
}
unsafe extern "C" {
  pub fn xmlRegisterCharEncodingHandler(handler: xmlCharEncodingHandlerPtr);
}
unsafe extern "C" {
  pub fn xmlGetCharEncodingHandler(enc: xmlCharEncoding) -> xmlCharEncodingHandlerPtr;
}
unsafe extern "C" {
  pub fn xmlFindCharEncodingHandler(
    name: *const ::std::os::raw::c_char,
  ) -> xmlCharEncodingHandlerPtr;
}
unsafe extern "C" {
  pub fn xmlNewCharEncodingHandler(
    name: *const ::std::os::raw::c_char,
    input: xmlCharEncodingInputFunc,
    output: xmlCharEncodingOutputFunc,
  ) -> xmlCharEncodingHandlerPtr;
}
unsafe extern "C" {
  pub fn xmlAddEncodingAlias(
    name: *const ::std::os::raw::c_char,
    alias: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlDelEncodingAlias(alias: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlGetEncodingAlias(alias: *const ::std::os::raw::c_char)
    -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn xmlCleanupEncodingAliases();
}
unsafe extern "C" {
  pub fn xmlParseCharEncoding(name: *const ::std::os::raw::c_char) -> xmlCharEncoding;
}
unsafe extern "C" {
  pub fn xmlGetCharEncodingName(enc: xmlCharEncoding) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn xmlDetectCharEncoding(
    in_: *const ::std::os::raw::c_uchar,
    len: ::std::os::raw::c_int,
  ) -> xmlCharEncoding;
}
unsafe extern "C" {
  pub fn xmlCharEncOutFunc(
    handler: *mut xmlCharEncodingHandler,
    out: xmlBufferPtr,
    in_: xmlBufferPtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlCharEncInFunc(
    handler: *mut xmlCharEncodingHandler,
    out: xmlBufferPtr,
    in_: xmlBufferPtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlCharEncFirstLine(
    handler: *mut xmlCharEncodingHandler,
    out: xmlBufferPtr,
    in_: xmlBufferPtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlCharEncCloseFunc(handler: *mut xmlCharEncodingHandler) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn UTF8Toisolat1(
    out: *mut ::std::os::raw::c_uchar,
    outlen: *mut ::std::os::raw::c_int,
    in_: *const ::std::os::raw::c_uchar,
    inlen: *mut ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn isolat1ToUTF8(
    out: *mut ::std::os::raw::c_uchar,
    outlen: *mut ::std::os::raw::c_int,
    in_: *const ::std::os::raw::c_uchar,
    inlen: *mut ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
#[doc = " xmlInputMatchCallback:\n @filename: the filename or URI\n\n Callback used in the I/O Input API to detect if the current handler\n can provide input functionality for this resource.\n\n Returns 1 if yes and 0 if another Input module should be used"]
pub type xmlInputMatchCallback = ::std::option::Option<
  unsafe extern "C" fn(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
>;
#[doc = " xmlInputOpenCallback:\n @filename: the filename or URI\n\n Callback used in the I/O Input API to open the resource\n\n Returns an Input context or NULL in case or error"]
pub type xmlInputOpenCallback = ::std::option::Option<
  unsafe extern "C" fn(filename: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void,
>;
#[doc = " xmlInputReadCallback:\n @context:  an Input context\n @buffer:  the buffer to store data read\n @len:  the length of the buffer in bytes\n\n Callback used in the I/O Input API to read the resource\n\n Returns the number of bytes read or -1 in case of error"]
pub type xmlInputReadCallback = ::std::option::Option<
  unsafe extern "C" fn(
    context: *mut ::std::os::raw::c_void,
    buffer: *mut ::std::os::raw::c_char,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int,
>;
#[doc = " xmlInputCloseCallback:\n @context:  an Input context\n\n Callback used in the I/O Input API to close the resource\n\n Returns 0 or -1 in case of error"]
pub type xmlInputCloseCallback = ::std::option::Option<
  unsafe extern "C" fn(context: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " xmlOutputMatchCallback:\n @filename: the filename or URI\n\n Callback used in the I/O Output API to detect if the current handler\n can provide output functionality for this resource.\n\n Returns 1 if yes and 0 if another Output module should be used"]
pub type xmlOutputMatchCallback = ::std::option::Option<
  unsafe extern "C" fn(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
>;
#[doc = " xmlOutputOpenCallback:\n @filename: the filename or URI\n\n Callback used in the I/O Output API to open the resource\n\n Returns an Output context or NULL in case or error"]
pub type xmlOutputOpenCallback = ::std::option::Option<
  unsafe extern "C" fn(filename: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void,
>;
#[doc = " xmlOutputWriteCallback:\n @context:  an Output context\n @buffer:  the buffer of data to write\n @len:  the length of the buffer in bytes\n\n Callback used in the I/O Output API to write to the resource\n\n Returns the number of bytes written or -1 in case of error"]
pub type xmlOutputWriteCallback = ::std::option::Option<
  unsafe extern "C" fn(
    context: *mut ::std::os::raw::c_void,
    buffer: *const ::std::os::raw::c_char,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int,
>;
#[doc = " xmlOutputCloseCallback:\n @context:  an Output context\n\n Callback used in the I/O Output API to close the resource\n\n Returns 0 or -1 in case of error"]
pub type xmlOutputCloseCallback = ::std::option::Option<
  unsafe extern "C" fn(context: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
  pub quot: ::std::os::raw::c_int,
  pub rem: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of div_t"][::std::mem::size_of::<div_t>() - 8usize];
  ["Alignment of div_t"][::std::mem::align_of::<div_t>() - 4usize];
  ["Offset of field: div_t::quot"][::std::mem::offset_of!(div_t, quot) - 0usize];
  ["Offset of field: div_t::rem"][::std::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
  pub quot: ::std::os::raw::c_long,
  pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of ldiv_t"][::std::mem::size_of::<ldiv_t>() - 16usize];
  ["Alignment of ldiv_t"][::std::mem::align_of::<ldiv_t>() - 8usize];
  ["Offset of field: ldiv_t::quot"][::std::mem::offset_of!(ldiv_t, quot) - 0usize];
  ["Offset of field: ldiv_t::rem"][::std::mem::offset_of!(ldiv_t, rem) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
  pub quot: ::std::os::raw::c_longlong,
  pub rem: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of lldiv_t"][::std::mem::size_of::<lldiv_t>() - 16usize];
  ["Alignment of lldiv_t"][::std::mem::align_of::<lldiv_t>() - 8usize];
  ["Offset of field: lldiv_t::quot"][::std::mem::offset_of!(lldiv_t, quot) - 0usize];
  ["Offset of field: lldiv_t::rem"][::std::mem::offset_of!(lldiv_t, rem) - 8usize];
};
unsafe extern "C" {
  pub fn __ctype_get_mb_cur_max() -> usize;
}
unsafe extern "C" {
  pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
  pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
  pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
  pub fn strtod(
    __nptr: *const ::std::os::raw::c_char,
    __endptr: *mut *mut ::std::os::raw::c_char,
  ) -> f64;
}
unsafe extern "C" {
  pub fn strtof(
    __nptr: *const ::std::os::raw::c_char,
    __endptr: *mut *mut ::std::os::raw::c_char,
  ) -> f32;
}
unsafe extern "C" {
  pub fn strtold(
    __nptr: *const ::std::os::raw::c_char,
    __endptr: *mut *mut ::std::os::raw::c_char,
  ) -> u128;
}
unsafe extern "C" {
  pub fn strtol(
    __nptr: *const ::std::os::raw::c_char,
    __endptr: *mut *mut ::std::os::raw::c_char,
    __base: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
  pub fn strtoul(
    __nptr: *const ::std::os::raw::c_char,
    __endptr: *mut *mut ::std::os::raw::c_char,
    __base: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
  pub fn strtoq(
    __nptr: *const ::std::os::raw::c_char,
    __endptr: *mut *mut ::std::os::raw::c_char,
    __base: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
  pub fn strtouq(
    __nptr: *const ::std::os::raw::c_char,
    __endptr: *mut *mut ::std::os::raw::c_char,
    __base: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
  pub fn strtoll(
    __nptr: *const ::std::os::raw::c_char,
    __endptr: *mut *mut ::std::os::raw::c_char,
    __base: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
  pub fn strtoull(
    __nptr: *const ::std::os::raw::c_char,
    __endptr: *mut *mut ::std::os::raw::c_char,
    __base: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
  pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
  pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of __sigset_t"][::std::mem::size_of::<__sigset_t>() - 128usize];
  ["Alignment of __sigset_t"][::std::mem::align_of::<__sigset_t>() - 8usize];
  ["Offset of field: __sigset_t::__val"][::std::mem::offset_of!(__sigset_t, __val) - 0usize];
};
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
  pub tv_sec: __time_t,
  pub tv_usec: __suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of timeval"][::std::mem::size_of::<timeval>() - 16usize];
  ["Alignment of timeval"][::std::mem::align_of::<timeval>() - 8usize];
  ["Offset of field: timeval::tv_sec"][::std::mem::offset_of!(timeval, tv_sec) - 0usize];
  ["Offset of field: timeval::tv_usec"][::std::mem::offset_of!(timeval, tv_usec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
  pub tv_sec: __time_t,
  pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
  ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
  ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
  ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
  pub __fds_bits: [__fd_mask; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of fd_set"][::std::mem::size_of::<fd_set>() - 128usize];
  ["Alignment of fd_set"][::std::mem::align_of::<fd_set>() - 8usize];
  ["Offset of field: fd_set::__fds_bits"][::std::mem::offset_of!(fd_set, __fds_bits) - 0usize];
};
pub type fd_mask = __fd_mask;
unsafe extern "C" {
  pub fn select(
    __nfds: ::std::os::raw::c_int,
    __readfds: *mut fd_set,
    __writefds: *mut fd_set,
    __exceptfds: *mut fd_set,
    __timeout: *mut timeval,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn pselect(
    __nfds: ::std::os::raw::c_int,
    __readfds: *mut fd_set,
    __writefds: *mut fd_set,
    __exceptfds: *mut fd_set,
    __timeout: *const timespec,
    __sigmask: *const __sigset_t,
  ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
  pub __value64: ::std::os::raw::c_ulonglong,
  pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
  pub __low: ::std::os::raw::c_uint,
  pub __high: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of __atomic_wide_counter__bindgen_ty_1"]
    [::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>() - 8usize];
  ["Alignment of __atomic_wide_counter__bindgen_ty_1"]
    [::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>() - 4usize];
  ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__low"]
    [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __low) - 0usize];
  ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__high"]
    [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of __atomic_wide_counter"][::std::mem::size_of::<__atomic_wide_counter>() - 8usize];
  ["Alignment of __atomic_wide_counter"][::std::mem::align_of::<__atomic_wide_counter>() - 8usize];
  ["Offset of field: __atomic_wide_counter::__value64"]
    [::std::mem::offset_of!(__atomic_wide_counter, __value64) - 0usize];
  ["Offset of field: __atomic_wide_counter::__value32"]
    [::std::mem::offset_of!(__atomic_wide_counter, __value32) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
  pub __prev: *mut __pthread_internal_list,
  pub __next: *mut __pthread_internal_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of __pthread_internal_list"][::std::mem::size_of::<__pthread_internal_list>() - 16usize];
  ["Alignment of __pthread_internal_list"]
    [::std::mem::align_of::<__pthread_internal_list>() - 8usize];
  ["Offset of field: __pthread_internal_list::__prev"]
    [::std::mem::offset_of!(__pthread_internal_list, __prev) - 0usize];
  ["Offset of field: __pthread_internal_list::__next"]
    [::std::mem::offset_of!(__pthread_internal_list, __next) - 8usize];
};
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
  pub __next: *mut __pthread_internal_slist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of __pthread_internal_slist"][::std::mem::size_of::<__pthread_internal_slist>() - 8usize];
  ["Alignment of __pthread_internal_slist"]
    [::std::mem::align_of::<__pthread_internal_slist>() - 8usize];
  ["Offset of field: __pthread_internal_slist::__next"]
    [::std::mem::offset_of!(__pthread_internal_slist, __next) - 0usize];
};
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
  pub __lock: ::std::os::raw::c_int,
  pub __count: ::std::os::raw::c_uint,
  pub __owner: ::std::os::raw::c_int,
  pub __nusers: ::std::os::raw::c_uint,
  pub __kind: ::std::os::raw::c_int,
  pub __spins: ::std::os::raw::c_short,
  pub __elision: ::std::os::raw::c_short,
  pub __list: __pthread_list_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of __pthread_mutex_s"][::std::mem::size_of::<__pthread_mutex_s>() - 40usize];
  ["Alignment of __pthread_mutex_s"][::std::mem::align_of::<__pthread_mutex_s>() - 8usize];
  ["Offset of field: __pthread_mutex_s::__lock"]
    [::std::mem::offset_of!(__pthread_mutex_s, __lock) - 0usize];
  ["Offset of field: __pthread_mutex_s::__count"]
    [::std::mem::offset_of!(__pthread_mutex_s, __count) - 4usize];
  ["Offset of field: __pthread_mutex_s::__owner"]
    [::std::mem::offset_of!(__pthread_mutex_s, __owner) - 8usize];
  ["Offset of field: __pthread_mutex_s::__nusers"]
    [::std::mem::offset_of!(__pthread_mutex_s, __nusers) - 12usize];
  ["Offset of field: __pthread_mutex_s::__kind"]
    [::std::mem::offset_of!(__pthread_mutex_s, __kind) - 16usize];
  ["Offset of field: __pthread_mutex_s::__spins"]
    [::std::mem::offset_of!(__pthread_mutex_s, __spins) - 20usize];
  ["Offset of field: __pthread_mutex_s::__elision"]
    [::std::mem::offset_of!(__pthread_mutex_s, __elision) - 22usize];
  ["Offset of field: __pthread_mutex_s::__list"]
    [::std::mem::offset_of!(__pthread_mutex_s, __list) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
  pub __readers: ::std::os::raw::c_uint,
  pub __writers: ::std::os::raw::c_uint,
  pub __wrphase_futex: ::std::os::raw::c_uint,
  pub __writers_futex: ::std::os::raw::c_uint,
  pub __pad3: ::std::os::raw::c_uint,
  pub __pad4: ::std::os::raw::c_uint,
  pub __cur_writer: ::std::os::raw::c_int,
  pub __shared: ::std::os::raw::c_int,
  pub __rwelision: ::std::os::raw::c_schar,
  pub __pad1: [::std::os::raw::c_uchar; 7usize],
  pub __pad2: ::std::os::raw::c_ulong,
  pub __flags: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of __pthread_rwlock_arch_t"][::std::mem::size_of::<__pthread_rwlock_arch_t>() - 56usize];
  ["Alignment of __pthread_rwlock_arch_t"]
    [::std::mem::align_of::<__pthread_rwlock_arch_t>() - 8usize];
  ["Offset of field: __pthread_rwlock_arch_t::__readers"]
    [::std::mem::offset_of!(__pthread_rwlock_arch_t, __readers) - 0usize];
  ["Offset of field: __pthread_rwlock_arch_t::__writers"]
    [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers) - 4usize];
  ["Offset of field: __pthread_rwlock_arch_t::__wrphase_futex"]
    [::std::mem::offset_of!(__pthread_rwlock_arch_t, __wrphase_futex) - 8usize];
  ["Offset of field: __pthread_rwlock_arch_t::__writers_futex"]
    [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers_futex) - 12usize];
  ["Offset of field: __pthread_rwlock_arch_t::__pad3"]
    [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad3) - 16usize];
  ["Offset of field: __pthread_rwlock_arch_t::__pad4"]
    [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad4) - 20usize];
  ["Offset of field: __pthread_rwlock_arch_t::__cur_writer"]
    [::std::mem::offset_of!(__pthread_rwlock_arch_t, __cur_writer) - 24usize];
  ["Offset of field: __pthread_rwlock_arch_t::__shared"]
    [::std::mem::offset_of!(__pthread_rwlock_arch_t, __shared) - 28usize];
  ["Offset of field: __pthread_rwlock_arch_t::__rwelision"]
    [::std::mem::offset_of!(__pthread_rwlock_arch_t, __rwelision) - 32usize];
  ["Offset of field: __pthread_rwlock_arch_t::__pad1"]
    [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad1) - 33usize];
  ["Offset of field: __pthread_rwlock_arch_t::__pad2"]
    [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad2) - 40usize];
  ["Offset of field: __pthread_rwlock_arch_t::__flags"]
    [::std::mem::offset_of!(__pthread_rwlock_arch_t, __flags) - 48usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
  pub __wseq: __atomic_wide_counter,
  pub __g1_start: __atomic_wide_counter,
  pub __g_refs: [::std::os::raw::c_uint; 2usize],
  pub __g_size: [::std::os::raw::c_uint; 2usize],
  pub __g1_orig_size: ::std::os::raw::c_uint,
  pub __wrefs: ::std::os::raw::c_uint,
  pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of __pthread_cond_s"][::std::mem::size_of::<__pthread_cond_s>() - 48usize];
  ["Alignment of __pthread_cond_s"][::std::mem::align_of::<__pthread_cond_s>() - 8usize];
  ["Offset of field: __pthread_cond_s::__wseq"]
    [::std::mem::offset_of!(__pthread_cond_s, __wseq) - 0usize];
  ["Offset of field: __pthread_cond_s::__g1_start"]
    [::std::mem::offset_of!(__pthread_cond_s, __g1_start) - 8usize];
  ["Offset of field: __pthread_cond_s::__g_refs"]
    [::std::mem::offset_of!(__pthread_cond_s, __g_refs) - 16usize];
  ["Offset of field: __pthread_cond_s::__g_size"]
    [::std::mem::offset_of!(__pthread_cond_s, __g_size) - 24usize];
  ["Offset of field: __pthread_cond_s::__g1_orig_size"]
    [::std::mem::offset_of!(__pthread_cond_s, __g1_orig_size) - 32usize];
  ["Offset of field: __pthread_cond_s::__wrefs"]
    [::std::mem::offset_of!(__pthread_cond_s, __wrefs) - 36usize];
  ["Offset of field: __pthread_cond_s::__g_signals"]
    [::std::mem::offset_of!(__pthread_cond_s, __g_signals) - 40usize];
};
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
  pub __data: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of __once_flag"][::std::mem::size_of::<__once_flag>() - 4usize];
  ["Alignment of __once_flag"][::std::mem::align_of::<__once_flag>() - 4usize];
  ["Offset of field: __once_flag::__data"][::std::mem::offset_of!(__once_flag, __data) - 0usize];
};
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
  pub __size: [::std::os::raw::c_char; 4usize],
  pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of pthread_mutexattr_t"][::std::mem::size_of::<pthread_mutexattr_t>() - 4usize];
  ["Alignment of pthread_mutexattr_t"][::std::mem::align_of::<pthread_mutexattr_t>() - 4usize];
  ["Offset of field: pthread_mutexattr_t::__size"]
    [::std::mem::offset_of!(pthread_mutexattr_t, __size) - 0usize];
  ["Offset of field: pthread_mutexattr_t::__align"]
    [::std::mem::offset_of!(pthread_mutexattr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
  pub __size: [::std::os::raw::c_char; 4usize],
  pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of pthread_condattr_t"][::std::mem::size_of::<pthread_condattr_t>() - 4usize];
  ["Alignment of pthread_condattr_t"][::std::mem::align_of::<pthread_condattr_t>() - 4usize];
  ["Offset of field: pthread_condattr_t::__size"]
    [::std::mem::offset_of!(pthread_condattr_t, __size) - 0usize];
  ["Offset of field: pthread_condattr_t::__align"]
    [::std::mem::offset_of!(pthread_condattr_t, __align) - 0usize];
};
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
  pub __size: [::std::os::raw::c_char; 56usize],
  pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of pthread_attr_t"][::std::mem::size_of::<pthread_attr_t>() - 56usize];
  ["Alignment of pthread_attr_t"][::std::mem::align_of::<pthread_attr_t>() - 8usize];
  ["Offset of field: pthread_attr_t::__size"]
    [::std::mem::offset_of!(pthread_attr_t, __size) - 0usize];
  ["Offset of field: pthread_attr_t::__align"]
    [::std::mem::offset_of!(pthread_attr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
  pub __data: __pthread_mutex_s,
  pub __size: [::std::os::raw::c_char; 40usize],
  pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of pthread_mutex_t"][::std::mem::size_of::<pthread_mutex_t>() - 40usize];
  ["Alignment of pthread_mutex_t"][::std::mem::align_of::<pthread_mutex_t>() - 8usize];
  ["Offset of field: pthread_mutex_t::__data"]
    [::std::mem::offset_of!(pthread_mutex_t, __data) - 0usize];
  ["Offset of field: pthread_mutex_t::__size"]
    [::std::mem::offset_of!(pthread_mutex_t, __size) - 0usize];
  ["Offset of field: pthread_mutex_t::__align"]
    [::std::mem::offset_of!(pthread_mutex_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
  pub __data: __pthread_cond_s,
  pub __size: [::std::os::raw::c_char; 48usize],
  pub __align: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of pthread_cond_t"][::std::mem::size_of::<pthread_cond_t>() - 48usize];
  ["Alignment of pthread_cond_t"][::std::mem::align_of::<pthread_cond_t>() - 8usize];
  ["Offset of field: pthread_cond_t::__data"]
    [::std::mem::offset_of!(pthread_cond_t, __data) - 0usize];
  ["Offset of field: pthread_cond_t::__size"]
    [::std::mem::offset_of!(pthread_cond_t, __size) - 0usize];
  ["Offset of field: pthread_cond_t::__align"]
    [::std::mem::offset_of!(pthread_cond_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
  pub __data: __pthread_rwlock_arch_t,
  pub __size: [::std::os::raw::c_char; 56usize],
  pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of pthread_rwlock_t"][::std::mem::size_of::<pthread_rwlock_t>() - 56usize];
  ["Alignment of pthread_rwlock_t"][::std::mem::align_of::<pthread_rwlock_t>() - 8usize];
  ["Offset of field: pthread_rwlock_t::__data"]
    [::std::mem::offset_of!(pthread_rwlock_t, __data) - 0usize];
  ["Offset of field: pthread_rwlock_t::__size"]
    [::std::mem::offset_of!(pthread_rwlock_t, __size) - 0usize];
  ["Offset of field: pthread_rwlock_t::__align"]
    [::std::mem::offset_of!(pthread_rwlock_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
  pub __size: [::std::os::raw::c_char; 8usize],
  pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of pthread_rwlockattr_t"][::std::mem::size_of::<pthread_rwlockattr_t>() - 8usize];
  ["Alignment of pthread_rwlockattr_t"][::std::mem::align_of::<pthread_rwlockattr_t>() - 8usize];
  ["Offset of field: pthread_rwlockattr_t::__size"]
    [::std::mem::offset_of!(pthread_rwlockattr_t, __size) - 0usize];
  ["Offset of field: pthread_rwlockattr_t::__align"]
    [::std::mem::offset_of!(pthread_rwlockattr_t, __align) - 0usize];
};
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
  pub __size: [::std::os::raw::c_char; 32usize],
  pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of pthread_barrier_t"][::std::mem::size_of::<pthread_barrier_t>() - 32usize];
  ["Alignment of pthread_barrier_t"][::std::mem::align_of::<pthread_barrier_t>() - 8usize];
  ["Offset of field: pthread_barrier_t::__size"]
    [::std::mem::offset_of!(pthread_barrier_t, __size) - 0usize];
  ["Offset of field: pthread_barrier_t::__align"]
    [::std::mem::offset_of!(pthread_barrier_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
  pub __size: [::std::os::raw::c_char; 4usize],
  pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of pthread_barrierattr_t"][::std::mem::size_of::<pthread_barrierattr_t>() - 4usize];
  ["Alignment of pthread_barrierattr_t"][::std::mem::align_of::<pthread_barrierattr_t>() - 4usize];
  ["Offset of field: pthread_barrierattr_t::__size"]
    [::std::mem::offset_of!(pthread_barrierattr_t, __size) - 0usize];
  ["Offset of field: pthread_barrierattr_t::__align"]
    [::std::mem::offset_of!(pthread_barrierattr_t, __align) - 0usize];
};
unsafe extern "C" {
  pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
  pub fn srandom(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
  pub fn initstate(
    __seed: ::std::os::raw::c_uint,
    __statebuf: *mut ::std::os::raw::c_char,
    __statelen: usize,
  ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
  pub fptr: *mut i32,
  pub rptr: *mut i32,
  pub state: *mut i32,
  pub rand_type: ::std::os::raw::c_int,
  pub rand_deg: ::std::os::raw::c_int,
  pub rand_sep: ::std::os::raw::c_int,
  pub end_ptr: *mut i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of random_data"][::std::mem::size_of::<random_data>() - 48usize];
  ["Alignment of random_data"][::std::mem::align_of::<random_data>() - 8usize];
  ["Offset of field: random_data::fptr"][::std::mem::offset_of!(random_data, fptr) - 0usize];
  ["Offset of field: random_data::rptr"][::std::mem::offset_of!(random_data, rptr) - 8usize];
  ["Offset of field: random_data::state"][::std::mem::offset_of!(random_data, state) - 16usize];
  ["Offset of field: random_data::rand_type"]
    [::std::mem::offset_of!(random_data, rand_type) - 24usize];
  ["Offset of field: random_data::rand_deg"]
    [::std::mem::offset_of!(random_data, rand_deg) - 28usize];
  ["Offset of field: random_data::rand_sep"]
    [::std::mem::offset_of!(random_data, rand_sep) - 32usize];
  ["Offset of field: random_data::end_ptr"][::std::mem::offset_of!(random_data, end_ptr) - 40usize];
};
unsafe extern "C" {
  pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn srandom_r(
    __seed: ::std::os::raw::c_uint,
    __buf: *mut random_data,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn initstate_r(
    __seed: ::std::os::raw::c_uint,
    __statebuf: *mut ::std::os::raw::c_char,
    __statelen: usize,
    __buf: *mut random_data,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn setstate_r(
    __statebuf: *mut ::std::os::raw::c_char,
    __buf: *mut random_data,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn srand(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
  pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn drand48() -> f64;
}
unsafe extern "C" {
  pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
  pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
  pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
  pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
  pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
  pub fn srand48(__seedval: ::std::os::raw::c_long);
}
unsafe extern "C" {
  pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
  pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
  pub __x: [::std::os::raw::c_ushort; 3usize],
  pub __old_x: [::std::os::raw::c_ushort; 3usize],
  pub __c: ::std::os::raw::c_ushort,
  pub __init: ::std::os::raw::c_ushort,
  pub __a: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of drand48_data"][::std::mem::size_of::<drand48_data>() - 24usize];
  ["Alignment of drand48_data"][::std::mem::align_of::<drand48_data>() - 8usize];
  ["Offset of field: drand48_data::__x"][::std::mem::offset_of!(drand48_data, __x) - 0usize];
  ["Offset of field: drand48_data::__old_x"]
    [::std::mem::offset_of!(drand48_data, __old_x) - 6usize];
  ["Offset of field: drand48_data::__c"][::std::mem::offset_of!(drand48_data, __c) - 12usize];
  ["Offset of field: drand48_data::__init"][::std::mem::offset_of!(drand48_data, __init) - 14usize];
  ["Offset of field: drand48_data::__a"][::std::mem::offset_of!(drand48_data, __a) - 16usize];
};
unsafe extern "C" {
  pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn erand48_r(
    __xsubi: *mut ::std::os::raw::c_ushort,
    __buffer: *mut drand48_data,
    __result: *mut f64,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn lrand48_r(
    __buffer: *mut drand48_data,
    __result: *mut ::std::os::raw::c_long,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn nrand48_r(
    __xsubi: *mut ::std::os::raw::c_ushort,
    __buffer: *mut drand48_data,
    __result: *mut ::std::os::raw::c_long,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn mrand48_r(
    __buffer: *mut drand48_data,
    __result: *mut ::std::os::raw::c_long,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn jrand48_r(
    __xsubi: *mut ::std::os::raw::c_ushort,
    __buffer: *mut drand48_data,
    __result: *mut ::std::os::raw::c_long,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn srand48_r(
    __seedval: ::std::os::raw::c_long,
    __buffer: *mut drand48_data,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn seed48_r(
    __seed16v: *mut ::std::os::raw::c_ushort,
    __buffer: *mut drand48_data,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn lcong48_r(
    __param: *mut ::std::os::raw::c_ushort,
    __buffer: *mut drand48_data,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn arc4random() -> __uint32_t;
}
unsafe extern "C" {
  pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
unsafe extern "C" {
  pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
unsafe extern "C" {
  pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn calloc(
    __nmemb: ::std::os::raw::c_ulong,
    __size: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn realloc(
    __ptr: *mut ::std::os::raw::c_void,
    __size: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
  pub fn reallocarray(
    __ptr: *mut ::std::os::raw::c_void,
    __nmemb: usize,
    __size: usize,
  ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn posix_memalign(
    __memptr: *mut *mut ::std::os::raw::c_void,
    __alignment: usize,
    __size: usize,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn aligned_alloc(
    __alignment: ::std::os::raw::c_ulong,
    __size: ::std::os::raw::c_ulong,
  ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn abort() -> !;
}
unsafe extern "C" {
  pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn at_quick_exit(
    __func: ::std::option::Option<unsafe extern "C" fn()>,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn on_exit(
    __func: ::std::option::Option<
      unsafe extern "C" fn(__status: ::std::os::raw::c_int, __arg: *mut ::std::os::raw::c_void),
    >,
    __arg: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
  pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
  pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
  pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn setenv(
    __name: *const ::std::os::raw::c_char,
    __value: *const ::std::os::raw::c_char,
    __replace: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn clearenv() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn mkstemps(
    __template: *mut ::std::os::raw::c_char,
    __suffixlen: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn realpath(
    __name: *const ::std::os::raw::c_char,
    __resolved: *mut ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
  unsafe extern "C" fn(
    arg1: *const ::std::os::raw::c_void,
    arg2: *const ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
  pub fn bsearch(
    __key: *const ::std::os::raw::c_void,
    __base: *const ::std::os::raw::c_void,
    __nmemb: usize,
    __size: usize,
    __compar: __compar_fn_t,
  ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn qsort(
    __base: *mut ::std::os::raw::c_void,
    __nmemb: usize,
    __size: usize,
    __compar: __compar_fn_t,
  );
}
unsafe extern "C" {
  pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
  pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
  pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
  pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
  pub fn lldiv(__numer: ::std::os::raw::c_longlong, __denom: ::std::os::raw::c_longlong)
    -> lldiv_t;
}
unsafe extern "C" {
  pub fn ecvt(
    __value: f64,
    __ndigit: ::std::os::raw::c_int,
    __decpt: *mut ::std::os::raw::c_int,
    __sign: *mut ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn fcvt(
    __value: f64,
    __ndigit: ::std::os::raw::c_int,
    __decpt: *mut ::std::os::raw::c_int,
    __sign: *mut ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn gcvt(
    __value: f64,
    __ndigit: ::std::os::raw::c_int,
    __buf: *mut ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn qecvt(
    __value: u128,
    __ndigit: ::std::os::raw::c_int,
    __decpt: *mut ::std::os::raw::c_int,
    __sign: *mut ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn qfcvt(
    __value: u128,
    __ndigit: ::std::os::raw::c_int,
    __decpt: *mut ::std::os::raw::c_int,
    __sign: *mut ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn qgcvt(
    __value: u128,
    __ndigit: ::std::os::raw::c_int,
    __buf: *mut ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn ecvt_r(
    __value: f64,
    __ndigit: ::std::os::raw::c_int,
    __decpt: *mut ::std::os::raw::c_int,
    __sign: *mut ::std::os::raw::c_int,
    __buf: *mut ::std::os::raw::c_char,
    __len: usize,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn fcvt_r(
    __value: f64,
    __ndigit: ::std::os::raw::c_int,
    __decpt: *mut ::std::os::raw::c_int,
    __sign: *mut ::std::os::raw::c_int,
    __buf: *mut ::std::os::raw::c_char,
    __len: usize,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn qecvt_r(
    __value: u128,
    __ndigit: ::std::os::raw::c_int,
    __decpt: *mut ::std::os::raw::c_int,
    __sign: *mut ::std::os::raw::c_int,
    __buf: *mut ::std::os::raw::c_char,
    __len: usize,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn qfcvt_r(
    __value: u128,
    __ndigit: ::std::os::raw::c_int,
    __decpt: *mut ::std::os::raw::c_int,
    __sign: *mut ::std::os::raw::c_int,
    __buf: *mut ::std::os::raw::c_char,
    __len: usize,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn mbtowc(
    __pwc: *mut wchar_t,
    __s: *const ::std::os::raw::c_char,
    __n: usize,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
  pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
  pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn getsubopt(
    __optionp: *mut *mut ::std::os::raw::c_char,
    __tokens: *const *mut ::std::os::raw::c_char,
    __valuep: *mut *mut ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = " Various defines for the various Link properties.\n\n NOTE: the link detection layer will try to resolve QName expansion\n       of namespaces. If \"foo\" is the prefix for \"http://foo.com/\"\n       then the link detection layer will expand role=\"foo:myrole\"\n       to \"http://foo.com/:myrole\".\n NOTE: the link detection layer will expand URI-References found on\n       href attributes by using the base mechanism if found."]
pub type xlinkHRef = *mut xmlChar;
pub type xlinkRole = *mut xmlChar;
pub type xlinkTitle = *mut xmlChar;
pub const xlinkType_XLINK_TYPE_NONE: xlinkType = 0;
pub const xlinkType_XLINK_TYPE_SIMPLE: xlinkType = 1;
pub const xlinkType_XLINK_TYPE_EXTENDED: xlinkType = 2;
pub const xlinkType_XLINK_TYPE_EXTENDED_SET: xlinkType = 3;
pub type xlinkType = ::std::os::raw::c_uint;
pub const xlinkShow_XLINK_SHOW_NONE: xlinkShow = 0;
pub const xlinkShow_XLINK_SHOW_NEW: xlinkShow = 1;
pub const xlinkShow_XLINK_SHOW_EMBED: xlinkShow = 2;
pub const xlinkShow_XLINK_SHOW_REPLACE: xlinkShow = 3;
pub type xlinkShow = ::std::os::raw::c_uint;
pub const xlinkActuate_XLINK_ACTUATE_NONE: xlinkActuate = 0;
pub const xlinkActuate_XLINK_ACTUATE_AUTO: xlinkActuate = 1;
pub const xlinkActuate_XLINK_ACTUATE_ONREQUEST: xlinkActuate = 2;
pub type xlinkActuate = ::std::os::raw::c_uint;
#[doc = " xlinkNodeDetectFunc:\n @ctx:  user data pointer\n @node:  the node to check\n\n This is the prototype for the link detection routine.\n It calls the default link detection callbacks upon link detection."]
pub type xlinkNodeDetectFunc =
  ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, node: xmlNodePtr)>;
#[doc = " xlinkSimpleLinkFunk:\n @ctx:  user data pointer\n @node:  the node carrying the link\n @href:  the target of the link\n @role:  the role string\n @title:  the link title\n\n This is the prototype for a simple link detection callback."]
pub type xlinkSimpleLinkFunk = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    node: xmlNodePtr,
    href: xlinkHRef,
    role: xlinkRole,
    title: xlinkTitle,
  ),
>;
#[doc = " xlinkExtendedLinkFunk:\n @ctx:  user data pointer\n @node:  the node carrying the link\n @nbLocators: the number of locators detected on the link\n @hrefs:  pointer to the array of locator hrefs\n @roles:  pointer to the array of locator roles\n @nbArcs: the number of arcs detected on the link\n @from:  pointer to the array of source roles found on the arcs\n @to:  pointer to the array of target roles found on the arcs\n @show:  array of values for the show attributes found on the arcs\n @actuate:  array of values for the actuate attributes found on the arcs\n @nbTitles: the number of titles detected on the link\n @title:  array of titles detected on the link\n @langs:  array of xml:lang values for the titles\n\n This is the prototype for a extended link detection callback."]
pub type xlinkExtendedLinkFunk = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    node: xmlNodePtr,
    nbLocators: ::std::os::raw::c_int,
    hrefs: *const xlinkHRef,
    roles: *const xlinkRole,
    nbArcs: ::std::os::raw::c_int,
    from: *const xlinkRole,
    to: *const xlinkRole,
    show: *mut xlinkShow,
    actuate: *mut xlinkActuate,
    nbTitles: ::std::os::raw::c_int,
    titles: *const xlinkTitle,
    langs: *mut *const xmlChar,
  ),
>;
#[doc = " xlinkExtendedLinkSetFunk:\n @ctx:  user data pointer\n @node:  the node carrying the link\n @nbLocators: the number of locators detected on the link\n @hrefs:  pointer to the array of locator hrefs\n @roles:  pointer to the array of locator roles\n @nbTitles: the number of titles detected on the link\n @title:  array of titles detected on the link\n @langs:  array of xml:lang values for the titles\n\n This is the prototype for a extended link set detection callback."]
pub type xlinkExtendedLinkSetFunk = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    node: xmlNodePtr,
    nbLocators: ::std::os::raw::c_int,
    hrefs: *const xlinkHRef,
    roles: *const xlinkRole,
    nbTitles: ::std::os::raw::c_int,
    titles: *const xlinkTitle,
    langs: *mut *const xmlChar,
  ),
>;
#[doc = " This is the structure containing a set of Links detection callbacks.\n\n There is no default xlink callbacks, if one want to get link\n recognition activated, those call backs must be provided before parsing."]
pub type xlinkHandler = _xlinkHandler;
pub type xlinkHandlerPtr = *mut xlinkHandler;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _xlinkHandler {
  pub simple: xlinkSimpleLinkFunk,
  pub extended: xlinkExtendedLinkFunk,
  pub set: xlinkExtendedLinkSetFunk,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xlinkHandler"][::std::mem::size_of::<_xlinkHandler>() - 24usize];
  ["Alignment of _xlinkHandler"][::std::mem::align_of::<_xlinkHandler>() - 8usize];
  ["Offset of field: _xlinkHandler::simple"]
    [::std::mem::offset_of!(_xlinkHandler, simple) - 0usize];
  ["Offset of field: _xlinkHandler::extended"]
    [::std::mem::offset_of!(_xlinkHandler, extended) - 8usize];
  ["Offset of field: _xlinkHandler::set"][::std::mem::offset_of!(_xlinkHandler, set) - 16usize];
};
unsafe extern "C" {
  pub fn xlinkGetDefaultDetect() -> xlinkNodeDetectFunc;
}
unsafe extern "C" {
  pub fn xlinkSetDefaultDetect(func: xlinkNodeDetectFunc);
}
unsafe extern "C" {
  pub fn xlinkGetDefaultHandler() -> xlinkHandlerPtr;
}
unsafe extern "C" {
  pub fn xlinkSetDefaultHandler(handler: xlinkHandlerPtr);
}
unsafe extern "C" {
  pub fn xlinkIsLink(doc: xmlDocPtr, node: xmlNodePtr) -> xlinkType;
}
unsafe extern "C" {
  pub fn xmlSAX2GetPublicId(ctx: *mut ::std::os::raw::c_void) -> *const xmlChar;
}
unsafe extern "C" {
  pub fn xmlSAX2GetSystemId(ctx: *mut ::std::os::raw::c_void) -> *const xmlChar;
}
unsafe extern "C" {
  pub fn xmlSAX2SetDocumentLocator(ctx: *mut ::std::os::raw::c_void, loc: xmlSAXLocatorPtr);
}
unsafe extern "C" {
  pub fn xmlSAX2GetLineNumber(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSAX2GetColumnNumber(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSAX2IsStandalone(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSAX2HasInternalSubset(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSAX2HasExternalSubset(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSAX2InternalSubset(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    ExternalID: *const xmlChar,
    SystemID: *const xmlChar,
  );
}
unsafe extern "C" {
  pub fn xmlSAX2ExternalSubset(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    ExternalID: *const xmlChar,
    SystemID: *const xmlChar,
  );
}
unsafe extern "C" {
  pub fn xmlSAX2GetEntity(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar) -> xmlEntityPtr;
}
unsafe extern "C" {
  pub fn xmlSAX2GetParameterEntity(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
  ) -> xmlEntityPtr;
}
unsafe extern "C" {
  pub fn xmlSAX2ResolveEntity(
    ctx: *mut ::std::os::raw::c_void,
    publicId: *const xmlChar,
    systemId: *const xmlChar,
  ) -> xmlParserInputPtr;
}
unsafe extern "C" {
  pub fn xmlSAX2EntityDecl(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    type_: ::std::os::raw::c_int,
    publicId: *const xmlChar,
    systemId: *const xmlChar,
    content: *mut xmlChar,
  );
}
unsafe extern "C" {
  pub fn xmlSAX2AttributeDecl(
    ctx: *mut ::std::os::raw::c_void,
    elem: *const xmlChar,
    fullname: *const xmlChar,
    type_: ::std::os::raw::c_int,
    def: ::std::os::raw::c_int,
    defaultValue: *const xmlChar,
    tree: xmlEnumerationPtr,
  );
}
unsafe extern "C" {
  pub fn xmlSAX2ElementDecl(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    type_: ::std::os::raw::c_int,
    content: xmlElementContentPtr,
  );
}
unsafe extern "C" {
  pub fn xmlSAX2NotationDecl(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    publicId: *const xmlChar,
    systemId: *const xmlChar,
  );
}
unsafe extern "C" {
  pub fn xmlSAX2UnparsedEntityDecl(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    publicId: *const xmlChar,
    systemId: *const xmlChar,
    notationName: *const xmlChar,
  );
}
unsafe extern "C" {
  pub fn xmlSAX2StartDocument(ctx: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
  pub fn xmlSAX2EndDocument(ctx: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
  pub fn xmlSAX2StartElement(
    ctx: *mut ::std::os::raw::c_void,
    fullname: *const xmlChar,
    atts: *mut *const xmlChar,
  );
}
unsafe extern "C" {
  pub fn xmlSAX2EndElement(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar);
}
unsafe extern "C" {
  pub fn xmlSAX2StartElementNs(
    ctx: *mut ::std::os::raw::c_void,
    localname: *const xmlChar,
    prefix: *const xmlChar,
    URI: *const xmlChar,
    nb_namespaces: ::std::os::raw::c_int,
    namespaces: *mut *const xmlChar,
    nb_attributes: ::std::os::raw::c_int,
    nb_defaulted: ::std::os::raw::c_int,
    attributes: *mut *const xmlChar,
  );
}
unsafe extern "C" {
  pub fn xmlSAX2EndElementNs(
    ctx: *mut ::std::os::raw::c_void,
    localname: *const xmlChar,
    prefix: *const xmlChar,
    URI: *const xmlChar,
  );
}
unsafe extern "C" {
  pub fn xmlSAX2Reference(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar);
}
unsafe extern "C" {
  pub fn xmlSAX2Characters(
    ctx: *mut ::std::os::raw::c_void,
    ch: *const xmlChar,
    len: ::std::os::raw::c_int,
  );
}
unsafe extern "C" {
  pub fn xmlSAX2IgnorableWhitespace(
    ctx: *mut ::std::os::raw::c_void,
    ch: *const xmlChar,
    len: ::std::os::raw::c_int,
  );
}
unsafe extern "C" {
  pub fn xmlSAX2ProcessingInstruction(
    ctx: *mut ::std::os::raw::c_void,
    target: *const xmlChar,
    data: *const xmlChar,
  );
}
unsafe extern "C" {
  pub fn xmlSAX2Comment(ctx: *mut ::std::os::raw::c_void, value: *const xmlChar);
}
unsafe extern "C" {
  pub fn xmlSAX2CDataBlock(
    ctx: *mut ::std::os::raw::c_void,
    value: *const xmlChar,
    len: ::std::os::raw::c_int,
  );
}
unsafe extern "C" {
  pub fn xmlSAXDefaultVersion(version: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSAXVersion(
    hdlr: *mut xmlSAXHandler,
    version: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSAX2InitDefaultSAXHandler(hdlr: *mut xmlSAXHandler, warning: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlSAX2InitHtmlDefaultSAXHandler(hdlr: *mut xmlSAXHandler);
}
unsafe extern "C" {
  pub fn htmlDefaultSAXHandlerInit();
}
unsafe extern "C" {
  pub fn xmlSAX2InitDocbDefaultSAXHandler(hdlr: *mut xmlSAXHandler);
}
unsafe extern "C" {
  pub fn docbDefaultSAXHandlerInit();
}
unsafe extern "C" {
  pub fn xmlDefaultSAXHandlerInit();
}
#[doc = " xmlFreeFunc:\n @mem: an already allocated block of memory\n\n Signature for a free() implementation."]
pub type xmlFreeFunc =
  ::std::option::Option<unsafe extern "C" fn(mem: *mut ::std::os::raw::c_void)>;
#[doc = " xmlMallocFunc:\n @size:  the size requested in bytes\n\n Signature for a malloc() implementation.\n\n Returns a pointer to the newly allocated block or NULL in case of error."]
pub type xmlMallocFunc =
  ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void>;
#[doc = " xmlReallocFunc:\n @mem: an already allocated block of memory\n @size:  the new size requested in bytes\n\n Signature for a realloc() implementation.\n\n Returns a pointer to the newly reallocated block or NULL in case of error."]
pub type xmlReallocFunc = ::std::option::Option<
  unsafe extern "C" fn(
    mem: *mut ::std::os::raw::c_void,
    size: usize,
  ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " xmlStrdupFunc:\n @str: a zero terminated string\n\n Signature for an strdup() implementation.\n\n Returns the copy of the string or NULL in case of error."]
pub type xmlStrdupFunc = ::std::option::Option<
  unsafe extern "C" fn(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
>;
unsafe extern "C" {
  pub fn xmlMemSetup(
    freeFunc: xmlFreeFunc,
    mallocFunc: xmlMallocFunc,
    reallocFunc: xmlReallocFunc,
    strdupFunc: xmlStrdupFunc,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlMemGet(
    freeFunc: *mut xmlFreeFunc,
    mallocFunc: *mut xmlMallocFunc,
    reallocFunc: *mut xmlReallocFunc,
    strdupFunc: *mut xmlStrdupFunc,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlGcMemSetup(
    freeFunc: xmlFreeFunc,
    mallocFunc: xmlMallocFunc,
    mallocAtomicFunc: xmlMallocFunc,
    reallocFunc: xmlReallocFunc,
    strdupFunc: xmlStrdupFunc,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlGcMemGet(
    freeFunc: *mut xmlFreeFunc,
    mallocFunc: *mut xmlMallocFunc,
    mallocAtomicFunc: *mut xmlMallocFunc,
    reallocFunc: *mut xmlReallocFunc,
    strdupFunc: *mut xmlStrdupFunc,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlInitMemory() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlCleanupMemory();
}
unsafe extern "C" {
  pub fn xmlMemUsed() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlMemBlocks() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlMemDisplay(fp: *mut FILE);
}
unsafe extern "C" {
  pub fn xmlMemDisplayLast(fp: *mut FILE, nbBytes: ::std::os::raw::c_long);
}
unsafe extern "C" {
  pub fn xmlMemShow(fp: *mut FILE, nr: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlMemoryDump();
}
unsafe extern "C" {
  pub fn xmlMemMalloc(size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn xmlMemRealloc(
    ptr: *mut ::std::os::raw::c_void,
    size: usize,
  ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn xmlMemFree(ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
  pub fn xmlMemoryStrdup(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn xmlMallocLoc(
    size: usize,
    file: *const ::std::os::raw::c_char,
    line: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn xmlReallocLoc(
    ptr: *mut ::std::os::raw::c_void,
    size: usize,
    file: *const ::std::os::raw::c_char,
    line: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn xmlMallocAtomicLoc(
    size: usize,
    file: *const ::std::os::raw::c_char,
    line: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn xmlMemStrdupLoc(
    str_: *const ::std::os::raw::c_char,
    file: *const ::std::os::raw::c_char,
    line: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn xmlInitGlobals();
}
unsafe extern "C" {
  pub fn xmlCleanupGlobals();
}
#[doc = " xmlParserInputBufferCreateFilenameFunc:\n @URI: the URI to read from\n @enc: the requested source encoding\n\n Signature for the function doing the lookup for a suitable input method\n corresponding to an URI.\n\n Returns the new xmlParserInputBufferPtr in case of success or NULL if no\n         method was found."]
pub type xmlParserInputBufferCreateFilenameFunc = ::std::option::Option<
  unsafe extern "C" fn(
    URI: *const ::std::os::raw::c_char,
    enc: xmlCharEncoding,
  ) -> xmlParserInputBufferPtr,
>;
#[doc = " xmlOutputBufferCreateFilenameFunc:\n @URI: the URI to write to\n @enc: the requested target encoding\n\n Signature for the function doing the lookup for a suitable output method\n corresponding to an URI.\n\n Returns the new xmlOutputBufferPtr in case of success or NULL if no\n         method was found."]
pub type xmlOutputBufferCreateFilenameFunc = ::std::option::Option<
  unsafe extern "C" fn(
    URI: *const ::std::os::raw::c_char,
    encoder: xmlCharEncodingHandlerPtr,
    compression: ::std::os::raw::c_int,
  ) -> xmlOutputBufferPtr,
>;
unsafe extern "C" {
  pub fn xmlParserInputBufferCreateFilenameDefault(
    func: xmlParserInputBufferCreateFilenameFunc,
  ) -> xmlParserInputBufferCreateFilenameFunc;
}
unsafe extern "C" {
  pub fn xmlOutputBufferCreateFilenameDefault(
    func: xmlOutputBufferCreateFilenameFunc,
  ) -> xmlOutputBufferCreateFilenameFunc;
}
#[doc = " xmlRegisterNodeFunc:\n @node: the current node\n\n Signature for the registration callback of a created node"]
pub type xmlRegisterNodeFunc = ::std::option::Option<unsafe extern "C" fn(node: xmlNodePtr)>;
#[doc = " xmlDeregisterNodeFunc:\n @node: the current node\n\n Signature for the deregistration callback of a discarded node"]
pub type xmlDeregisterNodeFunc = ::std::option::Option<unsafe extern "C" fn(node: xmlNodePtr)>;
pub type xmlGlobalState = _xmlGlobalState;
pub type xmlGlobalStatePtr = *mut xmlGlobalState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlGlobalState {
  pub xmlParserVersion: *const ::std::os::raw::c_char,
  pub xmlDefaultSAXLocator: xmlSAXLocator,
  pub xmlDefaultSAXHandler: xmlSAXHandlerV1,
  pub docbDefaultSAXHandler: xmlSAXHandlerV1,
  pub htmlDefaultSAXHandler: xmlSAXHandlerV1,
  pub xmlFree: xmlFreeFunc,
  pub xmlMalloc: xmlMallocFunc,
  pub xmlMemStrdup: xmlStrdupFunc,
  pub xmlRealloc: xmlReallocFunc,
  pub xmlGenericError: xmlGenericErrorFunc,
  pub xmlStructuredError: xmlStructuredErrorFunc,
  pub xmlGenericErrorContext: *mut ::std::os::raw::c_void,
  pub oldXMLWDcompatibility: ::std::os::raw::c_int,
  pub xmlBufferAllocScheme: xmlBufferAllocationScheme,
  pub xmlDefaultBufferSize: ::std::os::raw::c_int,
  pub xmlSubstituteEntitiesDefaultValue: ::std::os::raw::c_int,
  pub xmlDoValidityCheckingDefaultValue: ::std::os::raw::c_int,
  pub xmlGetWarningsDefaultValue: ::std::os::raw::c_int,
  pub xmlKeepBlanksDefaultValue: ::std::os::raw::c_int,
  pub xmlLineNumbersDefaultValue: ::std::os::raw::c_int,
  pub xmlLoadExtDtdDefaultValue: ::std::os::raw::c_int,
  pub xmlParserDebugEntities: ::std::os::raw::c_int,
  pub xmlPedanticParserDefaultValue: ::std::os::raw::c_int,
  pub xmlSaveNoEmptyTags: ::std::os::raw::c_int,
  pub xmlIndentTreeOutput: ::std::os::raw::c_int,
  pub xmlTreeIndentString: *const ::std::os::raw::c_char,
  pub xmlRegisterNodeDefaultValue: xmlRegisterNodeFunc,
  pub xmlDeregisterNodeDefaultValue: xmlDeregisterNodeFunc,
  pub xmlMallocAtomic: xmlMallocFunc,
  pub xmlLastError: xmlError,
  pub xmlParserInputBufferCreateFilenameValue: xmlParserInputBufferCreateFilenameFunc,
  pub xmlOutputBufferCreateFilenameValue: xmlOutputBufferCreateFilenameFunc,
  pub xmlStructuredErrorContext: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlGlobalState"][::std::mem::size_of::<_xmlGlobalState>() - 968usize];
  ["Alignment of _xmlGlobalState"][::std::mem::align_of::<_xmlGlobalState>() - 8usize];
  ["Offset of field: _xmlGlobalState::xmlParserVersion"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlParserVersion) - 0usize];
  ["Offset of field: _xmlGlobalState::xmlDefaultSAXLocator"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlDefaultSAXLocator) - 8usize];
  ["Offset of field: _xmlGlobalState::xmlDefaultSAXHandler"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlDefaultSAXHandler) - 40usize];
  ["Offset of field: _xmlGlobalState::docbDefaultSAXHandler"]
    [::std::mem::offset_of!(_xmlGlobalState, docbDefaultSAXHandler) - 264usize];
  ["Offset of field: _xmlGlobalState::htmlDefaultSAXHandler"]
    [::std::mem::offset_of!(_xmlGlobalState, htmlDefaultSAXHandler) - 488usize];
  ["Offset of field: _xmlGlobalState::xmlFree"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlFree) - 712usize];
  ["Offset of field: _xmlGlobalState::xmlMalloc"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlMalloc) - 720usize];
  ["Offset of field: _xmlGlobalState::xmlMemStrdup"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlMemStrdup) - 728usize];
  ["Offset of field: _xmlGlobalState::xmlRealloc"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlRealloc) - 736usize];
  ["Offset of field: _xmlGlobalState::xmlGenericError"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlGenericError) - 744usize];
  ["Offset of field: _xmlGlobalState::xmlStructuredError"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlStructuredError) - 752usize];
  ["Offset of field: _xmlGlobalState::xmlGenericErrorContext"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlGenericErrorContext) - 760usize];
  ["Offset of field: _xmlGlobalState::oldXMLWDcompatibility"]
    [::std::mem::offset_of!(_xmlGlobalState, oldXMLWDcompatibility) - 768usize];
  ["Offset of field: _xmlGlobalState::xmlBufferAllocScheme"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlBufferAllocScheme) - 772usize];
  ["Offset of field: _xmlGlobalState::xmlDefaultBufferSize"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlDefaultBufferSize) - 776usize];
  ["Offset of field: _xmlGlobalState::xmlSubstituteEntitiesDefaultValue"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlSubstituteEntitiesDefaultValue) - 780usize];
  ["Offset of field: _xmlGlobalState::xmlDoValidityCheckingDefaultValue"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlDoValidityCheckingDefaultValue) - 784usize];
  ["Offset of field: _xmlGlobalState::xmlGetWarningsDefaultValue"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlGetWarningsDefaultValue) - 788usize];
  ["Offset of field: _xmlGlobalState::xmlKeepBlanksDefaultValue"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlKeepBlanksDefaultValue) - 792usize];
  ["Offset of field: _xmlGlobalState::xmlLineNumbersDefaultValue"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlLineNumbersDefaultValue) - 796usize];
  ["Offset of field: _xmlGlobalState::xmlLoadExtDtdDefaultValue"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlLoadExtDtdDefaultValue) - 800usize];
  ["Offset of field: _xmlGlobalState::xmlParserDebugEntities"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlParserDebugEntities) - 804usize];
  ["Offset of field: _xmlGlobalState::xmlPedanticParserDefaultValue"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlPedanticParserDefaultValue) - 808usize];
  ["Offset of field: _xmlGlobalState::xmlSaveNoEmptyTags"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlSaveNoEmptyTags) - 812usize];
  ["Offset of field: _xmlGlobalState::xmlIndentTreeOutput"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlIndentTreeOutput) - 816usize];
  ["Offset of field: _xmlGlobalState::xmlTreeIndentString"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlTreeIndentString) - 824usize];
  ["Offset of field: _xmlGlobalState::xmlRegisterNodeDefaultValue"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlRegisterNodeDefaultValue) - 832usize];
  ["Offset of field: _xmlGlobalState::xmlDeregisterNodeDefaultValue"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlDeregisterNodeDefaultValue) - 840usize];
  ["Offset of field: _xmlGlobalState::xmlMallocAtomic"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlMallocAtomic) - 848usize];
  ["Offset of field: _xmlGlobalState::xmlLastError"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlLastError) - 856usize];
  ["Offset of field: _xmlGlobalState::xmlParserInputBufferCreateFilenameValue"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlParserInputBufferCreateFilenameValue) - 944usize];
  ["Offset of field: _xmlGlobalState::xmlOutputBufferCreateFilenameValue"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlOutputBufferCreateFilenameValue) - 952usize];
  ["Offset of field: _xmlGlobalState::xmlStructuredErrorContext"]
    [::std::mem::offset_of!(_xmlGlobalState, xmlStructuredErrorContext) - 960usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlMutex {
  _unused: [u8; 0],
}
pub type xmlMutex = _xmlMutex;
pub type xmlMutexPtr = *mut xmlMutex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlRMutex {
  _unused: [u8; 0],
}
pub type xmlRMutex = _xmlRMutex;
pub type xmlRMutexPtr = *mut xmlRMutex;
unsafe extern "C" {
  pub fn xmlNewMutex() -> xmlMutexPtr;
}
unsafe extern "C" {
  pub fn xmlMutexLock(tok: xmlMutexPtr);
}
unsafe extern "C" {
  pub fn xmlMutexUnlock(tok: xmlMutexPtr);
}
unsafe extern "C" {
  pub fn xmlFreeMutex(tok: xmlMutexPtr);
}
unsafe extern "C" {
  pub fn xmlNewRMutex() -> xmlRMutexPtr;
}
unsafe extern "C" {
  pub fn xmlRMutexLock(tok: xmlRMutexPtr);
}
unsafe extern "C" {
  pub fn xmlRMutexUnlock(tok: xmlRMutexPtr);
}
unsafe extern "C" {
  pub fn xmlFreeRMutex(tok: xmlRMutexPtr);
}
unsafe extern "C" {
  pub fn xmlInitThreads();
}
unsafe extern "C" {
  pub fn xmlLockLibrary();
}
unsafe extern "C" {
  pub fn xmlUnlockLibrary();
}
unsafe extern "C" {
  pub fn xmlGetThreadId() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlIsMainThread() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlCleanupThreads();
}
unsafe extern "C" {
  pub fn xmlGetGlobalState() -> xmlGlobalStatePtr;
}
unsafe extern "C" {
  pub fn xmlInitializeGlobalState(gs: xmlGlobalStatePtr);
}
unsafe extern "C" {
  pub fn xmlThrDefSetGenericErrorFunc(
    ctx: *mut ::std::os::raw::c_void,
    handler: xmlGenericErrorFunc,
  );
}
unsafe extern "C" {
  pub fn xmlThrDefSetStructuredErrorFunc(
    ctx: *mut ::std::os::raw::c_void,
    handler: xmlStructuredErrorFunc,
  );
}
unsafe extern "C" {
  pub fn xmlRegisterNodeDefault(func: xmlRegisterNodeFunc) -> xmlRegisterNodeFunc;
}
unsafe extern "C" {
  pub fn xmlThrDefRegisterNodeDefault(func: xmlRegisterNodeFunc) -> xmlRegisterNodeFunc;
}
unsafe extern "C" {
  pub fn xmlDeregisterNodeDefault(func: xmlDeregisterNodeFunc) -> xmlDeregisterNodeFunc;
}
unsafe extern "C" {
  pub fn xmlThrDefDeregisterNodeDefault(func: xmlDeregisterNodeFunc) -> xmlDeregisterNodeFunc;
}
unsafe extern "C" {
  pub fn xmlThrDefOutputBufferCreateFilenameDefault(
    func: xmlOutputBufferCreateFilenameFunc,
  ) -> xmlOutputBufferCreateFilenameFunc;
}
unsafe extern "C" {
  pub fn xmlThrDefParserInputBufferCreateFilenameDefault(
    func: xmlParserInputBufferCreateFilenameFunc,
  ) -> xmlParserInputBufferCreateFilenameFunc;
}
unsafe extern "C" {
  pub static mut xmlMalloc: xmlMallocFunc;
}
unsafe extern "C" {
  pub static mut xmlMallocAtomic: xmlMallocFunc;
}
unsafe extern "C" {
  pub static mut xmlRealloc: xmlReallocFunc;
}
unsafe extern "C" {
  pub static mut xmlFree: xmlFreeFunc;
}
unsafe extern "C" {
  pub static mut xmlMemStrdup: xmlStrdupFunc;
}
unsafe extern "C" {
  pub fn __docbDefaultSAXHandler() -> *mut xmlSAXHandlerV1;
}
unsafe extern "C" {
  pub fn __htmlDefaultSAXHandler() -> *mut xmlSAXHandlerV1;
}
unsafe extern "C" {
  pub fn __xmlLastError() -> *mut xmlError;
}
unsafe extern "C" {
  pub fn __oldXMLWDcompatibility() -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn __xmlBufferAllocScheme() -> *mut xmlBufferAllocationScheme;
}
unsafe extern "C" {
  pub fn xmlThrDefBufferAllocScheme(v: xmlBufferAllocationScheme) -> xmlBufferAllocationScheme;
}
unsafe extern "C" {
  pub fn __xmlDefaultBufferSize() -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlThrDefDefaultBufferSize(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn __xmlDefaultSAXHandler() -> *mut xmlSAXHandlerV1;
}
unsafe extern "C" {
  pub fn __xmlDefaultSAXLocator() -> *mut xmlSAXLocator;
}
unsafe extern "C" {
  pub fn __xmlDoValidityCheckingDefaultValue() -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlThrDefDoValidityCheckingDefaultValue(v: ::std::os::raw::c_int)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn __xmlGenericError() -> *mut xmlGenericErrorFunc;
}
unsafe extern "C" {
  pub fn __xmlStructuredError() -> *mut xmlStructuredErrorFunc;
}
unsafe extern "C" {
  pub fn __xmlGenericErrorContext() -> *mut *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn __xmlStructuredErrorContext() -> *mut *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn __xmlGetWarningsDefaultValue() -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlThrDefGetWarningsDefaultValue(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn __xmlIndentTreeOutput() -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlThrDefIndentTreeOutput(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn __xmlTreeIndentString() -> *mut *const ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn xmlThrDefTreeIndentString(
    v: *const ::std::os::raw::c_char,
  ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn __xmlKeepBlanksDefaultValue() -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlThrDefKeepBlanksDefaultValue(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn __xmlLineNumbersDefaultValue() -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlThrDefLineNumbersDefaultValue(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn __xmlLoadExtDtdDefaultValue() -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlThrDefLoadExtDtdDefaultValue(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn __xmlParserDebugEntities() -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlThrDefParserDebugEntities(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn __xmlParserVersion() -> *mut *const ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn __xmlPedanticParserDefaultValue() -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlThrDefPedanticParserDefaultValue(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn __xmlSaveNoEmptyTags() -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlThrDefSaveNoEmptyTags(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn __xmlSubstituteEntitiesDefaultValue() -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlThrDefSubstituteEntitiesDefaultValue(v: ::std::os::raw::c_int)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn __xmlRegisterNodeDefaultValue() -> *mut xmlRegisterNodeFunc;
}
unsafe extern "C" {
  pub fn __xmlDeregisterNodeDefaultValue() -> *mut xmlDeregisterNodeFunc;
}
unsafe extern "C" {
  pub fn __xmlParserInputBufferCreateFilenameValue() -> *mut xmlParserInputBufferCreateFilenameFunc;
}
unsafe extern "C" {
  pub fn __xmlOutputBufferCreateFilenameValue() -> *mut xmlOutputBufferCreateFilenameFunc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlParserInputBuffer {
  pub context: *mut ::std::os::raw::c_void,
  pub readcallback: xmlInputReadCallback,
  pub closecallback: xmlInputCloseCallback,
  pub encoder: xmlCharEncodingHandlerPtr,
  pub buffer: xmlBufPtr,
  pub raw: xmlBufPtr,
  pub compressed: ::std::os::raw::c_int,
  pub error: ::std::os::raw::c_int,
  pub rawconsumed: ::std::os::raw::c_ulong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlParserInputBuffer"][::std::mem::size_of::<_xmlParserInputBuffer>() - 64usize];
  ["Alignment of _xmlParserInputBuffer"][::std::mem::align_of::<_xmlParserInputBuffer>() - 8usize];
  ["Offset of field: _xmlParserInputBuffer::context"]
    [::std::mem::offset_of!(_xmlParserInputBuffer, context) - 0usize];
  ["Offset of field: _xmlParserInputBuffer::readcallback"]
    [::std::mem::offset_of!(_xmlParserInputBuffer, readcallback) - 8usize];
  ["Offset of field: _xmlParserInputBuffer::closecallback"]
    [::std::mem::offset_of!(_xmlParserInputBuffer, closecallback) - 16usize];
  ["Offset of field: _xmlParserInputBuffer::encoder"]
    [::std::mem::offset_of!(_xmlParserInputBuffer, encoder) - 24usize];
  ["Offset of field: _xmlParserInputBuffer::buffer"]
    [::std::mem::offset_of!(_xmlParserInputBuffer, buffer) - 32usize];
  ["Offset of field: _xmlParserInputBuffer::raw"]
    [::std::mem::offset_of!(_xmlParserInputBuffer, raw) - 40usize];
  ["Offset of field: _xmlParserInputBuffer::compressed"]
    [::std::mem::offset_of!(_xmlParserInputBuffer, compressed) - 48usize];
  ["Offset of field: _xmlParserInputBuffer::error"]
    [::std::mem::offset_of!(_xmlParserInputBuffer, error) - 52usize];
  ["Offset of field: _xmlParserInputBuffer::rawconsumed"]
    [::std::mem::offset_of!(_xmlParserInputBuffer, rawconsumed) - 56usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlOutputBuffer {
  pub context: *mut ::std::os::raw::c_void,
  pub writecallback: xmlOutputWriteCallback,
  pub closecallback: xmlOutputCloseCallback,
  pub encoder: xmlCharEncodingHandlerPtr,
  pub buffer: xmlBufPtr,
  pub conv: xmlBufPtr,
  pub written: ::std::os::raw::c_int,
  pub error: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlOutputBuffer"][::std::mem::size_of::<_xmlOutputBuffer>() - 56usize];
  ["Alignment of _xmlOutputBuffer"][::std::mem::align_of::<_xmlOutputBuffer>() - 8usize];
  ["Offset of field: _xmlOutputBuffer::context"]
    [::std::mem::offset_of!(_xmlOutputBuffer, context) - 0usize];
  ["Offset of field: _xmlOutputBuffer::writecallback"]
    [::std::mem::offset_of!(_xmlOutputBuffer, writecallback) - 8usize];
  ["Offset of field: _xmlOutputBuffer::closecallback"]
    [::std::mem::offset_of!(_xmlOutputBuffer, closecallback) - 16usize];
  ["Offset of field: _xmlOutputBuffer::encoder"]
    [::std::mem::offset_of!(_xmlOutputBuffer, encoder) - 24usize];
  ["Offset of field: _xmlOutputBuffer::buffer"]
    [::std::mem::offset_of!(_xmlOutputBuffer, buffer) - 32usize];
  ["Offset of field: _xmlOutputBuffer::conv"]
    [::std::mem::offset_of!(_xmlOutputBuffer, conv) - 40usize];
  ["Offset of field: _xmlOutputBuffer::written"]
    [::std::mem::offset_of!(_xmlOutputBuffer, written) - 48usize];
  ["Offset of field: _xmlOutputBuffer::error"]
    [::std::mem::offset_of!(_xmlOutputBuffer, error) - 52usize];
};
unsafe extern "C" {
  pub fn xmlCleanupInputCallbacks();
}
unsafe extern "C" {
  pub fn xmlPopInputCallbacks() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlRegisterDefaultInputCallbacks();
}
unsafe extern "C" {
  pub fn xmlAllocParserInputBuffer(enc: xmlCharEncoding) -> xmlParserInputBufferPtr;
}
unsafe extern "C" {
  pub fn xmlParserInputBufferCreateFilename(
    URI: *const ::std::os::raw::c_char,
    enc: xmlCharEncoding,
  ) -> xmlParserInputBufferPtr;
}
unsafe extern "C" {
  pub fn xmlParserInputBufferCreateFile(
    file: *mut FILE,
    enc: xmlCharEncoding,
  ) -> xmlParserInputBufferPtr;
}
unsafe extern "C" {
  pub fn xmlParserInputBufferCreateFd(
    fd: ::std::os::raw::c_int,
    enc: xmlCharEncoding,
  ) -> xmlParserInputBufferPtr;
}
unsafe extern "C" {
  pub fn xmlParserInputBufferCreateMem(
    mem: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    enc: xmlCharEncoding,
  ) -> xmlParserInputBufferPtr;
}
unsafe extern "C" {
  pub fn xmlParserInputBufferCreateStatic(
    mem: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    enc: xmlCharEncoding,
  ) -> xmlParserInputBufferPtr;
}
unsafe extern "C" {
  pub fn xmlParserInputBufferCreateIO(
    ioread: xmlInputReadCallback,
    ioclose: xmlInputCloseCallback,
    ioctx: *mut ::std::os::raw::c_void,
    enc: xmlCharEncoding,
  ) -> xmlParserInputBufferPtr;
}
unsafe extern "C" {
  pub fn xmlParserInputBufferRead(
    in_: xmlParserInputBufferPtr,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlParserInputBufferGrow(
    in_: xmlParserInputBufferPtr,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlParserInputBufferPush(
    in_: xmlParserInputBufferPtr,
    len: ::std::os::raw::c_int,
    buf: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlFreeParserInputBuffer(in_: xmlParserInputBufferPtr);
}
unsafe extern "C" {
  pub fn xmlParserGetDirectory(
    filename: *const ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
  pub fn xmlRegisterInputCallbacks(
    matchFunc: xmlInputMatchCallback,
    openFunc: xmlInputOpenCallback,
    readFunc: xmlInputReadCallback,
    closeFunc: xmlInputCloseCallback,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn __xmlParserInputBufferCreateFilename(
    URI: *const ::std::os::raw::c_char,
    enc: xmlCharEncoding,
  ) -> xmlParserInputBufferPtr;
}
unsafe extern "C" {
  pub fn xmlCleanupOutputCallbacks();
}
unsafe extern "C" {
  pub fn xmlPopOutputCallbacks() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlRegisterDefaultOutputCallbacks();
}
unsafe extern "C" {
  pub fn xmlAllocOutputBuffer(encoder: xmlCharEncodingHandlerPtr) -> xmlOutputBufferPtr;
}
unsafe extern "C" {
  pub fn xmlOutputBufferCreateFilename(
    URI: *const ::std::os::raw::c_char,
    encoder: xmlCharEncodingHandlerPtr,
    compression: ::std::os::raw::c_int,
  ) -> xmlOutputBufferPtr;
}
unsafe extern "C" {
  pub fn xmlOutputBufferCreateFile(
    file: *mut FILE,
    encoder: xmlCharEncodingHandlerPtr,
  ) -> xmlOutputBufferPtr;
}
unsafe extern "C" {
  pub fn xmlOutputBufferCreateBuffer(
    buffer: xmlBufferPtr,
    encoder: xmlCharEncodingHandlerPtr,
  ) -> xmlOutputBufferPtr;
}
unsafe extern "C" {
  pub fn xmlOutputBufferCreateFd(
    fd: ::std::os::raw::c_int,
    encoder: xmlCharEncodingHandlerPtr,
  ) -> xmlOutputBufferPtr;
}
unsafe extern "C" {
  pub fn xmlOutputBufferCreateIO(
    iowrite: xmlOutputWriteCallback,
    ioclose: xmlOutputCloseCallback,
    ioctx: *mut ::std::os::raw::c_void,
    encoder: xmlCharEncodingHandlerPtr,
  ) -> xmlOutputBufferPtr;
}
unsafe extern "C" {
  pub fn xmlOutputBufferGetContent(out: xmlOutputBufferPtr) -> *const xmlChar;
}
unsafe extern "C" {
  pub fn xmlOutputBufferGetSize(out: xmlOutputBufferPtr) -> usize;
}
unsafe extern "C" {
  pub fn xmlOutputBufferWrite(
    out: xmlOutputBufferPtr,
    len: ::std::os::raw::c_int,
    buf: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlOutputBufferWriteString(
    out: xmlOutputBufferPtr,
    str_: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlOutputBufferWriteEscape(
    out: xmlOutputBufferPtr,
    str_: *const xmlChar,
    escaping: xmlCharEncodingOutputFunc,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlOutputBufferFlush(out: xmlOutputBufferPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlOutputBufferClose(out: xmlOutputBufferPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlRegisterOutputCallbacks(
    matchFunc: xmlOutputMatchCallback,
    openFunc: xmlOutputOpenCallback,
    writeFunc: xmlOutputWriteCallback,
    closeFunc: xmlOutputCloseCallback,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn __xmlOutputBufferCreateFilename(
    URI: *const ::std::os::raw::c_char,
    encoder: xmlCharEncodingHandlerPtr,
    compression: ::std::os::raw::c_int,
  ) -> xmlOutputBufferPtr;
}
unsafe extern "C" {
  pub fn xmlRegisterHTTPPostCallbacks();
}
unsafe extern "C" {
  pub fn xmlCheckHTTPInput(ctxt: xmlParserCtxtPtr, ret: xmlParserInputPtr) -> xmlParserInputPtr;
}
unsafe extern "C" {
  pub fn xmlNoNetExternalEntityLoader(
    URL: *const ::std::os::raw::c_char,
    ID: *const ::std::os::raw::c_char,
    ctxt: xmlParserCtxtPtr,
  ) -> xmlParserInputPtr;
}
unsafe extern "C" {
  pub fn xmlNormalizeWindowsPath(path: *const xmlChar) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlCheckFilename(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  #[doc = " Default 'file://' protocol callbacks"]
  pub fn xmlFileMatch(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlFileOpen(filename: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn xmlFileRead(
    context: *mut ::std::os::raw::c_void,
    buffer: *mut ::std::os::raw::c_char,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlFileClose(context: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlIOHTTPMatch(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlIOHTTPOpen(filename: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn xmlIOHTTPOpenW(
    post_uri: *const ::std::os::raw::c_char,
    compression: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn xmlIOHTTPRead(
    context: *mut ::std::os::raw::c_void,
    buffer: *mut ::std::os::raw::c_char,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlIOHTTPClose(context: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlIOFTPMatch(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlIOFTPOpen(filename: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn xmlIOFTPRead(
    context: *mut ::std::os::raw::c_void,
    buffer: *mut ::std::os::raw::c_char,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlIOFTPClose(context: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlInitParser();
}
unsafe extern "C" {
  pub fn xmlCleanupParser();
}
unsafe extern "C" {
  pub fn xmlParserInputRead(
    in_: xmlParserInputPtr,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlParserInputGrow(
    in_: xmlParserInputPtr,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlParseDoc(cur: *const xmlChar) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlParseFile(filename: *const ::std::os::raw::c_char) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlParseMemory(
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlSubstituteEntitiesDefault(val: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlKeepBlanksDefault(val: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlStopParser(ctxt: xmlParserCtxtPtr);
}
unsafe extern "C" {
  pub fn xmlPedanticParserDefault(val: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlLineNumbersDefault(val: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlRecoverDoc(cur: *const xmlChar) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlRecoverMemory(
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlRecoverFile(filename: *const ::std::os::raw::c_char) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlParseDocument(ctxt: xmlParserCtxtPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlParseExtParsedEnt(ctxt: xmlParserCtxtPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSAXUserParseFile(
    sax: xmlSAXHandlerPtr,
    user_data: *mut ::std::os::raw::c_void,
    filename: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSAXUserParseMemory(
    sax: xmlSAXHandlerPtr,
    user_data: *mut ::std::os::raw::c_void,
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSAXParseDoc(
    sax: xmlSAXHandlerPtr,
    cur: *const xmlChar,
    recovery: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlSAXParseMemory(
    sax: xmlSAXHandlerPtr,
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    recovery: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlSAXParseMemoryWithData(
    sax: xmlSAXHandlerPtr,
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    recovery: ::std::os::raw::c_int,
    data: *mut ::std::os::raw::c_void,
  ) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlSAXParseFile(
    sax: xmlSAXHandlerPtr,
    filename: *const ::std::os::raw::c_char,
    recovery: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlSAXParseFileWithData(
    sax: xmlSAXHandlerPtr,
    filename: *const ::std::os::raw::c_char,
    recovery: ::std::os::raw::c_int,
    data: *mut ::std::os::raw::c_void,
  ) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlSAXParseEntity(
    sax: xmlSAXHandlerPtr,
    filename: *const ::std::os::raw::c_char,
  ) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlParseEntity(filename: *const ::std::os::raw::c_char) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlSAXParseDTD(
    sax: xmlSAXHandlerPtr,
    ExternalID: *const xmlChar,
    SystemID: *const xmlChar,
  ) -> xmlDtdPtr;
}
unsafe extern "C" {
  pub fn xmlParseDTD(ExternalID: *const xmlChar, SystemID: *const xmlChar) -> xmlDtdPtr;
}
unsafe extern "C" {
  pub fn xmlIOParseDTD(
    sax: xmlSAXHandlerPtr,
    input: xmlParserInputBufferPtr,
    enc: xmlCharEncoding,
  ) -> xmlDtdPtr;
}
unsafe extern "C" {
  pub fn xmlParseBalancedChunkMemory(
    doc: xmlDocPtr,
    sax: xmlSAXHandlerPtr,
    user_data: *mut ::std::os::raw::c_void,
    depth: ::std::os::raw::c_int,
    string: *const xmlChar,
    lst: *mut xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlParseInNodeContext(
    node: xmlNodePtr,
    data: *const ::std::os::raw::c_char,
    datalen: ::std::os::raw::c_int,
    options: ::std::os::raw::c_int,
    lst: *mut xmlNodePtr,
  ) -> xmlParserErrors;
}
unsafe extern "C" {
  pub fn xmlParseBalancedChunkMemoryRecover(
    doc: xmlDocPtr,
    sax: xmlSAXHandlerPtr,
    user_data: *mut ::std::os::raw::c_void,
    depth: ::std::os::raw::c_int,
    string: *const xmlChar,
    lst: *mut xmlNodePtr,
    recover: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlParseExternalEntity(
    doc: xmlDocPtr,
    sax: xmlSAXHandlerPtr,
    user_data: *mut ::std::os::raw::c_void,
    depth: ::std::os::raw::c_int,
    URL: *const xmlChar,
    ID: *const xmlChar,
    lst: *mut xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlParseCtxtExternalEntity(
    ctx: xmlParserCtxtPtr,
    URL: *const xmlChar,
    ID: *const xmlChar,
    lst: *mut xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlNewParserCtxt() -> xmlParserCtxtPtr;
}
unsafe extern "C" {
  pub fn xmlInitParserCtxt(ctxt: xmlParserCtxtPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlClearParserCtxt(ctxt: xmlParserCtxtPtr);
}
unsafe extern "C" {
  pub fn xmlFreeParserCtxt(ctxt: xmlParserCtxtPtr);
}
unsafe extern "C" {
  pub fn xmlSetupParserForBuffer(
    ctxt: xmlParserCtxtPtr,
    buffer: *const xmlChar,
    filename: *const ::std::os::raw::c_char,
  );
}
unsafe extern "C" {
  pub fn xmlCreateDocParserCtxt(cur: *const xmlChar) -> xmlParserCtxtPtr;
}
unsafe extern "C" {
  pub fn xmlGetFeaturesList(
    len: *mut ::std::os::raw::c_int,
    result: *mut *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlGetFeature(
    ctxt: xmlParserCtxtPtr,
    name: *const ::std::os::raw::c_char,
    result: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSetFeature(
    ctxt: xmlParserCtxtPtr,
    name: *const ::std::os::raw::c_char,
    value: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlCreatePushParserCtxt(
    sax: xmlSAXHandlerPtr,
    user_data: *mut ::std::os::raw::c_void,
    chunk: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    filename: *const ::std::os::raw::c_char,
  ) -> xmlParserCtxtPtr;
}
unsafe extern "C" {
  pub fn xmlParseChunk(
    ctxt: xmlParserCtxtPtr,
    chunk: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    terminate: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlCreateIOParserCtxt(
    sax: xmlSAXHandlerPtr,
    user_data: *mut ::std::os::raw::c_void,
    ioread: xmlInputReadCallback,
    ioclose: xmlInputCloseCallback,
    ioctx: *mut ::std::os::raw::c_void,
    enc: xmlCharEncoding,
  ) -> xmlParserCtxtPtr;
}
unsafe extern "C" {
  pub fn xmlNewIOInputStream(
    ctxt: xmlParserCtxtPtr,
    input: xmlParserInputBufferPtr,
    enc: xmlCharEncoding,
  ) -> xmlParserInputPtr;
}
unsafe extern "C" {
  pub fn xmlParserFindNodeInfo(
    ctxt: xmlParserCtxtPtr,
    node: xmlNodePtr,
  ) -> *const xmlParserNodeInfo;
}
unsafe extern "C" {
  pub fn xmlInitNodeInfoSeq(seq: xmlParserNodeInfoSeqPtr);
}
unsafe extern "C" {
  pub fn xmlClearNodeInfoSeq(seq: xmlParserNodeInfoSeqPtr);
}
unsafe extern "C" {
  pub fn xmlParserFindNodeInfoIndex(
    seq: xmlParserNodeInfoSeqPtr,
    node: xmlNodePtr,
  ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
  pub fn xmlParserAddNodeInfo(ctxt: xmlParserCtxtPtr, info: xmlParserNodeInfoPtr);
}
unsafe extern "C" {
  pub fn xmlSetExternalEntityLoader(f: xmlExternalEntityLoader);
}
unsafe extern "C" {
  pub fn xmlGetExternalEntityLoader() -> xmlExternalEntityLoader;
}
unsafe extern "C" {
  pub fn xmlLoadExternalEntity(
    URL: *const ::std::os::raw::c_char,
    ID: *const ::std::os::raw::c_char,
    ctxt: xmlParserCtxtPtr,
  ) -> xmlParserInputPtr;
}
unsafe extern "C" {
  pub fn xmlByteConsumed(ctxt: xmlParserCtxtPtr) -> ::std::os::raw::c_long;
}
pub const xmlParserOption_XML_PARSE_RECOVER: xmlParserOption = 1;
pub const xmlParserOption_XML_PARSE_NOENT: xmlParserOption = 2;
pub const xmlParserOption_XML_PARSE_DTDLOAD: xmlParserOption = 4;
pub const xmlParserOption_XML_PARSE_DTDATTR: xmlParserOption = 8;
pub const xmlParserOption_XML_PARSE_DTDVALID: xmlParserOption = 16;
pub const xmlParserOption_XML_PARSE_NOERROR: xmlParserOption = 32;
pub const xmlParserOption_XML_PARSE_NOWARNING: xmlParserOption = 64;
pub const xmlParserOption_XML_PARSE_PEDANTIC: xmlParserOption = 128;
pub const xmlParserOption_XML_PARSE_NOBLANKS: xmlParserOption = 256;
pub const xmlParserOption_XML_PARSE_SAX1: xmlParserOption = 512;
pub const xmlParserOption_XML_PARSE_XINCLUDE: xmlParserOption = 1024;
pub const xmlParserOption_XML_PARSE_NONET: xmlParserOption = 2048;
pub const xmlParserOption_XML_PARSE_NODICT: xmlParserOption = 4096;
pub const xmlParserOption_XML_PARSE_NSCLEAN: xmlParserOption = 8192;
pub const xmlParserOption_XML_PARSE_NOCDATA: xmlParserOption = 16384;
pub const xmlParserOption_XML_PARSE_NOXINCNODE: xmlParserOption = 32768;
pub const xmlParserOption_XML_PARSE_COMPACT: xmlParserOption = 65536;
pub const xmlParserOption_XML_PARSE_OLD10: xmlParserOption = 131072;
pub const xmlParserOption_XML_PARSE_NOBASEFIX: xmlParserOption = 262144;
pub const xmlParserOption_XML_PARSE_HUGE: xmlParserOption = 524288;
pub const xmlParserOption_XML_PARSE_OLDSAX: xmlParserOption = 1048576;
pub const xmlParserOption_XML_PARSE_IGNORE_ENC: xmlParserOption = 2097152;
pub const xmlParserOption_XML_PARSE_BIG_LINES: xmlParserOption = 4194304;
#[doc = " xmlParserOption:\n\n This is the set of XML parser options that can be passed down\n to the xmlReadDoc() and similar calls."]
pub type xmlParserOption = ::std::os::raw::c_uint;
unsafe extern "C" {
  pub fn xmlCtxtReset(ctxt: xmlParserCtxtPtr);
}
unsafe extern "C" {
  pub fn xmlCtxtResetPush(
    ctxt: xmlParserCtxtPtr,
    chunk: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    filename: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlCtxtUseOptions(
    ctxt: xmlParserCtxtPtr,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlReadDoc(
    cur: *const xmlChar,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlReadFile(
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlReadMemory(
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlReadFd(
    fd: ::std::os::raw::c_int,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlReadIO(
    ioread: xmlInputReadCallback,
    ioclose: xmlInputCloseCallback,
    ioctx: *mut ::std::os::raw::c_void,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlCtxtReadDoc(
    ctxt: xmlParserCtxtPtr,
    cur: *const xmlChar,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlCtxtReadFile(
    ctxt: xmlParserCtxtPtr,
    filename: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlCtxtReadMemory(
    ctxt: xmlParserCtxtPtr,
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlCtxtReadFd(
    ctxt: xmlParserCtxtPtr,
    fd: ::std::os::raw::c_int,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
unsafe extern "C" {
  pub fn xmlCtxtReadIO(
    ctxt: xmlParserCtxtPtr,
    ioread: xmlInputReadCallback,
    ioclose: xmlInputCloseCallback,
    ioctx: *mut ::std::os::raw::c_void,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
pub const xmlFeature_XML_WITH_THREAD: xmlFeature = 1;
pub const xmlFeature_XML_WITH_TREE: xmlFeature = 2;
pub const xmlFeature_XML_WITH_OUTPUT: xmlFeature = 3;
pub const xmlFeature_XML_WITH_PUSH: xmlFeature = 4;
pub const xmlFeature_XML_WITH_READER: xmlFeature = 5;
pub const xmlFeature_XML_WITH_PATTERN: xmlFeature = 6;
pub const xmlFeature_XML_WITH_WRITER: xmlFeature = 7;
pub const xmlFeature_XML_WITH_SAX1: xmlFeature = 8;
pub const xmlFeature_XML_WITH_FTP: xmlFeature = 9;
pub const xmlFeature_XML_WITH_HTTP: xmlFeature = 10;
pub const xmlFeature_XML_WITH_VALID: xmlFeature = 11;
pub const xmlFeature_XML_WITH_HTML: xmlFeature = 12;
pub const xmlFeature_XML_WITH_LEGACY: xmlFeature = 13;
pub const xmlFeature_XML_WITH_C14N: xmlFeature = 14;
pub const xmlFeature_XML_WITH_CATALOG: xmlFeature = 15;
pub const xmlFeature_XML_WITH_XPATH: xmlFeature = 16;
pub const xmlFeature_XML_WITH_XPTR: xmlFeature = 17;
pub const xmlFeature_XML_WITH_XINCLUDE: xmlFeature = 18;
pub const xmlFeature_XML_WITH_ICONV: xmlFeature = 19;
pub const xmlFeature_XML_WITH_ISO8859X: xmlFeature = 20;
pub const xmlFeature_XML_WITH_UNICODE: xmlFeature = 21;
pub const xmlFeature_XML_WITH_REGEXP: xmlFeature = 22;
pub const xmlFeature_XML_WITH_AUTOMATA: xmlFeature = 23;
pub const xmlFeature_XML_WITH_EXPR: xmlFeature = 24;
pub const xmlFeature_XML_WITH_SCHEMAS: xmlFeature = 25;
pub const xmlFeature_XML_WITH_SCHEMATRON: xmlFeature = 26;
pub const xmlFeature_XML_WITH_MODULES: xmlFeature = 27;
pub const xmlFeature_XML_WITH_DEBUG: xmlFeature = 28;
pub const xmlFeature_XML_WITH_DEBUG_MEM: xmlFeature = 29;
pub const xmlFeature_XML_WITH_DEBUG_RUN: xmlFeature = 30;
pub const xmlFeature_XML_WITH_ZLIB: xmlFeature = 31;
pub const xmlFeature_XML_WITH_ICU: xmlFeature = 32;
pub const xmlFeature_XML_WITH_LZMA: xmlFeature = 33;
pub const xmlFeature_XML_WITH_NONE: xmlFeature = 99999;
#[doc = " xmlFeature:\n\n Used to examine the existence of features that can be enabled\n or disabled at compile-time.\n They used to be called XML_FEATURE_xxx but this clashed with Expat"]
pub type xmlFeature = ::std::os::raw::c_uint;
unsafe extern "C" {
  pub fn xmlHasFeature(feature: xmlFeature) -> ::std::os::raw::c_int;
}
#[doc = " xmlXPathContext:\n\n Expression evaluation occurs with respect to a context.\n he context consists of:\n    - a node (the context node)\n    - a node list (the context node list)\n    - a set of variable bindings\n    - a function library\n    - the set of namespace declarations in scope for the expression\n Following the switch to hash tables, this need to be trimmed up at\n the next binary incompatible release.\n The node may be modified when the context is passed to libxml2\n for an XPath evaluation so you may need to initialize it again\n before the next call."]
pub type xmlXPathContext = _xmlXPathContext;
pub type xmlXPathContextPtr = *mut xmlXPathContext;
#[doc = " xmlXPathParserContext:\n\n An XPath parser context. It contains pure parsing information,\n an xmlXPathContext, and the stack of objects."]
pub type xmlXPathParserContext = _xmlXPathParserContext;
pub type xmlXPathParserContextPtr = *mut xmlXPathParserContext;
pub const xmlXPathError_XPATH_EXPRESSION_OK: xmlXPathError = 0;
pub const xmlXPathError_XPATH_NUMBER_ERROR: xmlXPathError = 1;
pub const xmlXPathError_XPATH_UNFINISHED_LITERAL_ERROR: xmlXPathError = 2;
pub const xmlXPathError_XPATH_START_LITERAL_ERROR: xmlXPathError = 3;
pub const xmlXPathError_XPATH_VARIABLE_REF_ERROR: xmlXPathError = 4;
pub const xmlXPathError_XPATH_UNDEF_VARIABLE_ERROR: xmlXPathError = 5;
pub const xmlXPathError_XPATH_INVALID_PREDICATE_ERROR: xmlXPathError = 6;
pub const xmlXPathError_XPATH_EXPR_ERROR: xmlXPathError = 7;
pub const xmlXPathError_XPATH_UNCLOSED_ERROR: xmlXPathError = 8;
pub const xmlXPathError_XPATH_UNKNOWN_FUNC_ERROR: xmlXPathError = 9;
pub const xmlXPathError_XPATH_INVALID_OPERAND: xmlXPathError = 10;
pub const xmlXPathError_XPATH_INVALID_TYPE: xmlXPathError = 11;
pub const xmlXPathError_XPATH_INVALID_ARITY: xmlXPathError = 12;
pub const xmlXPathError_XPATH_INVALID_CTXT_SIZE: xmlXPathError = 13;
pub const xmlXPathError_XPATH_INVALID_CTXT_POSITION: xmlXPathError = 14;
pub const xmlXPathError_XPATH_MEMORY_ERROR: xmlXPathError = 15;
pub const xmlXPathError_XPTR_SYNTAX_ERROR: xmlXPathError = 16;
pub const xmlXPathError_XPTR_RESOURCE_ERROR: xmlXPathError = 17;
pub const xmlXPathError_XPTR_SUB_RESOURCE_ERROR: xmlXPathError = 18;
pub const xmlXPathError_XPATH_UNDEF_PREFIX_ERROR: xmlXPathError = 19;
pub const xmlXPathError_XPATH_ENCODING_ERROR: xmlXPathError = 20;
pub const xmlXPathError_XPATH_INVALID_CHAR_ERROR: xmlXPathError = 21;
pub const xmlXPathError_XPATH_INVALID_CTXT: xmlXPathError = 22;
pub const xmlXPathError_XPATH_STACK_ERROR: xmlXPathError = 23;
pub const xmlXPathError_XPATH_FORBID_VARIABLE_ERROR: xmlXPathError = 24;
pub const xmlXPathError_XPATH_OP_LIMIT_EXCEEDED: xmlXPathError = 25;
pub const xmlXPathError_XPATH_RECURSION_LIMIT_EXCEEDED: xmlXPathError = 26;
#[doc = " The set of XPath error codes."]
pub type xmlXPathError = ::std::os::raw::c_uint;
pub type xmlNodeSet = _xmlNodeSet;
pub type xmlNodeSetPtr = *mut xmlNodeSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlNodeSet {
  pub nodeNr: ::std::os::raw::c_int,
  pub nodeMax: ::std::os::raw::c_int,
  pub nodeTab: *mut xmlNodePtr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlNodeSet"][::std::mem::size_of::<_xmlNodeSet>() - 16usize];
  ["Alignment of _xmlNodeSet"][::std::mem::align_of::<_xmlNodeSet>() - 8usize];
  ["Offset of field: _xmlNodeSet::nodeNr"][::std::mem::offset_of!(_xmlNodeSet, nodeNr) - 0usize];
  ["Offset of field: _xmlNodeSet::nodeMax"][::std::mem::offset_of!(_xmlNodeSet, nodeMax) - 4usize];
  ["Offset of field: _xmlNodeSet::nodeTab"][::std::mem::offset_of!(_xmlNodeSet, nodeTab) - 8usize];
};
pub const xmlXPathObjectType_XPATH_UNDEFINED: xmlXPathObjectType = 0;
pub const xmlXPathObjectType_XPATH_NODESET: xmlXPathObjectType = 1;
pub const xmlXPathObjectType_XPATH_BOOLEAN: xmlXPathObjectType = 2;
pub const xmlXPathObjectType_XPATH_NUMBER: xmlXPathObjectType = 3;
pub const xmlXPathObjectType_XPATH_STRING: xmlXPathObjectType = 4;
pub const xmlXPathObjectType_XPATH_POINT: xmlXPathObjectType = 5;
pub const xmlXPathObjectType_XPATH_RANGE: xmlXPathObjectType = 6;
pub const xmlXPathObjectType_XPATH_LOCATIONSET: xmlXPathObjectType = 7;
pub const xmlXPathObjectType_XPATH_USERS: xmlXPathObjectType = 8;
pub const xmlXPathObjectType_XPATH_XSLT_TREE: xmlXPathObjectType = 9;
pub type xmlXPathObjectType = ::std::os::raw::c_uint;
pub type xmlXPathObject = _xmlXPathObject;
pub type xmlXPathObjectPtr = *mut xmlXPathObject;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathObject {
  pub type_: xmlXPathObjectType,
  pub nodesetval: xmlNodeSetPtr,
  pub boolval: ::std::os::raw::c_int,
  pub floatval: f64,
  pub stringval: *mut xmlChar,
  pub user: *mut ::std::os::raw::c_void,
  pub index: ::std::os::raw::c_int,
  pub user2: *mut ::std::os::raw::c_void,
  pub index2: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlXPathObject"][::std::mem::size_of::<_xmlXPathObject>() - 72usize];
  ["Alignment of _xmlXPathObject"][::std::mem::align_of::<_xmlXPathObject>() - 8usize];
  ["Offset of field: _xmlXPathObject::type_"]
    [::std::mem::offset_of!(_xmlXPathObject, type_) - 0usize];
  ["Offset of field: _xmlXPathObject::nodesetval"]
    [::std::mem::offset_of!(_xmlXPathObject, nodesetval) - 8usize];
  ["Offset of field: _xmlXPathObject::boolval"]
    [::std::mem::offset_of!(_xmlXPathObject, boolval) - 16usize];
  ["Offset of field: _xmlXPathObject::floatval"]
    [::std::mem::offset_of!(_xmlXPathObject, floatval) - 24usize];
  ["Offset of field: _xmlXPathObject::stringval"]
    [::std::mem::offset_of!(_xmlXPathObject, stringval) - 32usize];
  ["Offset of field: _xmlXPathObject::user"]
    [::std::mem::offset_of!(_xmlXPathObject, user) - 40usize];
  ["Offset of field: _xmlXPathObject::index"]
    [::std::mem::offset_of!(_xmlXPathObject, index) - 48usize];
  ["Offset of field: _xmlXPathObject::user2"]
    [::std::mem::offset_of!(_xmlXPathObject, user2) - 56usize];
  ["Offset of field: _xmlXPathObject::index2"]
    [::std::mem::offset_of!(_xmlXPathObject, index2) - 64usize];
};
#[doc = " xmlXPathConvertFunc:\n @obj:  an XPath object\n @type:  the number of the target type\n\n A conversion function is associated to a type and used to cast\n the new type to primitive values.\n\n Returns -1 in case of error, 0 otherwise"]
pub type xmlXPathConvertFunc = ::std::option::Option<
  unsafe extern "C" fn(
    obj: xmlXPathObjectPtr,
    type_: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int,
>;
pub type xmlXPathType = _xmlXPathType;
pub type xmlXPathTypePtr = *mut xmlXPathType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathType {
  pub name: *const xmlChar,
  pub func: xmlXPathConvertFunc,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlXPathType"][::std::mem::size_of::<_xmlXPathType>() - 16usize];
  ["Alignment of _xmlXPathType"][::std::mem::align_of::<_xmlXPathType>() - 8usize];
  ["Offset of field: _xmlXPathType::name"][::std::mem::offset_of!(_xmlXPathType, name) - 0usize];
  ["Offset of field: _xmlXPathType::func"][::std::mem::offset_of!(_xmlXPathType, func) - 8usize];
};
pub type xmlXPathVariable = _xmlXPathVariable;
pub type xmlXPathVariablePtr = *mut xmlXPathVariable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathVariable {
  pub name: *const xmlChar,
  pub value: xmlXPathObjectPtr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlXPathVariable"][::std::mem::size_of::<_xmlXPathVariable>() - 16usize];
  ["Alignment of _xmlXPathVariable"][::std::mem::align_of::<_xmlXPathVariable>() - 8usize];
  ["Offset of field: _xmlXPathVariable::name"]
    [::std::mem::offset_of!(_xmlXPathVariable, name) - 0usize];
  ["Offset of field: _xmlXPathVariable::value"]
    [::std::mem::offset_of!(_xmlXPathVariable, value) - 8usize];
};
#[doc = " xmlXPathEvalFunc:\n @ctxt: an XPath parser context\n @nargs: the number of arguments passed to the function\n\n An XPath evaluation function, the parameters are on the XPath context stack."]
pub type xmlXPathEvalFunc = ::std::option::Option<
  unsafe extern "C" fn(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int),
>;
pub type xmlXPathFunct = _xmlXPathFunct;
pub type xmlXPathFuncPtr = *mut xmlXPathFunct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathFunct {
  pub name: *const xmlChar,
  pub func: xmlXPathEvalFunc,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlXPathFunct"][::std::mem::size_of::<_xmlXPathFunct>() - 16usize];
  ["Alignment of _xmlXPathFunct"][::std::mem::align_of::<_xmlXPathFunct>() - 8usize];
  ["Offset of field: _xmlXPathFunct::name"][::std::mem::offset_of!(_xmlXPathFunct, name) - 0usize];
  ["Offset of field: _xmlXPathFunct::func"][::std::mem::offset_of!(_xmlXPathFunct, func) - 8usize];
};
#[doc = " xmlXPathAxisFunc:\n @ctxt:  the XPath interpreter context\n @cur:  the previous node being explored on that axis\n\n An axis traversal function. To traverse an axis, the engine calls\n the first time with cur == NULL and repeat until the function returns\n NULL indicating the end of the axis traversal.\n\n Returns the next node in that axis or NULL if at the end of the axis."]
pub type xmlXPathAxisFunc = ::std::option::Option<
  unsafe extern "C" fn(ctxt: xmlXPathParserContextPtr, cur: xmlXPathObjectPtr) -> xmlXPathObjectPtr,
>;
pub type xmlXPathAxis = _xmlXPathAxis;
pub type xmlXPathAxisPtr = *mut xmlXPathAxis;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathAxis {
  pub name: *const xmlChar,
  pub func: xmlXPathAxisFunc,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlXPathAxis"][::std::mem::size_of::<_xmlXPathAxis>() - 16usize];
  ["Alignment of _xmlXPathAxis"][::std::mem::align_of::<_xmlXPathAxis>() - 8usize];
  ["Offset of field: _xmlXPathAxis::name"][::std::mem::offset_of!(_xmlXPathAxis, name) - 0usize];
  ["Offset of field: _xmlXPathAxis::func"][::std::mem::offset_of!(_xmlXPathAxis, func) - 8usize];
};
#[doc = " xmlXPathFunction:\n @ctxt:  the XPath interprestation context\n @nargs:  the number of arguments\n\n An XPath function.\n The arguments (if any) are popped out from the context stack\n and the result is pushed on the stack."]
pub type xmlXPathFunction = ::std::option::Option<
  unsafe extern "C" fn(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int),
>;
#[doc = " xmlXPathVariableLookupFunc:\n @ctxt:  an XPath context\n @name:  name of the variable\n @ns_uri:  the namespace name hosting this variable\n\n Prototype for callbacks used to plug variable lookup in the XPath\n engine.\n\n Returns the XPath object value or NULL if not found."]
pub type xmlXPathVariableLookupFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctxt: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    ns_uri: *const xmlChar,
  ) -> xmlXPathObjectPtr,
>;
#[doc = " xmlXPathFuncLookupFunc:\n @ctxt:  an XPath context\n @name:  name of the function\n @ns_uri:  the namespace name hosting this function\n\n Prototype for callbacks used to plug function lookup in the XPath\n engine.\n\n Returns the XPath function or NULL if not found."]
pub type xmlXPathFuncLookupFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctxt: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    ns_uri: *const xmlChar,
  ) -> xmlXPathFunction,
>;
#[doc = " xmlXPathContext:\n\n Expression evaluation occurs with respect to a context.\n he context consists of:\n    - a node (the context node)\n    - a node list (the context node list)\n    - a set of variable bindings\n    - a function library\n    - the set of namespace declarations in scope for the expression\n Following the switch to hash tables, this need to be trimmed up at\n the next binary incompatible release.\n The node may be modified when the context is passed to libxml2\n for an XPath evaluation so you may need to initialize it again\n before the next call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathContext {
  pub doc: xmlDocPtr,
  pub node: xmlNodePtr,
  pub nb_variables_unused: ::std::os::raw::c_int,
  pub max_variables_unused: ::std::os::raw::c_int,
  pub varHash: xmlHashTablePtr,
  pub nb_types: ::std::os::raw::c_int,
  pub max_types: ::std::os::raw::c_int,
  pub types: xmlXPathTypePtr,
  pub nb_funcs_unused: ::std::os::raw::c_int,
  pub max_funcs_unused: ::std::os::raw::c_int,
  pub funcHash: xmlHashTablePtr,
  pub nb_axis: ::std::os::raw::c_int,
  pub max_axis: ::std::os::raw::c_int,
  pub axis: xmlXPathAxisPtr,
  pub namespaces: *mut xmlNsPtr,
  pub nsNr: ::std::os::raw::c_int,
  pub user: *mut ::std::os::raw::c_void,
  pub contextSize: ::std::os::raw::c_int,
  pub proximityPosition: ::std::os::raw::c_int,
  pub xptr: ::std::os::raw::c_int,
  pub here: xmlNodePtr,
  pub origin: xmlNodePtr,
  pub nsHash: xmlHashTablePtr,
  pub varLookupFunc: xmlXPathVariableLookupFunc,
  pub varLookupData: *mut ::std::os::raw::c_void,
  pub extra: *mut ::std::os::raw::c_void,
  pub function: *const xmlChar,
  pub functionURI: *const xmlChar,
  pub funcLookupFunc: xmlXPathFuncLookupFunc,
  pub funcLookupData: *mut ::std::os::raw::c_void,
  pub tmpNsList: *mut xmlNsPtr,
  pub tmpNsNr: ::std::os::raw::c_int,
  pub userData: *mut ::std::os::raw::c_void,
  pub error: xmlStructuredErrorFunc,
  pub lastError: xmlError,
  pub debugNode: xmlNodePtr,
  pub dict: xmlDictPtr,
  pub flags: ::std::os::raw::c_int,
  pub cache: *mut ::std::os::raw::c_void,
  pub opLimit: ::std::os::raw::c_ulong,
  pub opCount: ::std::os::raw::c_ulong,
  pub depth: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlXPathContext"][::std::mem::size_of::<_xmlXPathContext>() - 376usize];
  ["Alignment of _xmlXPathContext"][::std::mem::align_of::<_xmlXPathContext>() - 8usize];
  ["Offset of field: _xmlXPathContext::doc"]
    [::std::mem::offset_of!(_xmlXPathContext, doc) - 0usize];
  ["Offset of field: _xmlXPathContext::node"]
    [::std::mem::offset_of!(_xmlXPathContext, node) - 8usize];
  ["Offset of field: _xmlXPathContext::nb_variables_unused"]
    [::std::mem::offset_of!(_xmlXPathContext, nb_variables_unused) - 16usize];
  ["Offset of field: _xmlXPathContext::max_variables_unused"]
    [::std::mem::offset_of!(_xmlXPathContext, max_variables_unused) - 20usize];
  ["Offset of field: _xmlXPathContext::varHash"]
    [::std::mem::offset_of!(_xmlXPathContext, varHash) - 24usize];
  ["Offset of field: _xmlXPathContext::nb_types"]
    [::std::mem::offset_of!(_xmlXPathContext, nb_types) - 32usize];
  ["Offset of field: _xmlXPathContext::max_types"]
    [::std::mem::offset_of!(_xmlXPathContext, max_types) - 36usize];
  ["Offset of field: _xmlXPathContext::types"]
    [::std::mem::offset_of!(_xmlXPathContext, types) - 40usize];
  ["Offset of field: _xmlXPathContext::nb_funcs_unused"]
    [::std::mem::offset_of!(_xmlXPathContext, nb_funcs_unused) - 48usize];
  ["Offset of field: _xmlXPathContext::max_funcs_unused"]
    [::std::mem::offset_of!(_xmlXPathContext, max_funcs_unused) - 52usize];
  ["Offset of field: _xmlXPathContext::funcHash"]
    [::std::mem::offset_of!(_xmlXPathContext, funcHash) - 56usize];
  ["Offset of field: _xmlXPathContext::nb_axis"]
    [::std::mem::offset_of!(_xmlXPathContext, nb_axis) - 64usize];
  ["Offset of field: _xmlXPathContext::max_axis"]
    [::std::mem::offset_of!(_xmlXPathContext, max_axis) - 68usize];
  ["Offset of field: _xmlXPathContext::axis"]
    [::std::mem::offset_of!(_xmlXPathContext, axis) - 72usize];
  ["Offset of field: _xmlXPathContext::namespaces"]
    [::std::mem::offset_of!(_xmlXPathContext, namespaces) - 80usize];
  ["Offset of field: _xmlXPathContext::nsNr"]
    [::std::mem::offset_of!(_xmlXPathContext, nsNr) - 88usize];
  ["Offset of field: _xmlXPathContext::user"]
    [::std::mem::offset_of!(_xmlXPathContext, user) - 96usize];
  ["Offset of field: _xmlXPathContext::contextSize"]
    [::std::mem::offset_of!(_xmlXPathContext, contextSize) - 104usize];
  ["Offset of field: _xmlXPathContext::proximityPosition"]
    [::std::mem::offset_of!(_xmlXPathContext, proximityPosition) - 108usize];
  ["Offset of field: _xmlXPathContext::xptr"]
    [::std::mem::offset_of!(_xmlXPathContext, xptr) - 112usize];
  ["Offset of field: _xmlXPathContext::here"]
    [::std::mem::offset_of!(_xmlXPathContext, here) - 120usize];
  ["Offset of field: _xmlXPathContext::origin"]
    [::std::mem::offset_of!(_xmlXPathContext, origin) - 128usize];
  ["Offset of field: _xmlXPathContext::nsHash"]
    [::std::mem::offset_of!(_xmlXPathContext, nsHash) - 136usize];
  ["Offset of field: _xmlXPathContext::varLookupFunc"]
    [::std::mem::offset_of!(_xmlXPathContext, varLookupFunc) - 144usize];
  ["Offset of field: _xmlXPathContext::varLookupData"]
    [::std::mem::offset_of!(_xmlXPathContext, varLookupData) - 152usize];
  ["Offset of field: _xmlXPathContext::extra"]
    [::std::mem::offset_of!(_xmlXPathContext, extra) - 160usize];
  ["Offset of field: _xmlXPathContext::function"]
    [::std::mem::offset_of!(_xmlXPathContext, function) - 168usize];
  ["Offset of field: _xmlXPathContext::functionURI"]
    [::std::mem::offset_of!(_xmlXPathContext, functionURI) - 176usize];
  ["Offset of field: _xmlXPathContext::funcLookupFunc"]
    [::std::mem::offset_of!(_xmlXPathContext, funcLookupFunc) - 184usize];
  ["Offset of field: _xmlXPathContext::funcLookupData"]
    [::std::mem::offset_of!(_xmlXPathContext, funcLookupData) - 192usize];
  ["Offset of field: _xmlXPathContext::tmpNsList"]
    [::std::mem::offset_of!(_xmlXPathContext, tmpNsList) - 200usize];
  ["Offset of field: _xmlXPathContext::tmpNsNr"]
    [::std::mem::offset_of!(_xmlXPathContext, tmpNsNr) - 208usize];
  ["Offset of field: _xmlXPathContext::userData"]
    [::std::mem::offset_of!(_xmlXPathContext, userData) - 216usize];
  ["Offset of field: _xmlXPathContext::error"]
    [::std::mem::offset_of!(_xmlXPathContext, error) - 224usize];
  ["Offset of field: _xmlXPathContext::lastError"]
    [::std::mem::offset_of!(_xmlXPathContext, lastError) - 232usize];
  ["Offset of field: _xmlXPathContext::debugNode"]
    [::std::mem::offset_of!(_xmlXPathContext, debugNode) - 320usize];
  ["Offset of field: _xmlXPathContext::dict"]
    [::std::mem::offset_of!(_xmlXPathContext, dict) - 328usize];
  ["Offset of field: _xmlXPathContext::flags"]
    [::std::mem::offset_of!(_xmlXPathContext, flags) - 336usize];
  ["Offset of field: _xmlXPathContext::cache"]
    [::std::mem::offset_of!(_xmlXPathContext, cache) - 344usize];
  ["Offset of field: _xmlXPathContext::opLimit"]
    [::std::mem::offset_of!(_xmlXPathContext, opLimit) - 352usize];
  ["Offset of field: _xmlXPathContext::opCount"]
    [::std::mem::offset_of!(_xmlXPathContext, opCount) - 360usize];
  ["Offset of field: _xmlXPathContext::depth"]
    [::std::mem::offset_of!(_xmlXPathContext, depth) - 368usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathCompExpr {
  _unused: [u8; 0],
}
pub type xmlXPathCompExpr = _xmlXPathCompExpr;
pub type xmlXPathCompExprPtr = *mut xmlXPathCompExpr;
#[doc = " xmlXPathParserContext:\n\n An XPath parser context. It contains pure parsing information,\n an xmlXPathContext, and the stack of objects."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathParserContext {
  pub cur: *const xmlChar,
  pub base: *const xmlChar,
  pub error: ::std::os::raw::c_int,
  pub context: xmlXPathContextPtr,
  pub value: xmlXPathObjectPtr,
  pub valueNr: ::std::os::raw::c_int,
  pub valueMax: ::std::os::raw::c_int,
  pub valueTab: *mut xmlXPathObjectPtr,
  pub comp: xmlXPathCompExprPtr,
  pub xptr: ::std::os::raw::c_int,
  pub ancestor: xmlNodePtr,
  pub valueFrame: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _xmlXPathParserContext"][::std::mem::size_of::<_xmlXPathParserContext>() - 88usize];
  ["Alignment of _xmlXPathParserContext"]
    [::std::mem::align_of::<_xmlXPathParserContext>() - 8usize];
  ["Offset of field: _xmlXPathParserContext::cur"]
    [::std::mem::offset_of!(_xmlXPathParserContext, cur) - 0usize];
  ["Offset of field: _xmlXPathParserContext::base"]
    [::std::mem::offset_of!(_xmlXPathParserContext, base) - 8usize];
  ["Offset of field: _xmlXPathParserContext::error"]
    [::std::mem::offset_of!(_xmlXPathParserContext, error) - 16usize];
  ["Offset of field: _xmlXPathParserContext::context"]
    [::std::mem::offset_of!(_xmlXPathParserContext, context) - 24usize];
  ["Offset of field: _xmlXPathParserContext::value"]
    [::std::mem::offset_of!(_xmlXPathParserContext, value) - 32usize];
  ["Offset of field: _xmlXPathParserContext::valueNr"]
    [::std::mem::offset_of!(_xmlXPathParserContext, valueNr) - 40usize];
  ["Offset of field: _xmlXPathParserContext::valueMax"]
    [::std::mem::offset_of!(_xmlXPathParserContext, valueMax) - 44usize];
  ["Offset of field: _xmlXPathParserContext::valueTab"]
    [::std::mem::offset_of!(_xmlXPathParserContext, valueTab) - 48usize];
  ["Offset of field: _xmlXPathParserContext::comp"]
    [::std::mem::offset_of!(_xmlXPathParserContext, comp) - 56usize];
  ["Offset of field: _xmlXPathParserContext::xptr"]
    [::std::mem::offset_of!(_xmlXPathParserContext, xptr) - 64usize];
  ["Offset of field: _xmlXPathParserContext::ancestor"]
    [::std::mem::offset_of!(_xmlXPathParserContext, ancestor) - 72usize];
  ["Offset of field: _xmlXPathParserContext::valueFrame"]
    [::std::mem::offset_of!(_xmlXPathParserContext, valueFrame) - 80usize];
};
unsafe extern "C" {
  #[doc = " Objects and Nodesets handling"]
  pub static mut xmlXPathNAN: f64;
}
unsafe extern "C" {
  pub static mut xmlXPathPINF: f64;
}
unsafe extern "C" {
  pub static mut xmlXPathNINF: f64;
}
unsafe extern "C" {
  pub fn xmlXPathFreeObject(obj: xmlXPathObjectPtr);
}
unsafe extern "C" {
  pub fn xmlXPathNodeSetCreate(val: xmlNodePtr) -> xmlNodeSetPtr;
}
unsafe extern "C" {
  pub fn xmlXPathFreeNodeSetList(obj: xmlXPathObjectPtr);
}
unsafe extern "C" {
  pub fn xmlXPathFreeNodeSet(obj: xmlNodeSetPtr);
}
unsafe extern "C" {
  pub fn xmlXPathObjectCopy(val: xmlXPathObjectPtr) -> xmlXPathObjectPtr;
}
unsafe extern "C" {
  pub fn xmlXPathCmpNodes(node1: xmlNodePtr, node2: xmlNodePtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  #[doc = " Conversion functions to basic types."]
  pub fn xmlXPathCastNumberToBoolean(val: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathCastStringToBoolean(val: *const xmlChar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathCastNodeSetToBoolean(ns: xmlNodeSetPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathCastToBoolean(val: xmlXPathObjectPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathCastBooleanToNumber(val: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
  pub fn xmlXPathCastStringToNumber(val: *const xmlChar) -> f64;
}
unsafe extern "C" {
  pub fn xmlXPathCastNodeToNumber(node: xmlNodePtr) -> f64;
}
unsafe extern "C" {
  pub fn xmlXPathCastNodeSetToNumber(ns: xmlNodeSetPtr) -> f64;
}
unsafe extern "C" {
  pub fn xmlXPathCastToNumber(val: xmlXPathObjectPtr) -> f64;
}
unsafe extern "C" {
  pub fn xmlXPathCastBooleanToString(val: ::std::os::raw::c_int) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlXPathCastNumberToString(val: f64) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlXPathCastNodeToString(node: xmlNodePtr) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlXPathCastNodeSetToString(ns: xmlNodeSetPtr) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlXPathCastToString(val: xmlXPathObjectPtr) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlXPathConvertBoolean(val: xmlXPathObjectPtr) -> xmlXPathObjectPtr;
}
unsafe extern "C" {
  pub fn xmlXPathConvertNumber(val: xmlXPathObjectPtr) -> xmlXPathObjectPtr;
}
unsafe extern "C" {
  pub fn xmlXPathConvertString(val: xmlXPathObjectPtr) -> xmlXPathObjectPtr;
}
unsafe extern "C" {
  #[doc = " Context handling."]
  pub fn xmlXPathNewContext(doc: xmlDocPtr) -> xmlXPathContextPtr;
}
unsafe extern "C" {
  pub fn xmlXPathFreeContext(ctxt: xmlXPathContextPtr);
}
unsafe extern "C" {
  pub fn xmlXPathContextSetCache(
    ctxt: xmlXPathContextPtr,
    active: ::std::os::raw::c_int,
    value: ::std::os::raw::c_int,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  #[doc = " Evaluation functions."]
  pub fn xmlXPathOrderDocElems(doc: xmlDocPtr) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
  pub fn xmlXPathSetContextNode(node: xmlNodePtr, ctx: xmlXPathContextPtr)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathNodeEval(
    node: xmlNodePtr,
    str_: *const xmlChar,
    ctx: xmlXPathContextPtr,
  ) -> xmlXPathObjectPtr;
}
unsafe extern "C" {
  pub fn xmlXPathEval(str_: *const xmlChar, ctx: xmlXPathContextPtr) -> xmlXPathObjectPtr;
}
unsafe extern "C" {
  pub fn xmlXPathEvalExpression(
    str_: *const xmlChar,
    ctxt: xmlXPathContextPtr,
  ) -> xmlXPathObjectPtr;
}
unsafe extern "C" {
  pub fn xmlXPathEvalPredicate(
    ctxt: xmlXPathContextPtr,
    res: xmlXPathObjectPtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  #[doc = " Separate compilation/evaluation entry points."]
  pub fn xmlXPathCompile(str_: *const xmlChar) -> xmlXPathCompExprPtr;
}
unsafe extern "C" {
  pub fn xmlXPathCtxtCompile(ctxt: xmlXPathContextPtr, str_: *const xmlChar)
    -> xmlXPathCompExprPtr;
}
unsafe extern "C" {
  pub fn xmlXPathCompiledEval(
    comp: xmlXPathCompExprPtr,
    ctx: xmlXPathContextPtr,
  ) -> xmlXPathObjectPtr;
}
unsafe extern "C" {
  pub fn xmlXPathCompiledEvalToBoolean(
    comp: xmlXPathCompExprPtr,
    ctxt: xmlXPathContextPtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathFreeCompExpr(comp: xmlXPathCompExprPtr);
}
unsafe extern "C" {
  pub fn xmlXPathInit();
}
unsafe extern "C" {
  pub fn xmlXPathIsNaN(val: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathIsInf(val: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathPopBoolean(ctxt: xmlXPathParserContextPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathPopNumber(ctxt: xmlXPathParserContextPtr) -> f64;
}
unsafe extern "C" {
  pub fn xmlXPathPopString(ctxt: xmlXPathParserContextPtr) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlXPathPopNodeSet(ctxt: xmlXPathParserContextPtr) -> xmlNodeSetPtr;
}
unsafe extern "C" {
  pub fn xmlXPathPopExternal(ctxt: xmlXPathParserContextPtr) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
  pub fn xmlXPathRegisterVariableLookup(
    ctxt: xmlXPathContextPtr,
    f: xmlXPathVariableLookupFunc,
    data: *mut ::std::os::raw::c_void,
  );
}
unsafe extern "C" {
  pub fn xmlXPathRegisterFuncLookup(
    ctxt: xmlXPathContextPtr,
    f: xmlXPathFuncLookupFunc,
    funcCtxt: *mut ::std::os::raw::c_void,
  );
}
unsafe extern "C" {
  pub fn xmlXPatherror(
    ctxt: xmlXPathParserContextPtr,
    file: *const ::std::os::raw::c_char,
    line: ::std::os::raw::c_int,
    no: ::std::os::raw::c_int,
  );
}
unsafe extern "C" {
  pub fn xmlXPathErr(ctxt: xmlXPathParserContextPtr, error: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathDebugDumpObject(
    output: *mut FILE,
    cur: xmlXPathObjectPtr,
    depth: ::std::os::raw::c_int,
  );
}
unsafe extern "C" {
  pub fn xmlXPathDebugDumpCompExpr(
    output: *mut FILE,
    comp: xmlXPathCompExprPtr,
    depth: ::std::os::raw::c_int,
  );
}
unsafe extern "C" {
  #[doc = " NodeSet handling."]
  pub fn xmlXPathNodeSetContains(cur: xmlNodeSetPtr, val: xmlNodePtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathDifference(nodes1: xmlNodeSetPtr, nodes2: xmlNodeSetPtr) -> xmlNodeSetPtr;
}
unsafe extern "C" {
  pub fn xmlXPathIntersection(nodes1: xmlNodeSetPtr, nodes2: xmlNodeSetPtr) -> xmlNodeSetPtr;
}
unsafe extern "C" {
  pub fn xmlXPathDistinctSorted(nodes: xmlNodeSetPtr) -> xmlNodeSetPtr;
}
unsafe extern "C" {
  pub fn xmlXPathDistinct(nodes: xmlNodeSetPtr) -> xmlNodeSetPtr;
}
unsafe extern "C" {
  pub fn xmlXPathHasSameNodes(
    nodes1: xmlNodeSetPtr,
    nodes2: xmlNodeSetPtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathNodeLeadingSorted(nodes: xmlNodeSetPtr, node: xmlNodePtr) -> xmlNodeSetPtr;
}
unsafe extern "C" {
  pub fn xmlXPathLeadingSorted(nodes1: xmlNodeSetPtr, nodes2: xmlNodeSetPtr) -> xmlNodeSetPtr;
}
unsafe extern "C" {
  pub fn xmlXPathNodeLeading(nodes: xmlNodeSetPtr, node: xmlNodePtr) -> xmlNodeSetPtr;
}
unsafe extern "C" {
  pub fn xmlXPathLeading(nodes1: xmlNodeSetPtr, nodes2: xmlNodeSetPtr) -> xmlNodeSetPtr;
}
unsafe extern "C" {
  pub fn xmlXPathNodeTrailingSorted(nodes: xmlNodeSetPtr, node: xmlNodePtr) -> xmlNodeSetPtr;
}
unsafe extern "C" {
  pub fn xmlXPathTrailingSorted(nodes1: xmlNodeSetPtr, nodes2: xmlNodeSetPtr) -> xmlNodeSetPtr;
}
unsafe extern "C" {
  pub fn xmlXPathNodeTrailing(nodes: xmlNodeSetPtr, node: xmlNodePtr) -> xmlNodeSetPtr;
}
unsafe extern "C" {
  pub fn xmlXPathTrailing(nodes1: xmlNodeSetPtr, nodes2: xmlNodeSetPtr) -> xmlNodeSetPtr;
}
unsafe extern "C" {
  #[doc = " Extending a context."]
  pub fn xmlXPathRegisterNs(
    ctxt: xmlXPathContextPtr,
    prefix: *const xmlChar,
    ns_uri: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathNsLookup(ctxt: xmlXPathContextPtr, prefix: *const xmlChar) -> *const xmlChar;
}
unsafe extern "C" {
  pub fn xmlXPathRegisteredNsCleanup(ctxt: xmlXPathContextPtr);
}
unsafe extern "C" {
  pub fn xmlXPathRegisterFunc(
    ctxt: xmlXPathContextPtr,
    name: *const xmlChar,
    f: xmlXPathFunction,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathRegisterFuncNS(
    ctxt: xmlXPathContextPtr,
    name: *const xmlChar,
    ns_uri: *const xmlChar,
    f: xmlXPathFunction,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathRegisterVariable(
    ctxt: xmlXPathContextPtr,
    name: *const xmlChar,
    value: xmlXPathObjectPtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathRegisterVariableNS(
    ctxt: xmlXPathContextPtr,
    name: *const xmlChar,
    ns_uri: *const xmlChar,
    value: xmlXPathObjectPtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathFunctionLookup(ctxt: xmlXPathContextPtr, name: *const xmlChar)
    -> xmlXPathFunction;
}
unsafe extern "C" {
  pub fn xmlXPathFunctionLookupNS(
    ctxt: xmlXPathContextPtr,
    name: *const xmlChar,
    ns_uri: *const xmlChar,
  ) -> xmlXPathFunction;
}
unsafe extern "C" {
  pub fn xmlXPathRegisteredFuncsCleanup(ctxt: xmlXPathContextPtr);
}
unsafe extern "C" {
  pub fn xmlXPathVariableLookup(
    ctxt: xmlXPathContextPtr,
    name: *const xmlChar,
  ) -> xmlXPathObjectPtr;
}
unsafe extern "C" {
  pub fn xmlXPathVariableLookupNS(
    ctxt: xmlXPathContextPtr,
    name: *const xmlChar,
    ns_uri: *const xmlChar,
  ) -> xmlXPathObjectPtr;
}
unsafe extern "C" {
  pub fn xmlXPathRegisteredVariablesCleanup(ctxt: xmlXPathContextPtr);
}
unsafe extern "C" {
  #[doc = " Utilities to extend XPath."]
  pub fn xmlXPathNewParserContext(
    str_: *const xmlChar,
    ctxt: xmlXPathContextPtr,
  ) -> xmlXPathParserContextPtr;
}
unsafe extern "C" {
  pub fn xmlXPathFreeParserContext(ctxt: xmlXPathParserContextPtr);
}
unsafe extern "C" {
  pub fn valuePop(ctxt: xmlXPathParserContextPtr) -> xmlXPathObjectPtr;
}
unsafe extern "C" {
  pub fn valuePush(
    ctxt: xmlXPathParserContextPtr,
    value: xmlXPathObjectPtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathNewString(val: *const xmlChar) -> xmlXPathObjectPtr;
}
unsafe extern "C" {
  pub fn xmlXPathNewCString(val: *const ::std::os::raw::c_char) -> xmlXPathObjectPtr;
}
unsafe extern "C" {
  pub fn xmlXPathWrapString(val: *mut xmlChar) -> xmlXPathObjectPtr;
}
unsafe extern "C" {
  pub fn xmlXPathWrapCString(val: *mut ::std::os::raw::c_char) -> xmlXPathObjectPtr;
}
unsafe extern "C" {
  pub fn xmlXPathNewFloat(val: f64) -> xmlXPathObjectPtr;
}
unsafe extern "C" {
  pub fn xmlXPathNewBoolean(val: ::std::os::raw::c_int) -> xmlXPathObjectPtr;
}
unsafe extern "C" {
  pub fn xmlXPathNewNodeSet(val: xmlNodePtr) -> xmlXPathObjectPtr;
}
unsafe extern "C" {
  pub fn xmlXPathNewValueTree(val: xmlNodePtr) -> xmlXPathObjectPtr;
}
unsafe extern "C" {
  pub fn xmlXPathNodeSetAdd(cur: xmlNodeSetPtr, val: xmlNodePtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathNodeSetAddUnique(cur: xmlNodeSetPtr, val: xmlNodePtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathNodeSetAddNs(
    cur: xmlNodeSetPtr,
    node: xmlNodePtr,
    ns: xmlNsPtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathNodeSetSort(set: xmlNodeSetPtr);
}
unsafe extern "C" {
  pub fn xmlXPathRoot(ctxt: xmlXPathParserContextPtr);
}
unsafe extern "C" {
  pub fn xmlXPathEvalExpr(ctxt: xmlXPathParserContextPtr);
}
unsafe extern "C" {
  pub fn xmlXPathParseName(ctxt: xmlXPathParserContextPtr) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlXPathParseNCName(ctxt: xmlXPathParserContextPtr) -> *mut xmlChar;
}
unsafe extern "C" {
  pub fn xmlXPathStringEvalNumber(str_: *const xmlChar) -> f64;
}
unsafe extern "C" {
  pub fn xmlXPathEvaluatePredicateResult(
    ctxt: xmlXPathParserContextPtr,
    res: xmlXPathObjectPtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathRegisterAllFunctions(ctxt: xmlXPathContextPtr);
}
unsafe extern "C" {
  pub fn xmlXPathNodeSetMerge(val1: xmlNodeSetPtr, val2: xmlNodeSetPtr) -> xmlNodeSetPtr;
}
unsafe extern "C" {
  pub fn xmlXPathNodeSetDel(cur: xmlNodeSetPtr, val: xmlNodePtr);
}
unsafe extern "C" {
  pub fn xmlXPathNodeSetRemove(cur: xmlNodeSetPtr, val: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathNewNodeSetList(val: xmlNodeSetPtr) -> xmlXPathObjectPtr;
}
unsafe extern "C" {
  pub fn xmlXPathWrapNodeSet(val: xmlNodeSetPtr) -> xmlXPathObjectPtr;
}
unsafe extern "C" {
  pub fn xmlXPathWrapExternal(val: *mut ::std::os::raw::c_void) -> xmlXPathObjectPtr;
}
unsafe extern "C" {
  pub fn xmlXPathEqualValues(ctxt: xmlXPathParserContextPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathNotEqualValues(ctxt: xmlXPathParserContextPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathCompareValues(
    ctxt: xmlXPathParserContextPtr,
    inf: ::std::os::raw::c_int,
    strict: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathValueFlipSign(ctxt: xmlXPathParserContextPtr);
}
unsafe extern "C" {
  pub fn xmlXPathAddValues(ctxt: xmlXPathParserContextPtr);
}
unsafe extern "C" {
  pub fn xmlXPathSubValues(ctxt: xmlXPathParserContextPtr);
}
unsafe extern "C" {
  pub fn xmlXPathMultValues(ctxt: xmlXPathParserContextPtr);
}
unsafe extern "C" {
  pub fn xmlXPathDivValues(ctxt: xmlXPathParserContextPtr);
}
unsafe extern "C" {
  pub fn xmlXPathModValues(ctxt: xmlXPathParserContextPtr);
}
unsafe extern "C" {
  pub fn xmlXPathIsNodeType(name: *const xmlChar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlXPathNextSelf(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlXPathNextChild(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlXPathNextDescendant(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlXPathNextDescendantOrSelf(
    ctxt: xmlXPathParserContextPtr,
    cur: xmlNodePtr,
  ) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlXPathNextParent(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlXPathNextAncestorOrSelf(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlXPathNextFollowingSibling(
    ctxt: xmlXPathParserContextPtr,
    cur: xmlNodePtr,
  ) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlXPathNextFollowing(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlXPathNextNamespace(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlXPathNextAttribute(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlXPathNextPreceding(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlXPathNextAncestor(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlXPathNextPrecedingSibling(
    ctxt: xmlXPathParserContextPtr,
    cur: xmlNodePtr,
  ) -> xmlNodePtr;
}
unsafe extern "C" {
  pub fn xmlXPathLastFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathPositionFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathCountFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathIdFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathLocalNameFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathNamespaceURIFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathStringFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathStringLengthFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathConcatFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathContainsFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathStartsWithFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathSubstringFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathSubstringBeforeFunction(
    ctxt: xmlXPathParserContextPtr,
    nargs: ::std::os::raw::c_int,
  );
}
unsafe extern "C" {
  pub fn xmlXPathSubstringAfterFunction(
    ctxt: xmlXPathParserContextPtr,
    nargs: ::std::os::raw::c_int,
  );
}
unsafe extern "C" {
  pub fn xmlXPathNormalizeFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathTranslateFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathNotFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathTrueFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathFalseFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathLangFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathNumberFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathSumFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathFloorFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathCeilingFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathRoundFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  pub fn xmlXPathBooleanFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
unsafe extern "C" {
  #[doc = " Really internal functions"]
  pub fn xmlXPathNodeSetFreeNs(ns: xmlNsPtr);
}
pub const xmlSaveOption_XML_SAVE_FORMAT: xmlSaveOption = 1;
pub const xmlSaveOption_XML_SAVE_NO_DECL: xmlSaveOption = 2;
pub const xmlSaveOption_XML_SAVE_NO_EMPTY: xmlSaveOption = 4;
pub const xmlSaveOption_XML_SAVE_NO_XHTML: xmlSaveOption = 8;
pub const xmlSaveOption_XML_SAVE_XHTML: xmlSaveOption = 16;
pub const xmlSaveOption_XML_SAVE_AS_XML: xmlSaveOption = 32;
pub const xmlSaveOption_XML_SAVE_AS_HTML: xmlSaveOption = 64;
pub const xmlSaveOption_XML_SAVE_WSNONSIG: xmlSaveOption = 128;
#[doc = " xmlSaveOption:\n\n This is the set of XML save options that can be passed down\n to the xmlSaveToFd() and similar calls."]
pub type xmlSaveOption = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSaveCtxt {
  _unused: [u8; 0],
}
pub type xmlSaveCtxt = _xmlSaveCtxt;
pub type xmlSaveCtxtPtr = *mut xmlSaveCtxt;
unsafe extern "C" {
  pub fn xmlSaveToFd(
    fd: ::std::os::raw::c_int,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlSaveCtxtPtr;
}
unsafe extern "C" {
  pub fn xmlSaveToFilename(
    filename: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlSaveCtxtPtr;
}
unsafe extern "C" {
  pub fn xmlSaveToBuffer(
    buffer: xmlBufferPtr,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlSaveCtxtPtr;
}
unsafe extern "C" {
  pub fn xmlSaveToIO(
    iowrite: xmlOutputWriteCallback,
    ioclose: xmlOutputCloseCallback,
    ioctx: *mut ::std::os::raw::c_void,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlSaveCtxtPtr;
}
unsafe extern "C" {
  pub fn xmlSaveDoc(ctxt: xmlSaveCtxtPtr, doc: xmlDocPtr) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
  pub fn xmlSaveTree(ctxt: xmlSaveCtxtPtr, node: xmlNodePtr) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
  pub fn xmlSaveFlush(ctxt: xmlSaveCtxtPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSaveClose(ctxt: xmlSaveCtxtPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSaveSetEscape(
    ctxt: xmlSaveCtxtPtr,
    escape: xmlCharEncodingOutputFunc,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSaveSetAttrEscape(
    ctxt: xmlSaveCtxtPtr,
    escape: xmlCharEncodingOutputFunc,
  ) -> ::std::os::raw::c_int;
}
#[doc = " xmlParserCtxt:\n\n The parser context.\n NOTE This doesn't completely define the parser state, the (current ?)\n      design of the parser uses recursive function calls since this allow\n      and easy mapping from the production rules of the specification\n      to the actual code. The drawback is that the actual function call\n      also reflect the parser state. However most of the parsing routines\n      takes as the only argument the parser context pointer, so migrating\n      to a state based parser for progressive parsing shouldn't be too hard."]
pub type htmlParserCtxt = xmlParserCtxt;
pub type htmlParserCtxtPtr = xmlParserCtxtPtr;
pub type htmlParserNodeInfo = xmlParserNodeInfo;
pub type htmlSAXHandler = xmlSAXHandler;
pub type htmlSAXHandlerPtr = xmlSAXHandlerPtr;
pub type htmlParserInput = xmlParserInput;
pub type htmlParserInputPtr = xmlParserInputPtr;
pub type htmlDocPtr = xmlDocPtr;
pub type htmlNodePtr = xmlNodePtr;
pub type htmlElemDesc = _htmlElemDesc;
pub type htmlElemDescPtr = *mut htmlElemDesc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _htmlElemDesc {
  pub name: *const ::std::os::raw::c_char,
  pub startTag: ::std::os::raw::c_char,
  pub endTag: ::std::os::raw::c_char,
  pub saveEndTag: ::std::os::raw::c_char,
  pub empty: ::std::os::raw::c_char,
  pub depr: ::std::os::raw::c_char,
  pub dtd: ::std::os::raw::c_char,
  pub isinline: ::std::os::raw::c_char,
  pub desc: *const ::std::os::raw::c_char,
  pub subelts: *mut *const ::std::os::raw::c_char,
  pub defaultsubelt: *const ::std::os::raw::c_char,
  pub attrs_opt: *mut *const ::std::os::raw::c_char,
  pub attrs_depr: *mut *const ::std::os::raw::c_char,
  pub attrs_req: *mut *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _htmlElemDesc"][::std::mem::size_of::<_htmlElemDesc>() - 64usize];
  ["Alignment of _htmlElemDesc"][::std::mem::align_of::<_htmlElemDesc>() - 8usize];
  ["Offset of field: _htmlElemDesc::name"][::std::mem::offset_of!(_htmlElemDesc, name) - 0usize];
  ["Offset of field: _htmlElemDesc::startTag"]
    [::std::mem::offset_of!(_htmlElemDesc, startTag) - 8usize];
  ["Offset of field: _htmlElemDesc::endTag"]
    [::std::mem::offset_of!(_htmlElemDesc, endTag) - 9usize];
  ["Offset of field: _htmlElemDesc::saveEndTag"]
    [::std::mem::offset_of!(_htmlElemDesc, saveEndTag) - 10usize];
  ["Offset of field: _htmlElemDesc::empty"][::std::mem::offset_of!(_htmlElemDesc, empty) - 11usize];
  ["Offset of field: _htmlElemDesc::depr"][::std::mem::offset_of!(_htmlElemDesc, depr) - 12usize];
  ["Offset of field: _htmlElemDesc::dtd"][::std::mem::offset_of!(_htmlElemDesc, dtd) - 13usize];
  ["Offset of field: _htmlElemDesc::isinline"]
    [::std::mem::offset_of!(_htmlElemDesc, isinline) - 14usize];
  ["Offset of field: _htmlElemDesc::desc"][::std::mem::offset_of!(_htmlElemDesc, desc) - 16usize];
  ["Offset of field: _htmlElemDesc::subelts"]
    [::std::mem::offset_of!(_htmlElemDesc, subelts) - 24usize];
  ["Offset of field: _htmlElemDesc::defaultsubelt"]
    [::std::mem::offset_of!(_htmlElemDesc, defaultsubelt) - 32usize];
  ["Offset of field: _htmlElemDesc::attrs_opt"]
    [::std::mem::offset_of!(_htmlElemDesc, attrs_opt) - 40usize];
  ["Offset of field: _htmlElemDesc::attrs_depr"]
    [::std::mem::offset_of!(_htmlElemDesc, attrs_depr) - 48usize];
  ["Offset of field: _htmlElemDesc::attrs_req"]
    [::std::mem::offset_of!(_htmlElemDesc, attrs_req) - 56usize];
};
pub type htmlEntityDesc = _htmlEntityDesc;
pub type htmlEntityDescPtr = *mut htmlEntityDesc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _htmlEntityDesc {
  pub value: ::std::os::raw::c_uint,
  pub name: *const ::std::os::raw::c_char,
  pub desc: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of _htmlEntityDesc"][::std::mem::size_of::<_htmlEntityDesc>() - 24usize];
  ["Alignment of _htmlEntityDesc"][::std::mem::align_of::<_htmlEntityDesc>() - 8usize];
  ["Offset of field: _htmlEntityDesc::value"]
    [::std::mem::offset_of!(_htmlEntityDesc, value) - 0usize];
  ["Offset of field: _htmlEntityDesc::name"]
    [::std::mem::offset_of!(_htmlEntityDesc, name) - 8usize];
  ["Offset of field: _htmlEntityDesc::desc"]
    [::std::mem::offset_of!(_htmlEntityDesc, desc) - 16usize];
};
unsafe extern "C" {
  pub fn htmlTagLookup(tag: *const xmlChar) -> *const htmlElemDesc;
}
unsafe extern "C" {
  pub fn htmlEntityLookup(name: *const xmlChar) -> *const htmlEntityDesc;
}
unsafe extern "C" {
  pub fn htmlEntityValueLookup(value: ::std::os::raw::c_uint) -> *const htmlEntityDesc;
}
unsafe extern "C" {
  pub fn htmlIsAutoClosed(doc: htmlDocPtr, elem: htmlNodePtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn htmlAutoCloseTag(
    doc: htmlDocPtr,
    name: *const xmlChar,
    elem: htmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn htmlParseEntityRef(
    ctxt: htmlParserCtxtPtr,
    str_: *mut *const xmlChar,
  ) -> *const htmlEntityDesc;
}
unsafe extern "C" {
  pub fn htmlParseCharRef(ctxt: htmlParserCtxtPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn htmlParseElement(ctxt: htmlParserCtxtPtr);
}
unsafe extern "C" {
  pub fn htmlNewParserCtxt() -> htmlParserCtxtPtr;
}
unsafe extern "C" {
  pub fn htmlCreateMemoryParserCtxt(
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
  ) -> htmlParserCtxtPtr;
}
unsafe extern "C" {
  pub fn htmlParseDocument(ctxt: htmlParserCtxtPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn htmlSAXParseDoc(
    cur: *const xmlChar,
    encoding: *const ::std::os::raw::c_char,
    sax: htmlSAXHandlerPtr,
    userData: *mut ::std::os::raw::c_void,
  ) -> htmlDocPtr;
}
unsafe extern "C" {
  pub fn htmlParseDoc(cur: *const xmlChar, encoding: *const ::std::os::raw::c_char) -> htmlDocPtr;
}
unsafe extern "C" {
  pub fn htmlSAXParseFile(
    filename: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    sax: htmlSAXHandlerPtr,
    userData: *mut ::std::os::raw::c_void,
  ) -> htmlDocPtr;
}
unsafe extern "C" {
  pub fn htmlParseFile(
    filename: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
  ) -> htmlDocPtr;
}
unsafe extern "C" {
  pub fn UTF8ToHtml(
    out: *mut ::std::os::raw::c_uchar,
    outlen: *mut ::std::os::raw::c_int,
    in_: *const ::std::os::raw::c_uchar,
    inlen: *mut ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn htmlEncodeEntities(
    out: *mut ::std::os::raw::c_uchar,
    outlen: *mut ::std::os::raw::c_int,
    in_: *const ::std::os::raw::c_uchar,
    inlen: *mut ::std::os::raw::c_int,
    quoteChar: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn htmlIsScriptAttribute(name: *const xmlChar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn htmlHandleOmittedElem(val: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  #[doc = " Interfaces for the Push mode."]
  pub fn htmlCreatePushParserCtxt(
    sax: htmlSAXHandlerPtr,
    user_data: *mut ::std::os::raw::c_void,
    chunk: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    filename: *const ::std::os::raw::c_char,
    enc: xmlCharEncoding,
  ) -> htmlParserCtxtPtr;
}
unsafe extern "C" {
  pub fn htmlParseChunk(
    ctxt: htmlParserCtxtPtr,
    chunk: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    terminate: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn htmlFreeParserCtxt(ctxt: htmlParserCtxtPtr);
}
pub const htmlParserOption_HTML_PARSE_RECOVER: htmlParserOption = 1;
pub const htmlParserOption_HTML_PARSE_NODEFDTD: htmlParserOption = 4;
pub const htmlParserOption_HTML_PARSE_NOERROR: htmlParserOption = 32;
pub const htmlParserOption_HTML_PARSE_NOWARNING: htmlParserOption = 64;
pub const htmlParserOption_HTML_PARSE_PEDANTIC: htmlParserOption = 128;
pub const htmlParserOption_HTML_PARSE_NOBLANKS: htmlParserOption = 256;
pub const htmlParserOption_HTML_PARSE_NONET: htmlParserOption = 2048;
pub const htmlParserOption_HTML_PARSE_NOIMPLIED: htmlParserOption = 8192;
pub const htmlParserOption_HTML_PARSE_COMPACT: htmlParserOption = 65536;
pub const htmlParserOption_HTML_PARSE_IGNORE_ENC: htmlParserOption = 2097152;
#[doc = " xmlParserOption:\n\n This is the set of XML parser options that can be passed down\n to the xmlReadDoc() and similar calls."]
pub type htmlParserOption = ::std::os::raw::c_uint;
unsafe extern "C" {
  pub fn htmlCtxtReset(ctxt: htmlParserCtxtPtr);
}
unsafe extern "C" {
  pub fn htmlCtxtUseOptions(
    ctxt: htmlParserCtxtPtr,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn htmlReadDoc(
    cur: *const xmlChar,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> htmlDocPtr;
}
unsafe extern "C" {
  pub fn htmlReadFile(
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> htmlDocPtr;
}
unsafe extern "C" {
  pub fn htmlReadMemory(
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> htmlDocPtr;
}
unsafe extern "C" {
  pub fn htmlReadFd(
    fd: ::std::os::raw::c_int,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> htmlDocPtr;
}
unsafe extern "C" {
  pub fn htmlReadIO(
    ioread: xmlInputReadCallback,
    ioclose: xmlInputCloseCallback,
    ioctx: *mut ::std::os::raw::c_void,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> htmlDocPtr;
}
unsafe extern "C" {
  pub fn htmlCtxtReadDoc(
    ctxt: xmlParserCtxtPtr,
    cur: *const xmlChar,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> htmlDocPtr;
}
unsafe extern "C" {
  pub fn htmlCtxtReadFile(
    ctxt: xmlParserCtxtPtr,
    filename: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> htmlDocPtr;
}
unsafe extern "C" {
  pub fn htmlCtxtReadMemory(
    ctxt: xmlParserCtxtPtr,
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> htmlDocPtr;
}
unsafe extern "C" {
  pub fn htmlCtxtReadFd(
    ctxt: xmlParserCtxtPtr,
    fd: ::std::os::raw::c_int,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> htmlDocPtr;
}
unsafe extern "C" {
  pub fn htmlCtxtReadIO(
    ctxt: xmlParserCtxtPtr,
    ioread: xmlInputReadCallback,
    ioclose: xmlInputCloseCallback,
    ioctx: *mut ::std::os::raw::c_void,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> htmlDocPtr;
}
pub const htmlStatus_HTML_NA: htmlStatus = 0;
pub const htmlStatus_HTML_INVALID: htmlStatus = 1;
pub const htmlStatus_HTML_DEPRECATED: htmlStatus = 2;
pub const htmlStatus_HTML_VALID: htmlStatus = 4;
pub const htmlStatus_HTML_REQUIRED: htmlStatus = 12;
pub type htmlStatus = ::std::os::raw::c_uint;
unsafe extern "C" {
  pub fn htmlAttrAllowed(
    arg1: *const htmlElemDesc,
    arg2: *const xmlChar,
    arg3: ::std::os::raw::c_int,
  ) -> htmlStatus;
}
unsafe extern "C" {
  pub fn htmlElementAllowedHere(
    arg1: *const htmlElemDesc,
    arg2: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn htmlElementStatusHere(arg1: *const htmlElemDesc, arg2: *const htmlElemDesc) -> htmlStatus;
}
unsafe extern "C" {
  pub fn htmlNodeStatus(arg1: htmlNodePtr, arg2: ::std::os::raw::c_int) -> htmlStatus;
}
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_OK: xmlSchemaValidError = 0;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_NOROOT: xmlSchemaValidError = 1;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_UNDECLAREDELEM: xmlSchemaValidError = 2;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_NOTTOPLEVEL: xmlSchemaValidError = 3;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_MISSING: xmlSchemaValidError = 4;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_WRONGELEM: xmlSchemaValidError = 5;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_NOTYPE: xmlSchemaValidError = 6;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_NOROLLBACK: xmlSchemaValidError = 7;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_ISABSTRACT: xmlSchemaValidError = 8;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_NOTEMPTY: xmlSchemaValidError = 9;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_ELEMCONT: xmlSchemaValidError = 10;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_HAVEDEFAULT: xmlSchemaValidError = 11;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_NOTNILLABLE: xmlSchemaValidError = 12;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_EXTRACONTENT: xmlSchemaValidError = 13;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_INVALIDATTR: xmlSchemaValidError = 14;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_INVALIDELEM: xmlSchemaValidError = 15;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_NOTDETERMINIST: xmlSchemaValidError = 16;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_CONSTRUCT: xmlSchemaValidError = 17;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_INTERNAL: xmlSchemaValidError = 18;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_NOTSIMPLE: xmlSchemaValidError = 19;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_ATTRUNKNOWN: xmlSchemaValidError = 20;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_ATTRINVALID: xmlSchemaValidError = 21;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_VALUE: xmlSchemaValidError = 22;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_FACET: xmlSchemaValidError = 23;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_: xmlSchemaValidError = 24;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_XXX: xmlSchemaValidError = 25;
#[doc = " This error codes are obsolete; not used any more."]
pub type xmlSchemaValidError = ::std::os::raw::c_uint;
pub const xmlSchemaValidOption_XML_SCHEMA_VAL_VC_I_CREATE: xmlSchemaValidOption = 1;
#[doc = " xmlSchemaValidOption:\n\n This is the set of XML Schema validation options."]
pub type xmlSchemaValidOption = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchema {
  _unused: [u8; 0],
}
#[doc = " The schemas related types are kept internal"]
pub type xmlSchema = _xmlSchema;
pub type xmlSchemaPtr = *mut xmlSchema;
#[doc = " xmlSchemaValidityErrorFunc:\n @ctx: the validation context\n @msg: the message\n @...: extra arguments\n\n Signature of an error callback from an XSD validation"]
pub type xmlSchemaValidityErrorFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
#[doc = " xmlSchemaValidityWarningFunc:\n @ctx: the validation context\n @msg: the message\n @...: extra arguments\n\n Signature of a warning callback from an XSD validation"]
pub type xmlSchemaValidityWarningFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchemaParserCtxt {
  _unused: [u8; 0],
}
#[doc = " A schemas validation context"]
pub type xmlSchemaParserCtxt = _xmlSchemaParserCtxt;
pub type xmlSchemaParserCtxtPtr = *mut xmlSchemaParserCtxt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchemaValidCtxt {
  _unused: [u8; 0],
}
pub type xmlSchemaValidCtxt = _xmlSchemaValidCtxt;
pub type xmlSchemaValidCtxtPtr = *mut xmlSchemaValidCtxt;
#[doc = " xmlSchemaValidityLocatorFunc:\n @ctx: user provided context\n @file: returned file information\n @line: returned line information\n\n A schemas validation locator, a callback called by the validator.\n This is used when file or node information are not available\n to find out what file and line number are affected\n\n Returns: 0 in case of success and -1 in case of error"]
pub type xmlSchemaValidityLocatorFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    file: *mut *const ::std::os::raw::c_char,
    line: *mut ::std::os::raw::c_ulong,
  ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
  pub fn xmlSchemaNewParserCtxt(URL: *const ::std::os::raw::c_char) -> xmlSchemaParserCtxtPtr;
}
unsafe extern "C" {
  pub fn xmlSchemaNewMemParserCtxt(
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
  ) -> xmlSchemaParserCtxtPtr;
}
unsafe extern "C" {
  pub fn xmlSchemaNewDocParserCtxt(doc: xmlDocPtr) -> xmlSchemaParserCtxtPtr;
}
unsafe extern "C" {
  pub fn xmlSchemaFreeParserCtxt(ctxt: xmlSchemaParserCtxtPtr);
}
unsafe extern "C" {
  pub fn xmlSchemaSetParserErrors(
    ctxt: xmlSchemaParserCtxtPtr,
    err: xmlSchemaValidityErrorFunc,
    warn: xmlSchemaValidityWarningFunc,
    ctx: *mut ::std::os::raw::c_void,
  );
}
unsafe extern "C" {
  pub fn xmlSchemaSetParserStructuredErrors(
    ctxt: xmlSchemaParserCtxtPtr,
    serror: xmlStructuredErrorFunc,
    ctx: *mut ::std::os::raw::c_void,
  );
}
unsafe extern "C" {
  pub fn xmlSchemaGetParserErrors(
    ctxt: xmlSchemaParserCtxtPtr,
    err: *mut xmlSchemaValidityErrorFunc,
    warn: *mut xmlSchemaValidityWarningFunc,
    ctx: *mut *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSchemaIsValid(ctxt: xmlSchemaValidCtxtPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSchemaInitTypes();
}
unsafe extern "C" {
  pub fn xmlSchemaParse(ctxt: xmlSchemaParserCtxtPtr) -> xmlSchemaPtr;
}
unsafe extern "C" {
  pub fn xmlSchemaFree(schema: xmlSchemaPtr);
}
unsafe extern "C" {
  pub fn xmlSchemaDump(output: *mut FILE, schema: xmlSchemaPtr);
}
unsafe extern "C" {
  pub fn xmlSchemaSetValidErrors(
    ctxt: xmlSchemaValidCtxtPtr,
    err: xmlSchemaValidityErrorFunc,
    warn: xmlSchemaValidityWarningFunc,
    ctx: *mut ::std::os::raw::c_void,
  );
}
unsafe extern "C" {
  pub fn xmlSchemaSetValidStructuredErrors(
    ctxt: xmlSchemaValidCtxtPtr,
    serror: xmlStructuredErrorFunc,
    ctx: *mut ::std::os::raw::c_void,
  );
}
unsafe extern "C" {
  pub fn xmlSchemaGetValidErrors(
    ctxt: xmlSchemaValidCtxtPtr,
    err: *mut xmlSchemaValidityErrorFunc,
    warn: *mut xmlSchemaValidityWarningFunc,
    ctx: *mut *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSchemaSetValidOptions(
    ctxt: xmlSchemaValidCtxtPtr,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSchemaValidateSetFilename(
    vctxt: xmlSchemaValidCtxtPtr,
    filename: *const ::std::os::raw::c_char,
  );
}
unsafe extern "C" {
  pub fn xmlSchemaValidCtxtGetOptions(ctxt: xmlSchemaValidCtxtPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSchemaNewValidCtxt(schema: xmlSchemaPtr) -> xmlSchemaValidCtxtPtr;
}
unsafe extern "C" {
  pub fn xmlSchemaFreeValidCtxt(ctxt: xmlSchemaValidCtxtPtr);
}
unsafe extern "C" {
  pub fn xmlSchemaValidateDoc(
    ctxt: xmlSchemaValidCtxtPtr,
    instance: xmlDocPtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSchemaValidateOneElement(
    ctxt: xmlSchemaValidCtxtPtr,
    elem: xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSchemaValidateStream(
    ctxt: xmlSchemaValidCtxtPtr,
    input: xmlParserInputBufferPtr,
    enc: xmlCharEncoding,
    sax: xmlSAXHandlerPtr,
    user_data: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSchemaValidateFile(
    ctxt: xmlSchemaValidCtxtPtr,
    filename: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSchemaValidCtxtGetParserCtxt(ctxt: xmlSchemaValidCtxtPtr) -> xmlParserCtxtPtr;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchemaSAXPlug {
  _unused: [u8; 0],
}
pub type xmlSchemaSAXPlugStruct = _xmlSchemaSAXPlug;
pub type xmlSchemaSAXPlugPtr = *mut xmlSchemaSAXPlugStruct;
unsafe extern "C" {
  pub fn xmlSchemaSAXPlug(
    ctxt: xmlSchemaValidCtxtPtr,
    sax: *mut xmlSAXHandlerPtr,
    user_data: *mut *mut ::std::os::raw::c_void,
  ) -> xmlSchemaSAXPlugPtr;
}
unsafe extern "C" {
  pub fn xmlSchemaSAXUnplug(plug: xmlSchemaSAXPlugPtr) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
  pub fn xmlSchemaValidateSetLocator(
    vctxt: xmlSchemaValidCtxtPtr,
    f: xmlSchemaValidityLocatorFunc,
    ctxt: *mut ::std::os::raw::c_void,
  );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
  pub gp_offset: ::std::os::raw::c_uint,
  pub fp_offset: ::std::os::raw::c_uint,
  pub overflow_arg_area: *mut ::std::os::raw::c_void,
  pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
  ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
  ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
  ["Offset of field: __va_list_tag::gp_offset"]
    [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
  ["Offset of field: __va_list_tag::fp_offset"]
    [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
  ["Offset of field: __va_list_tag::overflow_arg_area"]
    [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
  ["Offset of field: __va_list_tag::reg_save_area"]
    [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
