#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

/* automatically generated by rust-bindgen */

pub const LIBXML_DOTTED_VERSION: &'static [u8; 6usize] = b"2.9.4\0";
pub const LIBXML_VERSION: u32 = 20904;
pub const LIBXML_VERSION_STRING: &'static [u8; 6usize] = b"20904\0";
pub const LIBXML_VERSION_EXTRA: &'static [u8; 1usize] = b"\0";
pub const LIBXML_MODULE_EXTENSION: &'static [u8; 4usize] = b".so\0";
pub const __GNUC_VA_LIST: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const _BITS_LIBIO_H: u32 = 1;
pub const _BITS_G_CONFIG_H: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const BASE_BUFFER_SIZE: u32 = 4096;
pub const XML_DEFAULT_VERSION: &'static [u8; 4usize] = b"1.0\0";
pub const XML_DETECT_IDS: u32 = 2;
pub const XML_COMPLETE_ATTRS: u32 = 4;
pub const XML_SKIP_IDS: u32 = 8;
pub const XML_SAX2_MAGIC: u32 = 3740122799;
pub const _ICONV_H: u32 = 1;
pub const U_DEBUG: u32 = 0;
pub const UCLN_NO_AUTO_CLEANUP: u32 = 1;
pub const U_DISABLE_RENAMING: u32 = 0;
pub const U_NO_DEFAULT_INCLUDE_UTF_HEADERS: u32 = 0;
pub const U_OVERRIDE_CXX_ALLOCATION: u32 = 1;
pub const U_ENABLE_TRACING: u32 = 0;
pub const UCONFIG_ENABLE_PLUGINS: u32 = 0;
pub const U_ENABLE_DYLOAD: u32 = 1;
pub const U_CHECK_DYLOAD: u32 = 1;
pub const U_DEFAULT_SHOW_DRAFT: u32 = 1;
pub const U_LIB_SUFFIX_C_NAME_STRING: &'static [u8; 1usize] = b"\0";
pub const UCONFIG_ONLY_COLLATION: u32 = 0;
pub const UCONFIG_NO_FILE_IO: u32 = 0;
pub const UCONFIG_NO_CONVERSION: u32 = 0;
pub const UCONFIG_ONLY_HTML_CONVERSION: u32 = 0;
pub const UCONFIG_NO_LEGACY_CONVERSION: u32 = 0;
pub const UCONFIG_NO_NORMALIZATION: u32 = 0;
pub const UCONFIG_NO_BREAK_ITERATION: u32 = 0;
pub const UCONFIG_NO_IDNA: u32 = 0;
pub const UCONFIG_NO_COLLATION: u32 = 0;
pub const UCONFIG_NO_FORMATTING: u32 = 0;
pub const UCONFIG_NO_TRANSLITERATION: u32 = 0;
pub const UCONFIG_NO_REGULAR_EXPRESSIONS: u32 = 0;
pub const UCONFIG_NO_SERVICE: u32 = 0;
pub const UCONFIG_HAVE_PARSEALLINPUT: u32 = 1;
pub const UCONFIG_FORMAT_FASTPATHS_49: u32 = 1;
pub const UCONFIG_NO_FILTERED_BREAK_ITERATION: u32 = 0;
pub const U_COPYRIGHT_STRING : & 'static [ u8 ; 120usize ] = b" Copyright (C) 2016 and later: Unicode, Inc. and others. License & terms of use: http://www.unicode.org/copyright.html \0" ;
pub const U_ICU_VERSION_MAJOR_NUM: u32 = 60;
pub const U_ICU_VERSION_MINOR_NUM: u32 = 2;
pub const U_ICU_VERSION_PATCHLEVEL_NUM: u32 = 0;
pub const U_ICU_VERSION_BUILDLEVEL_NUM: u32 = 0;
pub const U_ICU_VERSION: &'static [u8; 5usize] = b"60.2\0";
pub const U_ICU_VERSION_SHORT: &'static [u8; 3usize] = b"60\0";
pub const U_ICU_DATA_VERSION: &'static [u8; 5usize] = b"60.2\0";
pub const UCOL_RUNTIME_VERSION: u32 = 9;
pub const UCOL_BUILDER_VERSION: u32 = 9;
pub const UCOL_TAILORINGS_VERSION: u32 = 1;
pub const U_PF_UNKNOWN: u32 = 0;
pub const U_PF_WINDOWS: u32 = 1000;
pub const U_PF_MINGW: u32 = 1800;
pub const U_PF_CYGWIN: u32 = 1900;
pub const U_PF_HPUX: u32 = 2100;
pub const U_PF_SOLARIS: u32 = 2600;
pub const U_PF_BSD: u32 = 3000;
pub const U_PF_AIX: u32 = 3100;
pub const U_PF_IRIX: u32 = 3200;
pub const U_PF_DARWIN: u32 = 3500;
pub const U_PF_IPHONE: u32 = 3550;
pub const U_PF_QNX: u32 = 3700;
pub const U_PF_LINUX: u32 = 4000;
pub const U_PF_BROWSER_NATIVE_CLIENT: u32 = 4020;
pub const U_PF_ANDROID: u32 = 4050;
pub const U_PF_FUCHSIA: u32 = 4100;
pub const U_PF_OS390: u32 = 9000;
pub const U_PF_OS400: u32 = 9400;
pub const U_PLATFORM: u32 = 4000;
pub const U_PLATFORM_USES_ONLY_WIN32_API: u32 = 0;
pub const U_PLATFORM_HAS_WIN32_API: u32 = 0;
pub const U_PLATFORM_HAS_WINUWP_API: u32 = 0;
pub const U_PLATFORM_IMPLEMENTS_POSIX: u32 = 1;
pub const U_PLATFORM_IS_LINUX_BASED: u32 = 1;
pub const U_PLATFORM_IS_DARWIN_BASED: u32 = 0;
pub const U_HAVE_STDINT_H: u32 = 1;
pub const U_HAVE_INTTYPES_H: u32 = 1;
pub const U_HAVE_PLACEMENT_NEW: u32 = 1;
pub const U_HAVE_DEBUG_LOCATION_NEW: u32 = 0;
pub const U_CPLUSPLUS_VERSION: u32 = 0;
pub const U_HAVE_RVALUE_REFERENCES: u32 = 0;
pub const U_ASCII_FAMILY: u32 = 0;
pub const U_EBCDIC_FAMILY: u32 = 1;
pub const U_CHARSET_FAMILY: u32 = 0;
pub const U_CHARSET_IS_UTF8: u32 = 0;
pub const U_HAVE_WCHAR_H: u32 = 1;
pub const U_SIZEOF_WCHAR_T: u32 = 4;
pub const U_HAVE_WCSCPY: u32 = 1;
pub const U_HAVE_CHAR16_T: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const U_SIZEOF_UCHAR: u32 = 2;
pub const U_CHAR16_IS_TYPEDEF: u32 = 0;
pub const U_SENTINEL: i32 = -1;
pub const U_COPYRIGHT_STRING_LENGTH: u32 = 128;
pub const U_MAX_VERSION_LENGTH: u32 = 4;
pub const U_VERSION_DELIMITER: u8 = 46u8;
pub const U_MAX_VERSION_STRING_LENGTH: u32 = 20;
pub const U8_LEAD3_T1_BITS: &'static [u8; 17usize] = b" 000000000000\x1000\0";
pub const U8_LEAD4_T1_BITS: &'static [u8; 17usize] = b"\0\0\0\0\0\0\0\0\x1E\x0F\x0F\x0F\0\0\0\0\0";
pub const U8_MAX_LENGTH: u32 = 4;
pub const U16_SURROGATE_OFFSET: u32 = 56613888;
pub const U16_MAX_LENGTH: u32 = 2;
pub const U_HIDE_OBSOLETE_UTF_OLD_H: u32 = 0;
pub const UTF_SIZE: u32 = 16;
pub const UTF8_ERROR_VALUE_1: u32 = 21;
pub const UTF8_ERROR_VALUE_2: u32 = 159;
pub const UTF_ERROR_VALUE: u32 = 65535;
pub const UTF8_MAX_CHAR_LENGTH: u32 = 4;
pub const UTF_SURROGATE_OFFSET: u32 = 56613888;
pub const UTF16_MAX_CHAR_LENGTH: u32 = 2;
pub const UTF32_MAX_CHAR_LENGTH: u32 = 1;
pub const UTF_MAX_CHAR_LENGTH: u32 = 2;
pub const U_SHOW_CPLUSPLUS_API: u32 = 0;
pub const U_ICUDATA_TYPE_LETTER: &'static [u8; 2usize] = b"l\0";
pub const U_ICUDATA_NAME: &'static [u8; 9usize] = b"icudt60l\0";
pub const U_USRDATA_NAME: &'static [u8; 9usize] = b"usrdt60l\0";
pub const U_USE_USRDATA: u32 = 0;
pub const U_MILLIS_PER_SECOND: u32 = 1000;
pub const U_MILLIS_PER_MINUTE: u32 = 60000;
pub const U_MILLIS_PER_HOUR: u32 = 3600000;
pub const U_MILLIS_PER_DAY: u32 = 86400000;
pub const UCNV_SUB_STOP_ON_ILLEGAL: &'static [u8; 2usize] = b"i\0";
pub const UCNV_SKIP_STOP_ON_ILLEGAL: &'static [u8; 2usize] = b"i\0";
pub const UCNV_ESCAPE_JAVA: &'static [u8; 2usize] = b"J\0";
pub const UCNV_ESCAPE_C: &'static [u8; 2usize] = b"C\0";
pub const UCNV_ESCAPE_XML_DEC: &'static [u8; 2usize] = b"D\0";
pub const UCNV_ESCAPE_XML_HEX: &'static [u8; 2usize] = b"X\0";
pub const UCNV_ESCAPE_UNICODE: &'static [u8; 2usize] = b"U\0";
pub const UCNV_ESCAPE_CSS2: &'static [u8; 2usize] = b"S\0";
pub const UCNV_MAX_CONVERTER_NAME_LENGTH: u32 = 60;
pub const UCNV_MAX_FULL_FILE_NAME_LENGTH: u32 = 660;
pub const UCNV_SI: u32 = 15;
pub const UCNV_SO: u32 = 14;
pub const UCNV_OPTION_SEP_CHAR: u8 = 44u8;
pub const UCNV_OPTION_SEP_STRING: &'static [u8; 2usize] = b",\0";
pub const UCNV_VALUE_SEP_CHAR: u8 = 61u8;
pub const UCNV_VALUE_SEP_STRING: &'static [u8; 2usize] = b"=\0";
pub const UCNV_LOCALE_OPTION_STRING: &'static [u8; 9usize] = b",locale=\0";
pub const UCNV_VERSION_OPTION_STRING: &'static [u8; 10usize] = b",version=\0";
pub const UCNV_SWAP_LFNL_OPTION_STRING: &'static [u8; 10usize] = b",swaplfnl\0";
pub const U_CNV_SAFECLONE_BUFFERSIZE: u32 = 1024;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const __timespec_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _SYS_SYSMACROS_H: u32 = 1;
pub const _BITS_SYSMACROS_H: u32 = 1;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __PTHREAD_MUTEX_LOCK_ELISION: u32 = 1;
pub const __PTHREAD_MUTEX_NUSERS_AFTER_KIND: u32 = 0;
pub const __PTHREAD_MUTEX_USE_UNION: u32 = 0;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const XML_MAX_TEXT_LENGTH: u32 = 10000000;
pub const XML_MAX_NAME_LENGTH: u32 = 50000;
pub const XML_MAX_DICTIONARY_LIMIT: u32 = 10000000;
pub const XML_MAX_LOOKUP_LIMIT: u32 = 10000000;
pub const XML_MAX_NAMELEN: u32 = 100;
pub const INPUT_CHUNK: u32 = 250;
pub const XML_SUBSTITUTE_NONE: u32 = 0;
pub const XML_SUBSTITUTE_REF: u32 = 1;
pub const XML_SUBSTITUTE_PEREF: u32 = 2;
pub const XML_SUBSTITUTE_BOTH: u32 = 3;
pub const XML_XPATH_CHECKNS: u32 = 1;
pub const XML_XPATH_NOVAR: u32 = 2;
pub const INVALID_SOCKET: i32 = -1;
pub const XML_SCHEMAS_ANYATTR_SKIP: u32 = 1;
pub const XML_SCHEMAS_ANYATTR_LAX: u32 = 2;
pub const XML_SCHEMAS_ANYATTR_STRICT: u32 = 3;
pub const XML_SCHEMAS_ANY_SKIP: u32 = 1;
pub const XML_SCHEMAS_ANY_LAX: u32 = 2;
pub const XML_SCHEMAS_ANY_STRICT: u32 = 3;
pub const XML_SCHEMAS_ATTR_USE_PROHIBITED: u32 = 0;
pub const XML_SCHEMAS_ATTR_USE_REQUIRED: u32 = 1;
pub const XML_SCHEMAS_ATTR_USE_OPTIONAL: u32 = 2;
pub const XML_SCHEMAS_ATTR_GLOBAL: u32 = 1;
pub const XML_SCHEMAS_ATTR_NSDEFAULT: u32 = 128;
pub const XML_SCHEMAS_ATTR_INTERNAL_RESOLVED: u32 = 256;
pub const XML_SCHEMAS_ATTR_FIXED: u32 = 512;
pub const XML_SCHEMAS_WILDCARD_COMPLETE: u32 = 1;
pub const XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED: u32 = 1;
pub const XML_SCHEMAS_ATTRGROUP_GLOBAL: u32 = 2;
pub const XML_SCHEMAS_ATTRGROUP_MARKED: u32 = 4;
pub const XML_SCHEMAS_ATTRGROUP_REDEFINED: u32 = 8;
pub const XML_SCHEMAS_ATTRGROUP_HAS_REFS: u32 = 16;
pub const XML_SCHEMAS_TYPE_MIXED: u32 = 1;
pub const XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION: u32 = 2;
pub const XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION: u32 = 4;
pub const XML_SCHEMAS_TYPE_GLOBAL: u32 = 8;
pub const XML_SCHEMAS_TYPE_OWNED_ATTR_WILDCARD: u32 = 16;
pub const XML_SCHEMAS_TYPE_VARIETY_ABSENT: u32 = 32;
pub const XML_SCHEMAS_TYPE_VARIETY_LIST: u32 = 64;
pub const XML_SCHEMAS_TYPE_VARIETY_UNION: u32 = 128;
pub const XML_SCHEMAS_TYPE_VARIETY_ATOMIC: u32 = 256;
pub const XML_SCHEMAS_TYPE_FINAL_EXTENSION: u32 = 512;
pub const XML_SCHEMAS_TYPE_FINAL_RESTRICTION: u32 = 1024;
pub const XML_SCHEMAS_TYPE_FINAL_LIST: u32 = 2048;
pub const XML_SCHEMAS_TYPE_FINAL_UNION: u32 = 4096;
pub const XML_SCHEMAS_TYPE_FINAL_DEFAULT: u32 = 8192;
pub const XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE: u32 = 16384;
pub const XML_SCHEMAS_TYPE_MARKED: u32 = 65536;
pub const XML_SCHEMAS_TYPE_BLOCK_DEFAULT: u32 = 131072;
pub const XML_SCHEMAS_TYPE_BLOCK_EXTENSION: u32 = 262144;
pub const XML_SCHEMAS_TYPE_BLOCK_RESTRICTION: u32 = 524288;
pub const XML_SCHEMAS_TYPE_ABSTRACT: u32 = 1048576;
pub const XML_SCHEMAS_TYPE_FACETSNEEDVALUE: u32 = 2097152;
pub const XML_SCHEMAS_TYPE_INTERNAL_RESOLVED: u32 = 4194304;
pub const XML_SCHEMAS_TYPE_INTERNAL_INVALID: u32 = 8388608;
pub const XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE: u32 = 16777216;
pub const XML_SCHEMAS_TYPE_WHITESPACE_REPLACE: u32 = 33554432;
pub const XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE: u32 = 67108864;
pub const XML_SCHEMAS_TYPE_HAS_FACETS: u32 = 134217728;
pub const XML_SCHEMAS_TYPE_NORMVALUENEEDED: u32 = 268435456;
pub const XML_SCHEMAS_TYPE_FIXUP_1: u32 = 536870912;
pub const XML_SCHEMAS_TYPE_REDEFINED: u32 = 1073741824;
pub const XML_SCHEMAS_ELEM_NILLABLE: u32 = 1;
pub const XML_SCHEMAS_ELEM_GLOBAL: u32 = 2;
pub const XML_SCHEMAS_ELEM_DEFAULT: u32 = 4;
pub const XML_SCHEMAS_ELEM_FIXED: u32 = 8;
pub const XML_SCHEMAS_ELEM_ABSTRACT: u32 = 16;
pub const XML_SCHEMAS_ELEM_TOPLEVEL: u32 = 32;
pub const XML_SCHEMAS_ELEM_REF: u32 = 64;
pub const XML_SCHEMAS_ELEM_NSDEFAULT: u32 = 128;
pub const XML_SCHEMAS_ELEM_INTERNAL_RESOLVED: u32 = 256;
pub const XML_SCHEMAS_ELEM_CIRCULAR: u32 = 512;
pub const XML_SCHEMAS_ELEM_BLOCK_ABSENT: u32 = 1024;
pub const XML_SCHEMAS_ELEM_BLOCK_EXTENSION: u32 = 2048;
pub const XML_SCHEMAS_ELEM_BLOCK_RESTRICTION: u32 = 4096;
pub const XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION: u32 = 8192;
pub const XML_SCHEMAS_ELEM_FINAL_ABSENT: u32 = 16384;
pub const XML_SCHEMAS_ELEM_FINAL_EXTENSION: u32 = 32768;
pub const XML_SCHEMAS_ELEM_FINAL_RESTRICTION: u32 = 65536;
pub const XML_SCHEMAS_ELEM_SUBST_GROUP_HEAD: u32 = 131072;
pub const XML_SCHEMAS_ELEM_INTERNAL_CHECKED: u32 = 262144;
pub const XML_SCHEMAS_FACET_UNKNOWN: u32 = 0;
pub const XML_SCHEMAS_FACET_PRESERVE: u32 = 1;
pub const XML_SCHEMAS_FACET_REPLACE: u32 = 2;
pub const XML_SCHEMAS_FACET_COLLAPSE: u32 = 3;
pub const XML_SCHEMAS_QUALIF_ELEM: u32 = 1;
pub const XML_SCHEMAS_QUALIF_ATTR: u32 = 2;
pub const XML_SCHEMAS_FINAL_DEFAULT_EXTENSION: u32 = 4;
pub const XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION: u32 = 8;
pub const XML_SCHEMAS_FINAL_DEFAULT_LIST: u32 = 16;
pub const XML_SCHEMAS_FINAL_DEFAULT_UNION: u32 = 32;
pub const XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION: u32 = 64;
pub const XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION: u32 = 128;
pub const XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION: u32 = 256;
pub const XML_SCHEMAS_INCLUDING_CONVERT_NS: u32 = 512;
extern "C" {
  pub fn xmlCheckVersion(version: ::std::os::raw::c_int);
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
  pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
  assert_eq!(
    ::std::mem::size_of::<__fsid_t>(),
    8usize,
    concat!("Size of: ", stringify!(__fsid_t))
  );
  assert_eq!(
    ::std::mem::align_of::<__fsid_t>(),
    4usize,
    concat!("Alignment of ", stringify!(__fsid_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__fsid_t),
      "::",
      stringify!(__val)
    )
  );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
  pub __count: ::std::os::raw::c_int,
  pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
  pub __wch: ::std::os::raw::c_uint,
  pub __wchb: [::std::os::raw::c_char; 4usize],
  _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
    4usize,
    concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
    4usize,
    concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__mbstate_t__bindgen_ty_1),
      "::",
      stringify!(__wch)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__mbstate_t__bindgen_ty_1),
      "::",
      stringify!(__wchb)
    )
  );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
  assert_eq!(
    ::std::mem::size_of::<__mbstate_t>(),
    8usize,
    concat!("Size of: ", stringify!(__mbstate_t))
  );
  assert_eq!(
    ::std::mem::align_of::<__mbstate_t>(),
    4usize,
    concat!("Alignment of ", stringify!(__mbstate_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__mbstate_t),
      "::",
      stringify!(__count)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(__mbstate_t),
      "::",
      stringify!(__value)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
  pub __pos: __off_t,
  pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
  assert_eq!(
    ::std::mem::size_of::<_G_fpos_t>(),
    16usize,
    concat!("Size of: ", stringify!(_G_fpos_t))
  );
  assert_eq!(
    ::std::mem::align_of::<_G_fpos_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_G_fpos_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_G_fpos_t),
      "::",
      stringify!(__pos)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_G_fpos_t),
      "::",
      stringify!(__state)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
  pub __pos: __off64_t,
  pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
  assert_eq!(
    ::std::mem::size_of::<_G_fpos64_t>(),
    16usize,
    concat!("Size of: ", stringify!(_G_fpos64_t))
  );
  assert_eq!(
    ::std::mem::align_of::<_G_fpos64_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_G_fpos64_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_G_fpos64_t),
      "::",
      stringify!(__pos)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_G_fpos64_t),
      "::",
      stringify!(__state)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
  _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
  pub _next: *mut _IO_marker,
  pub _sbuf: *mut _IO_FILE,
  pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
  assert_eq!(
    ::std::mem::size_of::<_IO_marker>(),
    24usize,
    concat!("Size of: ", stringify!(_IO_marker))
  );
  assert_eq!(
    ::std::mem::align_of::<_IO_marker>(),
    8usize,
    concat!("Alignment of ", stringify!(_IO_marker))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_marker>()))._next as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_marker),
      "::",
      stringify!(_next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_marker),
      "::",
      stringify!(_sbuf)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_marker>()))._pos as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_marker),
      "::",
      stringify!(_pos)
    )
  );
}
pub const __codecvt_result___codecvt_ok: __codecvt_result = 0;
pub const __codecvt_result___codecvt_partial: __codecvt_result = 1;
pub const __codecvt_result___codecvt_error: __codecvt_result = 2;
pub const __codecvt_result___codecvt_noconv: __codecvt_result = 3;
pub type __codecvt_result = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
  pub _flags: ::std::os::raw::c_int,
  pub _IO_read_ptr: *mut ::std::os::raw::c_char,
  pub _IO_read_end: *mut ::std::os::raw::c_char,
  pub _IO_read_base: *mut ::std::os::raw::c_char,
  pub _IO_write_base: *mut ::std::os::raw::c_char,
  pub _IO_write_ptr: *mut ::std::os::raw::c_char,
  pub _IO_write_end: *mut ::std::os::raw::c_char,
  pub _IO_buf_base: *mut ::std::os::raw::c_char,
  pub _IO_buf_end: *mut ::std::os::raw::c_char,
  pub _IO_save_base: *mut ::std::os::raw::c_char,
  pub _IO_backup_base: *mut ::std::os::raw::c_char,
  pub _IO_save_end: *mut ::std::os::raw::c_char,
  pub _markers: *mut _IO_marker,
  pub _chain: *mut _IO_FILE,
  pub _fileno: ::std::os::raw::c_int,
  pub _flags2: ::std::os::raw::c_int,
  pub _old_offset: __off_t,
  pub _cur_column: ::std::os::raw::c_ushort,
  pub _vtable_offset: ::std::os::raw::c_schar,
  pub _shortbuf: [::std::os::raw::c_char; 1usize],
  pub _lock: *mut _IO_lock_t,
  pub _offset: __off64_t,
  pub __pad1: *mut ::std::os::raw::c_void,
  pub __pad2: *mut ::std::os::raw::c_void,
  pub __pad3: *mut ::std::os::raw::c_void,
  pub __pad4: *mut ::std::os::raw::c_void,
  pub __pad5: usize,
  pub _mode: ::std::os::raw::c_int,
  pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
  assert_eq!(
    ::std::mem::size_of::<_IO_FILE>(),
    216usize,
    concat!("Size of: ", stringify!(_IO_FILE))
  );
  assert_eq!(
    ::std::mem::align_of::<_IO_FILE>(),
    8usize,
    concat!("Alignment of ", stringify!(_IO_FILE))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_IO_read_ptr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_IO_read_end)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_IO_read_base)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_IO_write_base)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_IO_write_ptr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_IO_write_end)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_IO_buf_base)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_IO_buf_end)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_IO_save_base)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_IO_backup_base)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_IO_save_end)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_markers)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_chain)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_fileno)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
    116usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_flags2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_old_offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_cur_column)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
    130usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_vtable_offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
    131usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_shortbuf)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_lock)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(__pad1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize },
    160usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(__pad2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(__pad3)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize },
    176usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(__pad4)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(__pad5)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
    192usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_mode)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
    196usize,
    concat!(
      "Offset of field: ",
      stringify!(_IO_FILE),
      "::",
      stringify!(_unused2)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
  _unused: [u8; 0],
}
extern "C" {
  #[link_name = "\u{1}_IO_2_1_stdin_"]
  pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
  #[link_name = "\u{1}_IO_2_1_stdout_"]
  pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
  #[link_name = "\u{1}_IO_2_1_stderr_"]
  pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::std::option::Option<
  unsafe extern "C" fn(
    __cookie: *mut ::std::os::raw::c_void,
    __buf: *mut ::std::os::raw::c_char,
    __nbytes: usize,
  ) -> __ssize_t,
>;
pub type __io_write_fn = ::std::option::Option<
  unsafe extern "C" fn(
    __cookie: *mut ::std::os::raw::c_void,
    __buf: *const ::std::os::raw::c_char,
    __n: usize,
  ) -> __ssize_t,
>;
pub type __io_seek_fn = ::std::option::Option<
  unsafe extern "C" fn(
    __cookie: *mut ::std::os::raw::c_void,
    __pos: *mut __off64_t,
    __w: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int,
>;
pub type __io_close_fn = ::std::option::Option<
  unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
  pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
  pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
  pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _IO_vfscanf(
    arg1: *mut _IO_FILE,
    arg2: *const ::std::os::raw::c_char,
    arg3: *mut __va_list_tag,
    arg4: *mut ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _IO_vfprintf(
    arg1: *mut _IO_FILE,
    arg2: *const ::std::os::raw::c_char,
    arg3: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int, arg3: __ssize_t) -> __ssize_t;
}
extern "C" {
  pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void, arg3: usize) -> usize;
}
extern "C" {
  pub fn _IO_seekoff(
    arg1: *mut _IO_FILE,
    arg2: __off64_t,
    arg3: ::std::os::raw::c_int,
    arg4: ::std::os::raw::c_int,
  ) -> __off64_t;
}
extern "C" {
  pub fn _IO_seekpos(
    arg1: *mut _IO_FILE,
    arg2: __off64_t,
    arg3: ::std::os::raw::c_int,
  ) -> __off64_t;
}
extern "C" {
  pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
  #[link_name = "\u{1}stdin"]
  pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
  #[link_name = "\u{1}stdout"]
  pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
  #[link_name = "\u{1}stderr"]
  pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
  pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn rename(
    __old: *const ::std::os::raw::c_char,
    __new: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn renameat(
    __oldfd: ::std::os::raw::c_int,
    __old: *const ::std::os::raw::c_char,
    __newfd: ::std::os::raw::c_int,
    __new: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn tmpfile() -> *mut FILE;
}
extern "C" {
  pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn tempnam(
    __dir: *const ::std::os::raw::c_char,
    __pfx: *const ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fopen(
    __filename: *const ::std::os::raw::c_char,
    __modes: *const ::std::os::raw::c_char,
  ) -> *mut FILE;
}
extern "C" {
  pub fn freopen(
    __filename: *const ::std::os::raw::c_char,
    __modes: *const ::std::os::raw::c_char,
    __stream: *mut FILE,
  ) -> *mut FILE;
}
extern "C" {
  pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
  pub fn fmemopen(
    __s: *mut ::std::os::raw::c_void,
    __len: usize,
    __modes: *const ::std::os::raw::c_char,
  ) -> *mut FILE;
}
extern "C" {
  pub fn open_memstream(
    __bufloc: *mut *mut ::std::os::raw::c_char,
    __sizeloc: *mut usize,
  ) -> *mut FILE;
}
extern "C" {
  pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
  pub fn setvbuf(
    __stream: *mut FILE,
    __buf: *mut ::std::os::raw::c_char,
    __modes: ::std::os::raw::c_int,
    __n: usize,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
  pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
  pub fn fprintf(
    __stream: *mut FILE,
    __format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn sprintf(
    __s: *mut ::std::os::raw::c_char,
    __format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn vfprintf(
    __s: *mut FILE,
    __format: *const ::std::os::raw::c_char,
    __arg: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn vprintf(
    __format: *const ::std::os::raw::c_char,
    __arg: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn vsprintf(
    __s: *mut ::std::os::raw::c_char,
    __format: *const ::std::os::raw::c_char,
    __arg: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn snprintf(
    __s: *mut ::std::os::raw::c_char,
    __maxlen: usize,
    __format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn vsnprintf(
    __s: *mut ::std::os::raw::c_char,
    __maxlen: usize,
    __format: *const ::std::os::raw::c_char,
    __arg: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn vdprintf(
    __fd: ::std::os::raw::c_int,
    __fmt: *const ::std::os::raw::c_char,
    __arg: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn dprintf(
    __fd: ::std::os::raw::c_int,
    __fmt: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fscanf(
    __stream: *mut FILE,
    __format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn sscanf(
    __s: *const ::std::os::raw::c_char,
    __format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}__isoc99_fscanf"]
  pub fn fscanf1(
    __stream: *mut FILE,
    __format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}__isoc99_scanf"]
  pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}__isoc99_sscanf"]
  pub fn sscanf1(
    __s: *const ::std::os::raw::c_char,
    __format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn vfscanf(
    __s: *mut FILE,
    __format: *const ::std::os::raw::c_char,
    __arg: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn vscanf(
    __format: *const ::std::os::raw::c_char,
    __arg: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn vsscanf(
    __s: *const ::std::os::raw::c_char,
    __format: *const ::std::os::raw::c_char,
    __arg: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}__isoc99_vfscanf"]
  pub fn vfscanf1(
    __s: *mut FILE,
    __format: *const ::std::os::raw::c_char,
    __arg: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}__isoc99_vscanf"]
  pub fn vscanf1(
    __format: *const ::std::os::raw::c_char,
    __arg: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}__isoc99_vsscanf"]
  pub fn vsscanf1(
    __s: *const ::std::os::raw::c_char,
    __format: *const ::std::os::raw::c_char,
    __arg: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fgets(
    __s: *mut ::std::os::raw::c_char,
    __n: ::std::os::raw::c_int,
    __stream: *mut FILE,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn __getdelim(
    __lineptr: *mut *mut ::std::os::raw::c_char,
    __n: *mut usize,
    __delimiter: ::std::os::raw::c_int,
    __stream: *mut FILE,
  ) -> __ssize_t;
}
extern "C" {
  pub fn getdelim(
    __lineptr: *mut *mut ::std::os::raw::c_char,
    __n: *mut usize,
    __delimiter: ::std::os::raw::c_int,
    __stream: *mut FILE,
  ) -> __ssize_t;
}
extern "C" {
  pub fn getline(
    __lineptr: *mut *mut ::std::os::raw::c_char,
    __n: *mut usize,
    __stream: *mut FILE,
  ) -> __ssize_t;
}
extern "C" {
  pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fread(
    __ptr: *mut ::std::os::raw::c_void,
    __size: usize,
    __n: usize,
    __stream: *mut FILE,
  ) -> usize;
}
extern "C" {
  pub fn fwrite(
    __ptr: *const ::std::os::raw::c_void,
    __size: usize,
    __n: usize,
    __s: *mut FILE,
  ) -> usize;
}
extern "C" {
  pub fn fread_unlocked(
    __ptr: *mut ::std::os::raw::c_void,
    __size: usize,
    __n: usize,
    __stream: *mut FILE,
  ) -> usize;
}
extern "C" {
  pub fn fwrite_unlocked(
    __ptr: *const ::std::os::raw::c_void,
    __size: usize,
    __n: usize,
    __stream: *mut FILE,
  ) -> usize;
}
extern "C" {
  pub fn fseek(
    __stream: *mut FILE,
    __off: ::std::os::raw::c_long,
    __whence: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn rewind(__stream: *mut FILE);
}
extern "C" {
  pub fn fseeko(
    __stream: *mut FILE,
    __off: __off_t,
    __whence: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
  pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
  pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
  pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
  #[link_name = "\u{1}sys_nerr"]
  pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}sys_errlist"]
  pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
  pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn popen(
    __command: *const ::std::os::raw::c_char,
    __modes: *const ::std::os::raw::c_char,
  ) -> *mut FILE;
}
extern "C" {
  pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
  pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn funlockfile(__stream: *mut FILE);
}
/// xmlChar:
///
/// This is a basic byte in an UTF-8 encoded string.
/// It's unsigned allowing to pinpoint case where char * are assigned
/// to xmlChar * (possibly making serialization back impossible).
pub type xmlChar = ::std::os::raw::c_uchar;
extern "C" {
  pub fn xmlStrdup(cur: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlStrndup(cur: *const xmlChar, len: ::std::os::raw::c_int) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlCharStrndup(
    cur: *const ::std::os::raw::c_char,
    len: ::std::os::raw::c_int,
  ) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlCharStrdup(cur: *const ::std::os::raw::c_char) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlStrsub(
    str: *const xmlChar,
    start: ::std::os::raw::c_int,
    len: ::std::os::raw::c_int,
  ) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlStrchr(str: *const xmlChar, val: xmlChar) -> *const xmlChar;
}
extern "C" {
  pub fn xmlStrstr(str: *const xmlChar, val: *const xmlChar) -> *const xmlChar;
}
extern "C" {
  pub fn xmlStrcasestr(str: *const xmlChar, val: *const xmlChar) -> *const xmlChar;
}
extern "C" {
  pub fn xmlStrcmp(str1: *const xmlChar, str2: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlStrncmp(
    str1: *const xmlChar,
    str2: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlStrcasecmp(str1: *const xmlChar, str2: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlStrncasecmp(
    str1: *const xmlChar,
    str2: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlStrEqual(str1: *const xmlChar, str2: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlStrQEqual(
    pref: *const xmlChar,
    name: *const xmlChar,
    str: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlStrlen(str: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlStrcat(cur: *mut xmlChar, add: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlStrncat(
    cur: *mut xmlChar,
    add: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlStrncatNew(
    str1: *const xmlChar,
    str2: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlStrPrintf(
    buf: *mut xmlChar,
    len: ::std::os::raw::c_int,
    msg: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlStrVPrintf(
    buf: *mut xmlChar,
    len: ::std::os::raw::c_int,
    msg: *const ::std::os::raw::c_char,
    ap: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlGetUTF8Char(
    utf: *const ::std::os::raw::c_uchar,
    len: *mut ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlCheckUTF8(utf: *const ::std::os::raw::c_uchar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUTF8Strsize(utf: *const xmlChar, len: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUTF8Strndup(utf: *const xmlChar, len: ::std::os::raw::c_int) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlUTF8Strpos(utf: *const xmlChar, pos: ::std::os::raw::c_int) -> *const xmlChar;
}
extern "C" {
  pub fn xmlUTF8Strloc(utf: *const xmlChar, utfchar: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUTF8Strsub(
    utf: *const xmlChar,
    start: ::std::os::raw::c_int,
    len: ::std::os::raw::c_int,
  ) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlUTF8Strlen(utf: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUTF8Size(utf: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUTF8Charcmp(utf1: *const xmlChar, utf2: *const xmlChar) -> ::std::os::raw::c_int;
}
pub type xmlParserInputBuffer = _xmlParserInputBuffer;
pub type xmlParserInputBufferPtr = *mut xmlParserInputBuffer;
pub type xmlOutputBuffer = _xmlOutputBuffer;
pub type xmlOutputBufferPtr = *mut xmlOutputBuffer;
pub type xmlParserInput = _xmlParserInput;
pub type xmlParserInputPtr = *mut xmlParserInput;
pub type xmlParserCtxt = _xmlParserCtxt;
pub type xmlParserCtxtPtr = *mut xmlParserCtxt;
pub type xmlSAXLocator = _xmlSAXLocator;
pub type xmlSAXLocatorPtr = *mut xmlSAXLocator;
pub type xmlSAXHandler = _xmlSAXHandler;
pub type xmlSAXHandlerPtr = *mut xmlSAXHandler;
pub type xmlEntity = _xmlEntity;
pub type xmlEntityPtr = *mut xmlEntity;
pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_DOUBLEIT: xmlBufferAllocationScheme = 0;
pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_EXACT: xmlBufferAllocationScheme = 1;
pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_IMMUTABLE: xmlBufferAllocationScheme = 2;
pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_IO: xmlBufferAllocationScheme = 3;
pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_HYBRID: xmlBufferAllocationScheme = 4;
pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_BOUNDED: xmlBufferAllocationScheme = 5;
/// xmlBufferAllocationScheme:
///
/// A buffer allocation scheme can be defined to either match exactly the
/// need or double it's allocated size each time it is found too small.
pub type xmlBufferAllocationScheme = u32;
/// xmlBuffer:
///
/// A buffer structure, this old construct is limited to 2GB and
/// is being deprecated, use API with xmlBuf instead
pub type xmlBuffer = _xmlBuffer;
pub type xmlBufferPtr = *mut xmlBuffer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlBuffer {
  pub content: *mut xmlChar,
  pub use_: ::std::os::raw::c_uint,
  pub size: ::std::os::raw::c_uint,
  pub alloc: xmlBufferAllocationScheme,
  pub contentIO: *mut xmlChar,
}
#[test]
fn bindgen_test_layout__xmlBuffer() {
  assert_eq!(
    ::std::mem::size_of::<_xmlBuffer>(),
    32usize,
    concat!("Size of: ", stringify!(_xmlBuffer))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlBuffer>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlBuffer))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlBuffer>())).content as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlBuffer),
      "::",
      stringify!(content)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlBuffer>())).use_ as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlBuffer),
      "::",
      stringify!(use_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlBuffer>())).size as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlBuffer),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlBuffer>())).alloc as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlBuffer),
      "::",
      stringify!(alloc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlBuffer>())).contentIO as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlBuffer),
      "::",
      stringify!(contentIO)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlBuf {
  _unused: [u8; 0],
}
/// xmlBuf:
///
/// A buffer structure, new one, the actual structure internals are not public
pub type xmlBuf = _xmlBuf;
/// xmlBufPtr:
///
/// A pointer to a buffer structure, the actual structure internals are not
/// public
pub type xmlBufPtr = *mut xmlBuf;
extern "C" {
  pub fn xmlBufContent(buf: *const xmlBuf) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlBufEnd(buf: xmlBufPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlBufUse(buf: xmlBufPtr) -> usize;
}
extern "C" {
  pub fn xmlBufShrink(buf: xmlBufPtr, len: usize) -> usize;
}
pub const xmlElementType_XML_ELEMENT_NODE: xmlElementType = 1;
pub const xmlElementType_XML_ATTRIBUTE_NODE: xmlElementType = 2;
pub const xmlElementType_XML_TEXT_NODE: xmlElementType = 3;
pub const xmlElementType_XML_CDATA_SECTION_NODE: xmlElementType = 4;
pub const xmlElementType_XML_ENTITY_REF_NODE: xmlElementType = 5;
pub const xmlElementType_XML_ENTITY_NODE: xmlElementType = 6;
pub const xmlElementType_XML_PI_NODE: xmlElementType = 7;
pub const xmlElementType_XML_COMMENT_NODE: xmlElementType = 8;
pub const xmlElementType_XML_DOCUMENT_NODE: xmlElementType = 9;
pub const xmlElementType_XML_DOCUMENT_TYPE_NODE: xmlElementType = 10;
pub const xmlElementType_XML_DOCUMENT_FRAG_NODE: xmlElementType = 11;
pub const xmlElementType_XML_NOTATION_NODE: xmlElementType = 12;
pub const xmlElementType_XML_HTML_DOCUMENT_NODE: xmlElementType = 13;
pub const xmlElementType_XML_DTD_NODE: xmlElementType = 14;
pub const xmlElementType_XML_ELEMENT_DECL: xmlElementType = 15;
pub const xmlElementType_XML_ATTRIBUTE_DECL: xmlElementType = 16;
pub const xmlElementType_XML_ENTITY_DECL: xmlElementType = 17;
pub const xmlElementType_XML_NAMESPACE_DECL: xmlElementType = 18;
pub const xmlElementType_XML_XINCLUDE_START: xmlElementType = 19;
pub const xmlElementType_XML_XINCLUDE_END: xmlElementType = 20;
pub const xmlElementType_XML_DOCB_DOCUMENT_NODE: xmlElementType = 21;
pub type xmlElementType = u32;
/// xmlNotation:
///
/// A DTD Notation definition.
pub type xmlNotation = _xmlNotation;
pub type xmlNotationPtr = *mut xmlNotation;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlNotation {
  pub name: *const xmlChar,
  pub PublicID: *const xmlChar,
  pub SystemID: *const xmlChar,
}
#[test]
fn bindgen_test_layout__xmlNotation() {
  assert_eq!(
    ::std::mem::size_of::<_xmlNotation>(),
    24usize,
    concat!("Size of: ", stringify!(_xmlNotation))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlNotation>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlNotation))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNotation>())).name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNotation),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNotation>())).PublicID as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNotation),
      "::",
      stringify!(PublicID)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNotation>())).SystemID as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNotation),
      "::",
      stringify!(SystemID)
    )
  );
}
pub const xmlAttributeType_XML_ATTRIBUTE_CDATA: xmlAttributeType = 1;
pub const xmlAttributeType_XML_ATTRIBUTE_ID: xmlAttributeType = 2;
pub const xmlAttributeType_XML_ATTRIBUTE_IDREF: xmlAttributeType = 3;
pub const xmlAttributeType_XML_ATTRIBUTE_IDREFS: xmlAttributeType = 4;
pub const xmlAttributeType_XML_ATTRIBUTE_ENTITY: xmlAttributeType = 5;
pub const xmlAttributeType_XML_ATTRIBUTE_ENTITIES: xmlAttributeType = 6;
pub const xmlAttributeType_XML_ATTRIBUTE_NMTOKEN: xmlAttributeType = 7;
pub const xmlAttributeType_XML_ATTRIBUTE_NMTOKENS: xmlAttributeType = 8;
pub const xmlAttributeType_XML_ATTRIBUTE_ENUMERATION: xmlAttributeType = 9;
pub const xmlAttributeType_XML_ATTRIBUTE_NOTATION: xmlAttributeType = 10;
/// xmlAttributeType:
///
/// A DTD Attribute type definition.
pub type xmlAttributeType = u32;
pub const xmlAttributeDefault_XML_ATTRIBUTE_NONE: xmlAttributeDefault = 1;
pub const xmlAttributeDefault_XML_ATTRIBUTE_REQUIRED: xmlAttributeDefault = 2;
pub const xmlAttributeDefault_XML_ATTRIBUTE_IMPLIED: xmlAttributeDefault = 3;
pub const xmlAttributeDefault_XML_ATTRIBUTE_FIXED: xmlAttributeDefault = 4;
/// xmlAttributeDefault:
///
/// A DTD Attribute default definition.
pub type xmlAttributeDefault = u32;
/// xmlEnumeration:
///
/// List structure used when there is an enumeration in DTDs.
pub type xmlEnumeration = _xmlEnumeration;
pub type xmlEnumerationPtr = *mut xmlEnumeration;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlEnumeration {
  pub next: *mut _xmlEnumeration,
  pub name: *const xmlChar,
}
#[test]
fn bindgen_test_layout__xmlEnumeration() {
  assert_eq!(
    ::std::mem::size_of::<_xmlEnumeration>(),
    16usize,
    concat!("Size of: ", stringify!(_xmlEnumeration))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlEnumeration>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlEnumeration))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlEnumeration>())).next as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlEnumeration),
      "::",
      stringify!(next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlEnumeration>())).name as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlEnumeration),
      "::",
      stringify!(name)
    )
  );
}
/// xmlAttribute:
///
/// An Attribute declaration in a DTD.
pub type xmlAttribute = _xmlAttribute;
pub type xmlAttributePtr = *mut xmlAttribute;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlAttribute {
  pub _private: *mut ::std::os::raw::c_void,
  pub type_: xmlElementType,
  pub name: *const xmlChar,
  pub children: *mut _xmlNode,
  pub last: *mut _xmlNode,
  pub parent: *mut _xmlDtd,
  pub next: *mut _xmlNode,
  pub prev: *mut _xmlNode,
  pub doc: *mut _xmlDoc,
  pub nexth: *mut _xmlAttribute,
  pub atype: xmlAttributeType,
  pub def: xmlAttributeDefault,
  pub defaultValue: *const xmlChar,
  pub tree: xmlEnumerationPtr,
  pub prefix: *const xmlChar,
  pub elem: *const xmlChar,
}
#[test]
fn bindgen_test_layout__xmlAttribute() {
  assert_eq!(
    ::std::mem::size_of::<_xmlAttribute>(),
    120usize,
    concat!("Size of: ", stringify!(_xmlAttribute))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlAttribute>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlAttribute))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttribute>()))._private as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttribute),
      "::",
      stringify!(_private)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttribute>())).type_ as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttribute),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttribute>())).name as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttribute),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttribute>())).children as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttribute),
      "::",
      stringify!(children)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttribute>())).last as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttribute),
      "::",
      stringify!(last)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttribute>())).parent as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttribute),
      "::",
      stringify!(parent)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttribute>())).next as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttribute),
      "::",
      stringify!(next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttribute>())).prev as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttribute),
      "::",
      stringify!(prev)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttribute>())).doc as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttribute),
      "::",
      stringify!(doc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttribute>())).nexth as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttribute),
      "::",
      stringify!(nexth)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttribute>())).atype as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttribute),
      "::",
      stringify!(atype)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttribute>())).def as *const _ as usize },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttribute),
      "::",
      stringify!(def)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttribute>())).defaultValue as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttribute),
      "::",
      stringify!(defaultValue)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttribute>())).tree as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttribute),
      "::",
      stringify!(tree)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttribute>())).prefix as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttribute),
      "::",
      stringify!(prefix)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttribute>())).elem as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttribute),
      "::",
      stringify!(elem)
    )
  );
}
pub const xmlElementContentType_XML_ELEMENT_CONTENT_PCDATA: xmlElementContentType = 1;
pub const xmlElementContentType_XML_ELEMENT_CONTENT_ELEMENT: xmlElementContentType = 2;
pub const xmlElementContentType_XML_ELEMENT_CONTENT_SEQ: xmlElementContentType = 3;
pub const xmlElementContentType_XML_ELEMENT_CONTENT_OR: xmlElementContentType = 4;
/// xmlElementContentType:
///
/// Possible definitions of element content types.
pub type xmlElementContentType = u32;
pub const xmlElementContentOccur_XML_ELEMENT_CONTENT_ONCE: xmlElementContentOccur = 1;
pub const xmlElementContentOccur_XML_ELEMENT_CONTENT_OPT: xmlElementContentOccur = 2;
pub const xmlElementContentOccur_XML_ELEMENT_CONTENT_MULT: xmlElementContentOccur = 3;
pub const xmlElementContentOccur_XML_ELEMENT_CONTENT_PLUS: xmlElementContentOccur = 4;
/// xmlElementContentOccur:
///
/// Possible definitions of element content occurrences.
pub type xmlElementContentOccur = u32;
/// xmlElementContent:
///
/// An XML Element content as stored after parsing an element definition
/// in a DTD.
pub type xmlElementContent = _xmlElementContent;
pub type xmlElementContentPtr = *mut xmlElementContent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlElementContent {
  pub type_: xmlElementContentType,
  pub ocur: xmlElementContentOccur,
  pub name: *const xmlChar,
  pub c1: *mut _xmlElementContent,
  pub c2: *mut _xmlElementContent,
  pub parent: *mut _xmlElementContent,
  pub prefix: *const xmlChar,
}
#[test]
fn bindgen_test_layout__xmlElementContent() {
  assert_eq!(
    ::std::mem::size_of::<_xmlElementContent>(),
    48usize,
    concat!("Size of: ", stringify!(_xmlElementContent))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlElementContent>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlElementContent))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlElementContent>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlElementContent),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlElementContent>())).ocur as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlElementContent),
      "::",
      stringify!(ocur)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlElementContent>())).name as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlElementContent),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlElementContent>())).c1 as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlElementContent),
      "::",
      stringify!(c1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlElementContent>())).c2 as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlElementContent),
      "::",
      stringify!(c2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlElementContent>())).parent as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlElementContent),
      "::",
      stringify!(parent)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlElementContent>())).prefix as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlElementContent),
      "::",
      stringify!(prefix)
    )
  );
}
pub const xmlElementTypeVal_XML_ELEMENT_TYPE_UNDEFINED: xmlElementTypeVal = 0;
pub const xmlElementTypeVal_XML_ELEMENT_TYPE_EMPTY: xmlElementTypeVal = 1;
pub const xmlElementTypeVal_XML_ELEMENT_TYPE_ANY: xmlElementTypeVal = 2;
pub const xmlElementTypeVal_XML_ELEMENT_TYPE_MIXED: xmlElementTypeVal = 3;
pub const xmlElementTypeVal_XML_ELEMENT_TYPE_ELEMENT: xmlElementTypeVal = 4;
/// xmlElementTypeVal:
///
/// The different possibilities for an element content type.
pub type xmlElementTypeVal = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlRegexp {
  _unused: [u8; 0],
}
/// xmlRegexpPtr:
///
/// A libxml regular expression, they can actually be far more complex
/// thank the POSIX regex expressions.
pub type xmlRegexp = _xmlRegexp;
pub type xmlRegexpPtr = *mut xmlRegexp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlRegExecCtxt {
  _unused: [u8; 0],
}
/// xmlRegExecCtxtPtr:
///
/// A libxml progressive regular expression evaluation context
pub type xmlRegExecCtxt = _xmlRegExecCtxt;
pub type xmlRegExecCtxtPtr = *mut xmlRegExecCtxt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlDict {
  _unused: [u8; 0],
}
pub type xmlDict = _xmlDict;
pub type xmlDictPtr = *mut xmlDict;
extern "C" {
  pub fn xmlInitializeDict() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlDictCreate() -> xmlDictPtr;
}
extern "C" {
  pub fn xmlDictSetLimit(dict: xmlDictPtr, limit: usize) -> usize;
}
extern "C" {
  pub fn xmlDictGetUsage(dict: xmlDictPtr) -> usize;
}
extern "C" {
  pub fn xmlDictCreateSub(sub: xmlDictPtr) -> xmlDictPtr;
}
extern "C" {
  pub fn xmlDictReference(dict: xmlDictPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlDictFree(dict: xmlDictPtr);
}
extern "C" {
  pub fn xmlDictLookup(
    dict: xmlDictPtr,
    name: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> *const xmlChar;
}
extern "C" {
  pub fn xmlDictExists(
    dict: xmlDictPtr,
    name: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> *const xmlChar;
}
extern "C" {
  pub fn xmlDictQLookup(
    dict: xmlDictPtr,
    prefix: *const xmlChar,
    name: *const xmlChar,
  ) -> *const xmlChar;
}
extern "C" {
  pub fn xmlDictOwns(dict: xmlDictPtr, str: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlDictSize(dict: xmlDictPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlDictCleanup();
}
extern "C" {
  pub fn xmlRegexpCompile(regexp: *const xmlChar) -> xmlRegexpPtr;
}
extern "C" {
  pub fn xmlRegFreeRegexp(regexp: xmlRegexpPtr);
}
extern "C" {
  pub fn xmlRegexpExec(comp: xmlRegexpPtr, value: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlRegexpPrint(output: *mut FILE, regexp: xmlRegexpPtr);
}
extern "C" {
  pub fn xmlRegexpIsDeterminist(comp: xmlRegexpPtr) -> ::std::os::raw::c_int;
}
/// xmlRegExecCallbacks:
/// @exec: the regular expression context
/// @token: the current token string
/// @transdata: transition data
/// @inputdata: input data
///
/// Callback function when doing a transition in the automata
pub type xmlRegExecCallbacks = ::std::option::Option<
  unsafe extern "C" fn(
    exec: xmlRegExecCtxtPtr,
    token: *const xmlChar,
    transdata: *mut ::std::os::raw::c_void,
    inputdata: *mut ::std::os::raw::c_void,
  ),
>;
extern "C" {
  pub fn xmlRegNewExecCtxt(
    comp: xmlRegexpPtr,
    callback: xmlRegExecCallbacks,
    data: *mut ::std::os::raw::c_void,
  ) -> xmlRegExecCtxtPtr;
}
extern "C" {
  pub fn xmlRegFreeExecCtxt(exec: xmlRegExecCtxtPtr);
}
extern "C" {
  pub fn xmlRegExecPushString(
    exec: xmlRegExecCtxtPtr,
    value: *const xmlChar,
    data: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlRegExecPushString2(
    exec: xmlRegExecCtxtPtr,
    value: *const xmlChar,
    value2: *const xmlChar,
    data: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlRegExecNextValues(
    exec: xmlRegExecCtxtPtr,
    nbval: *mut ::std::os::raw::c_int,
    nbneg: *mut ::std::os::raw::c_int,
    values: *mut *mut xmlChar,
    terminal: *mut ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlRegExecErrInfo(
    exec: xmlRegExecCtxtPtr,
    string: *mut *const xmlChar,
    nbval: *mut ::std::os::raw::c_int,
    nbneg: *mut ::std::os::raw::c_int,
    values: *mut *mut xmlChar,
    terminal: *mut ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlExpCtxt {
  _unused: [u8; 0],
}
pub type xmlExpCtxt = _xmlExpCtxt;
pub type xmlExpCtxtPtr = *mut xmlExpCtxt;
extern "C" {
  pub fn xmlExpFreeCtxt(ctxt: xmlExpCtxtPtr);
}
extern "C" {
  pub fn xmlExpNewCtxt(maxNodes: ::std::os::raw::c_int, dict: xmlDictPtr) -> xmlExpCtxtPtr;
}
extern "C" {
  pub fn xmlExpCtxtNbNodes(ctxt: xmlExpCtxtPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlExpCtxtNbCons(ctxt: xmlExpCtxtPtr) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlExpNode {
  _unused: [u8; 0],
}
pub type xmlExpNode = _xmlExpNode;
pub type xmlExpNodePtr = *mut xmlExpNode;
pub const xmlExpNodeType_XML_EXP_EMPTY: xmlExpNodeType = 0;
pub const xmlExpNodeType_XML_EXP_FORBID: xmlExpNodeType = 1;
pub const xmlExpNodeType_XML_EXP_ATOM: xmlExpNodeType = 2;
pub const xmlExpNodeType_XML_EXP_SEQ: xmlExpNodeType = 3;
pub const xmlExpNodeType_XML_EXP_OR: xmlExpNodeType = 4;
pub const xmlExpNodeType_XML_EXP_COUNT: xmlExpNodeType = 5;
pub type xmlExpNodeType = u32;
extern "C" {
  #[link_name = "\u{1}forbiddenExp"]
  pub static mut forbiddenExp: xmlExpNodePtr;
}
extern "C" {
  #[link_name = "\u{1}emptyExp"]
  pub static mut emptyExp: xmlExpNodePtr;
}
extern "C" {
  pub fn xmlExpFree(ctxt: xmlExpCtxtPtr, expr: xmlExpNodePtr);
}
extern "C" {
  pub fn xmlExpRef(expr: xmlExpNodePtr);
}
extern "C" {
  pub fn xmlExpParse(ctxt: xmlExpCtxtPtr, expr: *const ::std::os::raw::c_char) -> xmlExpNodePtr;
}
extern "C" {
  pub fn xmlExpNewAtom(
    ctxt: xmlExpCtxtPtr,
    name: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> xmlExpNodePtr;
}
extern "C" {
  pub fn xmlExpNewOr(
    ctxt: xmlExpCtxtPtr,
    left: xmlExpNodePtr,
    right: xmlExpNodePtr,
  ) -> xmlExpNodePtr;
}
extern "C" {
  pub fn xmlExpNewSeq(
    ctxt: xmlExpCtxtPtr,
    left: xmlExpNodePtr,
    right: xmlExpNodePtr,
  ) -> xmlExpNodePtr;
}
extern "C" {
  pub fn xmlExpNewRange(
    ctxt: xmlExpCtxtPtr,
    subset: xmlExpNodePtr,
    min: ::std::os::raw::c_int,
    max: ::std::os::raw::c_int,
  ) -> xmlExpNodePtr;
}
extern "C" {
  pub fn xmlExpIsNillable(expr: xmlExpNodePtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlExpMaxToken(expr: xmlExpNodePtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlExpGetLanguage(
    ctxt: xmlExpCtxtPtr,
    expr: xmlExpNodePtr,
    langList: *mut *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlExpGetStart(
    ctxt: xmlExpCtxtPtr,
    expr: xmlExpNodePtr,
    tokList: *mut *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlExpStringDerive(
    ctxt: xmlExpCtxtPtr,
    expr: xmlExpNodePtr,
    str: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> xmlExpNodePtr;
}
extern "C" {
  pub fn xmlExpExpDerive(
    ctxt: xmlExpCtxtPtr,
    expr: xmlExpNodePtr,
    sub: xmlExpNodePtr,
  ) -> xmlExpNodePtr;
}
extern "C" {
  pub fn xmlExpSubsume(
    ctxt: xmlExpCtxtPtr,
    expr: xmlExpNodePtr,
    sub: xmlExpNodePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlExpDump(buf: xmlBufferPtr, expr: xmlExpNodePtr);
}
/// xmlElement:
///
/// An XML Element declaration from a DTD.
pub type xmlElement = _xmlElement;
pub type xmlElementPtr = *mut xmlElement;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlElement {
  pub _private: *mut ::std::os::raw::c_void,
  pub type_: xmlElementType,
  pub name: *const xmlChar,
  pub children: *mut _xmlNode,
  pub last: *mut _xmlNode,
  pub parent: *mut _xmlDtd,
  pub next: *mut _xmlNode,
  pub prev: *mut _xmlNode,
  pub doc: *mut _xmlDoc,
  pub etype: xmlElementTypeVal,
  pub content: xmlElementContentPtr,
  pub attributes: xmlAttributePtr,
  pub prefix: *const xmlChar,
  pub contModel: xmlRegexpPtr,
}
#[test]
fn bindgen_test_layout__xmlElement() {
  assert_eq!(
    ::std::mem::size_of::<_xmlElement>(),
    112usize,
    concat!("Size of: ", stringify!(_xmlElement))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlElement>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlElement))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlElement>()))._private as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlElement),
      "::",
      stringify!(_private)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlElement>())).type_ as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlElement),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlElement>())).name as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlElement),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlElement>())).children as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlElement),
      "::",
      stringify!(children)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlElement>())).last as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlElement),
      "::",
      stringify!(last)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlElement>())).parent as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlElement),
      "::",
      stringify!(parent)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlElement>())).next as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlElement),
      "::",
      stringify!(next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlElement>())).prev as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlElement),
      "::",
      stringify!(prev)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlElement>())).doc as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlElement),
      "::",
      stringify!(doc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlElement>())).etype as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlElement),
      "::",
      stringify!(etype)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlElement>())).content as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlElement),
      "::",
      stringify!(content)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlElement>())).attributes as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlElement),
      "::",
      stringify!(attributes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlElement>())).prefix as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlElement),
      "::",
      stringify!(prefix)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlElement>())).contModel as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlElement),
      "::",
      stringify!(contModel)
    )
  );
}
pub use self::xmlElementType as xmlNsType;
/// xmlNs:
///
/// An XML namespace.
/// Note that prefix == NULL is valid, it defines the default namespace
/// within the subtree (until overridden).
///
/// xmlNsType is unified with xmlElementType.
pub type xmlNs = _xmlNs;
pub type xmlNsPtr = *mut xmlNs;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlNs {
  pub next: *mut _xmlNs,
  pub type_: xmlNsType,
  pub href: *const xmlChar,
  pub prefix: *const xmlChar,
  pub _private: *mut ::std::os::raw::c_void,
  pub context: *mut _xmlDoc,
}
#[test]
fn bindgen_test_layout__xmlNs() {
  assert_eq!(
    ::std::mem::size_of::<_xmlNs>(),
    48usize,
    concat!("Size of: ", stringify!(_xmlNs))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlNs>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlNs))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNs>())).next as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNs),
      "::",
      stringify!(next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNs>())).type_ as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNs),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNs>())).href as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNs),
      "::",
      stringify!(href)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNs>())).prefix as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNs),
      "::",
      stringify!(prefix)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNs>()))._private as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNs),
      "::",
      stringify!(_private)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNs>())).context as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNs),
      "::",
      stringify!(context)
    )
  );
}
/// xmlDtd:
///
/// An XML DTD, as defined by <!DOCTYPE ... There is actually one for
/// the internal subset and for the external subset.
pub type xmlDtd = _xmlDtd;
pub type xmlDtdPtr = *mut xmlDtd;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlDtd {
  pub _private: *mut ::std::os::raw::c_void,
  pub type_: xmlElementType,
  pub name: *const xmlChar,
  pub children: *mut _xmlNode,
  pub last: *mut _xmlNode,
  pub parent: *mut _xmlDoc,
  pub next: *mut _xmlNode,
  pub prev: *mut _xmlNode,
  pub doc: *mut _xmlDoc,
  pub notations: *mut ::std::os::raw::c_void,
  pub elements: *mut ::std::os::raw::c_void,
  pub attributes: *mut ::std::os::raw::c_void,
  pub entities: *mut ::std::os::raw::c_void,
  pub ExternalID: *const xmlChar,
  pub SystemID: *const xmlChar,
  pub pentities: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlDtd() {
  assert_eq!(
    ::std::mem::size_of::<_xmlDtd>(),
    128usize,
    concat!("Size of: ", stringify!(_xmlDtd))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlDtd>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlDtd))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDtd>()))._private as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDtd),
      "::",
      stringify!(_private)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDtd>())).type_ as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDtd),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDtd>())).name as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDtd),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDtd>())).children as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDtd),
      "::",
      stringify!(children)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDtd>())).last as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDtd),
      "::",
      stringify!(last)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDtd>())).parent as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDtd),
      "::",
      stringify!(parent)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDtd>())).next as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDtd),
      "::",
      stringify!(next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDtd>())).prev as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDtd),
      "::",
      stringify!(prev)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDtd>())).doc as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDtd),
      "::",
      stringify!(doc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDtd>())).notations as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDtd),
      "::",
      stringify!(notations)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDtd>())).elements as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDtd),
      "::",
      stringify!(elements)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDtd>())).attributes as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDtd),
      "::",
      stringify!(attributes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDtd>())).entities as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDtd),
      "::",
      stringify!(entities)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDtd>())).ExternalID as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDtd),
      "::",
      stringify!(ExternalID)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDtd>())).SystemID as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDtd),
      "::",
      stringify!(SystemID)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDtd>())).pentities as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDtd),
      "::",
      stringify!(pentities)
    )
  );
}
/// xmlAttr:
///
/// An attribute on an XML node.
pub type xmlAttr = _xmlAttr;
pub type xmlAttrPtr = *mut xmlAttr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlAttr {
  pub _private: *mut ::std::os::raw::c_void,
  pub type_: xmlElementType,
  pub name: *const xmlChar,
  pub children: *mut _xmlNode,
  pub last: *mut _xmlNode,
  pub parent: *mut _xmlNode,
  pub next: *mut _xmlAttr,
  pub prev: *mut _xmlAttr,
  pub doc: *mut _xmlDoc,
  pub ns: *mut xmlNs,
  pub atype: xmlAttributeType,
  pub psvi: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlAttr() {
  assert_eq!(
    ::std::mem::size_of::<_xmlAttr>(),
    96usize,
    concat!("Size of: ", stringify!(_xmlAttr))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlAttr>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlAttr))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttr>()))._private as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttr),
      "::",
      stringify!(_private)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttr>())).type_ as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttr),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttr>())).name as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttr),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttr>())).children as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttr),
      "::",
      stringify!(children)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttr>())).last as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttr),
      "::",
      stringify!(last)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttr>())).parent as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttr),
      "::",
      stringify!(parent)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttr>())).next as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttr),
      "::",
      stringify!(next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttr>())).prev as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttr),
      "::",
      stringify!(prev)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttr>())).doc as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttr),
      "::",
      stringify!(doc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttr>())).ns as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttr),
      "::",
      stringify!(ns)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttr>())).atype as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttr),
      "::",
      stringify!(atype)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlAttr>())).psvi as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlAttr),
      "::",
      stringify!(psvi)
    )
  );
}
/// xmlID:
///
/// An XML ID instance.
pub type xmlID = _xmlID;
pub type xmlIDPtr = *mut xmlID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlID {
  pub next: *mut _xmlID,
  pub value: *const xmlChar,
  pub attr: xmlAttrPtr,
  pub name: *const xmlChar,
  pub lineno: ::std::os::raw::c_int,
  pub doc: *mut _xmlDoc,
}
#[test]
fn bindgen_test_layout__xmlID() {
  assert_eq!(
    ::std::mem::size_of::<_xmlID>(),
    48usize,
    concat!("Size of: ", stringify!(_xmlID))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlID>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlID))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlID>())).next as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlID),
      "::",
      stringify!(next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlID>())).value as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlID),
      "::",
      stringify!(value)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlID>())).attr as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlID),
      "::",
      stringify!(attr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlID>())).name as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlID),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlID>())).lineno as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlID),
      "::",
      stringify!(lineno)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlID>())).doc as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlID),
      "::",
      stringify!(doc)
    )
  );
}
/// xmlRef:
///
/// An XML IDREF instance.
pub type xmlRef = _xmlRef;
pub type xmlRefPtr = *mut xmlRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlRef {
  pub next: *mut _xmlRef,
  pub value: *const xmlChar,
  pub attr: xmlAttrPtr,
  pub name: *const xmlChar,
  pub lineno: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__xmlRef() {
  assert_eq!(
    ::std::mem::size_of::<_xmlRef>(),
    40usize,
    concat!("Size of: ", stringify!(_xmlRef))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlRef>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlRef))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlRef>())).next as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlRef),
      "::",
      stringify!(next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlRef>())).value as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlRef),
      "::",
      stringify!(value)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlRef>())).attr as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlRef),
      "::",
      stringify!(attr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlRef>())).name as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlRef),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlRef>())).lineno as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlRef),
      "::",
      stringify!(lineno)
    )
  );
}
/// xmlNode:
///
/// A node in an XML tree.
pub type xmlNode = _xmlNode;
pub type xmlNodePtr = *mut xmlNode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlNode {
  pub _private: *mut ::std::os::raw::c_void,
  pub type_: xmlElementType,
  pub name: *const xmlChar,
  pub children: *mut _xmlNode,
  pub last: *mut _xmlNode,
  pub parent: *mut _xmlNode,
  pub next: *mut _xmlNode,
  pub prev: *mut _xmlNode,
  pub doc: *mut _xmlDoc,
  pub ns: *mut xmlNs,
  pub content: *mut xmlChar,
  pub properties: *mut _xmlAttr,
  pub nsDef: *mut xmlNs,
  pub psvi: *mut ::std::os::raw::c_void,
  pub line: ::std::os::raw::c_ushort,
  pub extra: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__xmlNode() {
  assert_eq!(
    ::std::mem::size_of::<_xmlNode>(),
    120usize,
    concat!("Size of: ", stringify!(_xmlNode))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlNode>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlNode))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNode>()))._private as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNode),
      "::",
      stringify!(_private)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNode>())).type_ as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNode),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNode>())).name as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNode),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNode>())).children as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNode),
      "::",
      stringify!(children)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNode>())).last as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNode),
      "::",
      stringify!(last)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNode>())).parent as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNode),
      "::",
      stringify!(parent)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNode>())).next as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNode),
      "::",
      stringify!(next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNode>())).prev as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNode),
      "::",
      stringify!(prev)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNode>())).doc as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNode),
      "::",
      stringify!(doc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNode>())).ns as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNode),
      "::",
      stringify!(ns)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNode>())).content as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNode),
      "::",
      stringify!(content)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNode>())).properties as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNode),
      "::",
      stringify!(properties)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNode>())).nsDef as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNode),
      "::",
      stringify!(nsDef)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNode>())).psvi as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNode),
      "::",
      stringify!(psvi)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNode>())).line as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNode),
      "::",
      stringify!(line)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNode>())).extra as *const _ as usize },
    114usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNode),
      "::",
      stringify!(extra)
    )
  );
}
pub const xmlDocProperties_XML_DOC_WELLFORMED: xmlDocProperties = 1;
pub const xmlDocProperties_XML_DOC_NSVALID: xmlDocProperties = 2;
pub const xmlDocProperties_XML_DOC_OLD10: xmlDocProperties = 4;
pub const xmlDocProperties_XML_DOC_DTDVALID: xmlDocProperties = 8;
pub const xmlDocProperties_XML_DOC_XINCLUDE: xmlDocProperties = 16;
pub const xmlDocProperties_XML_DOC_USERBUILT: xmlDocProperties = 32;
pub const xmlDocProperties_XML_DOC_INTERNAL: xmlDocProperties = 64;
pub const xmlDocProperties_XML_DOC_HTML: xmlDocProperties = 128;
/// xmlDocProperty
///
/// Set of properties of the document as found by the parser
/// Some of them are linked to similary named xmlParserOption
pub type xmlDocProperties = u32;
/// xmlDoc:
///
/// An XML document.
pub type xmlDoc = _xmlDoc;
pub type xmlDocPtr = *mut xmlDoc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlDoc {
  pub _private: *mut ::std::os::raw::c_void,
  pub type_: xmlElementType,
  pub name: *mut ::std::os::raw::c_char,
  pub children: *mut _xmlNode,
  pub last: *mut _xmlNode,
  pub parent: *mut _xmlNode,
  pub next: *mut _xmlNode,
  pub prev: *mut _xmlNode,
  pub doc: *mut _xmlDoc,
  pub compression: ::std::os::raw::c_int,
  pub standalone: ::std::os::raw::c_int,
  pub intSubset: *mut _xmlDtd,
  pub extSubset: *mut _xmlDtd,
  pub oldNs: *mut _xmlNs,
  pub version: *const xmlChar,
  pub encoding: *const xmlChar,
  pub ids: *mut ::std::os::raw::c_void,
  pub refs: *mut ::std::os::raw::c_void,
  pub URL: *const xmlChar,
  pub charset: ::std::os::raw::c_int,
  pub dict: *mut _xmlDict,
  pub psvi: *mut ::std::os::raw::c_void,
  pub parseFlags: ::std::os::raw::c_int,
  pub properties: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__xmlDoc() {
  assert_eq!(
    ::std::mem::size_of::<_xmlDoc>(),
    176usize,
    concat!("Size of: ", stringify!(_xmlDoc))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlDoc>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlDoc))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>()))._private as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(_private)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>())).type_ as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>())).name as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>())).children as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(children)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>())).last as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(last)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>())).parent as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(parent)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>())).next as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>())).prev as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(prev)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>())).doc as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(doc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>())).compression as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(compression)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>())).standalone as *const _ as usize },
    76usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(standalone)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>())).intSubset as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(intSubset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>())).extSubset as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(extSubset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>())).oldNs as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(oldNs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>())).version as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>())).encoding as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(encoding)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>())).ids as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(ids)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>())).refs as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(refs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>())).URL as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(URL)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>())).charset as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(charset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>())).dict as *const _ as usize },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(dict)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>())).psvi as *const _ as usize },
    160usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(psvi)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>())).parseFlags as *const _ as usize },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(parseFlags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDoc>())).properties as *const _ as usize },
    172usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDoc),
      "::",
      stringify!(properties)
    )
  );
}
pub type xmlDOMWrapCtxt = _xmlDOMWrapCtxt;
pub type xmlDOMWrapCtxtPtr = *mut xmlDOMWrapCtxt;
/// xmlDOMWrapAcquireNsFunction:
/// @ctxt:  a DOM wrapper context
/// @node:  the context node (element or attribute)
/// @nsName:  the requested namespace name
/// @nsPrefix:  the requested namespace prefix
///
/// A function called to acquire namespaces (xmlNs) from the wrapper.
///
/// Returns an xmlNsPtr or NULL in case of an error.
pub type xmlDOMWrapAcquireNsFunction = ::std::option::Option<
  unsafe extern "C" fn(
    ctxt: xmlDOMWrapCtxtPtr,
    node: xmlNodePtr,
    nsName: *const xmlChar,
    nsPrefix: *const xmlChar,
  ) -> xmlNsPtr,
>;
/// xmlDOMWrapCtxt:
///
/// Context for DOM wrapper-operations.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlDOMWrapCtxt {
  pub _private: *mut ::std::os::raw::c_void,
  pub type_: ::std::os::raw::c_int,
  pub namespaceMap: *mut ::std::os::raw::c_void,
  pub getNsForNodeFunc: xmlDOMWrapAcquireNsFunction,
}
#[test]
fn bindgen_test_layout__xmlDOMWrapCtxt() {
  assert_eq!(
    ::std::mem::size_of::<_xmlDOMWrapCtxt>(),
    32usize,
    concat!("Size of: ", stringify!(_xmlDOMWrapCtxt))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlDOMWrapCtxt>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlDOMWrapCtxt))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDOMWrapCtxt>()))._private as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDOMWrapCtxt),
      "::",
      stringify!(_private)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDOMWrapCtxt>())).type_ as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDOMWrapCtxt),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDOMWrapCtxt>())).namespaceMap as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDOMWrapCtxt),
      "::",
      stringify!(namespaceMap)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlDOMWrapCtxt>())).getNsForNodeFunc as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlDOMWrapCtxt),
      "::",
      stringify!(getNsForNodeFunc)
    )
  );
}
extern "C" {
  pub fn xmlValidateNCName(
    value: *const xmlChar,
    space: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidateQName(
    value: *const xmlChar,
    space: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidateName(
    value: *const xmlChar,
    space: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidateNMToken(
    value: *const xmlChar,
    space: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlBuildQName(
    ncname: *const xmlChar,
    prefix: *const xmlChar,
    memory: *mut xmlChar,
    len: ::std::os::raw::c_int,
  ) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlSplitQName2(name: *const xmlChar, prefix: *mut *mut xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlSplitQName3(name: *const xmlChar, len: *mut ::std::os::raw::c_int) -> *const xmlChar;
}
extern "C" {
  pub fn xmlSetBufferAllocationScheme(scheme: xmlBufferAllocationScheme);
}
extern "C" {
  pub fn xmlGetBufferAllocationScheme() -> xmlBufferAllocationScheme;
}
extern "C" {
  pub fn xmlBufferCreate() -> xmlBufferPtr;
}
extern "C" {
  pub fn xmlBufferCreateSize(size: usize) -> xmlBufferPtr;
}
extern "C" {
  pub fn xmlBufferCreateStatic(mem: *mut ::std::os::raw::c_void, size: usize) -> xmlBufferPtr;
}
extern "C" {
  pub fn xmlBufferResize(buf: xmlBufferPtr, size: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlBufferFree(buf: xmlBufferPtr);
}
extern "C" {
  pub fn xmlBufferDump(file: *mut FILE, buf: xmlBufferPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlBufferAdd(
    buf: xmlBufferPtr,
    str: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlBufferAddHead(
    buf: xmlBufferPtr,
    str: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlBufferCat(buf: xmlBufferPtr, str: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlBufferCCat(
    buf: xmlBufferPtr,
    str: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlBufferShrink(buf: xmlBufferPtr, len: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlBufferGrow(buf: xmlBufferPtr, len: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlBufferEmpty(buf: xmlBufferPtr);
}
extern "C" {
  pub fn xmlBufferContent(buf: *const xmlBuffer) -> *const xmlChar;
}
extern "C" {
  pub fn xmlBufferDetach(buf: xmlBufferPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlBufferSetAllocationScheme(buf: xmlBufferPtr, scheme: xmlBufferAllocationScheme);
}
extern "C" {
  pub fn xmlBufferLength(buf: *const xmlBuffer) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlCreateIntSubset(
    doc: xmlDocPtr,
    name: *const xmlChar,
    ExternalID: *const xmlChar,
    SystemID: *const xmlChar,
  ) -> xmlDtdPtr;
}
extern "C" {
  pub fn xmlNewDtd(
    doc: xmlDocPtr,
    name: *const xmlChar,
    ExternalID: *const xmlChar,
    SystemID: *const xmlChar,
  ) -> xmlDtdPtr;
}
extern "C" {
  pub fn xmlGetIntSubset(doc: *const xmlDoc) -> xmlDtdPtr;
}
extern "C" {
  pub fn xmlFreeDtd(cur: xmlDtdPtr);
}
extern "C" {
  pub fn xmlNewGlobalNs(doc: xmlDocPtr, href: *const xmlChar, prefix: *const xmlChar) -> xmlNsPtr;
}
extern "C" {
  pub fn xmlNewNs(node: xmlNodePtr, href: *const xmlChar, prefix: *const xmlChar) -> xmlNsPtr;
}
extern "C" {
  pub fn xmlFreeNs(cur: xmlNsPtr);
}
extern "C" {
  pub fn xmlFreeNsList(cur: xmlNsPtr);
}
extern "C" {
  pub fn xmlNewDoc(version: *const xmlChar) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlFreeDoc(cur: xmlDocPtr);
}
extern "C" {
  pub fn xmlNewDocProp(doc: xmlDocPtr, name: *const xmlChar, value: *const xmlChar) -> xmlAttrPtr;
}
extern "C" {
  pub fn xmlNewProp(node: xmlNodePtr, name: *const xmlChar, value: *const xmlChar) -> xmlAttrPtr;
}
extern "C" {
  pub fn xmlNewNsProp(
    node: xmlNodePtr,
    ns: xmlNsPtr,
    name: *const xmlChar,
    value: *const xmlChar,
  ) -> xmlAttrPtr;
}
extern "C" {
  pub fn xmlNewNsPropEatName(
    node: xmlNodePtr,
    ns: xmlNsPtr,
    name: *mut xmlChar,
    value: *const xmlChar,
  ) -> xmlAttrPtr;
}
extern "C" {
  pub fn xmlFreePropList(cur: xmlAttrPtr);
}
extern "C" {
  pub fn xmlFreeProp(cur: xmlAttrPtr);
}
extern "C" {
  pub fn xmlCopyProp(target: xmlNodePtr, cur: xmlAttrPtr) -> xmlAttrPtr;
}
extern "C" {
  pub fn xmlCopyPropList(target: xmlNodePtr, cur: xmlAttrPtr) -> xmlAttrPtr;
}
extern "C" {
  pub fn xmlCopyDtd(dtd: xmlDtdPtr) -> xmlDtdPtr;
}
extern "C" {
  pub fn xmlCopyDoc(doc: xmlDocPtr, recursive: ::std::os::raw::c_int) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlNewDocNode(
    doc: xmlDocPtr,
    ns: xmlNsPtr,
    name: *const xmlChar,
    content: *const xmlChar,
  ) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlNewDocNodeEatName(
    doc: xmlDocPtr,
    ns: xmlNsPtr,
    name: *mut xmlChar,
    content: *const xmlChar,
  ) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlNewNode(ns: xmlNsPtr, name: *const xmlChar) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlNewNodeEatName(ns: xmlNsPtr, name: *mut xmlChar) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlNewChild(
    parent: xmlNodePtr,
    ns: xmlNsPtr,
    name: *const xmlChar,
    content: *const xmlChar,
  ) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlNewDocText(doc: *const xmlDoc, content: *const xmlChar) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlNewText(content: *const xmlChar) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlNewDocPI(doc: xmlDocPtr, name: *const xmlChar, content: *const xmlChar) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlNewPI(name: *const xmlChar, content: *const xmlChar) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlNewDocTextLen(
    doc: xmlDocPtr,
    content: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlNewTextLen(content: *const xmlChar, len: ::std::os::raw::c_int) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlNewDocComment(doc: xmlDocPtr, content: *const xmlChar) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlNewComment(content: *const xmlChar) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlNewCDataBlock(
    doc: xmlDocPtr,
    content: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlNewCharRef(doc: xmlDocPtr, name: *const xmlChar) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlNewReference(doc: *const xmlDoc, name: *const xmlChar) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlCopyNode(node: xmlNodePtr, recursive: ::std::os::raw::c_int) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlDocCopyNode(
    node: xmlNodePtr,
    doc: xmlDocPtr,
    recursive: ::std::os::raw::c_int,
  ) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlDocCopyNodeList(doc: xmlDocPtr, node: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlCopyNodeList(node: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlNewTextChild(
    parent: xmlNodePtr,
    ns: xmlNsPtr,
    name: *const xmlChar,
    content: *const xmlChar,
  ) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlNewDocRawNode(
    doc: xmlDocPtr,
    ns: xmlNsPtr,
    name: *const xmlChar,
    content: *const xmlChar,
  ) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlNewDocFragment(doc: xmlDocPtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlGetLineNo(node: *const xmlNode) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn xmlGetNodePath(node: *const xmlNode) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlDocGetRootElement(doc: *const xmlDoc) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlGetLastChild(parent: *const xmlNode) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlNodeIsText(node: *const xmlNode) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlIsBlankNode(node: *const xmlNode) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlDocSetRootElement(doc: xmlDocPtr, root: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlNodeSetName(cur: xmlNodePtr, name: *const xmlChar);
}
extern "C" {
  pub fn xmlAddChild(parent: xmlNodePtr, cur: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlAddChildList(parent: xmlNodePtr, cur: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlReplaceNode(old: xmlNodePtr, cur: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlAddPrevSibling(cur: xmlNodePtr, elem: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlAddSibling(cur: xmlNodePtr, elem: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlAddNextSibling(cur: xmlNodePtr, elem: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlUnlinkNode(cur: xmlNodePtr);
}
extern "C" {
  pub fn xmlTextMerge(first: xmlNodePtr, second: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlTextConcat(
    node: xmlNodePtr,
    content: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlFreeNodeList(cur: xmlNodePtr);
}
extern "C" {
  pub fn xmlFreeNode(cur: xmlNodePtr);
}
extern "C" {
  pub fn xmlSetTreeDoc(tree: xmlNodePtr, doc: xmlDocPtr);
}
extern "C" {
  pub fn xmlSetListDoc(list: xmlNodePtr, doc: xmlDocPtr);
}
extern "C" {
  pub fn xmlSearchNs(doc: xmlDocPtr, node: xmlNodePtr, nameSpace: *const xmlChar) -> xmlNsPtr;
}
extern "C" {
  pub fn xmlSearchNsByHref(doc: xmlDocPtr, node: xmlNodePtr, href: *const xmlChar) -> xmlNsPtr;
}
extern "C" {
  pub fn xmlGetNsList(doc: *const xmlDoc, node: *const xmlNode) -> *mut xmlNsPtr;
}
extern "C" {
  pub fn xmlSetNs(node: xmlNodePtr, ns: xmlNsPtr);
}
extern "C" {
  pub fn xmlCopyNamespace(cur: xmlNsPtr) -> xmlNsPtr;
}
extern "C" {
  pub fn xmlCopyNamespaceList(cur: xmlNsPtr) -> xmlNsPtr;
}
extern "C" {
  pub fn xmlSetProp(node: xmlNodePtr, name: *const xmlChar, value: *const xmlChar) -> xmlAttrPtr;
}
extern "C" {
  pub fn xmlSetNsProp(
    node: xmlNodePtr,
    ns: xmlNsPtr,
    name: *const xmlChar,
    value: *const xmlChar,
  ) -> xmlAttrPtr;
}
extern "C" {
  pub fn xmlGetNoNsProp(node: *const xmlNode, name: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlGetProp(node: *const xmlNode, name: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlHasProp(node: *const xmlNode, name: *const xmlChar) -> xmlAttrPtr;
}
extern "C" {
  pub fn xmlHasNsProp(
    node: *const xmlNode,
    name: *const xmlChar,
    nameSpace: *const xmlChar,
  ) -> xmlAttrPtr;
}
extern "C" {
  pub fn xmlGetNsProp(
    node: *const xmlNode,
    name: *const xmlChar,
    nameSpace: *const xmlChar,
  ) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlStringGetNodeList(doc: *const xmlDoc, value: *const xmlChar) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlStringLenGetNodeList(
    doc: *const xmlDoc,
    value: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlNodeListGetString(
    doc: xmlDocPtr,
    list: *const xmlNode,
    inLine: ::std::os::raw::c_int,
  ) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlNodeListGetRawString(
    doc: *const xmlDoc,
    list: *const xmlNode,
    inLine: ::std::os::raw::c_int,
  ) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlNodeSetContent(cur: xmlNodePtr, content: *const xmlChar);
}
extern "C" {
  pub fn xmlNodeSetContentLen(cur: xmlNodePtr, content: *const xmlChar, len: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlNodeAddContent(cur: xmlNodePtr, content: *const xmlChar);
}
extern "C" {
  pub fn xmlNodeAddContentLen(cur: xmlNodePtr, content: *const xmlChar, len: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlNodeGetContent(cur: *const xmlNode) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlNodeBufGetContent(buffer: xmlBufferPtr, cur: *const xmlNode) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlBufGetNodeContent(buf: xmlBufPtr, cur: *const xmlNode) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNodeGetLang(cur: *const xmlNode) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlNodeGetSpacePreserve(cur: *const xmlNode) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNodeSetLang(cur: xmlNodePtr, lang: *const xmlChar);
}
extern "C" {
  pub fn xmlNodeSetSpacePreserve(cur: xmlNodePtr, val: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlNodeGetBase(doc: *const xmlDoc, cur: *const xmlNode) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlNodeSetBase(cur: xmlNodePtr, uri: *const xmlChar);
}
extern "C" {
  pub fn xmlRemoveProp(cur: xmlAttrPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUnsetNsProp(
    node: xmlNodePtr,
    ns: xmlNsPtr,
    name: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUnsetProp(node: xmlNodePtr, name: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlBufferWriteCHAR(buf: xmlBufferPtr, string: *const xmlChar);
}
extern "C" {
  pub fn xmlBufferWriteChar(buf: xmlBufferPtr, string: *const ::std::os::raw::c_char);
}
extern "C" {
  pub fn xmlBufferWriteQuotedString(buf: xmlBufferPtr, string: *const xmlChar);
}
extern "C" {
  pub fn xmlAttrSerializeTxtContent(
    buf: xmlBufferPtr,
    doc: xmlDocPtr,
    attr: xmlAttrPtr,
    string: *const xmlChar,
  );
}
extern "C" {
  pub fn xmlReconciliateNs(doc: xmlDocPtr, tree: xmlNodePtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlDocDumpFormatMemory(
    cur: xmlDocPtr,
    mem: *mut *mut xmlChar,
    size: *mut ::std::os::raw::c_int,
    format: ::std::os::raw::c_int,
  );
}
extern "C" {
  pub fn xmlDocDumpMemory(cur: xmlDocPtr, mem: *mut *mut xmlChar, size: *mut ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlDocDumpMemoryEnc(
    out_doc: xmlDocPtr,
    doc_txt_ptr: *mut *mut xmlChar,
    doc_txt_len: *mut ::std::os::raw::c_int,
    txt_encoding: *const ::std::os::raw::c_char,
  );
}
extern "C" {
  pub fn xmlDocDumpFormatMemoryEnc(
    out_doc: xmlDocPtr,
    doc_txt_ptr: *mut *mut xmlChar,
    doc_txt_len: *mut ::std::os::raw::c_int,
    txt_encoding: *const ::std::os::raw::c_char,
    format: ::std::os::raw::c_int,
  );
}
extern "C" {
  pub fn xmlDocFormatDump(
    f: *mut FILE,
    cur: xmlDocPtr,
    format: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlDocDump(f: *mut FILE, cur: xmlDocPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlElemDump(f: *mut FILE, doc: xmlDocPtr, cur: xmlNodePtr);
}
extern "C" {
  pub fn xmlSaveFile(
    filename: *const ::std::os::raw::c_char,
    cur: xmlDocPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSaveFormatFile(
    filename: *const ::std::os::raw::c_char,
    cur: xmlDocPtr,
    format: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlBufNodeDump(
    buf: xmlBufPtr,
    doc: xmlDocPtr,
    cur: xmlNodePtr,
    level: ::std::os::raw::c_int,
    format: ::std::os::raw::c_int,
  ) -> usize;
}
extern "C" {
  pub fn xmlNodeDump(
    buf: xmlBufferPtr,
    doc: xmlDocPtr,
    cur: xmlNodePtr,
    level: ::std::os::raw::c_int,
    format: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSaveFileTo(
    buf: xmlOutputBufferPtr,
    cur: xmlDocPtr,
    encoding: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSaveFormatFileTo(
    buf: xmlOutputBufferPtr,
    cur: xmlDocPtr,
    encoding: *const ::std::os::raw::c_char,
    format: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNodeDumpOutput(
    buf: xmlOutputBufferPtr,
    doc: xmlDocPtr,
    cur: xmlNodePtr,
    level: ::std::os::raw::c_int,
    format: ::std::os::raw::c_int,
    encoding: *const ::std::os::raw::c_char,
  );
}
extern "C" {
  pub fn xmlSaveFormatFileEnc(
    filename: *const ::std::os::raw::c_char,
    cur: xmlDocPtr,
    encoding: *const ::std::os::raw::c_char,
    format: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSaveFileEnc(
    filename: *const ::std::os::raw::c_char,
    cur: xmlDocPtr,
    encoding: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlIsXHTML(systemID: *const xmlChar, publicID: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlGetDocCompressMode(doc: *const xmlDoc) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSetDocCompressMode(doc: xmlDocPtr, mode: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlGetCompressMode() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSetCompressMode(mode: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlDOMWrapNewCtxt() -> xmlDOMWrapCtxtPtr;
}
extern "C" {
  pub fn xmlDOMWrapFreeCtxt(ctxt: xmlDOMWrapCtxtPtr);
}
extern "C" {
  pub fn xmlDOMWrapReconcileNamespaces(
    ctxt: xmlDOMWrapCtxtPtr,
    elem: xmlNodePtr,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlDOMWrapAdoptNode(
    ctxt: xmlDOMWrapCtxtPtr,
    sourceDoc: xmlDocPtr,
    node: xmlNodePtr,
    destDoc: xmlDocPtr,
    destParent: xmlNodePtr,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlDOMWrapRemoveNode(
    ctxt: xmlDOMWrapCtxtPtr,
    doc: xmlDocPtr,
    node: xmlNodePtr,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlDOMWrapCloneNode(
    ctxt: xmlDOMWrapCtxtPtr,
    sourceDoc: xmlDocPtr,
    node: xmlNodePtr,
    clonedNode: *mut xmlNodePtr,
    destDoc: xmlDocPtr,
    destParent: xmlNodePtr,
    deep: ::std::os::raw::c_int,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlChildElementCount(parent: xmlNodePtr) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn xmlNextElementSibling(node: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlFirstElementChild(parent: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlLastElementChild(parent: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlPreviousElementSibling(node: xmlNodePtr) -> xmlNodePtr;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlHashTable {
  _unused: [u8; 0],
}
pub type xmlHashTable = _xmlHashTable;
pub type xmlHashTablePtr = *mut xmlHashTable;
/// xmlHashDeallocator:
/// @payload:  the data in the hash
/// @name:  the name associated
///
/// Callback to free data from a hash.
pub type xmlHashDeallocator = ::std::option::Option<
  unsafe extern "C" fn(payload: *mut ::std::os::raw::c_void, name: *mut xmlChar),
>;
/// xmlHashCopier:
/// @payload:  the data in the hash
/// @name:  the name associated
///
/// Callback to copy data from a hash.
///
/// Returns a copy of the data or NULL in case of error.
pub type xmlHashCopier = ::std::option::Option<
  unsafe extern "C" fn(payload: *mut ::std::os::raw::c_void, name: *mut xmlChar)
    -> *mut ::std::os::raw::c_void,
>;
/// xmlHashScanner:
/// @payload:  the data in the hash
/// @data:  extra scannner data
/// @name:  the name associated
///
/// Callback when scanning data in a hash with the simple scanner.
pub type xmlHashScanner = ::std::option::Option<
  unsafe extern "C" fn(
    payload: *mut ::std::os::raw::c_void,
    data: *mut ::std::os::raw::c_void,
    name: *mut xmlChar,
  ),
>;
/// xmlHashScannerFull:
/// @payload:  the data in the hash
/// @data:  extra scannner data
/// @name:  the name associated
/// @name2:  the second name associated
/// @name3:  the third name associated
///
/// Callback when scanning data in a hash with the full scanner.
pub type xmlHashScannerFull = ::std::option::Option<
  unsafe extern "C" fn(
    payload: *mut ::std::os::raw::c_void,
    data: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    name2: *const xmlChar,
    name3: *const xmlChar,
  ),
>;
extern "C" {
  pub fn xmlHashCreate(size: ::std::os::raw::c_int) -> xmlHashTablePtr;
}
extern "C" {
  pub fn xmlHashCreateDict(size: ::std::os::raw::c_int, dict: xmlDictPtr) -> xmlHashTablePtr;
}
extern "C" {
  pub fn xmlHashFree(table: xmlHashTablePtr, f: xmlHashDeallocator);
}
extern "C" {
  pub fn xmlHashAddEntry(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    userdata: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlHashUpdateEntry(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    userdata: *mut ::std::os::raw::c_void,
    f: xmlHashDeallocator,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlHashAddEntry2(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    name2: *const xmlChar,
    userdata: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlHashUpdateEntry2(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    name2: *const xmlChar,
    userdata: *mut ::std::os::raw::c_void,
    f: xmlHashDeallocator,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlHashAddEntry3(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    name2: *const xmlChar,
    name3: *const xmlChar,
    userdata: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlHashUpdateEntry3(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    name2: *const xmlChar,
    name3: *const xmlChar,
    userdata: *mut ::std::os::raw::c_void,
    f: xmlHashDeallocator,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlHashRemoveEntry(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    f: xmlHashDeallocator,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlHashRemoveEntry2(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    name2: *const xmlChar,
    f: xmlHashDeallocator,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlHashRemoveEntry3(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    name2: *const xmlChar,
    name3: *const xmlChar,
    f: xmlHashDeallocator,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlHashLookup(table: xmlHashTablePtr, name: *const xmlChar)
    -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlHashLookup2(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    name2: *const xmlChar,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlHashLookup3(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    name2: *const xmlChar,
    name3: *const xmlChar,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlHashQLookup(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    prefix: *const xmlChar,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlHashQLookup2(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    prefix: *const xmlChar,
    name2: *const xmlChar,
    prefix2: *const xmlChar,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlHashQLookup3(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    prefix: *const xmlChar,
    name2: *const xmlChar,
    prefix2: *const xmlChar,
    name3: *const xmlChar,
    prefix3: *const xmlChar,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlHashCopy(table: xmlHashTablePtr, f: xmlHashCopier) -> xmlHashTablePtr;
}
extern "C" {
  pub fn xmlHashSize(table: xmlHashTablePtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlHashScan(table: xmlHashTablePtr, f: xmlHashScanner, data: *mut ::std::os::raw::c_void);
}
extern "C" {
  pub fn xmlHashScan3(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    name2: *const xmlChar,
    name3: *const xmlChar,
    f: xmlHashScanner,
    data: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn xmlHashScanFull(
    table: xmlHashTablePtr,
    f: xmlHashScannerFull,
    data: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn xmlHashScanFull3(
    table: xmlHashTablePtr,
    name: *const xmlChar,
    name2: *const xmlChar,
    name3: *const xmlChar,
    f: xmlHashScannerFull,
    data: *mut ::std::os::raw::c_void,
  );
}
pub const xmlErrorLevel_XML_ERR_NONE: xmlErrorLevel = 0;
pub const xmlErrorLevel_XML_ERR_WARNING: xmlErrorLevel = 1;
pub const xmlErrorLevel_XML_ERR_ERROR: xmlErrorLevel = 2;
pub const xmlErrorLevel_XML_ERR_FATAL: xmlErrorLevel = 3;
/// xmlErrorLevel:
///
/// Indicates the level of an error
pub type xmlErrorLevel = u32;
pub const xmlErrorDomain_XML_FROM_NONE: xmlErrorDomain = 0;
pub const xmlErrorDomain_XML_FROM_PARSER: xmlErrorDomain = 1;
pub const xmlErrorDomain_XML_FROM_TREE: xmlErrorDomain = 2;
pub const xmlErrorDomain_XML_FROM_NAMESPACE: xmlErrorDomain = 3;
pub const xmlErrorDomain_XML_FROM_DTD: xmlErrorDomain = 4;
pub const xmlErrorDomain_XML_FROM_HTML: xmlErrorDomain = 5;
pub const xmlErrorDomain_XML_FROM_MEMORY: xmlErrorDomain = 6;
pub const xmlErrorDomain_XML_FROM_OUTPUT: xmlErrorDomain = 7;
pub const xmlErrorDomain_XML_FROM_IO: xmlErrorDomain = 8;
pub const xmlErrorDomain_XML_FROM_FTP: xmlErrorDomain = 9;
pub const xmlErrorDomain_XML_FROM_HTTP: xmlErrorDomain = 10;
pub const xmlErrorDomain_XML_FROM_XINCLUDE: xmlErrorDomain = 11;
pub const xmlErrorDomain_XML_FROM_XPATH: xmlErrorDomain = 12;
pub const xmlErrorDomain_XML_FROM_XPOINTER: xmlErrorDomain = 13;
pub const xmlErrorDomain_XML_FROM_REGEXP: xmlErrorDomain = 14;
pub const xmlErrorDomain_XML_FROM_DATATYPE: xmlErrorDomain = 15;
pub const xmlErrorDomain_XML_FROM_SCHEMASP: xmlErrorDomain = 16;
pub const xmlErrorDomain_XML_FROM_SCHEMASV: xmlErrorDomain = 17;
pub const xmlErrorDomain_XML_FROM_RELAXNGP: xmlErrorDomain = 18;
pub const xmlErrorDomain_XML_FROM_RELAXNGV: xmlErrorDomain = 19;
pub const xmlErrorDomain_XML_FROM_CATALOG: xmlErrorDomain = 20;
pub const xmlErrorDomain_XML_FROM_C14N: xmlErrorDomain = 21;
pub const xmlErrorDomain_XML_FROM_XSLT: xmlErrorDomain = 22;
pub const xmlErrorDomain_XML_FROM_VALID: xmlErrorDomain = 23;
pub const xmlErrorDomain_XML_FROM_CHECK: xmlErrorDomain = 24;
pub const xmlErrorDomain_XML_FROM_WRITER: xmlErrorDomain = 25;
pub const xmlErrorDomain_XML_FROM_MODULE: xmlErrorDomain = 26;
pub const xmlErrorDomain_XML_FROM_I18N: xmlErrorDomain = 27;
pub const xmlErrorDomain_XML_FROM_SCHEMATRONV: xmlErrorDomain = 28;
pub const xmlErrorDomain_XML_FROM_BUFFER: xmlErrorDomain = 29;
pub const xmlErrorDomain_XML_FROM_URI: xmlErrorDomain = 30;
/// xmlErrorDomain:
///
/// Indicates where an error may have come from
pub type xmlErrorDomain = u32;
/// xmlError:
///
/// An XML Error instance.
pub type xmlError = _xmlError;
pub type xmlErrorPtr = *mut xmlError;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlError {
  pub domain: ::std::os::raw::c_int,
  pub code: ::std::os::raw::c_int,
  pub message: *mut ::std::os::raw::c_char,
  pub level: xmlErrorLevel,
  pub file: *mut ::std::os::raw::c_char,
  pub line: ::std::os::raw::c_int,
  pub str1: *mut ::std::os::raw::c_char,
  pub str2: *mut ::std::os::raw::c_char,
  pub str3: *mut ::std::os::raw::c_char,
  pub int1: ::std::os::raw::c_int,
  pub int2: ::std::os::raw::c_int,
  pub ctxt: *mut ::std::os::raw::c_void,
  pub node: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlError() {
  assert_eq!(
    ::std::mem::size_of::<_xmlError>(),
    88usize,
    concat!("Size of: ", stringify!(_xmlError))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlError>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlError))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlError>())).domain as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlError),
      "::",
      stringify!(domain)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlError>())).code as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlError),
      "::",
      stringify!(code)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlError>())).message as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlError),
      "::",
      stringify!(message)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlError>())).level as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlError),
      "::",
      stringify!(level)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlError>())).file as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlError),
      "::",
      stringify!(file)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlError>())).line as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlError),
      "::",
      stringify!(line)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlError>())).str1 as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlError),
      "::",
      stringify!(str1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlError>())).str2 as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlError),
      "::",
      stringify!(str2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlError>())).str3 as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlError),
      "::",
      stringify!(str3)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlError>())).int1 as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlError),
      "::",
      stringify!(int1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlError>())).int2 as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlError),
      "::",
      stringify!(int2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlError>())).ctxt as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlError),
      "::",
      stringify!(ctxt)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlError>())).node as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlError),
      "::",
      stringify!(node)
    )
  );
}
pub const xmlParserErrors_XML_ERR_OK: xmlParserErrors = 0;
pub const xmlParserErrors_XML_ERR_INTERNAL_ERROR: xmlParserErrors = 1;
pub const xmlParserErrors_XML_ERR_NO_MEMORY: xmlParserErrors = 2;
pub const xmlParserErrors_XML_ERR_DOCUMENT_START: xmlParserErrors = 3;
pub const xmlParserErrors_XML_ERR_DOCUMENT_EMPTY: xmlParserErrors = 4;
pub const xmlParserErrors_XML_ERR_DOCUMENT_END: xmlParserErrors = 5;
pub const xmlParserErrors_XML_ERR_INVALID_HEX_CHARREF: xmlParserErrors = 6;
pub const xmlParserErrors_XML_ERR_INVALID_DEC_CHARREF: xmlParserErrors = 7;
pub const xmlParserErrors_XML_ERR_INVALID_CHARREF: xmlParserErrors = 8;
pub const xmlParserErrors_XML_ERR_INVALID_CHAR: xmlParserErrors = 9;
pub const xmlParserErrors_XML_ERR_CHARREF_AT_EOF: xmlParserErrors = 10;
pub const xmlParserErrors_XML_ERR_CHARREF_IN_PROLOG: xmlParserErrors = 11;
pub const xmlParserErrors_XML_ERR_CHARREF_IN_EPILOG: xmlParserErrors = 12;
pub const xmlParserErrors_XML_ERR_CHARREF_IN_DTD: xmlParserErrors = 13;
pub const xmlParserErrors_XML_ERR_ENTITYREF_AT_EOF: xmlParserErrors = 14;
pub const xmlParserErrors_XML_ERR_ENTITYREF_IN_PROLOG: xmlParserErrors = 15;
pub const xmlParserErrors_XML_ERR_ENTITYREF_IN_EPILOG: xmlParserErrors = 16;
pub const xmlParserErrors_XML_ERR_ENTITYREF_IN_DTD: xmlParserErrors = 17;
pub const xmlParserErrors_XML_ERR_PEREF_AT_EOF: xmlParserErrors = 18;
pub const xmlParserErrors_XML_ERR_PEREF_IN_PROLOG: xmlParserErrors = 19;
pub const xmlParserErrors_XML_ERR_PEREF_IN_EPILOG: xmlParserErrors = 20;
pub const xmlParserErrors_XML_ERR_PEREF_IN_INT_SUBSET: xmlParserErrors = 21;
pub const xmlParserErrors_XML_ERR_ENTITYREF_NO_NAME: xmlParserErrors = 22;
pub const xmlParserErrors_XML_ERR_ENTITYREF_SEMICOL_MISSING: xmlParserErrors = 23;
pub const xmlParserErrors_XML_ERR_PEREF_NO_NAME: xmlParserErrors = 24;
pub const xmlParserErrors_XML_ERR_PEREF_SEMICOL_MISSING: xmlParserErrors = 25;
pub const xmlParserErrors_XML_ERR_UNDECLARED_ENTITY: xmlParserErrors = 26;
pub const xmlParserErrors_XML_WAR_UNDECLARED_ENTITY: xmlParserErrors = 27;
pub const xmlParserErrors_XML_ERR_UNPARSED_ENTITY: xmlParserErrors = 28;
pub const xmlParserErrors_XML_ERR_ENTITY_IS_EXTERNAL: xmlParserErrors = 29;
pub const xmlParserErrors_XML_ERR_ENTITY_IS_PARAMETER: xmlParserErrors = 30;
pub const xmlParserErrors_XML_ERR_UNKNOWN_ENCODING: xmlParserErrors = 31;
pub const xmlParserErrors_XML_ERR_UNSUPPORTED_ENCODING: xmlParserErrors = 32;
pub const xmlParserErrors_XML_ERR_STRING_NOT_STARTED: xmlParserErrors = 33;
pub const xmlParserErrors_XML_ERR_STRING_NOT_CLOSED: xmlParserErrors = 34;
pub const xmlParserErrors_XML_ERR_NS_DECL_ERROR: xmlParserErrors = 35;
pub const xmlParserErrors_XML_ERR_ENTITY_NOT_STARTED: xmlParserErrors = 36;
pub const xmlParserErrors_XML_ERR_ENTITY_NOT_FINISHED: xmlParserErrors = 37;
pub const xmlParserErrors_XML_ERR_LT_IN_ATTRIBUTE: xmlParserErrors = 38;
pub const xmlParserErrors_XML_ERR_ATTRIBUTE_NOT_STARTED: xmlParserErrors = 39;
pub const xmlParserErrors_XML_ERR_ATTRIBUTE_NOT_FINISHED: xmlParserErrors = 40;
pub const xmlParserErrors_XML_ERR_ATTRIBUTE_WITHOUT_VALUE: xmlParserErrors = 41;
pub const xmlParserErrors_XML_ERR_ATTRIBUTE_REDEFINED: xmlParserErrors = 42;
pub const xmlParserErrors_XML_ERR_LITERAL_NOT_STARTED: xmlParserErrors = 43;
pub const xmlParserErrors_XML_ERR_LITERAL_NOT_FINISHED: xmlParserErrors = 44;
pub const xmlParserErrors_XML_ERR_COMMENT_NOT_FINISHED: xmlParserErrors = 45;
pub const xmlParserErrors_XML_ERR_PI_NOT_STARTED: xmlParserErrors = 46;
pub const xmlParserErrors_XML_ERR_PI_NOT_FINISHED: xmlParserErrors = 47;
pub const xmlParserErrors_XML_ERR_NOTATION_NOT_STARTED: xmlParserErrors = 48;
pub const xmlParserErrors_XML_ERR_NOTATION_NOT_FINISHED: xmlParserErrors = 49;
pub const xmlParserErrors_XML_ERR_ATTLIST_NOT_STARTED: xmlParserErrors = 50;
pub const xmlParserErrors_XML_ERR_ATTLIST_NOT_FINISHED: xmlParserErrors = 51;
pub const xmlParserErrors_XML_ERR_MIXED_NOT_STARTED: xmlParserErrors = 52;
pub const xmlParserErrors_XML_ERR_MIXED_NOT_FINISHED: xmlParserErrors = 53;
pub const xmlParserErrors_XML_ERR_ELEMCONTENT_NOT_STARTED: xmlParserErrors = 54;
pub const xmlParserErrors_XML_ERR_ELEMCONTENT_NOT_FINISHED: xmlParserErrors = 55;
pub const xmlParserErrors_XML_ERR_XMLDECL_NOT_STARTED: xmlParserErrors = 56;
pub const xmlParserErrors_XML_ERR_XMLDECL_NOT_FINISHED: xmlParserErrors = 57;
pub const xmlParserErrors_XML_ERR_CONDSEC_NOT_STARTED: xmlParserErrors = 58;
pub const xmlParserErrors_XML_ERR_CONDSEC_NOT_FINISHED: xmlParserErrors = 59;
pub const xmlParserErrors_XML_ERR_EXT_SUBSET_NOT_FINISHED: xmlParserErrors = 60;
pub const xmlParserErrors_XML_ERR_DOCTYPE_NOT_FINISHED: xmlParserErrors = 61;
pub const xmlParserErrors_XML_ERR_MISPLACED_CDATA_END: xmlParserErrors = 62;
pub const xmlParserErrors_XML_ERR_CDATA_NOT_FINISHED: xmlParserErrors = 63;
pub const xmlParserErrors_XML_ERR_RESERVED_XML_NAME: xmlParserErrors = 64;
pub const xmlParserErrors_XML_ERR_SPACE_REQUIRED: xmlParserErrors = 65;
pub const xmlParserErrors_XML_ERR_SEPARATOR_REQUIRED: xmlParserErrors = 66;
pub const xmlParserErrors_XML_ERR_NMTOKEN_REQUIRED: xmlParserErrors = 67;
pub const xmlParserErrors_XML_ERR_NAME_REQUIRED: xmlParserErrors = 68;
pub const xmlParserErrors_XML_ERR_PCDATA_REQUIRED: xmlParserErrors = 69;
pub const xmlParserErrors_XML_ERR_URI_REQUIRED: xmlParserErrors = 70;
pub const xmlParserErrors_XML_ERR_PUBID_REQUIRED: xmlParserErrors = 71;
pub const xmlParserErrors_XML_ERR_LT_REQUIRED: xmlParserErrors = 72;
pub const xmlParserErrors_XML_ERR_GT_REQUIRED: xmlParserErrors = 73;
pub const xmlParserErrors_XML_ERR_LTSLASH_REQUIRED: xmlParserErrors = 74;
pub const xmlParserErrors_XML_ERR_EQUAL_REQUIRED: xmlParserErrors = 75;
pub const xmlParserErrors_XML_ERR_TAG_NAME_MISMATCH: xmlParserErrors = 76;
pub const xmlParserErrors_XML_ERR_TAG_NOT_FINISHED: xmlParserErrors = 77;
pub const xmlParserErrors_XML_ERR_STANDALONE_VALUE: xmlParserErrors = 78;
pub const xmlParserErrors_XML_ERR_ENCODING_NAME: xmlParserErrors = 79;
pub const xmlParserErrors_XML_ERR_HYPHEN_IN_COMMENT: xmlParserErrors = 80;
pub const xmlParserErrors_XML_ERR_INVALID_ENCODING: xmlParserErrors = 81;
pub const xmlParserErrors_XML_ERR_EXT_ENTITY_STANDALONE: xmlParserErrors = 82;
pub const xmlParserErrors_XML_ERR_CONDSEC_INVALID: xmlParserErrors = 83;
pub const xmlParserErrors_XML_ERR_VALUE_REQUIRED: xmlParserErrors = 84;
pub const xmlParserErrors_XML_ERR_NOT_WELL_BALANCED: xmlParserErrors = 85;
pub const xmlParserErrors_XML_ERR_EXTRA_CONTENT: xmlParserErrors = 86;
pub const xmlParserErrors_XML_ERR_ENTITY_CHAR_ERROR: xmlParserErrors = 87;
pub const xmlParserErrors_XML_ERR_ENTITY_PE_INTERNAL: xmlParserErrors = 88;
pub const xmlParserErrors_XML_ERR_ENTITY_LOOP: xmlParserErrors = 89;
pub const xmlParserErrors_XML_ERR_ENTITY_BOUNDARY: xmlParserErrors = 90;
pub const xmlParserErrors_XML_ERR_INVALID_URI: xmlParserErrors = 91;
pub const xmlParserErrors_XML_ERR_URI_FRAGMENT: xmlParserErrors = 92;
pub const xmlParserErrors_XML_WAR_CATALOG_PI: xmlParserErrors = 93;
pub const xmlParserErrors_XML_ERR_NO_DTD: xmlParserErrors = 94;
pub const xmlParserErrors_XML_ERR_CONDSEC_INVALID_KEYWORD: xmlParserErrors = 95;
pub const xmlParserErrors_XML_ERR_VERSION_MISSING: xmlParserErrors = 96;
pub const xmlParserErrors_XML_WAR_UNKNOWN_VERSION: xmlParserErrors = 97;
pub const xmlParserErrors_XML_WAR_LANG_VALUE: xmlParserErrors = 98;
pub const xmlParserErrors_XML_WAR_NS_URI: xmlParserErrors = 99;
pub const xmlParserErrors_XML_WAR_NS_URI_RELATIVE: xmlParserErrors = 100;
pub const xmlParserErrors_XML_ERR_MISSING_ENCODING: xmlParserErrors = 101;
pub const xmlParserErrors_XML_WAR_SPACE_VALUE: xmlParserErrors = 102;
pub const xmlParserErrors_XML_ERR_NOT_STANDALONE: xmlParserErrors = 103;
pub const xmlParserErrors_XML_ERR_ENTITY_PROCESSING: xmlParserErrors = 104;
pub const xmlParserErrors_XML_ERR_NOTATION_PROCESSING: xmlParserErrors = 105;
pub const xmlParserErrors_XML_WAR_NS_COLUMN: xmlParserErrors = 106;
pub const xmlParserErrors_XML_WAR_ENTITY_REDEFINED: xmlParserErrors = 107;
pub const xmlParserErrors_XML_ERR_UNKNOWN_VERSION: xmlParserErrors = 108;
pub const xmlParserErrors_XML_ERR_VERSION_MISMATCH: xmlParserErrors = 109;
pub const xmlParserErrors_XML_ERR_NAME_TOO_LONG: xmlParserErrors = 110;
pub const xmlParserErrors_XML_ERR_USER_STOP: xmlParserErrors = 111;
pub const xmlParserErrors_XML_NS_ERR_XML_NAMESPACE: xmlParserErrors = 200;
pub const xmlParserErrors_XML_NS_ERR_UNDEFINED_NAMESPACE: xmlParserErrors = 201;
pub const xmlParserErrors_XML_NS_ERR_QNAME: xmlParserErrors = 202;
pub const xmlParserErrors_XML_NS_ERR_ATTRIBUTE_REDEFINED: xmlParserErrors = 203;
pub const xmlParserErrors_XML_NS_ERR_EMPTY: xmlParserErrors = 204;
pub const xmlParserErrors_XML_NS_ERR_COLON: xmlParserErrors = 205;
pub const xmlParserErrors_XML_DTD_ATTRIBUTE_DEFAULT: xmlParserErrors = 500;
pub const xmlParserErrors_XML_DTD_ATTRIBUTE_REDEFINED: xmlParserErrors = 501;
pub const xmlParserErrors_XML_DTD_ATTRIBUTE_VALUE: xmlParserErrors = 502;
pub const xmlParserErrors_XML_DTD_CONTENT_ERROR: xmlParserErrors = 503;
pub const xmlParserErrors_XML_DTD_CONTENT_MODEL: xmlParserErrors = 504;
pub const xmlParserErrors_XML_DTD_CONTENT_NOT_DETERMINIST: xmlParserErrors = 505;
pub const xmlParserErrors_XML_DTD_DIFFERENT_PREFIX: xmlParserErrors = 506;
pub const xmlParserErrors_XML_DTD_ELEM_DEFAULT_NAMESPACE: xmlParserErrors = 507;
pub const xmlParserErrors_XML_DTD_ELEM_NAMESPACE: xmlParserErrors = 508;
pub const xmlParserErrors_XML_DTD_ELEM_REDEFINED: xmlParserErrors = 509;
pub const xmlParserErrors_XML_DTD_EMPTY_NOTATION: xmlParserErrors = 510;
pub const xmlParserErrors_XML_DTD_ENTITY_TYPE: xmlParserErrors = 511;
pub const xmlParserErrors_XML_DTD_ID_FIXED: xmlParserErrors = 512;
pub const xmlParserErrors_XML_DTD_ID_REDEFINED: xmlParserErrors = 513;
pub const xmlParserErrors_XML_DTD_ID_SUBSET: xmlParserErrors = 514;
pub const xmlParserErrors_XML_DTD_INVALID_CHILD: xmlParserErrors = 515;
pub const xmlParserErrors_XML_DTD_INVALID_DEFAULT: xmlParserErrors = 516;
pub const xmlParserErrors_XML_DTD_LOAD_ERROR: xmlParserErrors = 517;
pub const xmlParserErrors_XML_DTD_MISSING_ATTRIBUTE: xmlParserErrors = 518;
pub const xmlParserErrors_XML_DTD_MIXED_CORRUPT: xmlParserErrors = 519;
pub const xmlParserErrors_XML_DTD_MULTIPLE_ID: xmlParserErrors = 520;
pub const xmlParserErrors_XML_DTD_NO_DOC: xmlParserErrors = 521;
pub const xmlParserErrors_XML_DTD_NO_DTD: xmlParserErrors = 522;
pub const xmlParserErrors_XML_DTD_NO_ELEM_NAME: xmlParserErrors = 523;
pub const xmlParserErrors_XML_DTD_NO_PREFIX: xmlParserErrors = 524;
pub const xmlParserErrors_XML_DTD_NO_ROOT: xmlParserErrors = 525;
pub const xmlParserErrors_XML_DTD_NOTATION_REDEFINED: xmlParserErrors = 526;
pub const xmlParserErrors_XML_DTD_NOTATION_VALUE: xmlParserErrors = 527;
pub const xmlParserErrors_XML_DTD_NOT_EMPTY: xmlParserErrors = 528;
pub const xmlParserErrors_XML_DTD_NOT_PCDATA: xmlParserErrors = 529;
pub const xmlParserErrors_XML_DTD_NOT_STANDALONE: xmlParserErrors = 530;
pub const xmlParserErrors_XML_DTD_ROOT_NAME: xmlParserErrors = 531;
pub const xmlParserErrors_XML_DTD_STANDALONE_WHITE_SPACE: xmlParserErrors = 532;
pub const xmlParserErrors_XML_DTD_UNKNOWN_ATTRIBUTE: xmlParserErrors = 533;
pub const xmlParserErrors_XML_DTD_UNKNOWN_ELEM: xmlParserErrors = 534;
pub const xmlParserErrors_XML_DTD_UNKNOWN_ENTITY: xmlParserErrors = 535;
pub const xmlParserErrors_XML_DTD_UNKNOWN_ID: xmlParserErrors = 536;
pub const xmlParserErrors_XML_DTD_UNKNOWN_NOTATION: xmlParserErrors = 537;
pub const xmlParserErrors_XML_DTD_STANDALONE_DEFAULTED: xmlParserErrors = 538;
pub const xmlParserErrors_XML_DTD_XMLID_VALUE: xmlParserErrors = 539;
pub const xmlParserErrors_XML_DTD_XMLID_TYPE: xmlParserErrors = 540;
pub const xmlParserErrors_XML_DTD_DUP_TOKEN: xmlParserErrors = 541;
pub const xmlParserErrors_XML_HTML_STRUCURE_ERROR: xmlParserErrors = 800;
pub const xmlParserErrors_XML_HTML_UNKNOWN_TAG: xmlParserErrors = 801;
pub const xmlParserErrors_XML_RNGP_ANYNAME_ATTR_ANCESTOR: xmlParserErrors = 1000;
pub const xmlParserErrors_XML_RNGP_ATTR_CONFLICT: xmlParserErrors = 1001;
pub const xmlParserErrors_XML_RNGP_ATTRIBUTE_CHILDREN: xmlParserErrors = 1002;
pub const xmlParserErrors_XML_RNGP_ATTRIBUTE_CONTENT: xmlParserErrors = 1003;
pub const xmlParserErrors_XML_RNGP_ATTRIBUTE_EMPTY: xmlParserErrors = 1004;
pub const xmlParserErrors_XML_RNGP_ATTRIBUTE_NOOP: xmlParserErrors = 1005;
pub const xmlParserErrors_XML_RNGP_CHOICE_CONTENT: xmlParserErrors = 1006;
pub const xmlParserErrors_XML_RNGP_CHOICE_EMPTY: xmlParserErrors = 1007;
pub const xmlParserErrors_XML_RNGP_CREATE_FAILURE: xmlParserErrors = 1008;
pub const xmlParserErrors_XML_RNGP_DATA_CONTENT: xmlParserErrors = 1009;
pub const xmlParserErrors_XML_RNGP_DEF_CHOICE_AND_INTERLEAVE: xmlParserErrors = 1010;
pub const xmlParserErrors_XML_RNGP_DEFINE_CREATE_FAILED: xmlParserErrors = 1011;
pub const xmlParserErrors_XML_RNGP_DEFINE_EMPTY: xmlParserErrors = 1012;
pub const xmlParserErrors_XML_RNGP_DEFINE_MISSING: xmlParserErrors = 1013;
pub const xmlParserErrors_XML_RNGP_DEFINE_NAME_MISSING: xmlParserErrors = 1014;
pub const xmlParserErrors_XML_RNGP_ELEM_CONTENT_EMPTY: xmlParserErrors = 1015;
pub const xmlParserErrors_XML_RNGP_ELEM_CONTENT_ERROR: xmlParserErrors = 1016;
pub const xmlParserErrors_XML_RNGP_ELEMENT_EMPTY: xmlParserErrors = 1017;
pub const xmlParserErrors_XML_RNGP_ELEMENT_CONTENT: xmlParserErrors = 1018;
pub const xmlParserErrors_XML_RNGP_ELEMENT_NAME: xmlParserErrors = 1019;
pub const xmlParserErrors_XML_RNGP_ELEMENT_NO_CONTENT: xmlParserErrors = 1020;
pub const xmlParserErrors_XML_RNGP_ELEM_TEXT_CONFLICT: xmlParserErrors = 1021;
pub const xmlParserErrors_XML_RNGP_EMPTY: xmlParserErrors = 1022;
pub const xmlParserErrors_XML_RNGP_EMPTY_CONSTRUCT: xmlParserErrors = 1023;
pub const xmlParserErrors_XML_RNGP_EMPTY_CONTENT: xmlParserErrors = 1024;
pub const xmlParserErrors_XML_RNGP_EMPTY_NOT_EMPTY: xmlParserErrors = 1025;
pub const xmlParserErrors_XML_RNGP_ERROR_TYPE_LIB: xmlParserErrors = 1026;
pub const xmlParserErrors_XML_RNGP_EXCEPT_EMPTY: xmlParserErrors = 1027;
pub const xmlParserErrors_XML_RNGP_EXCEPT_MISSING: xmlParserErrors = 1028;
pub const xmlParserErrors_XML_RNGP_EXCEPT_MULTIPLE: xmlParserErrors = 1029;
pub const xmlParserErrors_XML_RNGP_EXCEPT_NO_CONTENT: xmlParserErrors = 1030;
pub const xmlParserErrors_XML_RNGP_EXTERNALREF_EMTPY: xmlParserErrors = 1031;
pub const xmlParserErrors_XML_RNGP_EXTERNAL_REF_FAILURE: xmlParserErrors = 1032;
pub const xmlParserErrors_XML_RNGP_EXTERNALREF_RECURSE: xmlParserErrors = 1033;
pub const xmlParserErrors_XML_RNGP_FORBIDDEN_ATTRIBUTE: xmlParserErrors = 1034;
pub const xmlParserErrors_XML_RNGP_FOREIGN_ELEMENT: xmlParserErrors = 1035;
pub const xmlParserErrors_XML_RNGP_GRAMMAR_CONTENT: xmlParserErrors = 1036;
pub const xmlParserErrors_XML_RNGP_GRAMMAR_EMPTY: xmlParserErrors = 1037;
pub const xmlParserErrors_XML_RNGP_GRAMMAR_MISSING: xmlParserErrors = 1038;
pub const xmlParserErrors_XML_RNGP_GRAMMAR_NO_START: xmlParserErrors = 1039;
pub const xmlParserErrors_XML_RNGP_GROUP_ATTR_CONFLICT: xmlParserErrors = 1040;
pub const xmlParserErrors_XML_RNGP_HREF_ERROR: xmlParserErrors = 1041;
pub const xmlParserErrors_XML_RNGP_INCLUDE_EMPTY: xmlParserErrors = 1042;
pub const xmlParserErrors_XML_RNGP_INCLUDE_FAILURE: xmlParserErrors = 1043;
pub const xmlParserErrors_XML_RNGP_INCLUDE_RECURSE: xmlParserErrors = 1044;
pub const xmlParserErrors_XML_RNGP_INTERLEAVE_ADD: xmlParserErrors = 1045;
pub const xmlParserErrors_XML_RNGP_INTERLEAVE_CREATE_FAILED: xmlParserErrors = 1046;
pub const xmlParserErrors_XML_RNGP_INTERLEAVE_EMPTY: xmlParserErrors = 1047;
pub const xmlParserErrors_XML_RNGP_INTERLEAVE_NO_CONTENT: xmlParserErrors = 1048;
pub const xmlParserErrors_XML_RNGP_INVALID_DEFINE_NAME: xmlParserErrors = 1049;
pub const xmlParserErrors_XML_RNGP_INVALID_URI: xmlParserErrors = 1050;
pub const xmlParserErrors_XML_RNGP_INVALID_VALUE: xmlParserErrors = 1051;
pub const xmlParserErrors_XML_RNGP_MISSING_HREF: xmlParserErrors = 1052;
pub const xmlParserErrors_XML_RNGP_NAME_MISSING: xmlParserErrors = 1053;
pub const xmlParserErrors_XML_RNGP_NEED_COMBINE: xmlParserErrors = 1054;
pub const xmlParserErrors_XML_RNGP_NOTALLOWED_NOT_EMPTY: xmlParserErrors = 1055;
pub const xmlParserErrors_XML_RNGP_NSNAME_ATTR_ANCESTOR: xmlParserErrors = 1056;
pub const xmlParserErrors_XML_RNGP_NSNAME_NO_NS: xmlParserErrors = 1057;
pub const xmlParserErrors_XML_RNGP_PARAM_FORBIDDEN: xmlParserErrors = 1058;
pub const xmlParserErrors_XML_RNGP_PARAM_NAME_MISSING: xmlParserErrors = 1059;
pub const xmlParserErrors_XML_RNGP_PARENTREF_CREATE_FAILED: xmlParserErrors = 1060;
pub const xmlParserErrors_XML_RNGP_PARENTREF_NAME_INVALID: xmlParserErrors = 1061;
pub const xmlParserErrors_XML_RNGP_PARENTREF_NO_NAME: xmlParserErrors = 1062;
pub const xmlParserErrors_XML_RNGP_PARENTREF_NO_PARENT: xmlParserErrors = 1063;
pub const xmlParserErrors_XML_RNGP_PARENTREF_NOT_EMPTY: xmlParserErrors = 1064;
pub const xmlParserErrors_XML_RNGP_PARSE_ERROR: xmlParserErrors = 1065;
pub const xmlParserErrors_XML_RNGP_PAT_ANYNAME_EXCEPT_ANYNAME: xmlParserErrors = 1066;
pub const xmlParserErrors_XML_RNGP_PAT_ATTR_ATTR: xmlParserErrors = 1067;
pub const xmlParserErrors_XML_RNGP_PAT_ATTR_ELEM: xmlParserErrors = 1068;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_ATTR: xmlParserErrors = 1069;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_ELEM: xmlParserErrors = 1070;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_EMPTY: xmlParserErrors = 1071;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_GROUP: xmlParserErrors = 1072;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_INTERLEAVE: xmlParserErrors = 1073;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_LIST: xmlParserErrors = 1074;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_ONEMORE: xmlParserErrors = 1075;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_REF: xmlParserErrors = 1076;
pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_TEXT: xmlParserErrors = 1077;
pub const xmlParserErrors_XML_RNGP_PAT_LIST_ATTR: xmlParserErrors = 1078;
pub const xmlParserErrors_XML_RNGP_PAT_LIST_ELEM: xmlParserErrors = 1079;
pub const xmlParserErrors_XML_RNGP_PAT_LIST_INTERLEAVE: xmlParserErrors = 1080;
pub const xmlParserErrors_XML_RNGP_PAT_LIST_LIST: xmlParserErrors = 1081;
pub const xmlParserErrors_XML_RNGP_PAT_LIST_REF: xmlParserErrors = 1082;
pub const xmlParserErrors_XML_RNGP_PAT_LIST_TEXT: xmlParserErrors = 1083;
pub const xmlParserErrors_XML_RNGP_PAT_NSNAME_EXCEPT_ANYNAME: xmlParserErrors = 1084;
pub const xmlParserErrors_XML_RNGP_PAT_NSNAME_EXCEPT_NSNAME: xmlParserErrors = 1085;
pub const xmlParserErrors_XML_RNGP_PAT_ONEMORE_GROUP_ATTR: xmlParserErrors = 1086;
pub const xmlParserErrors_XML_RNGP_PAT_ONEMORE_INTERLEAVE_ATTR: xmlParserErrors = 1087;
pub const xmlParserErrors_XML_RNGP_PAT_START_ATTR: xmlParserErrors = 1088;
pub const xmlParserErrors_XML_RNGP_PAT_START_DATA: xmlParserErrors = 1089;
pub const xmlParserErrors_XML_RNGP_PAT_START_EMPTY: xmlParserErrors = 1090;
pub const xmlParserErrors_XML_RNGP_PAT_START_GROUP: xmlParserErrors = 1091;
pub const xmlParserErrors_XML_RNGP_PAT_START_INTERLEAVE: xmlParserErrors = 1092;
pub const xmlParserErrors_XML_RNGP_PAT_START_LIST: xmlParserErrors = 1093;
pub const xmlParserErrors_XML_RNGP_PAT_START_ONEMORE: xmlParserErrors = 1094;
pub const xmlParserErrors_XML_RNGP_PAT_START_TEXT: xmlParserErrors = 1095;
pub const xmlParserErrors_XML_RNGP_PAT_START_VALUE: xmlParserErrors = 1096;
pub const xmlParserErrors_XML_RNGP_PREFIX_UNDEFINED: xmlParserErrors = 1097;
pub const xmlParserErrors_XML_RNGP_REF_CREATE_FAILED: xmlParserErrors = 1098;
pub const xmlParserErrors_XML_RNGP_REF_CYCLE: xmlParserErrors = 1099;
pub const xmlParserErrors_XML_RNGP_REF_NAME_INVALID: xmlParserErrors = 1100;
pub const xmlParserErrors_XML_RNGP_REF_NO_DEF: xmlParserErrors = 1101;
pub const xmlParserErrors_XML_RNGP_REF_NO_NAME: xmlParserErrors = 1102;
pub const xmlParserErrors_XML_RNGP_REF_NOT_EMPTY: xmlParserErrors = 1103;
pub const xmlParserErrors_XML_RNGP_START_CHOICE_AND_INTERLEAVE: xmlParserErrors = 1104;
pub const xmlParserErrors_XML_RNGP_START_CONTENT: xmlParserErrors = 1105;
pub const xmlParserErrors_XML_RNGP_START_EMPTY: xmlParserErrors = 1106;
pub const xmlParserErrors_XML_RNGP_START_MISSING: xmlParserErrors = 1107;
pub const xmlParserErrors_XML_RNGP_TEXT_EXPECTED: xmlParserErrors = 1108;
pub const xmlParserErrors_XML_RNGP_TEXT_HAS_CHILD: xmlParserErrors = 1109;
pub const xmlParserErrors_XML_RNGP_TYPE_MISSING: xmlParserErrors = 1110;
pub const xmlParserErrors_XML_RNGP_TYPE_NOT_FOUND: xmlParserErrors = 1111;
pub const xmlParserErrors_XML_RNGP_TYPE_VALUE: xmlParserErrors = 1112;
pub const xmlParserErrors_XML_RNGP_UNKNOWN_ATTRIBUTE: xmlParserErrors = 1113;
pub const xmlParserErrors_XML_RNGP_UNKNOWN_COMBINE: xmlParserErrors = 1114;
pub const xmlParserErrors_XML_RNGP_UNKNOWN_CONSTRUCT: xmlParserErrors = 1115;
pub const xmlParserErrors_XML_RNGP_UNKNOWN_TYPE_LIB: xmlParserErrors = 1116;
pub const xmlParserErrors_XML_RNGP_URI_FRAGMENT: xmlParserErrors = 1117;
pub const xmlParserErrors_XML_RNGP_URI_NOT_ABSOLUTE: xmlParserErrors = 1118;
pub const xmlParserErrors_XML_RNGP_VALUE_EMPTY: xmlParserErrors = 1119;
pub const xmlParserErrors_XML_RNGP_VALUE_NO_CONTENT: xmlParserErrors = 1120;
pub const xmlParserErrors_XML_RNGP_XMLNS_NAME: xmlParserErrors = 1121;
pub const xmlParserErrors_XML_RNGP_XML_NS: xmlParserErrors = 1122;
pub const xmlParserErrors_XML_XPATH_EXPRESSION_OK: xmlParserErrors = 1200;
pub const xmlParserErrors_XML_XPATH_NUMBER_ERROR: xmlParserErrors = 1201;
pub const xmlParserErrors_XML_XPATH_UNFINISHED_LITERAL_ERROR: xmlParserErrors = 1202;
pub const xmlParserErrors_XML_XPATH_START_LITERAL_ERROR: xmlParserErrors = 1203;
pub const xmlParserErrors_XML_XPATH_VARIABLE_REF_ERROR: xmlParserErrors = 1204;
pub const xmlParserErrors_XML_XPATH_UNDEF_VARIABLE_ERROR: xmlParserErrors = 1205;
pub const xmlParserErrors_XML_XPATH_INVALID_PREDICATE_ERROR: xmlParserErrors = 1206;
pub const xmlParserErrors_XML_XPATH_EXPR_ERROR: xmlParserErrors = 1207;
pub const xmlParserErrors_XML_XPATH_UNCLOSED_ERROR: xmlParserErrors = 1208;
pub const xmlParserErrors_XML_XPATH_UNKNOWN_FUNC_ERROR: xmlParserErrors = 1209;
pub const xmlParserErrors_XML_XPATH_INVALID_OPERAND: xmlParserErrors = 1210;
pub const xmlParserErrors_XML_XPATH_INVALID_TYPE: xmlParserErrors = 1211;
pub const xmlParserErrors_XML_XPATH_INVALID_ARITY: xmlParserErrors = 1212;
pub const xmlParserErrors_XML_XPATH_INVALID_CTXT_SIZE: xmlParserErrors = 1213;
pub const xmlParserErrors_XML_XPATH_INVALID_CTXT_POSITION: xmlParserErrors = 1214;
pub const xmlParserErrors_XML_XPATH_MEMORY_ERROR: xmlParserErrors = 1215;
pub const xmlParserErrors_XML_XPTR_SYNTAX_ERROR: xmlParserErrors = 1216;
pub const xmlParserErrors_XML_XPTR_RESOURCE_ERROR: xmlParserErrors = 1217;
pub const xmlParserErrors_XML_XPTR_SUB_RESOURCE_ERROR: xmlParserErrors = 1218;
pub const xmlParserErrors_XML_XPATH_UNDEF_PREFIX_ERROR: xmlParserErrors = 1219;
pub const xmlParserErrors_XML_XPATH_ENCODING_ERROR: xmlParserErrors = 1220;
pub const xmlParserErrors_XML_XPATH_INVALID_CHAR_ERROR: xmlParserErrors = 1221;
pub const xmlParserErrors_XML_TREE_INVALID_HEX: xmlParserErrors = 1300;
pub const xmlParserErrors_XML_TREE_INVALID_DEC: xmlParserErrors = 1301;
pub const xmlParserErrors_XML_TREE_UNTERMINATED_ENTITY: xmlParserErrors = 1302;
pub const xmlParserErrors_XML_TREE_NOT_UTF8: xmlParserErrors = 1303;
pub const xmlParserErrors_XML_SAVE_NOT_UTF8: xmlParserErrors = 1400;
pub const xmlParserErrors_XML_SAVE_CHAR_INVALID: xmlParserErrors = 1401;
pub const xmlParserErrors_XML_SAVE_NO_DOCTYPE: xmlParserErrors = 1402;
pub const xmlParserErrors_XML_SAVE_UNKNOWN_ENCODING: xmlParserErrors = 1403;
pub const xmlParserErrors_XML_REGEXP_COMPILE_ERROR: xmlParserErrors = 1450;
pub const xmlParserErrors_XML_IO_UNKNOWN: xmlParserErrors = 1500;
pub const xmlParserErrors_XML_IO_EACCES: xmlParserErrors = 1501;
pub const xmlParserErrors_XML_IO_EAGAIN: xmlParserErrors = 1502;
pub const xmlParserErrors_XML_IO_EBADF: xmlParserErrors = 1503;
pub const xmlParserErrors_XML_IO_EBADMSG: xmlParserErrors = 1504;
pub const xmlParserErrors_XML_IO_EBUSY: xmlParserErrors = 1505;
pub const xmlParserErrors_XML_IO_ECANCELED: xmlParserErrors = 1506;
pub const xmlParserErrors_XML_IO_ECHILD: xmlParserErrors = 1507;
pub const xmlParserErrors_XML_IO_EDEADLK: xmlParserErrors = 1508;
pub const xmlParserErrors_XML_IO_EDOM: xmlParserErrors = 1509;
pub const xmlParserErrors_XML_IO_EEXIST: xmlParserErrors = 1510;
pub const xmlParserErrors_XML_IO_EFAULT: xmlParserErrors = 1511;
pub const xmlParserErrors_XML_IO_EFBIG: xmlParserErrors = 1512;
pub const xmlParserErrors_XML_IO_EINPROGRESS: xmlParserErrors = 1513;
pub const xmlParserErrors_XML_IO_EINTR: xmlParserErrors = 1514;
pub const xmlParserErrors_XML_IO_EINVAL: xmlParserErrors = 1515;
pub const xmlParserErrors_XML_IO_EIO: xmlParserErrors = 1516;
pub const xmlParserErrors_XML_IO_EISDIR: xmlParserErrors = 1517;
pub const xmlParserErrors_XML_IO_EMFILE: xmlParserErrors = 1518;
pub const xmlParserErrors_XML_IO_EMLINK: xmlParserErrors = 1519;
pub const xmlParserErrors_XML_IO_EMSGSIZE: xmlParserErrors = 1520;
pub const xmlParserErrors_XML_IO_ENAMETOOLONG: xmlParserErrors = 1521;
pub const xmlParserErrors_XML_IO_ENFILE: xmlParserErrors = 1522;
pub const xmlParserErrors_XML_IO_ENODEV: xmlParserErrors = 1523;
pub const xmlParserErrors_XML_IO_ENOENT: xmlParserErrors = 1524;
pub const xmlParserErrors_XML_IO_ENOEXEC: xmlParserErrors = 1525;
pub const xmlParserErrors_XML_IO_ENOLCK: xmlParserErrors = 1526;
pub const xmlParserErrors_XML_IO_ENOMEM: xmlParserErrors = 1527;
pub const xmlParserErrors_XML_IO_ENOSPC: xmlParserErrors = 1528;
pub const xmlParserErrors_XML_IO_ENOSYS: xmlParserErrors = 1529;
pub const xmlParserErrors_XML_IO_ENOTDIR: xmlParserErrors = 1530;
pub const xmlParserErrors_XML_IO_ENOTEMPTY: xmlParserErrors = 1531;
pub const xmlParserErrors_XML_IO_ENOTSUP: xmlParserErrors = 1532;
pub const xmlParserErrors_XML_IO_ENOTTY: xmlParserErrors = 1533;
pub const xmlParserErrors_XML_IO_ENXIO: xmlParserErrors = 1534;
pub const xmlParserErrors_XML_IO_EPERM: xmlParserErrors = 1535;
pub const xmlParserErrors_XML_IO_EPIPE: xmlParserErrors = 1536;
pub const xmlParserErrors_XML_IO_ERANGE: xmlParserErrors = 1537;
pub const xmlParserErrors_XML_IO_EROFS: xmlParserErrors = 1538;
pub const xmlParserErrors_XML_IO_ESPIPE: xmlParserErrors = 1539;
pub const xmlParserErrors_XML_IO_ESRCH: xmlParserErrors = 1540;
pub const xmlParserErrors_XML_IO_ETIMEDOUT: xmlParserErrors = 1541;
pub const xmlParserErrors_XML_IO_EXDEV: xmlParserErrors = 1542;
pub const xmlParserErrors_XML_IO_NETWORK_ATTEMPT: xmlParserErrors = 1543;
pub const xmlParserErrors_XML_IO_ENCODER: xmlParserErrors = 1544;
pub const xmlParserErrors_XML_IO_FLUSH: xmlParserErrors = 1545;
pub const xmlParserErrors_XML_IO_WRITE: xmlParserErrors = 1546;
pub const xmlParserErrors_XML_IO_NO_INPUT: xmlParserErrors = 1547;
pub const xmlParserErrors_XML_IO_BUFFER_FULL: xmlParserErrors = 1548;
pub const xmlParserErrors_XML_IO_LOAD_ERROR: xmlParserErrors = 1549;
pub const xmlParserErrors_XML_IO_ENOTSOCK: xmlParserErrors = 1550;
pub const xmlParserErrors_XML_IO_EISCONN: xmlParserErrors = 1551;
pub const xmlParserErrors_XML_IO_ECONNREFUSED: xmlParserErrors = 1552;
pub const xmlParserErrors_XML_IO_ENETUNREACH: xmlParserErrors = 1553;
pub const xmlParserErrors_XML_IO_EADDRINUSE: xmlParserErrors = 1554;
pub const xmlParserErrors_XML_IO_EALREADY: xmlParserErrors = 1555;
pub const xmlParserErrors_XML_IO_EAFNOSUPPORT: xmlParserErrors = 1556;
pub const xmlParserErrors_XML_XINCLUDE_RECURSION: xmlParserErrors = 1600;
pub const xmlParserErrors_XML_XINCLUDE_PARSE_VALUE: xmlParserErrors = 1601;
pub const xmlParserErrors_XML_XINCLUDE_ENTITY_DEF_MISMATCH: xmlParserErrors = 1602;
pub const xmlParserErrors_XML_XINCLUDE_NO_HREF: xmlParserErrors = 1603;
pub const xmlParserErrors_XML_XINCLUDE_NO_FALLBACK: xmlParserErrors = 1604;
pub const xmlParserErrors_XML_XINCLUDE_HREF_URI: xmlParserErrors = 1605;
pub const xmlParserErrors_XML_XINCLUDE_TEXT_FRAGMENT: xmlParserErrors = 1606;
pub const xmlParserErrors_XML_XINCLUDE_TEXT_DOCUMENT: xmlParserErrors = 1607;
pub const xmlParserErrors_XML_XINCLUDE_INVALID_CHAR: xmlParserErrors = 1608;
pub const xmlParserErrors_XML_XINCLUDE_BUILD_FAILED: xmlParserErrors = 1609;
pub const xmlParserErrors_XML_XINCLUDE_UNKNOWN_ENCODING: xmlParserErrors = 1610;
pub const xmlParserErrors_XML_XINCLUDE_MULTIPLE_ROOT: xmlParserErrors = 1611;
pub const xmlParserErrors_XML_XINCLUDE_XPTR_FAILED: xmlParserErrors = 1612;
pub const xmlParserErrors_XML_XINCLUDE_XPTR_RESULT: xmlParserErrors = 1613;
pub const xmlParserErrors_XML_XINCLUDE_INCLUDE_IN_INCLUDE: xmlParserErrors = 1614;
pub const xmlParserErrors_XML_XINCLUDE_FALLBACKS_IN_INCLUDE: xmlParserErrors = 1615;
pub const xmlParserErrors_XML_XINCLUDE_FALLBACK_NOT_IN_INCLUDE: xmlParserErrors = 1616;
pub const xmlParserErrors_XML_XINCLUDE_DEPRECATED_NS: xmlParserErrors = 1617;
pub const xmlParserErrors_XML_XINCLUDE_FRAGMENT_ID: xmlParserErrors = 1618;
pub const xmlParserErrors_XML_CATALOG_MISSING_ATTR: xmlParserErrors = 1650;
pub const xmlParserErrors_XML_CATALOG_ENTRY_BROKEN: xmlParserErrors = 1651;
pub const xmlParserErrors_XML_CATALOG_PREFER_VALUE: xmlParserErrors = 1652;
pub const xmlParserErrors_XML_CATALOG_NOT_CATALOG: xmlParserErrors = 1653;
pub const xmlParserErrors_XML_CATALOG_RECURSION: xmlParserErrors = 1654;
pub const xmlParserErrors_XML_SCHEMAP_PREFIX_UNDEFINED: xmlParserErrors = 1700;
pub const xmlParserErrors_XML_SCHEMAP_ATTRFORMDEFAULT_VALUE: xmlParserErrors = 1701;
pub const xmlParserErrors_XML_SCHEMAP_ATTRGRP_NONAME_NOREF: xmlParserErrors = 1702;
pub const xmlParserErrors_XML_SCHEMAP_ATTR_NONAME_NOREF: xmlParserErrors = 1703;
pub const xmlParserErrors_XML_SCHEMAP_COMPLEXTYPE_NONAME_NOREF: xmlParserErrors = 1704;
pub const xmlParserErrors_XML_SCHEMAP_ELEMFORMDEFAULT_VALUE: xmlParserErrors = 1705;
pub const xmlParserErrors_XML_SCHEMAP_ELEM_NONAME_NOREF: xmlParserErrors = 1706;
pub const xmlParserErrors_XML_SCHEMAP_EXTENSION_NO_BASE: xmlParserErrors = 1707;
pub const xmlParserErrors_XML_SCHEMAP_FACET_NO_VALUE: xmlParserErrors = 1708;
pub const xmlParserErrors_XML_SCHEMAP_FAILED_BUILD_IMPORT: xmlParserErrors = 1709;
pub const xmlParserErrors_XML_SCHEMAP_GROUP_NONAME_NOREF: xmlParserErrors = 1710;
pub const xmlParserErrors_XML_SCHEMAP_IMPORT_NAMESPACE_NOT_URI: xmlParserErrors = 1711;
pub const xmlParserErrors_XML_SCHEMAP_IMPORT_REDEFINE_NSNAME: xmlParserErrors = 1712;
pub const xmlParserErrors_XML_SCHEMAP_IMPORT_SCHEMA_NOT_URI: xmlParserErrors = 1713;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_BOOLEAN: xmlParserErrors = 1714;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_ENUM: xmlParserErrors = 1715;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_FACET: xmlParserErrors = 1716;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_FACET_VALUE: xmlParserErrors = 1717;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_MAXOCCURS: xmlParserErrors = 1718;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_MINOCCURS: xmlParserErrors = 1719;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_REF_AND_SUBTYPE: xmlParserErrors = 1720;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_WHITE_SPACE: xmlParserErrors = 1721;
pub const xmlParserErrors_XML_SCHEMAP_NOATTR_NOREF: xmlParserErrors = 1722;
pub const xmlParserErrors_XML_SCHEMAP_NOTATION_NO_NAME: xmlParserErrors = 1723;
pub const xmlParserErrors_XML_SCHEMAP_NOTYPE_NOREF: xmlParserErrors = 1724;
pub const xmlParserErrors_XML_SCHEMAP_REF_AND_SUBTYPE: xmlParserErrors = 1725;
pub const xmlParserErrors_XML_SCHEMAP_RESTRICTION_NONAME_NOREF: xmlParserErrors = 1726;
pub const xmlParserErrors_XML_SCHEMAP_SIMPLETYPE_NONAME: xmlParserErrors = 1727;
pub const xmlParserErrors_XML_SCHEMAP_TYPE_AND_SUBTYPE: xmlParserErrors = 1728;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ALL_CHILD: xmlParserErrors = 1729;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ANYATTRIBUTE_CHILD: xmlParserErrors = 1730;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ATTR_CHILD: xmlParserErrors = 1731;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ATTRGRP_CHILD: xmlParserErrors = 1732;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ATTRIBUTE_GROUP: xmlParserErrors = 1733;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_BASE_TYPE: xmlParserErrors = 1734;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_CHOICE_CHILD: xmlParserErrors = 1735;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_COMPLEXCONTENT_CHILD: xmlParserErrors = 1736;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_COMPLEXTYPE_CHILD: xmlParserErrors = 1737;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ELEM_CHILD: xmlParserErrors = 1738;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_EXTENSION_CHILD: xmlParserErrors = 1739;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_FACET_CHILD: xmlParserErrors = 1740;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_FACET_TYPE: xmlParserErrors = 1741;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_GROUP_CHILD: xmlParserErrors = 1742;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_IMPORT_CHILD: xmlParserErrors = 1743;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_LIST_CHILD: xmlParserErrors = 1744;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_NOTATION_CHILD: xmlParserErrors = 1745;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_PROCESSCONTENT_CHILD: xmlParserErrors = 1746;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_REF: xmlParserErrors = 1747;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_RESTRICTION_CHILD: xmlParserErrors = 1748;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_SCHEMAS_CHILD: xmlParserErrors = 1749;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_SEQUENCE_CHILD: xmlParserErrors = 1750;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_SIMPLECONTENT_CHILD: xmlParserErrors = 1751;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_SIMPLETYPE_CHILD: xmlParserErrors = 1752;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_TYPE: xmlParserErrors = 1753;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_UNION_CHILD: xmlParserErrors = 1754;
pub const xmlParserErrors_XML_SCHEMAP_ELEM_DEFAULT_FIXED: xmlParserErrors = 1755;
pub const xmlParserErrors_XML_SCHEMAP_REGEXP_INVALID: xmlParserErrors = 1756;
pub const xmlParserErrors_XML_SCHEMAP_FAILED_LOAD: xmlParserErrors = 1757;
pub const xmlParserErrors_XML_SCHEMAP_NOTHING_TO_PARSE: xmlParserErrors = 1758;
pub const xmlParserErrors_XML_SCHEMAP_NOROOT: xmlParserErrors = 1759;
pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_GROUP: xmlParserErrors = 1760;
pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_TYPE: xmlParserErrors = 1761;
pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_ELEMENT: xmlParserErrors = 1762;
pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_ATTRGROUP: xmlParserErrors = 1763;
pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_ATTR: xmlParserErrors = 1764;
pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_NOTATION: xmlParserErrors = 1765;
pub const xmlParserErrors_XML_SCHEMAP_FAILED_PARSE: xmlParserErrors = 1766;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_PREFIX: xmlParserErrors = 1767;
pub const xmlParserErrors_XML_SCHEMAP_DEF_AND_PREFIX: xmlParserErrors = 1768;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_INCLUDE_CHILD: xmlParserErrors = 1769;
pub const xmlParserErrors_XML_SCHEMAP_INCLUDE_SCHEMA_NOT_URI: xmlParserErrors = 1770;
pub const xmlParserErrors_XML_SCHEMAP_INCLUDE_SCHEMA_NO_URI: xmlParserErrors = 1771;
pub const xmlParserErrors_XML_SCHEMAP_NOT_SCHEMA: xmlParserErrors = 1772;
pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_MEMBER_TYPE: xmlParserErrors = 1773;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_ATTR_USE: xmlParserErrors = 1774;
pub const xmlParserErrors_XML_SCHEMAP_RECURSIVE: xmlParserErrors = 1775;
pub const xmlParserErrors_XML_SCHEMAP_SUPERNUMEROUS_LIST_ITEM_TYPE: xmlParserErrors = 1776;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_ATTR_COMBINATION: xmlParserErrors = 1777;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_ATTR_INLINE_COMBINATION: xmlParserErrors = 1778;
pub const xmlParserErrors_XML_SCHEMAP_MISSING_SIMPLETYPE_CHILD: xmlParserErrors = 1779;
pub const xmlParserErrors_XML_SCHEMAP_INVALID_ATTR_NAME: xmlParserErrors = 1780;
pub const xmlParserErrors_XML_SCHEMAP_REF_AND_CONTENT: xmlParserErrors = 1781;
pub const xmlParserErrors_XML_SCHEMAP_CT_PROPS_CORRECT_1: xmlParserErrors = 1782;
pub const xmlParserErrors_XML_SCHEMAP_CT_PROPS_CORRECT_2: xmlParserErrors = 1783;
pub const xmlParserErrors_XML_SCHEMAP_CT_PROPS_CORRECT_3: xmlParserErrors = 1784;
pub const xmlParserErrors_XML_SCHEMAP_CT_PROPS_CORRECT_4: xmlParserErrors = 1785;
pub const xmlParserErrors_XML_SCHEMAP_CT_PROPS_CORRECT_5: xmlParserErrors = 1786;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1: xmlParserErrors = 1787;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1: xmlParserErrors = 1788;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2: xmlParserErrors = 1789;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2: xmlParserErrors = 1790;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3: xmlParserErrors = 1791;
pub const xmlParserErrors_XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER: xmlParserErrors = 1792;
pub const xmlParserErrors_XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE: xmlParserErrors = 1793;
pub const xmlParserErrors_XML_SCHEMAP_UNION_NOT_EXPRESSIBLE: xmlParserErrors = 1794;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_3_1: xmlParserErrors = 1795;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_3_2: xmlParserErrors = 1796;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1: xmlParserErrors = 1797;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2: xmlParserErrors = 1798;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3: xmlParserErrors = 1799;
pub const xmlParserErrors_XML_SCHEMAP_COS_CT_EXTENDS_1_3: xmlParserErrors = 1800;
pub const xmlParserErrors_XML_SCHEMAV_NOROOT: xmlParserErrors = 1801;
pub const xmlParserErrors_XML_SCHEMAV_UNDECLAREDELEM: xmlParserErrors = 1802;
pub const xmlParserErrors_XML_SCHEMAV_NOTTOPLEVEL: xmlParserErrors = 1803;
pub const xmlParserErrors_XML_SCHEMAV_MISSING: xmlParserErrors = 1804;
pub const xmlParserErrors_XML_SCHEMAV_WRONGELEM: xmlParserErrors = 1805;
pub const xmlParserErrors_XML_SCHEMAV_NOTYPE: xmlParserErrors = 1806;
pub const xmlParserErrors_XML_SCHEMAV_NOROLLBACK: xmlParserErrors = 1807;
pub const xmlParserErrors_XML_SCHEMAV_ISABSTRACT: xmlParserErrors = 1808;
pub const xmlParserErrors_XML_SCHEMAV_NOTEMPTY: xmlParserErrors = 1809;
pub const xmlParserErrors_XML_SCHEMAV_ELEMCONT: xmlParserErrors = 1810;
pub const xmlParserErrors_XML_SCHEMAV_HAVEDEFAULT: xmlParserErrors = 1811;
pub const xmlParserErrors_XML_SCHEMAV_NOTNILLABLE: xmlParserErrors = 1812;
pub const xmlParserErrors_XML_SCHEMAV_EXTRACONTENT: xmlParserErrors = 1813;
pub const xmlParserErrors_XML_SCHEMAV_INVALIDATTR: xmlParserErrors = 1814;
pub const xmlParserErrors_XML_SCHEMAV_INVALIDELEM: xmlParserErrors = 1815;
pub const xmlParserErrors_XML_SCHEMAV_NOTDETERMINIST: xmlParserErrors = 1816;
pub const xmlParserErrors_XML_SCHEMAV_CONSTRUCT: xmlParserErrors = 1817;
pub const xmlParserErrors_XML_SCHEMAV_INTERNAL: xmlParserErrors = 1818;
pub const xmlParserErrors_XML_SCHEMAV_NOTSIMPLE: xmlParserErrors = 1819;
pub const xmlParserErrors_XML_SCHEMAV_ATTRUNKNOWN: xmlParserErrors = 1820;
pub const xmlParserErrors_XML_SCHEMAV_ATTRINVALID: xmlParserErrors = 1821;
pub const xmlParserErrors_XML_SCHEMAV_VALUE: xmlParserErrors = 1822;
pub const xmlParserErrors_XML_SCHEMAV_FACET: xmlParserErrors = 1823;
pub const xmlParserErrors_XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1: xmlParserErrors = 1824;
pub const xmlParserErrors_XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2: xmlParserErrors = 1825;
pub const xmlParserErrors_XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3: xmlParserErrors = 1826;
pub const xmlParserErrors_XML_SCHEMAV_CVC_TYPE_3_1_1: xmlParserErrors = 1827;
pub const xmlParserErrors_XML_SCHEMAV_CVC_TYPE_3_1_2: xmlParserErrors = 1828;
pub const xmlParserErrors_XML_SCHEMAV_CVC_FACET_VALID: xmlParserErrors = 1829;
pub const xmlParserErrors_XML_SCHEMAV_CVC_LENGTH_VALID: xmlParserErrors = 1830;
pub const xmlParserErrors_XML_SCHEMAV_CVC_MINLENGTH_VALID: xmlParserErrors = 1831;
pub const xmlParserErrors_XML_SCHEMAV_CVC_MAXLENGTH_VALID: xmlParserErrors = 1832;
pub const xmlParserErrors_XML_SCHEMAV_CVC_MININCLUSIVE_VALID: xmlParserErrors = 1833;
pub const xmlParserErrors_XML_SCHEMAV_CVC_MAXINCLUSIVE_VALID: xmlParserErrors = 1834;
pub const xmlParserErrors_XML_SCHEMAV_CVC_MINEXCLUSIVE_VALID: xmlParserErrors = 1835;
pub const xmlParserErrors_XML_SCHEMAV_CVC_MAXEXCLUSIVE_VALID: xmlParserErrors = 1836;
pub const xmlParserErrors_XML_SCHEMAV_CVC_TOTALDIGITS_VALID: xmlParserErrors = 1837;
pub const xmlParserErrors_XML_SCHEMAV_CVC_FRACTIONDIGITS_VALID: xmlParserErrors = 1838;
pub const xmlParserErrors_XML_SCHEMAV_CVC_PATTERN_VALID: xmlParserErrors = 1839;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ENUMERATION_VALID: xmlParserErrors = 1840;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1: xmlParserErrors = 1841;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2: xmlParserErrors = 1842;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3: xmlParserErrors = 1843;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_2_4: xmlParserErrors = 1844;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_1: xmlParserErrors = 1845;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_2: xmlParserErrors = 1846;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_3_1: xmlParserErrors = 1847;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_3_2_1: xmlParserErrors = 1848;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_3_2_2: xmlParserErrors = 1849;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_4_1: xmlParserErrors = 1850;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_4_2: xmlParserErrors = 1851;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_4_3: xmlParserErrors = 1852;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_1_1: xmlParserErrors = 1853;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_1_2: xmlParserErrors = 1854;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_2_1: xmlParserErrors = 1855;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_2_2_1: xmlParserErrors = 1856;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_2_2_2_1: xmlParserErrors = 1857;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_2_2_2_2: xmlParserErrors = 1858;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_6: xmlParserErrors = 1859;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_7: xmlParserErrors = 1860;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ATTRIBUTE_1: xmlParserErrors = 1861;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ATTRIBUTE_2: xmlParserErrors = 1862;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ATTRIBUTE_3: xmlParserErrors = 1863;
pub const xmlParserErrors_XML_SCHEMAV_CVC_ATTRIBUTE_4: xmlParserErrors = 1864;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_3_1: xmlParserErrors = 1865;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1: xmlParserErrors = 1866;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2: xmlParserErrors = 1867;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_4: xmlParserErrors = 1868;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_5_1: xmlParserErrors = 1869;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_5_2: xmlParserErrors = 1870;
pub const xmlParserErrors_XML_SCHEMAV_ELEMENT_CONTENT: xmlParserErrors = 1871;
pub const xmlParserErrors_XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING: xmlParserErrors = 1872;
pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_1: xmlParserErrors = 1873;
pub const xmlParserErrors_XML_SCHEMAV_CVC_AU: xmlParserErrors = 1874;
pub const xmlParserErrors_XML_SCHEMAV_CVC_TYPE_1: xmlParserErrors = 1875;
pub const xmlParserErrors_XML_SCHEMAV_CVC_TYPE_2: xmlParserErrors = 1876;
pub const xmlParserErrors_XML_SCHEMAV_CVC_IDC: xmlParserErrors = 1877;
pub const xmlParserErrors_XML_SCHEMAV_CVC_WILDCARD: xmlParserErrors = 1878;
pub const xmlParserErrors_XML_SCHEMAV_MISC: xmlParserErrors = 1879;
pub const xmlParserErrors_XML_XPTR_UNKNOWN_SCHEME: xmlParserErrors = 1900;
pub const xmlParserErrors_XML_XPTR_CHILDSEQ_START: xmlParserErrors = 1901;
pub const xmlParserErrors_XML_XPTR_EVAL_FAILED: xmlParserErrors = 1902;
pub const xmlParserErrors_XML_XPTR_EXTRA_OBJECTS: xmlParserErrors = 1903;
pub const xmlParserErrors_XML_C14N_CREATE_CTXT: xmlParserErrors = 1950;
pub const xmlParserErrors_XML_C14N_REQUIRES_UTF8: xmlParserErrors = 1951;
pub const xmlParserErrors_XML_C14N_CREATE_STACK: xmlParserErrors = 1952;
pub const xmlParserErrors_XML_C14N_INVALID_NODE: xmlParserErrors = 1953;
pub const xmlParserErrors_XML_C14N_UNKNOW_NODE: xmlParserErrors = 1954;
pub const xmlParserErrors_XML_C14N_RELATIVE_NAMESPACE: xmlParserErrors = 1955;
pub const xmlParserErrors_XML_FTP_PASV_ANSWER: xmlParserErrors = 2000;
pub const xmlParserErrors_XML_FTP_EPSV_ANSWER: xmlParserErrors = 2001;
pub const xmlParserErrors_XML_FTP_ACCNT: xmlParserErrors = 2002;
pub const xmlParserErrors_XML_FTP_URL_SYNTAX: xmlParserErrors = 2003;
pub const xmlParserErrors_XML_HTTP_URL_SYNTAX: xmlParserErrors = 2020;
pub const xmlParserErrors_XML_HTTP_USE_IP: xmlParserErrors = 2021;
pub const xmlParserErrors_XML_HTTP_UNKNOWN_HOST: xmlParserErrors = 2022;
pub const xmlParserErrors_XML_SCHEMAP_SRC_SIMPLE_TYPE_1: xmlParserErrors = 3000;
pub const xmlParserErrors_XML_SCHEMAP_SRC_SIMPLE_TYPE_2: xmlParserErrors = 3001;
pub const xmlParserErrors_XML_SCHEMAP_SRC_SIMPLE_TYPE_3: xmlParserErrors = 3002;
pub const xmlParserErrors_XML_SCHEMAP_SRC_SIMPLE_TYPE_4: xmlParserErrors = 3003;
pub const xmlParserErrors_XML_SCHEMAP_SRC_RESOLVE: xmlParserErrors = 3004;
pub const xmlParserErrors_XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE: xmlParserErrors = 3005;
pub const xmlParserErrors_XML_SCHEMAP_SRC_LIST_ITEMTYPE_OR_SIMPLETYPE: xmlParserErrors = 3006;
pub const xmlParserErrors_XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES: xmlParserErrors = 3007;
pub const xmlParserErrors_XML_SCHEMAP_ST_PROPS_CORRECT_1: xmlParserErrors = 3008;
pub const xmlParserErrors_XML_SCHEMAP_ST_PROPS_CORRECT_2: xmlParserErrors = 3009;
pub const xmlParserErrors_XML_SCHEMAP_ST_PROPS_CORRECT_3: xmlParserErrors = 3010;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_1_1: xmlParserErrors = 3011;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_1_2: xmlParserErrors = 3012;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1: xmlParserErrors = 3013;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_1_3_2: xmlParserErrors = 3014;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_1: xmlParserErrors = 3015;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1: xmlParserErrors = 3016;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2: xmlParserErrors = 3017;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1: xmlParserErrors = 3018;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2: xmlParserErrors = 3019;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3: xmlParserErrors = 3020;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4: xmlParserErrors = 3021;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_5: xmlParserErrors = 3022;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_1: xmlParserErrors = 3023;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1: xmlParserErrors = 3024;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2: xmlParserErrors = 3025;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2: xmlParserErrors = 3026;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1: xmlParserErrors = 3027;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3: xmlParserErrors = 3028;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4: xmlParserErrors = 3029;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_5: xmlParserErrors = 3030;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_DERIVED_OK_2_1: xmlParserErrors = 3031;
pub const xmlParserErrors_XML_SCHEMAP_COS_ST_DERIVED_OK_2_2: xmlParserErrors = 3032;
pub const xmlParserErrors_XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED: xmlParserErrors = 3033;
pub const xmlParserErrors_XML_SCHEMAP_S4S_ELEM_MISSING: xmlParserErrors = 3034;
pub const xmlParserErrors_XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED: xmlParserErrors = 3035;
pub const xmlParserErrors_XML_SCHEMAP_S4S_ATTR_MISSING: xmlParserErrors = 3036;
pub const xmlParserErrors_XML_SCHEMAP_S4S_ATTR_INVALID_VALUE: xmlParserErrors = 3037;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ELEMENT_1: xmlParserErrors = 3038;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ELEMENT_2_1: xmlParserErrors = 3039;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ELEMENT_2_2: xmlParserErrors = 3040;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ELEMENT_3: xmlParserErrors = 3041;
pub const xmlParserErrors_XML_SCHEMAP_P_PROPS_CORRECT_1: xmlParserErrors = 3042;
pub const xmlParserErrors_XML_SCHEMAP_P_PROPS_CORRECT_2_1: xmlParserErrors = 3043;
pub const xmlParserErrors_XML_SCHEMAP_P_PROPS_CORRECT_2_2: xmlParserErrors = 3044;
pub const xmlParserErrors_XML_SCHEMAP_E_PROPS_CORRECT_2: xmlParserErrors = 3045;
pub const xmlParserErrors_XML_SCHEMAP_E_PROPS_CORRECT_3: xmlParserErrors = 3046;
pub const xmlParserErrors_XML_SCHEMAP_E_PROPS_CORRECT_4: xmlParserErrors = 3047;
pub const xmlParserErrors_XML_SCHEMAP_E_PROPS_CORRECT_5: xmlParserErrors = 3048;
pub const xmlParserErrors_XML_SCHEMAP_E_PROPS_CORRECT_6: xmlParserErrors = 3049;
pub const xmlParserErrors_XML_SCHEMAP_SRC_INCLUDE: xmlParserErrors = 3050;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_1: xmlParserErrors = 3051;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_2: xmlParserErrors = 3052;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_3_1: xmlParserErrors = 3053;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_3_2: xmlParserErrors = 3054;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_4: xmlParserErrors = 3055;
pub const xmlParserErrors_XML_SCHEMAP_NO_XMLNS: xmlParserErrors = 3056;
pub const xmlParserErrors_XML_SCHEMAP_NO_XSI: xmlParserErrors = 3057;
pub const xmlParserErrors_XML_SCHEMAP_COS_VALID_DEFAULT_1: xmlParserErrors = 3058;
pub const xmlParserErrors_XML_SCHEMAP_COS_VALID_DEFAULT_2_1: xmlParserErrors = 3059;
pub const xmlParserErrors_XML_SCHEMAP_COS_VALID_DEFAULT_2_2_1: xmlParserErrors = 3060;
pub const xmlParserErrors_XML_SCHEMAP_COS_VALID_DEFAULT_2_2_2: xmlParserErrors = 3061;
pub const xmlParserErrors_XML_SCHEMAP_CVC_SIMPLE_TYPE: xmlParserErrors = 3062;
pub const xmlParserErrors_XML_SCHEMAP_COS_CT_EXTENDS_1_1: xmlParserErrors = 3063;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_1_1: xmlParserErrors = 3064;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_1_2: xmlParserErrors = 3065;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_2: xmlParserErrors = 3066;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_2_1: xmlParserErrors = 3067;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_2_2: xmlParserErrors = 3068;
pub const xmlParserErrors_XML_SCHEMAP_INTERNAL: xmlParserErrors = 3069;
pub const xmlParserErrors_XML_SCHEMAP_NOT_DETERMINISTIC: xmlParserErrors = 3070;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_1: xmlParserErrors = 3071;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_2: xmlParserErrors = 3072;
pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3: xmlParserErrors = 3073;
pub const xmlParserErrors_XML_SCHEMAP_MG_PROPS_CORRECT_1: xmlParserErrors = 3074;
pub const xmlParserErrors_XML_SCHEMAP_MG_PROPS_CORRECT_2: xmlParserErrors = 3075;
pub const xmlParserErrors_XML_SCHEMAP_SRC_CT_1: xmlParserErrors = 3076;
pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3: xmlParserErrors = 3077;
pub const xmlParserErrors_XML_SCHEMAP_AU_PROPS_CORRECT_2: xmlParserErrors = 3078;
pub const xmlParserErrors_XML_SCHEMAP_A_PROPS_CORRECT_2: xmlParserErrors = 3079;
pub const xmlParserErrors_XML_SCHEMAP_C_PROPS_CORRECT: xmlParserErrors = 3080;
pub const xmlParserErrors_XML_SCHEMAP_SRC_REDEFINE: xmlParserErrors = 3081;
pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT: xmlParserErrors = 3082;
pub const xmlParserErrors_XML_SCHEMAP_WARN_SKIP_SCHEMA: xmlParserErrors = 3083;
pub const xmlParserErrors_XML_SCHEMAP_WARN_UNLOCATED_SCHEMA: xmlParserErrors = 3084;
pub const xmlParserErrors_XML_SCHEMAP_WARN_ATTR_REDECL_PROH: xmlParserErrors = 3085;
pub const xmlParserErrors_XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH: xmlParserErrors = 3086;
pub const xmlParserErrors_XML_SCHEMAP_AG_PROPS_CORRECT: xmlParserErrors = 3087;
pub const xmlParserErrors_XML_SCHEMAP_COS_CT_EXTENDS_1_2: xmlParserErrors = 3088;
pub const xmlParserErrors_XML_SCHEMAP_AU_PROPS_CORRECT: xmlParserErrors = 3089;
pub const xmlParserErrors_XML_SCHEMAP_A_PROPS_CORRECT_3: xmlParserErrors = 3090;
pub const xmlParserErrors_XML_SCHEMAP_COS_ALL_LIMITED: xmlParserErrors = 3091;
pub const xmlParserErrors_XML_SCHEMATRONV_ASSERT: xmlParserErrors = 4000;
pub const xmlParserErrors_XML_SCHEMATRONV_REPORT: xmlParserErrors = 4001;
pub const xmlParserErrors_XML_MODULE_OPEN: xmlParserErrors = 4900;
pub const xmlParserErrors_XML_MODULE_CLOSE: xmlParserErrors = 4901;
pub const xmlParserErrors_XML_CHECK_FOUND_ELEMENT: xmlParserErrors = 5000;
pub const xmlParserErrors_XML_CHECK_FOUND_ATTRIBUTE: xmlParserErrors = 5001;
pub const xmlParserErrors_XML_CHECK_FOUND_TEXT: xmlParserErrors = 5002;
pub const xmlParserErrors_XML_CHECK_FOUND_CDATA: xmlParserErrors = 5003;
pub const xmlParserErrors_XML_CHECK_FOUND_ENTITYREF: xmlParserErrors = 5004;
pub const xmlParserErrors_XML_CHECK_FOUND_ENTITY: xmlParserErrors = 5005;
pub const xmlParserErrors_XML_CHECK_FOUND_PI: xmlParserErrors = 5006;
pub const xmlParserErrors_XML_CHECK_FOUND_COMMENT: xmlParserErrors = 5007;
pub const xmlParserErrors_XML_CHECK_FOUND_DOCTYPE: xmlParserErrors = 5008;
pub const xmlParserErrors_XML_CHECK_FOUND_FRAGMENT: xmlParserErrors = 5009;
pub const xmlParserErrors_XML_CHECK_FOUND_NOTATION: xmlParserErrors = 5010;
pub const xmlParserErrors_XML_CHECK_UNKNOWN_NODE: xmlParserErrors = 5011;
pub const xmlParserErrors_XML_CHECK_ENTITY_TYPE: xmlParserErrors = 5012;
pub const xmlParserErrors_XML_CHECK_NO_PARENT: xmlParserErrors = 5013;
pub const xmlParserErrors_XML_CHECK_NO_DOC: xmlParserErrors = 5014;
pub const xmlParserErrors_XML_CHECK_NO_NAME: xmlParserErrors = 5015;
pub const xmlParserErrors_XML_CHECK_NO_ELEM: xmlParserErrors = 5016;
pub const xmlParserErrors_XML_CHECK_WRONG_DOC: xmlParserErrors = 5017;
pub const xmlParserErrors_XML_CHECK_NO_PREV: xmlParserErrors = 5018;
pub const xmlParserErrors_XML_CHECK_WRONG_PREV: xmlParserErrors = 5019;
pub const xmlParserErrors_XML_CHECK_NO_NEXT: xmlParserErrors = 5020;
pub const xmlParserErrors_XML_CHECK_WRONG_NEXT: xmlParserErrors = 5021;
pub const xmlParserErrors_XML_CHECK_NOT_DTD: xmlParserErrors = 5022;
pub const xmlParserErrors_XML_CHECK_NOT_ATTR: xmlParserErrors = 5023;
pub const xmlParserErrors_XML_CHECK_NOT_ATTR_DECL: xmlParserErrors = 5024;
pub const xmlParserErrors_XML_CHECK_NOT_ELEM_DECL: xmlParserErrors = 5025;
pub const xmlParserErrors_XML_CHECK_NOT_ENTITY_DECL: xmlParserErrors = 5026;
pub const xmlParserErrors_XML_CHECK_NOT_NS_DECL: xmlParserErrors = 5027;
pub const xmlParserErrors_XML_CHECK_NO_HREF: xmlParserErrors = 5028;
pub const xmlParserErrors_XML_CHECK_WRONG_PARENT: xmlParserErrors = 5029;
pub const xmlParserErrors_XML_CHECK_NS_SCOPE: xmlParserErrors = 5030;
pub const xmlParserErrors_XML_CHECK_NS_ANCESTOR: xmlParserErrors = 5031;
pub const xmlParserErrors_XML_CHECK_NOT_UTF8: xmlParserErrors = 5032;
pub const xmlParserErrors_XML_CHECK_NO_DICT: xmlParserErrors = 5033;
pub const xmlParserErrors_XML_CHECK_NOT_NCNAME: xmlParserErrors = 5034;
pub const xmlParserErrors_XML_CHECK_OUTSIDE_DICT: xmlParserErrors = 5035;
pub const xmlParserErrors_XML_CHECK_WRONG_NAME: xmlParserErrors = 5036;
pub const xmlParserErrors_XML_CHECK_NAME_NOT_NULL: xmlParserErrors = 5037;
pub const xmlParserErrors_XML_I18N_NO_NAME: xmlParserErrors = 6000;
pub const xmlParserErrors_XML_I18N_NO_HANDLER: xmlParserErrors = 6001;
pub const xmlParserErrors_XML_I18N_EXCESS_HANDLER: xmlParserErrors = 6002;
pub const xmlParserErrors_XML_I18N_CONV_FAILED: xmlParserErrors = 6003;
pub const xmlParserErrors_XML_I18N_NO_OUTPUT: xmlParserErrors = 6004;
pub const xmlParserErrors_XML_BUF_OVERFLOW: xmlParserErrors = 7000;
/// xmlParserError:
///
/// This is an error that the XML (or HTML) parser can generate
pub type xmlParserErrors = u32;
/// xmlGenericErrorFunc:
/// @ctx:  a parsing context
/// @msg:  the message
/// @...:  the extra arguments of the varags to format the message
///
/// Signature of the function to use when there is an error and
/// no parsing or validity context available .
pub type xmlGenericErrorFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
/// xmlStructuredErrorFunc:
/// @userData:  user provided data for the error callback
/// @error:  the error being raised.
///
/// Signature of the function to use when there is an error and
/// the module handles the new error reporting mechanism.
pub type xmlStructuredErrorFunc = ::std::option::Option<
  unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void, error: xmlErrorPtr),
>;
extern "C" {
  pub fn xmlSetGenericErrorFunc(ctx: *mut ::std::os::raw::c_void, handler: xmlGenericErrorFunc);
}
extern "C" {
  pub fn initGenericErrorDefaultFunc(handler: *mut xmlGenericErrorFunc);
}
extern "C" {
  pub fn xmlSetStructuredErrorFunc(
    ctx: *mut ::std::os::raw::c_void,
    handler: xmlStructuredErrorFunc,
  );
}
extern "C" {
  pub fn xmlParserError(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...);
}
extern "C" {
  pub fn xmlParserWarning(
    ctx: *mut ::std::os::raw::c_void,
    msg: *const ::std::os::raw::c_char,
    ...
  );
}
extern "C" {
  pub fn xmlParserValidityError(
    ctx: *mut ::std::os::raw::c_void,
    msg: *const ::std::os::raw::c_char,
    ...
  );
}
extern "C" {
  pub fn xmlParserValidityWarning(
    ctx: *mut ::std::os::raw::c_void,
    msg: *const ::std::os::raw::c_char,
    ...
  );
}
extern "C" {
  pub fn xmlParserPrintFileInfo(input: xmlParserInputPtr);
}
extern "C" {
  pub fn xmlParserPrintFileContext(input: xmlParserInputPtr);
}
extern "C" {
  pub fn xmlGetLastError() -> xmlErrorPtr;
}
extern "C" {
  pub fn xmlResetLastError();
}
extern "C" {
  pub fn xmlCtxtGetLastError(ctx: *mut ::std::os::raw::c_void) -> xmlErrorPtr;
}
extern "C" {
  pub fn xmlCtxtResetLastError(ctx: *mut ::std::os::raw::c_void);
}
extern "C" {
  pub fn xmlResetError(err: xmlErrorPtr);
}
extern "C" {
  pub fn xmlCopyError(from: xmlErrorPtr, to: xmlErrorPtr) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlLink {
  _unused: [u8; 0],
}
pub type xmlLink = _xmlLink;
pub type xmlLinkPtr = *mut xmlLink;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlList {
  _unused: [u8; 0],
}
pub type xmlList = _xmlList;
pub type xmlListPtr = *mut xmlList;
/// xmlListDeallocator:
/// @lk:  the data to deallocate
///
/// Callback function used to free data from a list.
pub type xmlListDeallocator = ::std::option::Option<unsafe extern "C" fn(lk: xmlLinkPtr)>;
/// xmlListDataCompare:
/// @data0: the first data
/// @data1: the second data
///
/// Callback function used to compare 2 data.
///
/// Returns 0 is equality, -1 or 1 otherwise depending on the ordering.
pub type xmlListDataCompare = ::std::option::Option<
  unsafe extern "C" fn(data0: *const ::std::os::raw::c_void, data1: *const ::std::os::raw::c_void)
    -> ::std::os::raw::c_int,
>;
/// xmlListWalker:
/// @data: the data found in the list
/// @user: extra user provided data to the walker
///
/// Callback function used when walking a list with xmlListWalk().
///
/// Returns 0 to stop walking the list, 1 otherwise.
pub type xmlListWalker = ::std::option::Option<
  unsafe extern "C" fn(data: *const ::std::os::raw::c_void, user: *const ::std::os::raw::c_void)
    -> ::std::os::raw::c_int,
>;
extern "C" {
  pub fn xmlListCreate(deallocator: xmlListDeallocator, compare: xmlListDataCompare) -> xmlListPtr;
}
extern "C" {
  pub fn xmlListDelete(l: xmlListPtr);
}
extern "C" {
  pub fn xmlListSearch(
    l: xmlListPtr,
    data: *mut ::std::os::raw::c_void,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlListReverseSearch(
    l: xmlListPtr,
    data: *mut ::std::os::raw::c_void,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlListInsert(l: xmlListPtr, data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlListAppend(l: xmlListPtr, data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlListRemoveFirst(
    l: xmlListPtr,
    data: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlListRemoveLast(
    l: xmlListPtr,
    data: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlListRemoveAll(
    l: xmlListPtr,
    data: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlListClear(l: xmlListPtr);
}
extern "C" {
  pub fn xmlListEmpty(l: xmlListPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlListFront(l: xmlListPtr) -> xmlLinkPtr;
}
extern "C" {
  pub fn xmlListEnd(l: xmlListPtr) -> xmlLinkPtr;
}
extern "C" {
  pub fn xmlListSize(l: xmlListPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlListPopFront(l: xmlListPtr);
}
extern "C" {
  pub fn xmlListPopBack(l: xmlListPtr);
}
extern "C" {
  pub fn xmlListPushFront(
    l: xmlListPtr,
    data: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlListPushBack(l: xmlListPtr, data: *mut ::std::os::raw::c_void)
    -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlListReverse(l: xmlListPtr);
}
extern "C" {
  pub fn xmlListSort(l: xmlListPtr);
}
extern "C" {
  pub fn xmlListWalk(l: xmlListPtr, walker: xmlListWalker, user: *const ::std::os::raw::c_void);
}
extern "C" {
  pub fn xmlListReverseWalk(
    l: xmlListPtr,
    walker: xmlListWalker,
    user: *const ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn xmlListMerge(l1: xmlListPtr, l2: xmlListPtr);
}
extern "C" {
  pub fn xmlListDup(old: xmlListPtr) -> xmlListPtr;
}
extern "C" {
  pub fn xmlListCopy(cur: xmlListPtr, old: xmlListPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlLinkGetData(lk: xmlLinkPtr) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlAutomata {
  _unused: [u8; 0],
}
/// xmlAutomataPtr:
///
/// A libxml automata description, It can be compiled into a regexp
pub type xmlAutomata = _xmlAutomata;
pub type xmlAutomataPtr = *mut xmlAutomata;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlAutomataState {
  _unused: [u8; 0],
}
/// xmlAutomataStatePtr:
///
/// A state int the automata description,
pub type xmlAutomataState = _xmlAutomataState;
pub type xmlAutomataStatePtr = *mut xmlAutomataState;
extern "C" {
  pub fn xmlNewAutomata() -> xmlAutomataPtr;
}
extern "C" {
  pub fn xmlFreeAutomata(am: xmlAutomataPtr);
}
extern "C" {
  pub fn xmlAutomataGetInitState(am: xmlAutomataPtr) -> xmlAutomataStatePtr;
}
extern "C" {
  pub fn xmlAutomataSetFinalState(
    am: xmlAutomataPtr,
    state: xmlAutomataStatePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlAutomataNewState(am: xmlAutomataPtr) -> xmlAutomataStatePtr;
}
extern "C" {
  pub fn xmlAutomataNewTransition(
    am: xmlAutomataPtr,
    from: xmlAutomataStatePtr,
    to: xmlAutomataStatePtr,
    token: *const xmlChar,
    data: *mut ::std::os::raw::c_void,
  ) -> xmlAutomataStatePtr;
}
extern "C" {
  pub fn xmlAutomataNewTransition2(
    am: xmlAutomataPtr,
    from: xmlAutomataStatePtr,
    to: xmlAutomataStatePtr,
    token: *const xmlChar,
    token2: *const xmlChar,
    data: *mut ::std::os::raw::c_void,
  ) -> xmlAutomataStatePtr;
}
extern "C" {
  pub fn xmlAutomataNewNegTrans(
    am: xmlAutomataPtr,
    from: xmlAutomataStatePtr,
    to: xmlAutomataStatePtr,
    token: *const xmlChar,
    token2: *const xmlChar,
    data: *mut ::std::os::raw::c_void,
  ) -> xmlAutomataStatePtr;
}
extern "C" {
  pub fn xmlAutomataNewCountTrans(
    am: xmlAutomataPtr,
    from: xmlAutomataStatePtr,
    to: xmlAutomataStatePtr,
    token: *const xmlChar,
    min: ::std::os::raw::c_int,
    max: ::std::os::raw::c_int,
    data: *mut ::std::os::raw::c_void,
  ) -> xmlAutomataStatePtr;
}
extern "C" {
  pub fn xmlAutomataNewCountTrans2(
    am: xmlAutomataPtr,
    from: xmlAutomataStatePtr,
    to: xmlAutomataStatePtr,
    token: *const xmlChar,
    token2: *const xmlChar,
    min: ::std::os::raw::c_int,
    max: ::std::os::raw::c_int,
    data: *mut ::std::os::raw::c_void,
  ) -> xmlAutomataStatePtr;
}
extern "C" {
  pub fn xmlAutomataNewOnceTrans(
    am: xmlAutomataPtr,
    from: xmlAutomataStatePtr,
    to: xmlAutomataStatePtr,
    token: *const xmlChar,
    min: ::std::os::raw::c_int,
    max: ::std::os::raw::c_int,
    data: *mut ::std::os::raw::c_void,
  ) -> xmlAutomataStatePtr;
}
extern "C" {
  pub fn xmlAutomataNewOnceTrans2(
    am: xmlAutomataPtr,
    from: xmlAutomataStatePtr,
    to: xmlAutomataStatePtr,
    token: *const xmlChar,
    token2: *const xmlChar,
    min: ::std::os::raw::c_int,
    max: ::std::os::raw::c_int,
    data: *mut ::std::os::raw::c_void,
  ) -> xmlAutomataStatePtr;
}
extern "C" {
  pub fn xmlAutomataNewAllTrans(
    am: xmlAutomataPtr,
    from: xmlAutomataStatePtr,
    to: xmlAutomataStatePtr,
    lax: ::std::os::raw::c_int,
  ) -> xmlAutomataStatePtr;
}
extern "C" {
  pub fn xmlAutomataNewEpsilon(
    am: xmlAutomataPtr,
    from: xmlAutomataStatePtr,
    to: xmlAutomataStatePtr,
  ) -> xmlAutomataStatePtr;
}
extern "C" {
  pub fn xmlAutomataNewCountedTrans(
    am: xmlAutomataPtr,
    from: xmlAutomataStatePtr,
    to: xmlAutomataStatePtr,
    counter: ::std::os::raw::c_int,
  ) -> xmlAutomataStatePtr;
}
extern "C" {
  pub fn xmlAutomataNewCounterTrans(
    am: xmlAutomataPtr,
    from: xmlAutomataStatePtr,
    to: xmlAutomataStatePtr,
    counter: ::std::os::raw::c_int,
  ) -> xmlAutomataStatePtr;
}
extern "C" {
  pub fn xmlAutomataNewCounter(
    am: xmlAutomataPtr,
    min: ::std::os::raw::c_int,
    max: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlAutomataCompile(am: xmlAutomataPtr) -> xmlRegexpPtr;
}
extern "C" {
  pub fn xmlAutomataIsDeterminist(am: xmlAutomataPtr) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlValidState {
  _unused: [u8; 0],
}
pub type xmlValidState = _xmlValidState;
pub type xmlValidStatePtr = *mut xmlValidState;
/// xmlValidityErrorFunc:
/// @ctx:  usually an xmlValidCtxtPtr to a validity error context,
/// but comes from ctxt->userData (which normally contains such
/// a pointer); ctxt->userData can be changed by the user.
/// @msg:  the string to format *printf like vararg
/// @...:  remaining arguments to the format
///
/// Callback called when a validity error is found. This is a message
/// oriented function similar to an *printf function.
pub type xmlValidityErrorFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
/// xmlValidityWarningFunc:
/// @ctx:  usually an xmlValidCtxtPtr to a validity error context,
/// but comes from ctxt->userData (which normally contains such
/// a pointer); ctxt->userData can be changed by the user.
/// @msg:  the string to format *printf like vararg
/// @...:  remaining arguments to the format
///
/// Callback called when a validity warning is found. This is a message
/// oriented function similar to an *printf function.
pub type xmlValidityWarningFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
pub type xmlValidCtxt = _xmlValidCtxt;
pub type xmlValidCtxtPtr = *mut xmlValidCtxt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlValidCtxt {
  pub userData: *mut ::std::os::raw::c_void,
  pub error: xmlValidityErrorFunc,
  pub warning: xmlValidityWarningFunc,
  pub node: xmlNodePtr,
  pub nodeNr: ::std::os::raw::c_int,
  pub nodeMax: ::std::os::raw::c_int,
  pub nodeTab: *mut xmlNodePtr,
  pub finishDtd: ::std::os::raw::c_uint,
  pub doc: xmlDocPtr,
  pub valid: ::std::os::raw::c_int,
  pub vstate: *mut xmlValidState,
  pub vstateNr: ::std::os::raw::c_int,
  pub vstateMax: ::std::os::raw::c_int,
  pub vstateTab: *mut xmlValidState,
  pub am: xmlAutomataPtr,
  pub state: xmlAutomataStatePtr,
}
#[test]
fn bindgen_test_layout__xmlValidCtxt() {
  assert_eq!(
    ::std::mem::size_of::<_xmlValidCtxt>(),
    112usize,
    concat!("Size of: ", stringify!(_xmlValidCtxt))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlValidCtxt>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlValidCtxt))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlValidCtxt>())).userData as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlValidCtxt),
      "::",
      stringify!(userData)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlValidCtxt>())).error as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlValidCtxt),
      "::",
      stringify!(error)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlValidCtxt>())).warning as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlValidCtxt),
      "::",
      stringify!(warning)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlValidCtxt>())).node as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlValidCtxt),
      "::",
      stringify!(node)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlValidCtxt>())).nodeNr as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlValidCtxt),
      "::",
      stringify!(nodeNr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlValidCtxt>())).nodeMax as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlValidCtxt),
      "::",
      stringify!(nodeMax)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlValidCtxt>())).nodeTab as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlValidCtxt),
      "::",
      stringify!(nodeTab)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlValidCtxt>())).finishDtd as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlValidCtxt),
      "::",
      stringify!(finishDtd)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlValidCtxt>())).doc as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlValidCtxt),
      "::",
      stringify!(doc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlValidCtxt>())).valid as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlValidCtxt),
      "::",
      stringify!(valid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlValidCtxt>())).vstate as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlValidCtxt),
      "::",
      stringify!(vstate)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlValidCtxt>())).vstateNr as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlValidCtxt),
      "::",
      stringify!(vstateNr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlValidCtxt>())).vstateMax as *const _ as usize },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlValidCtxt),
      "::",
      stringify!(vstateMax)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlValidCtxt>())).vstateTab as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlValidCtxt),
      "::",
      stringify!(vstateTab)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlValidCtxt>())).am as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlValidCtxt),
      "::",
      stringify!(am)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlValidCtxt>())).state as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlValidCtxt),
      "::",
      stringify!(state)
    )
  );
}
pub type xmlNotationTable = _xmlHashTable;
pub type xmlNotationTablePtr = *mut xmlNotationTable;
pub type xmlElementTable = _xmlHashTable;
pub type xmlElementTablePtr = *mut xmlElementTable;
pub type xmlAttributeTable = _xmlHashTable;
pub type xmlAttributeTablePtr = *mut xmlAttributeTable;
pub type xmlIDTable = _xmlHashTable;
pub type xmlIDTablePtr = *mut xmlIDTable;
pub type xmlRefTable = _xmlHashTable;
pub type xmlRefTablePtr = *mut xmlRefTable;
extern "C" {
  pub fn xmlAddNotationDecl(
    ctxt: xmlValidCtxtPtr,
    dtd: xmlDtdPtr,
    name: *const xmlChar,
    PublicID: *const xmlChar,
    SystemID: *const xmlChar,
  ) -> xmlNotationPtr;
}
extern "C" {
  pub fn xmlCopyNotationTable(table: xmlNotationTablePtr) -> xmlNotationTablePtr;
}
extern "C" {
  pub fn xmlFreeNotationTable(table: xmlNotationTablePtr);
}
extern "C" {
  pub fn xmlDumpNotationDecl(buf: xmlBufferPtr, nota: xmlNotationPtr);
}
extern "C" {
  pub fn xmlDumpNotationTable(buf: xmlBufferPtr, table: xmlNotationTablePtr);
}
extern "C" {
  pub fn xmlNewElementContent(
    name: *const xmlChar,
    type_: xmlElementContentType,
  ) -> xmlElementContentPtr;
}
extern "C" {
  pub fn xmlCopyElementContent(content: xmlElementContentPtr) -> xmlElementContentPtr;
}
extern "C" {
  pub fn xmlFreeElementContent(cur: xmlElementContentPtr);
}
extern "C" {
  pub fn xmlNewDocElementContent(
    doc: xmlDocPtr,
    name: *const xmlChar,
    type_: xmlElementContentType,
  ) -> xmlElementContentPtr;
}
extern "C" {
  pub fn xmlCopyDocElementContent(
    doc: xmlDocPtr,
    content: xmlElementContentPtr,
  ) -> xmlElementContentPtr;
}
extern "C" {
  pub fn xmlFreeDocElementContent(doc: xmlDocPtr, cur: xmlElementContentPtr);
}
extern "C" {
  pub fn xmlSnprintfElementContent(
    buf: *mut ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    content: xmlElementContentPtr,
    englob: ::std::os::raw::c_int,
  );
}
extern "C" {
  pub fn xmlSprintfElementContent(
    buf: *mut ::std::os::raw::c_char,
    content: xmlElementContentPtr,
    englob: ::std::os::raw::c_int,
  );
}
extern "C" {
  pub fn xmlAddElementDecl(
    ctxt: xmlValidCtxtPtr,
    dtd: xmlDtdPtr,
    name: *const xmlChar,
    type_: xmlElementTypeVal,
    content: xmlElementContentPtr,
  ) -> xmlElementPtr;
}
extern "C" {
  pub fn xmlCopyElementTable(table: xmlElementTablePtr) -> xmlElementTablePtr;
}
extern "C" {
  pub fn xmlFreeElementTable(table: xmlElementTablePtr);
}
extern "C" {
  pub fn xmlDumpElementTable(buf: xmlBufferPtr, table: xmlElementTablePtr);
}
extern "C" {
  pub fn xmlDumpElementDecl(buf: xmlBufferPtr, elem: xmlElementPtr);
}
extern "C" {
  pub fn xmlCreateEnumeration(name: *const xmlChar) -> xmlEnumerationPtr;
}
extern "C" {
  pub fn xmlFreeEnumeration(cur: xmlEnumerationPtr);
}
extern "C" {
  pub fn xmlCopyEnumeration(cur: xmlEnumerationPtr) -> xmlEnumerationPtr;
}
extern "C" {
  pub fn xmlAddAttributeDecl(
    ctxt: xmlValidCtxtPtr,
    dtd: xmlDtdPtr,
    elem: *const xmlChar,
    name: *const xmlChar,
    ns: *const xmlChar,
    type_: xmlAttributeType,
    def: xmlAttributeDefault,
    defaultValue: *const xmlChar,
    tree: xmlEnumerationPtr,
  ) -> xmlAttributePtr;
}
extern "C" {
  pub fn xmlCopyAttributeTable(table: xmlAttributeTablePtr) -> xmlAttributeTablePtr;
}
extern "C" {
  pub fn xmlFreeAttributeTable(table: xmlAttributeTablePtr);
}
extern "C" {
  pub fn xmlDumpAttributeTable(buf: xmlBufferPtr, table: xmlAttributeTablePtr);
}
extern "C" {
  pub fn xmlDumpAttributeDecl(buf: xmlBufferPtr, attr: xmlAttributePtr);
}
extern "C" {
  pub fn xmlAddID(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    value: *const xmlChar,
    attr: xmlAttrPtr,
  ) -> xmlIDPtr;
}
extern "C" {
  pub fn xmlFreeIDTable(table: xmlIDTablePtr);
}
extern "C" {
  pub fn xmlGetID(doc: xmlDocPtr, ID: *const xmlChar) -> xmlAttrPtr;
}
extern "C" {
  pub fn xmlIsID(doc: xmlDocPtr, elem: xmlNodePtr, attr: xmlAttrPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlRemoveID(doc: xmlDocPtr, attr: xmlAttrPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlAddRef(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    value: *const xmlChar,
    attr: xmlAttrPtr,
  ) -> xmlRefPtr;
}
extern "C" {
  pub fn xmlFreeRefTable(table: xmlRefTablePtr);
}
extern "C" {
  pub fn xmlIsRef(doc: xmlDocPtr, elem: xmlNodePtr, attr: xmlAttrPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlRemoveRef(doc: xmlDocPtr, attr: xmlAttrPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlGetRefs(doc: xmlDocPtr, ID: *const xmlChar) -> xmlListPtr;
}
extern "C" {
  pub fn xmlNewValidCtxt() -> xmlValidCtxtPtr;
}
extern "C" {
  pub fn xmlFreeValidCtxt(arg1: xmlValidCtxtPtr);
}
extern "C" {
  pub fn xmlValidateRoot(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidateElementDecl(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    elem: xmlElementPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidNormalizeAttributeValue(
    doc: xmlDocPtr,
    elem: xmlNodePtr,
    name: *const xmlChar,
    value: *const xmlChar,
  ) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlValidCtxtNormalizeAttributeValue(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    elem: xmlNodePtr,
    name: *const xmlChar,
    value: *const xmlChar,
  ) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlValidateAttributeDecl(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    attr: xmlAttributePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidateAttributeValue(
    type_: xmlAttributeType,
    value: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidateNotationDecl(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    nota: xmlNotationPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidateDtd(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    dtd: xmlDtdPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidateDtdFinal(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidateDocument(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidateElement(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    elem: xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidateOneElement(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    elem: xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidateOneAttribute(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    elem: xmlNodePtr,
    attr: xmlAttrPtr,
    value: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidateOneNamespace(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    elem: xmlNodePtr,
    prefix: *const xmlChar,
    ns: xmlNsPtr,
    value: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidateDocumentFinal(ctxt: xmlValidCtxtPtr, doc: xmlDocPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidateNotationUse(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    notationName: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlIsMixedElement(doc: xmlDocPtr, name: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlGetDtdAttrDesc(
    dtd: xmlDtdPtr,
    elem: *const xmlChar,
    name: *const xmlChar,
  ) -> xmlAttributePtr;
}
extern "C" {
  pub fn xmlGetDtdQAttrDesc(
    dtd: xmlDtdPtr,
    elem: *const xmlChar,
    name: *const xmlChar,
    prefix: *const xmlChar,
  ) -> xmlAttributePtr;
}
extern "C" {
  pub fn xmlGetDtdNotationDesc(dtd: xmlDtdPtr, name: *const xmlChar) -> xmlNotationPtr;
}
extern "C" {
  pub fn xmlGetDtdQElementDesc(
    dtd: xmlDtdPtr,
    name: *const xmlChar,
    prefix: *const xmlChar,
  ) -> xmlElementPtr;
}
extern "C" {
  pub fn xmlGetDtdElementDesc(dtd: xmlDtdPtr, name: *const xmlChar) -> xmlElementPtr;
}
extern "C" {
  pub fn xmlValidGetPotentialChildren(
    ctree: *mut xmlElementContent,
    names: *mut *const xmlChar,
    len: *mut ::std::os::raw::c_int,
    max: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidGetValidElements(
    prev: *mut xmlNode,
    next: *mut xmlNode,
    names: *mut *const xmlChar,
    max: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidateNameValue(value: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidateNamesValue(value: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidateNmtokenValue(value: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidateNmtokensValue(value: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidBuildContentModel(
    ctxt: xmlValidCtxtPtr,
    elem: xmlElementPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidatePushElement(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    elem: xmlNodePtr,
    qname: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidatePushCData(
    ctxt: xmlValidCtxtPtr,
    data: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlValidatePopElement(
    ctxt: xmlValidCtxtPtr,
    doc: xmlDocPtr,
    elem: xmlNodePtr,
    qname: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
pub const xmlEntityType_XML_INTERNAL_GENERAL_ENTITY: xmlEntityType = 1;
pub const xmlEntityType_XML_EXTERNAL_GENERAL_PARSED_ENTITY: xmlEntityType = 2;
pub const xmlEntityType_XML_EXTERNAL_GENERAL_UNPARSED_ENTITY: xmlEntityType = 3;
pub const xmlEntityType_XML_INTERNAL_PARAMETER_ENTITY: xmlEntityType = 4;
pub const xmlEntityType_XML_EXTERNAL_PARAMETER_ENTITY: xmlEntityType = 5;
pub const xmlEntityType_XML_INTERNAL_PREDEFINED_ENTITY: xmlEntityType = 6;
pub type xmlEntityType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlEntity {
  pub _private: *mut ::std::os::raw::c_void,
  pub type_: xmlElementType,
  pub name: *const xmlChar,
  pub children: *mut _xmlNode,
  pub last: *mut _xmlNode,
  pub parent: *mut _xmlDtd,
  pub next: *mut _xmlNode,
  pub prev: *mut _xmlNode,
  pub doc: *mut _xmlDoc,
  pub orig: *mut xmlChar,
  pub content: *mut xmlChar,
  pub length: ::std::os::raw::c_int,
  pub etype: xmlEntityType,
  pub ExternalID: *const xmlChar,
  pub SystemID: *const xmlChar,
  pub nexte: *mut _xmlEntity,
  pub URI: *const xmlChar,
  pub owner: ::std::os::raw::c_int,
  pub checked: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__xmlEntity() {
  assert_eq!(
    ::std::mem::size_of::<_xmlEntity>(),
    136usize,
    concat!("Size of: ", stringify!(_xmlEntity))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlEntity>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlEntity))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlEntity>()))._private as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlEntity),
      "::",
      stringify!(_private)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlEntity>())).type_ as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlEntity),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlEntity>())).name as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlEntity),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlEntity>())).children as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlEntity),
      "::",
      stringify!(children)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlEntity>())).last as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlEntity),
      "::",
      stringify!(last)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlEntity>())).parent as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlEntity),
      "::",
      stringify!(parent)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlEntity>())).next as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlEntity),
      "::",
      stringify!(next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlEntity>())).prev as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlEntity),
      "::",
      stringify!(prev)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlEntity>())).doc as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlEntity),
      "::",
      stringify!(doc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlEntity>())).orig as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlEntity),
      "::",
      stringify!(orig)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlEntity>())).content as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlEntity),
      "::",
      stringify!(content)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlEntity>())).length as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlEntity),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlEntity>())).etype as *const _ as usize },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlEntity),
      "::",
      stringify!(etype)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlEntity>())).ExternalID as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlEntity),
      "::",
      stringify!(ExternalID)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlEntity>())).SystemID as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlEntity),
      "::",
      stringify!(SystemID)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlEntity>())).nexte as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlEntity),
      "::",
      stringify!(nexte)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlEntity>())).URI as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlEntity),
      "::",
      stringify!(URI)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlEntity>())).owner as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlEntity),
      "::",
      stringify!(owner)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlEntity>())).checked as *const _ as usize },
    132usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlEntity),
      "::",
      stringify!(checked)
    )
  );
}
pub type xmlEntitiesTable = _xmlHashTable;
pub type xmlEntitiesTablePtr = *mut xmlEntitiesTable;
extern "C" {
  pub fn xmlInitializePredefinedEntities();
}
extern "C" {
  pub fn xmlNewEntity(
    doc: xmlDocPtr,
    name: *const xmlChar,
    type_: ::std::os::raw::c_int,
    ExternalID: *const xmlChar,
    SystemID: *const xmlChar,
    content: *const xmlChar,
  ) -> xmlEntityPtr;
}
extern "C" {
  pub fn xmlAddDocEntity(
    doc: xmlDocPtr,
    name: *const xmlChar,
    type_: ::std::os::raw::c_int,
    ExternalID: *const xmlChar,
    SystemID: *const xmlChar,
    content: *const xmlChar,
  ) -> xmlEntityPtr;
}
extern "C" {
  pub fn xmlAddDtdEntity(
    doc: xmlDocPtr,
    name: *const xmlChar,
    type_: ::std::os::raw::c_int,
    ExternalID: *const xmlChar,
    SystemID: *const xmlChar,
    content: *const xmlChar,
  ) -> xmlEntityPtr;
}
extern "C" {
  pub fn xmlGetPredefinedEntity(name: *const xmlChar) -> xmlEntityPtr;
}
extern "C" {
  pub fn xmlGetDocEntity(doc: *const xmlDoc, name: *const xmlChar) -> xmlEntityPtr;
}
extern "C" {
  pub fn xmlGetDtdEntity(doc: xmlDocPtr, name: *const xmlChar) -> xmlEntityPtr;
}
extern "C" {
  pub fn xmlGetParameterEntity(doc: xmlDocPtr, name: *const xmlChar) -> xmlEntityPtr;
}
extern "C" {
  pub fn xmlEncodeEntities(doc: xmlDocPtr, input: *const xmlChar) -> *const xmlChar;
}
extern "C" {
  pub fn xmlEncodeEntitiesReentrant(doc: xmlDocPtr, input: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlEncodeSpecialChars(doc: *const xmlDoc, input: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlCreateEntitiesTable() -> xmlEntitiesTablePtr;
}
extern "C" {
  pub fn xmlCopyEntitiesTable(table: xmlEntitiesTablePtr) -> xmlEntitiesTablePtr;
}
extern "C" {
  pub fn xmlFreeEntitiesTable(table: xmlEntitiesTablePtr);
}
extern "C" {
  pub fn xmlDumpEntitiesTable(buf: xmlBufferPtr, table: xmlEntitiesTablePtr);
}
extern "C" {
  pub fn xmlDumpEntityDecl(buf: xmlBufferPtr, ent: xmlEntityPtr);
}
extern "C" {
  pub fn xmlCleanupPredefinedEntities();
}
/// xmlParserInputDeallocate:
/// @str:  the string to deallocate
///
/// Callback for freeing some parser input allocations.
pub type xmlParserInputDeallocate = ::std::option::Option<unsafe extern "C" fn(str: *mut xmlChar)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlParserInput {
  pub buf: xmlParserInputBufferPtr,
  pub filename: *const ::std::os::raw::c_char,
  pub directory: *const ::std::os::raw::c_char,
  pub base: *const xmlChar,
  pub cur: *const xmlChar,
  pub end: *const xmlChar,
  pub length: ::std::os::raw::c_int,
  pub line: ::std::os::raw::c_int,
  pub col: ::std::os::raw::c_int,
  pub consumed: ::std::os::raw::c_ulong,
  pub free: xmlParserInputDeallocate,
  pub encoding: *const xmlChar,
  pub version: *const xmlChar,
  pub standalone: ::std::os::raw::c_int,
  pub id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__xmlParserInput() {
  assert_eq!(
    ::std::mem::size_of::<_xmlParserInput>(),
    104usize,
    concat!("Size of: ", stringify!(_xmlParserInput))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlParserInput>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlParserInput))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInput>())).buf as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInput),
      "::",
      stringify!(buf)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInput>())).filename as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInput),
      "::",
      stringify!(filename)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInput>())).directory as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInput),
      "::",
      stringify!(directory)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInput>())).base as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInput),
      "::",
      stringify!(base)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInput>())).cur as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInput),
      "::",
      stringify!(cur)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInput>())).end as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInput),
      "::",
      stringify!(end)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInput>())).length as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInput),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInput>())).line as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInput),
      "::",
      stringify!(line)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInput>())).col as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInput),
      "::",
      stringify!(col)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInput>())).consumed as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInput),
      "::",
      stringify!(consumed)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInput>())).free as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInput),
      "::",
      stringify!(free)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInput>())).encoding as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInput),
      "::",
      stringify!(encoding)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInput>())).version as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInput),
      "::",
      stringify!(version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInput>())).standalone as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInput),
      "::",
      stringify!(standalone)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInput>())).id as *const _ as usize },
    100usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInput),
      "::",
      stringify!(id)
    )
  );
}
/// xmlParserNodeInfo:
///
/// The parser can be asked to collect Node informations, i.e. at what
/// place in the file they were detected.
/// NOTE: This is off by default and not very well tested.
pub type xmlParserNodeInfo = _xmlParserNodeInfo;
pub type xmlParserNodeInfoPtr = *mut xmlParserNodeInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlParserNodeInfo {
  pub node: *const _xmlNode,
  pub begin_pos: ::std::os::raw::c_ulong,
  pub begin_line: ::std::os::raw::c_ulong,
  pub end_pos: ::std::os::raw::c_ulong,
  pub end_line: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout__xmlParserNodeInfo() {
  assert_eq!(
    ::std::mem::size_of::<_xmlParserNodeInfo>(),
    40usize,
    concat!("Size of: ", stringify!(_xmlParserNodeInfo))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlParserNodeInfo>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlParserNodeInfo))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserNodeInfo>())).node as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserNodeInfo),
      "::",
      stringify!(node)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserNodeInfo>())).begin_pos as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserNodeInfo),
      "::",
      stringify!(begin_pos)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserNodeInfo>())).begin_line as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserNodeInfo),
      "::",
      stringify!(begin_line)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserNodeInfo>())).end_pos as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserNodeInfo),
      "::",
      stringify!(end_pos)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserNodeInfo>())).end_line as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserNodeInfo),
      "::",
      stringify!(end_line)
    )
  );
}
pub type xmlParserNodeInfoSeq = _xmlParserNodeInfoSeq;
pub type xmlParserNodeInfoSeqPtr = *mut xmlParserNodeInfoSeq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlParserNodeInfoSeq {
  pub maximum: ::std::os::raw::c_ulong,
  pub length: ::std::os::raw::c_ulong,
  pub buffer: *mut xmlParserNodeInfo,
}
#[test]
fn bindgen_test_layout__xmlParserNodeInfoSeq() {
  assert_eq!(
    ::std::mem::size_of::<_xmlParserNodeInfoSeq>(),
    24usize,
    concat!("Size of: ", stringify!(_xmlParserNodeInfoSeq))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlParserNodeInfoSeq>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlParserNodeInfoSeq))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserNodeInfoSeq>())).maximum as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserNodeInfoSeq),
      "::",
      stringify!(maximum)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserNodeInfoSeq>())).length as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserNodeInfoSeq),
      "::",
      stringify!(length)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserNodeInfoSeq>())).buffer as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserNodeInfoSeq),
      "::",
      stringify!(buffer)
    )
  );
}
pub const xmlParserInputState_XML_PARSER_EOF: xmlParserInputState = -1;
pub const xmlParserInputState_XML_PARSER_START: xmlParserInputState = 0;
pub const xmlParserInputState_XML_PARSER_MISC: xmlParserInputState = 1;
pub const xmlParserInputState_XML_PARSER_PI: xmlParserInputState = 2;
pub const xmlParserInputState_XML_PARSER_DTD: xmlParserInputState = 3;
pub const xmlParserInputState_XML_PARSER_PROLOG: xmlParserInputState = 4;
pub const xmlParserInputState_XML_PARSER_COMMENT: xmlParserInputState = 5;
pub const xmlParserInputState_XML_PARSER_START_TAG: xmlParserInputState = 6;
pub const xmlParserInputState_XML_PARSER_CONTENT: xmlParserInputState = 7;
pub const xmlParserInputState_XML_PARSER_CDATA_SECTION: xmlParserInputState = 8;
pub const xmlParserInputState_XML_PARSER_END_TAG: xmlParserInputState = 9;
pub const xmlParserInputState_XML_PARSER_ENTITY_DECL: xmlParserInputState = 10;
pub const xmlParserInputState_XML_PARSER_ENTITY_VALUE: xmlParserInputState = 11;
pub const xmlParserInputState_XML_PARSER_ATTRIBUTE_VALUE: xmlParserInputState = 12;
pub const xmlParserInputState_XML_PARSER_SYSTEM_LITERAL: xmlParserInputState = 13;
pub const xmlParserInputState_XML_PARSER_EPILOG: xmlParserInputState = 14;
pub const xmlParserInputState_XML_PARSER_IGNORE: xmlParserInputState = 15;
pub const xmlParserInputState_XML_PARSER_PUBLIC_LITERAL: xmlParserInputState = 16;
/// xmlParserInputState:
///
/// The parser is now working also as a state based parser.
/// The recursive one use the state info for entities processing.
pub type xmlParserInputState = i32;
pub const xmlParserMode_XML_PARSE_UNKNOWN: xmlParserMode = 0;
pub const xmlParserMode_XML_PARSE_DOM: xmlParserMode = 1;
pub const xmlParserMode_XML_PARSE_SAX: xmlParserMode = 2;
pub const xmlParserMode_XML_PARSE_PUSH_DOM: xmlParserMode = 3;
pub const xmlParserMode_XML_PARSE_PUSH_SAX: xmlParserMode = 4;
pub const xmlParserMode_XML_PARSE_READER: xmlParserMode = 5;
/// xmlParserMode:
///
/// A parser can operate in various modes
pub type xmlParserMode = u32;
/// xmlParserCtxt:
///
/// The parser context.
/// NOTE This doesn't completely define the parser state, the (current ?)
/// design of the parser uses recursive function calls since this allow
/// and easy mapping from the production rules of the specification
/// to the actual code. The drawback is that the actual function call
/// also reflect the parser state. However most of the parsing routines
/// takes as the only argument the parser context pointer, so migrating
/// to a state based parser for progressive parsing shouldn't be too hard.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlParserCtxt {
  pub sax: *mut _xmlSAXHandler,
  pub userData: *mut ::std::os::raw::c_void,
  pub myDoc: xmlDocPtr,
  pub wellFormed: ::std::os::raw::c_int,
  pub replaceEntities: ::std::os::raw::c_int,
  pub version: *const xmlChar,
  pub encoding: *const xmlChar,
  pub standalone: ::std::os::raw::c_int,
  pub html: ::std::os::raw::c_int,
  pub input: xmlParserInputPtr,
  pub inputNr: ::std::os::raw::c_int,
  pub inputMax: ::std::os::raw::c_int,
  pub inputTab: *mut xmlParserInputPtr,
  pub node: xmlNodePtr,
  pub nodeNr: ::std::os::raw::c_int,
  pub nodeMax: ::std::os::raw::c_int,
  pub nodeTab: *mut xmlNodePtr,
  pub record_info: ::std::os::raw::c_int,
  pub node_seq: xmlParserNodeInfoSeq,
  pub errNo: ::std::os::raw::c_int,
  pub hasExternalSubset: ::std::os::raw::c_int,
  pub hasPErefs: ::std::os::raw::c_int,
  pub external: ::std::os::raw::c_int,
  pub valid: ::std::os::raw::c_int,
  pub validate: ::std::os::raw::c_int,
  pub vctxt: xmlValidCtxt,
  pub instate: xmlParserInputState,
  pub token: ::std::os::raw::c_int,
  pub directory: *mut ::std::os::raw::c_char,
  pub name: *const xmlChar,
  pub nameNr: ::std::os::raw::c_int,
  pub nameMax: ::std::os::raw::c_int,
  pub nameTab: *mut *const xmlChar,
  pub nbChars: ::std::os::raw::c_long,
  pub checkIndex: ::std::os::raw::c_long,
  pub keepBlanks: ::std::os::raw::c_int,
  pub disableSAX: ::std::os::raw::c_int,
  pub inSubset: ::std::os::raw::c_int,
  pub intSubName: *const xmlChar,
  pub extSubURI: *mut xmlChar,
  pub extSubSystem: *mut xmlChar,
  pub space: *mut ::std::os::raw::c_int,
  pub spaceNr: ::std::os::raw::c_int,
  pub spaceMax: ::std::os::raw::c_int,
  pub spaceTab: *mut ::std::os::raw::c_int,
  pub depth: ::std::os::raw::c_int,
  pub entity: xmlParserInputPtr,
  pub charset: ::std::os::raw::c_int,
  pub nodelen: ::std::os::raw::c_int,
  pub nodemem: ::std::os::raw::c_int,
  pub pedantic: ::std::os::raw::c_int,
  pub _private: *mut ::std::os::raw::c_void,
  pub loadsubset: ::std::os::raw::c_int,
  pub linenumbers: ::std::os::raw::c_int,
  pub catalogs: *mut ::std::os::raw::c_void,
  pub recovery: ::std::os::raw::c_int,
  pub progressive: ::std::os::raw::c_int,
  pub dict: xmlDictPtr,
  pub atts: *mut *const xmlChar,
  pub maxatts: ::std::os::raw::c_int,
  pub docdict: ::std::os::raw::c_int,
  pub str_xml: *const xmlChar,
  pub str_xmlns: *const xmlChar,
  pub str_xml_ns: *const xmlChar,
  pub sax2: ::std::os::raw::c_int,
  pub nsNr: ::std::os::raw::c_int,
  pub nsMax: ::std::os::raw::c_int,
  pub nsTab: *mut *const xmlChar,
  pub attallocs: *mut ::std::os::raw::c_int,
  pub pushTab: *mut *mut ::std::os::raw::c_void,
  pub attsDefault: xmlHashTablePtr,
  pub attsSpecial: xmlHashTablePtr,
  pub nsWellFormed: ::std::os::raw::c_int,
  pub options: ::std::os::raw::c_int,
  pub dictNames: ::std::os::raw::c_int,
  pub freeElemsNr: ::std::os::raw::c_int,
  pub freeElems: xmlNodePtr,
  pub freeAttrsNr: ::std::os::raw::c_int,
  pub freeAttrs: xmlAttrPtr,
  pub lastError: xmlError,
  pub parseMode: xmlParserMode,
  pub nbentities: ::std::os::raw::c_ulong,
  pub sizeentities: ::std::os::raw::c_ulong,
  pub nodeInfo: *mut xmlParserNodeInfo,
  pub nodeInfoNr: ::std::os::raw::c_int,
  pub nodeInfoMax: ::std::os::raw::c_int,
  pub nodeInfoTab: *mut xmlParserNodeInfo,
  pub input_id: ::std::os::raw::c_int,
  pub sizeentcopy: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout__xmlParserCtxt() {
  assert_eq!(
    ::std::mem::size_of::<_xmlParserCtxt>(),
    752usize,
    concat!("Size of: ", stringify!(_xmlParserCtxt))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlParserCtxt>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlParserCtxt))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).sax as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(sax)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).userData as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(userData)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).myDoc as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(myDoc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).wellFormed as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(wellFormed)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).replaceEntities as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(replaceEntities)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).version as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).encoding as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(encoding)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).standalone as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(standalone)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).html as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(html)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).input as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(input)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).inputNr as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(inputNr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).inputMax as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(inputMax)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).inputTab as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(inputTab)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).node as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(node)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).nodeNr as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(nodeNr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).nodeMax as *const _ as usize },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(nodeMax)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).nodeTab as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(nodeTab)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).record_info as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(record_info)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).node_seq as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(node_seq)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).errNo as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(errNo)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).hasExternalSubset as *const _ as usize },
    140usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(hasExternalSubset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).hasPErefs as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(hasPErefs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).external as *const _ as usize },
    148usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(external)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).valid as *const _ as usize },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(valid)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).validate as *const _ as usize },
    156usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(validate)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).vctxt as *const _ as usize },
    160usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(vctxt)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).instate as *const _ as usize },
    272usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(instate)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).token as *const _ as usize },
    276usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(token)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).directory as *const _ as usize },
    280usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(directory)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).name as *const _ as usize },
    288usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).nameNr as *const _ as usize },
    296usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(nameNr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).nameMax as *const _ as usize },
    300usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(nameMax)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).nameTab as *const _ as usize },
    304usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(nameTab)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).nbChars as *const _ as usize },
    312usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(nbChars)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).checkIndex as *const _ as usize },
    320usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(checkIndex)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).keepBlanks as *const _ as usize },
    328usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(keepBlanks)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).disableSAX as *const _ as usize },
    332usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(disableSAX)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).inSubset as *const _ as usize },
    336usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(inSubset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).intSubName as *const _ as usize },
    344usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(intSubName)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).extSubURI as *const _ as usize },
    352usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(extSubURI)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).extSubSystem as *const _ as usize },
    360usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(extSubSystem)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).space as *const _ as usize },
    368usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(space)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).spaceNr as *const _ as usize },
    376usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(spaceNr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).spaceMax as *const _ as usize },
    380usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(spaceMax)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).spaceTab as *const _ as usize },
    384usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(spaceTab)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).depth as *const _ as usize },
    392usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(depth)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).entity as *const _ as usize },
    400usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(entity)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).charset as *const _ as usize },
    408usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(charset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).nodelen as *const _ as usize },
    412usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(nodelen)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).nodemem as *const _ as usize },
    416usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(nodemem)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).pedantic as *const _ as usize },
    420usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(pedantic)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>()))._private as *const _ as usize },
    424usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(_private)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).loadsubset as *const _ as usize },
    432usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(loadsubset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).linenumbers as *const _ as usize },
    436usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(linenumbers)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).catalogs as *const _ as usize },
    440usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(catalogs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).recovery as *const _ as usize },
    448usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(recovery)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).progressive as *const _ as usize },
    452usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(progressive)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).dict as *const _ as usize },
    456usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(dict)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).atts as *const _ as usize },
    464usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(atts)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).maxatts as *const _ as usize },
    472usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(maxatts)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).docdict as *const _ as usize },
    476usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(docdict)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).str_xml as *const _ as usize },
    480usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(str_xml)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).str_xmlns as *const _ as usize },
    488usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(str_xmlns)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).str_xml_ns as *const _ as usize },
    496usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(str_xml_ns)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).sax2 as *const _ as usize },
    504usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(sax2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).nsNr as *const _ as usize },
    508usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(nsNr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).nsMax as *const _ as usize },
    512usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(nsMax)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).nsTab as *const _ as usize },
    520usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(nsTab)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).attallocs as *const _ as usize },
    528usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(attallocs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).pushTab as *const _ as usize },
    536usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(pushTab)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).attsDefault as *const _ as usize },
    544usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(attsDefault)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).attsSpecial as *const _ as usize },
    552usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(attsSpecial)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).nsWellFormed as *const _ as usize },
    560usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(nsWellFormed)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).options as *const _ as usize },
    564usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(options)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).dictNames as *const _ as usize },
    568usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(dictNames)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).freeElemsNr as *const _ as usize },
    572usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(freeElemsNr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).freeElems as *const _ as usize },
    576usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(freeElems)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).freeAttrsNr as *const _ as usize },
    584usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(freeAttrsNr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).freeAttrs as *const _ as usize },
    592usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(freeAttrs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).lastError as *const _ as usize },
    600usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(lastError)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).parseMode as *const _ as usize },
    688usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(parseMode)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).nbentities as *const _ as usize },
    696usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(nbentities)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).sizeentities as *const _ as usize },
    704usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(sizeentities)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).nodeInfo as *const _ as usize },
    712usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(nodeInfo)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).nodeInfoNr as *const _ as usize },
    720usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(nodeInfoNr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).nodeInfoMax as *const _ as usize },
    724usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(nodeInfoMax)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).nodeInfoTab as *const _ as usize },
    728usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(nodeInfoTab)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).input_id as *const _ as usize },
    736usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(input_id)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserCtxt>())).sizeentcopy as *const _ as usize },
    744usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserCtxt),
      "::",
      stringify!(sizeentcopy)
    )
  );
}
/// xmlSAXLocator:
///
/// A SAX Locator.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSAXLocator {
  pub getPublicId:
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> *const xmlChar>,
  pub getSystemId:
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> *const xmlChar>,
  pub getLineNumber: ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
  >,
  pub getColumnNumber: ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
  >,
}
#[test]
fn bindgen_test_layout__xmlSAXLocator() {
  assert_eq!(
    ::std::mem::size_of::<_xmlSAXLocator>(),
    32usize,
    concat!("Size of: ", stringify!(_xmlSAXLocator))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlSAXLocator>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlSAXLocator))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXLocator>())).getPublicId as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXLocator),
      "::",
      stringify!(getPublicId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXLocator>())).getSystemId as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXLocator),
      "::",
      stringify!(getSystemId)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXLocator>())).getLineNumber as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXLocator),
      "::",
      stringify!(getLineNumber)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXLocator>())).getColumnNumber as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXLocator),
      "::",
      stringify!(getColumnNumber)
    )
  );
}
/// resolveEntitySAXFunc:
/// @ctx:  the user data (XML parser context)
/// @publicId: The public ID of the entity
/// @systemId: The system ID of the entity
///
/// Callback:
/// The entity loader, to control the loading of external entities,
/// the application can either:
/// - override this resolveEntity() callback in the SAX block
/// - or better use the xmlSetExternalEntityLoader() function to
/// set up it's own entity resolution routine
///
/// Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.
pub type resolveEntitySAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    publicId: *const xmlChar,
    systemId: *const xmlChar,
  ) -> xmlParserInputPtr,
>;
/// internalSubsetSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name:  the root element name
/// @ExternalID:  the external ID
/// @SystemID:  the SYSTEM ID (e.g. filename or URL)
///
/// Callback on internal subset declaration.
pub type internalSubsetSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    ExternalID: *const xmlChar,
    SystemID: *const xmlChar,
  ),
>;
/// externalSubsetSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name:  the root element name
/// @ExternalID:  the external ID
/// @SystemID:  the SYSTEM ID (e.g. filename or URL)
///
/// Callback on external subset declaration.
pub type externalSubsetSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    ExternalID: *const xmlChar,
    SystemID: *const xmlChar,
  ),
>;
/// getEntitySAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name: The entity name
///
/// Get an entity by name.
///
/// Returns the xmlEntityPtr if found.
pub type getEntitySAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar) -> xmlEntityPtr,
>;
/// getParameterEntitySAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name: The entity name
///
/// Get a parameter entity by name.
///
/// Returns the xmlEntityPtr if found.
pub type getParameterEntitySAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar) -> xmlEntityPtr,
>;
/// entityDeclSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name:  the entity name
/// @type:  the entity type
/// @publicId: The public ID of the entity
/// @systemId: The system ID of the entity
/// @content: the entity value (without processing).
///
/// An entity definition has been parsed.
pub type entityDeclSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    type_: ::std::os::raw::c_int,
    publicId: *const xmlChar,
    systemId: *const xmlChar,
    content: *mut xmlChar,
  ),
>;
/// notationDeclSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name: The name of the notation
/// @publicId: The public ID of the entity
/// @systemId: The system ID of the entity
///
/// What to do when a notation declaration has been parsed.
pub type notationDeclSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    publicId: *const xmlChar,
    systemId: *const xmlChar,
  ),
>;
/// attributeDeclSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @elem:  the name of the element
/// @fullname:  the attribute name
/// @type:  the attribute type
/// @def:  the type of default value
/// @defaultValue: the attribute default value
/// @tree:  the tree of enumerated value set
///
/// An attribute definition has been parsed.
pub type attributeDeclSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    elem: *const xmlChar,
    fullname: *const xmlChar,
    type_: ::std::os::raw::c_int,
    def: ::std::os::raw::c_int,
    defaultValue: *const xmlChar,
    tree: xmlEnumerationPtr,
  ),
>;
/// elementDeclSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name:  the element name
/// @type:  the element type
/// @content: the element value tree
///
/// An element definition has been parsed.
pub type elementDeclSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    type_: ::std::os::raw::c_int,
    content: xmlElementContentPtr,
  ),
>;
/// unparsedEntityDeclSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name: The name of the entity
/// @publicId: The public ID of the entity
/// @systemId: The system ID of the entity
/// @notationName: the name of the notation
///
/// What to do when an unparsed entity declaration is parsed.
pub type unparsedEntityDeclSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    publicId: *const xmlChar,
    systemId: *const xmlChar,
    notationName: *const xmlChar,
  ),
>;
/// setDocumentLocatorSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @loc: A SAX Locator
///
/// Receive the document locator at startup, actually xmlDefaultSAXLocator.
/// Everything is available on the context, so this is useless in our case.
pub type setDocumentLocatorSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, loc: xmlSAXLocatorPtr),
>;
/// startDocumentSAXFunc:
/// @ctx:  the user data (XML parser context)
///
/// Called when the document start being processed.
pub type startDocumentSAXFunc =
  ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>;
/// endDocumentSAXFunc:
/// @ctx:  the user data (XML parser context)
///
/// Called when the document end has been detected.
pub type endDocumentSAXFunc =
  ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>;
/// startElementSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name:  The element name, including namespace prefix
/// @atts:  An array of name/value attributes pairs, NULL terminated
///
/// Called when an opening tag has been processed.
pub type startElementSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    atts: *mut *const xmlChar,
  ),
>;
/// endElementSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name:  The element name
///
/// Called when the end of an element has been detected.
pub type endElementSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar),
>;
/// attributeSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name:  The attribute name, including namespace prefix
/// @value:  The attribute value
///
/// Handle an attribute that has been read by the parser.
/// The default handling is to convert the attribute into an
/// DOM subtree and past it in a new xmlAttr element added to
/// the element.
pub type attributeSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    value: *const xmlChar,
  ),
>;
/// referenceSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name:  The entity name
///
/// Called when an entity reference is detected.
pub type referenceSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar),
>;
/// charactersSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @ch:  a xmlChar string
/// @len: the number of xmlChar
///
/// Receiving some chars from the parser.
pub type charactersSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    ch: *const xmlChar,
    len: ::std::os::raw::c_int,
  ),
>;
/// ignorableWhitespaceSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @ch:  a xmlChar string
/// @len: the number of xmlChar
///
/// Receiving some ignorable whitespaces from the parser.
/// UNUSED: by default the DOM building will use characters.
pub type ignorableWhitespaceSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    ch: *const xmlChar,
    len: ::std::os::raw::c_int,
  ),
>;
/// processingInstructionSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @target:  the target name
/// @data: the PI data's
///
/// A processing instruction has been parsed.
pub type processingInstructionSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    target: *const xmlChar,
    data: *const xmlChar,
  ),
>;
/// commentSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @value:  the comment content
///
/// A comment has been parsed.
pub type commentSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, value: *const xmlChar),
>;
/// cdataBlockSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @value:  The pcdata content
/// @len:  the block length
///
/// Called when a pcdata block has been parsed.
pub type cdataBlockSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    value: *const xmlChar,
    len: ::std::os::raw::c_int,
  ),
>;
/// warningSAXFunc:
/// @ctx:  an XML parser context
/// @msg:  the message to display/transmit
/// @...:  extra parameters for the message display
///
/// Display and format a warning messages, callback.
pub type warningSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
/// errorSAXFunc:
/// @ctx:  an XML parser context
/// @msg:  the message to display/transmit
/// @...:  extra parameters for the message display
///
/// Display and format an error messages, callback.
pub type errorSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
/// fatalErrorSAXFunc:
/// @ctx:  an XML parser context
/// @msg:  the message to display/transmit
/// @...:  extra parameters for the message display
///
/// Display and format fatal error messages, callback.
/// Note: so far fatalError() SAX callbacks are not used, error()
/// get all the callbacks for errors.
pub type fatalErrorSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
/// isStandaloneSAXFunc:
/// @ctx:  the user data (XML parser context)
///
/// Is this document tagged standalone?
///
/// Returns 1 if true
pub type isStandaloneSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
/// hasInternalSubsetSAXFunc:
/// @ctx:  the user data (XML parser context)
///
/// Does this document has an internal subset.
///
/// Returns 1 if true
pub type hasInternalSubsetSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
/// hasExternalSubsetSAXFunc:
/// @ctx:  the user data (XML parser context)
///
/// Does this document has an external subset?
///
/// Returns 1 if true
pub type hasExternalSubsetSAXFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
/// startElementNsSAX2Func:
/// @ctx:  the user data (XML parser context)
/// @localname:  the local name of the element
/// @prefix:  the element namespace prefix if available
/// @URI:  the element namespace name if available
/// @nb_namespaces:  number of namespace definitions on that node
/// @namespaces:  pointer to the array of prefix/URI pairs namespace definitions
/// @nb_attributes:  the number of attributes on that node
/// @nb_defaulted:  the number of defaulted attributes. The defaulted
/// ones are at the end of the array
/// @attributes:  pointer to the array of (localname/prefix/URI/value/end)
/// attribute values.
///
/// SAX2 callback when an element start has been detected by the parser.
/// It provides the namespace informations for the element, as well as
/// the new namespace declarations on the element.
pub type startElementNsSAX2Func = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    localname: *const xmlChar,
    prefix: *const xmlChar,
    URI: *const xmlChar,
    nb_namespaces: ::std::os::raw::c_int,
    namespaces: *mut *const xmlChar,
    nb_attributes: ::std::os::raw::c_int,
    nb_defaulted: ::std::os::raw::c_int,
    attributes: *mut *const xmlChar,
  ),
>;
/// endElementNsSAX2Func:
/// @ctx:  the user data (XML parser context)
/// @localname:  the local name of the element
/// @prefix:  the element namespace prefix if available
/// @URI:  the element namespace name if available
///
/// SAX2 callback when an element end has been detected by the parser.
/// It provides the namespace informations for the element.
pub type endElementNsSAX2Func = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    localname: *const xmlChar,
    prefix: *const xmlChar,
    URI: *const xmlChar,
  ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSAXHandler {
  pub internalSubset: internalSubsetSAXFunc,
  pub isStandalone: isStandaloneSAXFunc,
  pub hasInternalSubset: hasInternalSubsetSAXFunc,
  pub hasExternalSubset: hasExternalSubsetSAXFunc,
  pub resolveEntity: resolveEntitySAXFunc,
  pub getEntity: getEntitySAXFunc,
  pub entityDecl: entityDeclSAXFunc,
  pub notationDecl: notationDeclSAXFunc,
  pub attributeDecl: attributeDeclSAXFunc,
  pub elementDecl: elementDeclSAXFunc,
  pub unparsedEntityDecl: unparsedEntityDeclSAXFunc,
  pub setDocumentLocator: setDocumentLocatorSAXFunc,
  pub startDocument: startDocumentSAXFunc,
  pub endDocument: endDocumentSAXFunc,
  pub startElement: startElementSAXFunc,
  pub endElement: endElementSAXFunc,
  pub reference: referenceSAXFunc,
  pub characters: charactersSAXFunc,
  pub ignorableWhitespace: ignorableWhitespaceSAXFunc,
  pub processingInstruction: processingInstructionSAXFunc,
  pub comment: commentSAXFunc,
  pub warning: warningSAXFunc,
  pub error: errorSAXFunc,
  pub fatalError: fatalErrorSAXFunc,
  pub getParameterEntity: getParameterEntitySAXFunc,
  pub cdataBlock: cdataBlockSAXFunc,
  pub externalSubset: externalSubsetSAXFunc,
  pub initialized: ::std::os::raw::c_uint,
  pub _private: *mut ::std::os::raw::c_void,
  pub startElementNs: startElementNsSAX2Func,
  pub endElementNs: endElementNsSAX2Func,
  pub serror: xmlStructuredErrorFunc,
}
#[test]
fn bindgen_test_layout__xmlSAXHandler() {
  assert_eq!(
    ::std::mem::size_of::<_xmlSAXHandler>(),
    256usize,
    concat!("Size of: ", stringify!(_xmlSAXHandler))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlSAXHandler>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlSAXHandler))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).internalSubset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(internalSubset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).isStandalone as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(isStandalone)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).hasInternalSubset as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(hasInternalSubset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).hasExternalSubset as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(hasExternalSubset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).resolveEntity as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(resolveEntity)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).getEntity as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(getEntity)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).entityDecl as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(entityDecl)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).notationDecl as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(notationDecl)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).attributeDecl as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(attributeDecl)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).elementDecl as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(elementDecl)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).unparsedEntityDecl as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(unparsedEntityDecl)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).setDocumentLocator as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(setDocumentLocator)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).startDocument as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(startDocument)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).endDocument as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(endDocument)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).startElement as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(startElement)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).endElement as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(endElement)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).reference as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(reference)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).characters as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(characters)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).ignorableWhitespace as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(ignorableWhitespace)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlSAXHandler>())).processingInstruction as *const _ as usize
    },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(processingInstruction)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).comment as *const _ as usize },
    160usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(comment)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).warning as *const _ as usize },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(warning)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).error as *const _ as usize },
    176usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(error)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).fatalError as *const _ as usize },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(fatalError)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).getParameterEntity as *const _ as usize },
    192usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(getParameterEntity)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).cdataBlock as *const _ as usize },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(cdataBlock)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).externalSubset as *const _ as usize },
    208usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(externalSubset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).initialized as *const _ as usize },
    216usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(initialized)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>()))._private as *const _ as usize },
    224usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(_private)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).startElementNs as *const _ as usize },
    232usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(startElementNs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).endElementNs as *const _ as usize },
    240usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(endElementNs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandler>())).serror as *const _ as usize },
    248usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandler),
      "::",
      stringify!(serror)
    )
  );
}
pub type xmlSAXHandlerV1 = _xmlSAXHandlerV1;
pub type xmlSAXHandlerV1Ptr = *mut xmlSAXHandlerV1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSAXHandlerV1 {
  pub internalSubset: internalSubsetSAXFunc,
  pub isStandalone: isStandaloneSAXFunc,
  pub hasInternalSubset: hasInternalSubsetSAXFunc,
  pub hasExternalSubset: hasExternalSubsetSAXFunc,
  pub resolveEntity: resolveEntitySAXFunc,
  pub getEntity: getEntitySAXFunc,
  pub entityDecl: entityDeclSAXFunc,
  pub notationDecl: notationDeclSAXFunc,
  pub attributeDecl: attributeDeclSAXFunc,
  pub elementDecl: elementDeclSAXFunc,
  pub unparsedEntityDecl: unparsedEntityDeclSAXFunc,
  pub setDocumentLocator: setDocumentLocatorSAXFunc,
  pub startDocument: startDocumentSAXFunc,
  pub endDocument: endDocumentSAXFunc,
  pub startElement: startElementSAXFunc,
  pub endElement: endElementSAXFunc,
  pub reference: referenceSAXFunc,
  pub characters: charactersSAXFunc,
  pub ignorableWhitespace: ignorableWhitespaceSAXFunc,
  pub processingInstruction: processingInstructionSAXFunc,
  pub comment: commentSAXFunc,
  pub warning: warningSAXFunc,
  pub error: errorSAXFunc,
  pub fatalError: fatalErrorSAXFunc,
  pub getParameterEntity: getParameterEntitySAXFunc,
  pub cdataBlock: cdataBlockSAXFunc,
  pub externalSubset: externalSubsetSAXFunc,
  pub initialized: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__xmlSAXHandlerV1() {
  assert_eq!(
    ::std::mem::size_of::<_xmlSAXHandlerV1>(),
    224usize,
    concat!("Size of: ", stringify!(_xmlSAXHandlerV1))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlSAXHandlerV1>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlSAXHandlerV1))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).internalSubset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(internalSubset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).isStandalone as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(isStandalone)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).hasInternalSubset as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(hasInternalSubset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).hasExternalSubset as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(hasExternalSubset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).resolveEntity as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(resolveEntity)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).getEntity as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(getEntity)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).entityDecl as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(entityDecl)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).notationDecl as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(notationDecl)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).attributeDecl as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(attributeDecl)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).elementDecl as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(elementDecl)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).unparsedEntityDecl as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(unparsedEntityDecl)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).setDocumentLocator as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(setDocumentLocator)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).startDocument as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(startDocument)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).endDocument as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(endDocument)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).startElement as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(startElement)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).endElement as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(endElement)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).reference as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(reference)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).characters as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(characters)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).ignorableWhitespace as *const _ as usize
    },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(ignorableWhitespace)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).processingInstruction as *const _ as usize
    },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(processingInstruction)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).comment as *const _ as usize },
    160usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(comment)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).warning as *const _ as usize },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(warning)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).error as *const _ as usize },
    176usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(error)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).fatalError as *const _ as usize },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(fatalError)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).getParameterEntity as *const _ as usize },
    192usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(getParameterEntity)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).cdataBlock as *const _ as usize },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(cdataBlock)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).externalSubset as *const _ as usize },
    208usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(externalSubset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSAXHandlerV1>())).initialized as *const _ as usize },
    216usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSAXHandlerV1),
      "::",
      stringify!(initialized)
    )
  );
}
/// xmlExternalEntityLoader:
/// @URL: The System ID of the resource requested
/// @ID: The Public ID of the resource requested
/// @context: the XML parser context
///
/// External entity loaders types.
///
/// Returns the entity input parser.
pub type xmlExternalEntityLoader = ::std::option::Option<
  unsafe extern "C" fn(
    URL: *const ::std::os::raw::c_char,
    ID: *const ::std::os::raw::c_char,
    context: xmlParserCtxtPtr,
  ) -> xmlParserInputPtr,
>;
pub type iconv_t = *mut ::std::os::raw::c_void;
extern "C" {
  pub fn iconv_open(
    __tocode: *const ::std::os::raw::c_char,
    __fromcode: *const ::std::os::raw::c_char,
  ) -> iconv_t;
}
extern "C" {
  pub fn iconv(
    __cd: iconv_t,
    __inbuf: *mut *mut ::std::os::raw::c_char,
    __inbytesleft: *mut usize,
    __outbuf: *mut *mut ::std::os::raw::c_char,
    __outbytesleft: *mut usize,
  ) -> usize;
}
extern "C" {
  pub fn iconv_close(__cd: iconv_t) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
  pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
  pub __bindgen_padding_0: u64,
  pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
  // assert_eq!(
  //   ::std::mem::size_of::<max_align_t>(),
  //   32usize,
  //   concat!("Size of: ", stringify!(max_align_t))
  // );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(max_align_t),
      "::",
      stringify!(__clang_max_align_nonce1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(max_align_t),
      "::",
      stringify!(__clang_max_align_nonce2)
    )
  );
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type UBool = i8;
pub type UChar = u16;
pub type OldUChar = ::std::os::raw::c_ushort;
pub type UChar32 = i32;
pub type UVersionInfo = [u8; 4usize];
extern "C" {
  pub fn u_versionFromString_60(
    versionArray: *mut u8,
    versionString: *const ::std::os::raw::c_char,
  );
}
extern "C" {
  pub fn u_versionFromUString_60(versionArray: *mut u8, versionString: *const UChar);
}
extern "C" {
  pub fn u_versionToString_60(versionArray: *mut u8, versionString: *mut ::std::os::raw::c_char);
}
extern "C" {
  pub fn u_getVersion_60(versionArray: *mut u8);
}
extern "C" {
  pub fn utf8_nextCharSafeBody_60(
    s: *const u8,
    pi: *mut i32,
    length: i32,
    c: UChar32,
    strict: UBool,
  ) -> UChar32;
}
extern "C" {
  pub fn utf8_appendCharSafeBody_60(
    s: *mut u8,
    i: i32,
    length: i32,
    c: UChar32,
    pIsError: *mut UBool,
  ) -> i32;
}
extern "C" {
  pub fn utf8_prevCharSafeBody_60(
    s: *const u8,
    start: i32,
    pi: *mut i32,
    c: UChar32,
    strict: UBool,
  ) -> UChar32;
}
extern "C" {
  pub fn utf8_back1SafeBody_60(s: *const u8, start: i32, i: i32) -> i32;
}
extern "C" {
  #[link_name = "\u{1}utf8_countTrailBytes_60"]
  pub static mut utf8_countTrailBytes_60: [u8; 0usize];
}
pub type UDate = f64;
pub const UErrorCode_U_USING_FALLBACK_WARNING: UErrorCode = -128;
pub const UErrorCode_U_ERROR_WARNING_START: UErrorCode = -128;
pub const UErrorCode_U_USING_DEFAULT_WARNING: UErrorCode = -127;
pub const UErrorCode_U_SAFECLONE_ALLOCATED_WARNING: UErrorCode = -126;
pub const UErrorCode_U_STATE_OLD_WARNING: UErrorCode = -125;
pub const UErrorCode_U_STRING_NOT_TERMINATED_WARNING: UErrorCode = -124;
pub const UErrorCode_U_SORT_KEY_TOO_SHORT_WARNING: UErrorCode = -123;
pub const UErrorCode_U_AMBIGUOUS_ALIAS_WARNING: UErrorCode = -122;
pub const UErrorCode_U_DIFFERENT_UCA_VERSION: UErrorCode = -121;
pub const UErrorCode_U_PLUGIN_CHANGED_LEVEL_WARNING: UErrorCode = -120;
pub const UErrorCode_U_ERROR_WARNING_LIMIT: UErrorCode = -119;
pub const UErrorCode_U_ZERO_ERROR: UErrorCode = 0;
pub const UErrorCode_U_ILLEGAL_ARGUMENT_ERROR: UErrorCode = 1;
pub const UErrorCode_U_MISSING_RESOURCE_ERROR: UErrorCode = 2;
pub const UErrorCode_U_INVALID_FORMAT_ERROR: UErrorCode = 3;
pub const UErrorCode_U_FILE_ACCESS_ERROR: UErrorCode = 4;
pub const UErrorCode_U_INTERNAL_PROGRAM_ERROR: UErrorCode = 5;
pub const UErrorCode_U_MESSAGE_PARSE_ERROR: UErrorCode = 6;
pub const UErrorCode_U_MEMORY_ALLOCATION_ERROR: UErrorCode = 7;
pub const UErrorCode_U_INDEX_OUTOFBOUNDS_ERROR: UErrorCode = 8;
pub const UErrorCode_U_PARSE_ERROR: UErrorCode = 9;
pub const UErrorCode_U_INVALID_CHAR_FOUND: UErrorCode = 10;
pub const UErrorCode_U_TRUNCATED_CHAR_FOUND: UErrorCode = 11;
pub const UErrorCode_U_ILLEGAL_CHAR_FOUND: UErrorCode = 12;
pub const UErrorCode_U_INVALID_TABLE_FORMAT: UErrorCode = 13;
pub const UErrorCode_U_INVALID_TABLE_FILE: UErrorCode = 14;
pub const UErrorCode_U_BUFFER_OVERFLOW_ERROR: UErrorCode = 15;
pub const UErrorCode_U_UNSUPPORTED_ERROR: UErrorCode = 16;
pub const UErrorCode_U_RESOURCE_TYPE_MISMATCH: UErrorCode = 17;
pub const UErrorCode_U_ILLEGAL_ESCAPE_SEQUENCE: UErrorCode = 18;
pub const UErrorCode_U_UNSUPPORTED_ESCAPE_SEQUENCE: UErrorCode = 19;
pub const UErrorCode_U_NO_SPACE_AVAILABLE: UErrorCode = 20;
pub const UErrorCode_U_CE_NOT_FOUND_ERROR: UErrorCode = 21;
pub const UErrorCode_U_PRIMARY_TOO_LONG_ERROR: UErrorCode = 22;
pub const UErrorCode_U_STATE_TOO_OLD_ERROR: UErrorCode = 23;
pub const UErrorCode_U_TOO_MANY_ALIASES_ERROR: UErrorCode = 24;
pub const UErrorCode_U_ENUM_OUT_OF_SYNC_ERROR: UErrorCode = 25;
pub const UErrorCode_U_INVARIANT_CONVERSION_ERROR: UErrorCode = 26;
pub const UErrorCode_U_INVALID_STATE_ERROR: UErrorCode = 27;
pub const UErrorCode_U_COLLATOR_VERSION_MISMATCH: UErrorCode = 28;
pub const UErrorCode_U_USELESS_COLLATOR_ERROR: UErrorCode = 29;
pub const UErrorCode_U_NO_WRITE_PERMISSION: UErrorCode = 30;
pub const UErrorCode_U_STANDARD_ERROR_LIMIT: UErrorCode = 31;
pub const UErrorCode_U_BAD_VARIABLE_DEFINITION: UErrorCode = 65536;
pub const UErrorCode_U_PARSE_ERROR_START: UErrorCode = 65536;
pub const UErrorCode_U_MALFORMED_RULE: UErrorCode = 65537;
pub const UErrorCode_U_MALFORMED_SET: UErrorCode = 65538;
pub const UErrorCode_U_MALFORMED_SYMBOL_REFERENCE: UErrorCode = 65539;
pub const UErrorCode_U_MALFORMED_UNICODE_ESCAPE: UErrorCode = 65540;
pub const UErrorCode_U_MALFORMED_VARIABLE_DEFINITION: UErrorCode = 65541;
pub const UErrorCode_U_MALFORMED_VARIABLE_REFERENCE: UErrorCode = 65542;
pub const UErrorCode_U_MISMATCHED_SEGMENT_DELIMITERS: UErrorCode = 65543;
pub const UErrorCode_U_MISPLACED_ANCHOR_START: UErrorCode = 65544;
pub const UErrorCode_U_MISPLACED_CURSOR_OFFSET: UErrorCode = 65545;
pub const UErrorCode_U_MISPLACED_QUANTIFIER: UErrorCode = 65546;
pub const UErrorCode_U_MISSING_OPERATOR: UErrorCode = 65547;
pub const UErrorCode_U_MISSING_SEGMENT_CLOSE: UErrorCode = 65548;
pub const UErrorCode_U_MULTIPLE_ANTE_CONTEXTS: UErrorCode = 65549;
pub const UErrorCode_U_MULTIPLE_CURSORS: UErrorCode = 65550;
pub const UErrorCode_U_MULTIPLE_POST_CONTEXTS: UErrorCode = 65551;
pub const UErrorCode_U_TRAILING_BACKSLASH: UErrorCode = 65552;
pub const UErrorCode_U_UNDEFINED_SEGMENT_REFERENCE: UErrorCode = 65553;
pub const UErrorCode_U_UNDEFINED_VARIABLE: UErrorCode = 65554;
pub const UErrorCode_U_UNQUOTED_SPECIAL: UErrorCode = 65555;
pub const UErrorCode_U_UNTERMINATED_QUOTE: UErrorCode = 65556;
pub const UErrorCode_U_RULE_MASK_ERROR: UErrorCode = 65557;
pub const UErrorCode_U_MISPLACED_COMPOUND_FILTER: UErrorCode = 65558;
pub const UErrorCode_U_MULTIPLE_COMPOUND_FILTERS: UErrorCode = 65559;
pub const UErrorCode_U_INVALID_RBT_SYNTAX: UErrorCode = 65560;
pub const UErrorCode_U_INVALID_PROPERTY_PATTERN: UErrorCode = 65561;
pub const UErrorCode_U_MALFORMED_PRAGMA: UErrorCode = 65562;
pub const UErrorCode_U_UNCLOSED_SEGMENT: UErrorCode = 65563;
pub const UErrorCode_U_ILLEGAL_CHAR_IN_SEGMENT: UErrorCode = 65564;
pub const UErrorCode_U_VARIABLE_RANGE_EXHAUSTED: UErrorCode = 65565;
pub const UErrorCode_U_VARIABLE_RANGE_OVERLAP: UErrorCode = 65566;
pub const UErrorCode_U_ILLEGAL_CHARACTER: UErrorCode = 65567;
pub const UErrorCode_U_INTERNAL_TRANSLITERATOR_ERROR: UErrorCode = 65568;
pub const UErrorCode_U_INVALID_ID: UErrorCode = 65569;
pub const UErrorCode_U_INVALID_FUNCTION: UErrorCode = 65570;
pub const UErrorCode_U_PARSE_ERROR_LIMIT: UErrorCode = 65571;
pub const UErrorCode_U_UNEXPECTED_TOKEN: UErrorCode = 65792;
pub const UErrorCode_U_FMT_PARSE_ERROR_START: UErrorCode = 65792;
pub const UErrorCode_U_MULTIPLE_DECIMAL_SEPARATORS: UErrorCode = 65793;
pub const UErrorCode_U_MULTIPLE_DECIMAL_SEPERATORS: UErrorCode = 65793;
pub const UErrorCode_U_MULTIPLE_EXPONENTIAL_SYMBOLS: UErrorCode = 65794;
pub const UErrorCode_U_MALFORMED_EXPONENTIAL_PATTERN: UErrorCode = 65795;
pub const UErrorCode_U_MULTIPLE_PERCENT_SYMBOLS: UErrorCode = 65796;
pub const UErrorCode_U_MULTIPLE_PERMILL_SYMBOLS: UErrorCode = 65797;
pub const UErrorCode_U_MULTIPLE_PAD_SPECIFIERS: UErrorCode = 65798;
pub const UErrorCode_U_PATTERN_SYNTAX_ERROR: UErrorCode = 65799;
pub const UErrorCode_U_ILLEGAL_PAD_POSITION: UErrorCode = 65800;
pub const UErrorCode_U_UNMATCHED_BRACES: UErrorCode = 65801;
pub const UErrorCode_U_UNSUPPORTED_PROPERTY: UErrorCode = 65802;
pub const UErrorCode_U_UNSUPPORTED_ATTRIBUTE: UErrorCode = 65803;
pub const UErrorCode_U_ARGUMENT_TYPE_MISMATCH: UErrorCode = 65804;
pub const UErrorCode_U_DUPLICATE_KEYWORD: UErrorCode = 65805;
pub const UErrorCode_U_UNDEFINED_KEYWORD: UErrorCode = 65806;
pub const UErrorCode_U_DEFAULT_KEYWORD_MISSING: UErrorCode = 65807;
pub const UErrorCode_U_DECIMAL_NUMBER_SYNTAX_ERROR: UErrorCode = 65808;
pub const UErrorCode_U_FORMAT_INEXACT_ERROR: UErrorCode = 65809;
pub const UErrorCode_U_FMT_PARSE_ERROR_LIMIT: UErrorCode = 65810;
pub const UErrorCode_U_BRK_INTERNAL_ERROR: UErrorCode = 66048;
pub const UErrorCode_U_BRK_ERROR_START: UErrorCode = 66048;
pub const UErrorCode_U_BRK_HEX_DIGITS_EXPECTED: UErrorCode = 66049;
pub const UErrorCode_U_BRK_SEMICOLON_EXPECTED: UErrorCode = 66050;
pub const UErrorCode_U_BRK_RULE_SYNTAX: UErrorCode = 66051;
pub const UErrorCode_U_BRK_UNCLOSED_SET: UErrorCode = 66052;
pub const UErrorCode_U_BRK_ASSIGN_ERROR: UErrorCode = 66053;
pub const UErrorCode_U_BRK_VARIABLE_REDFINITION: UErrorCode = 66054;
pub const UErrorCode_U_BRK_MISMATCHED_PAREN: UErrorCode = 66055;
pub const UErrorCode_U_BRK_NEW_LINE_IN_QUOTED_STRING: UErrorCode = 66056;
pub const UErrorCode_U_BRK_UNDEFINED_VARIABLE: UErrorCode = 66057;
pub const UErrorCode_U_BRK_INIT_ERROR: UErrorCode = 66058;
pub const UErrorCode_U_BRK_RULE_EMPTY_SET: UErrorCode = 66059;
pub const UErrorCode_U_BRK_UNRECOGNIZED_OPTION: UErrorCode = 66060;
pub const UErrorCode_U_BRK_MALFORMED_RULE_TAG: UErrorCode = 66061;
pub const UErrorCode_U_BRK_ERROR_LIMIT: UErrorCode = 66062;
pub const UErrorCode_U_REGEX_INTERNAL_ERROR: UErrorCode = 66304;
pub const UErrorCode_U_REGEX_ERROR_START: UErrorCode = 66304;
pub const UErrorCode_U_REGEX_RULE_SYNTAX: UErrorCode = 66305;
pub const UErrorCode_U_REGEX_INVALID_STATE: UErrorCode = 66306;
pub const UErrorCode_U_REGEX_BAD_ESCAPE_SEQUENCE: UErrorCode = 66307;
pub const UErrorCode_U_REGEX_PROPERTY_SYNTAX: UErrorCode = 66308;
pub const UErrorCode_U_REGEX_UNIMPLEMENTED: UErrorCode = 66309;
pub const UErrorCode_U_REGEX_MISMATCHED_PAREN: UErrorCode = 66310;
pub const UErrorCode_U_REGEX_NUMBER_TOO_BIG: UErrorCode = 66311;
pub const UErrorCode_U_REGEX_BAD_INTERVAL: UErrorCode = 66312;
pub const UErrorCode_U_REGEX_MAX_LT_MIN: UErrorCode = 66313;
pub const UErrorCode_U_REGEX_INVALID_BACK_REF: UErrorCode = 66314;
pub const UErrorCode_U_REGEX_INVALID_FLAG: UErrorCode = 66315;
pub const UErrorCode_U_REGEX_LOOK_BEHIND_LIMIT: UErrorCode = 66316;
pub const UErrorCode_U_REGEX_SET_CONTAINS_STRING: UErrorCode = 66317;
pub const UErrorCode_U_REGEX_OCTAL_TOO_BIG: UErrorCode = 66318;
pub const UErrorCode_U_REGEX_MISSING_CLOSE_BRACKET: UErrorCode = 66319;
pub const UErrorCode_U_REGEX_INVALID_RANGE: UErrorCode = 66320;
pub const UErrorCode_U_REGEX_STACK_OVERFLOW: UErrorCode = 66321;
pub const UErrorCode_U_REGEX_TIME_OUT: UErrorCode = 66322;
pub const UErrorCode_U_REGEX_STOPPED_BY_CALLER: UErrorCode = 66323;
pub const UErrorCode_U_REGEX_PATTERN_TOO_BIG: UErrorCode = 66324;
pub const UErrorCode_U_REGEX_INVALID_CAPTURE_GROUP_NAME: UErrorCode = 66325;
pub const UErrorCode_U_REGEX_ERROR_LIMIT: UErrorCode = 66326;
pub const UErrorCode_U_IDNA_PROHIBITED_ERROR: UErrorCode = 66560;
pub const UErrorCode_U_IDNA_ERROR_START: UErrorCode = 66560;
pub const UErrorCode_U_IDNA_UNASSIGNED_ERROR: UErrorCode = 66561;
pub const UErrorCode_U_IDNA_CHECK_BIDI_ERROR: UErrorCode = 66562;
pub const UErrorCode_U_IDNA_STD3_ASCII_RULES_ERROR: UErrorCode = 66563;
pub const UErrorCode_U_IDNA_ACE_PREFIX_ERROR: UErrorCode = 66564;
pub const UErrorCode_U_IDNA_VERIFICATION_ERROR: UErrorCode = 66565;
pub const UErrorCode_U_IDNA_LABEL_TOO_LONG_ERROR: UErrorCode = 66566;
pub const UErrorCode_U_IDNA_ZERO_LENGTH_LABEL_ERROR: UErrorCode = 66567;
pub const UErrorCode_U_IDNA_DOMAIN_NAME_TOO_LONG_ERROR: UErrorCode = 66568;
pub const UErrorCode_U_IDNA_ERROR_LIMIT: UErrorCode = 66569;
pub const UErrorCode_U_STRINGPREP_PROHIBITED_ERROR: UErrorCode = 66560;
pub const UErrorCode_U_STRINGPREP_UNASSIGNED_ERROR: UErrorCode = 66561;
pub const UErrorCode_U_STRINGPREP_CHECK_BIDI_ERROR: UErrorCode = 66562;
pub const UErrorCode_U_PLUGIN_ERROR_START: UErrorCode = 66816;
pub const UErrorCode_U_PLUGIN_TOO_HIGH: UErrorCode = 66816;
pub const UErrorCode_U_PLUGIN_DIDNT_SET_LEVEL: UErrorCode = 66817;
pub const UErrorCode_U_PLUGIN_ERROR_LIMIT: UErrorCode = 66818;
pub const UErrorCode_U_ERROR_LIMIT: UErrorCode = 66818;
pub type UErrorCode = i32;
extern "C" {
  pub fn u_errorName_60(code: UErrorCode) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UConverter {
  _unused: [u8; 0],
}
pub const UConverterCallbackReason_UCNV_UNASSIGNED: UConverterCallbackReason = 0;
pub const UConverterCallbackReason_UCNV_ILLEGAL: UConverterCallbackReason = 1;
pub const UConverterCallbackReason_UCNV_IRREGULAR: UConverterCallbackReason = 2;
pub const UConverterCallbackReason_UCNV_RESET: UConverterCallbackReason = 3;
pub const UConverterCallbackReason_UCNV_CLOSE: UConverterCallbackReason = 4;
pub const UConverterCallbackReason_UCNV_CLONE: UConverterCallbackReason = 5;
pub type UConverterCallbackReason = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UConverterFromUnicodeArgs {
  pub size: u16,
  pub flush: UBool,
  pub converter: *mut UConverter,
  pub source: *const UChar,
  pub sourceLimit: *const UChar,
  pub target: *mut ::std::os::raw::c_char,
  pub targetLimit: *const ::std::os::raw::c_char,
  pub offsets: *mut i32,
}
#[test]
fn bindgen_test_layout_UConverterFromUnicodeArgs() {
  assert_eq!(
    ::std::mem::size_of::<UConverterFromUnicodeArgs>(),
    56usize,
    concat!("Size of: ", stringify!(UConverterFromUnicodeArgs))
  );
  assert_eq!(
    ::std::mem::align_of::<UConverterFromUnicodeArgs>(),
    8usize,
    concat!("Alignment of ", stringify!(UConverterFromUnicodeArgs))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<UConverterFromUnicodeArgs>())).size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(UConverterFromUnicodeArgs),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<UConverterFromUnicodeArgs>())).flush as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(UConverterFromUnicodeArgs),
      "::",
      stringify!(flush)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<UConverterFromUnicodeArgs>())).converter as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(UConverterFromUnicodeArgs),
      "::",
      stringify!(converter)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<UConverterFromUnicodeArgs>())).source as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(UConverterFromUnicodeArgs),
      "::",
      stringify!(source)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<UConverterFromUnicodeArgs>())).sourceLimit as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(UConverterFromUnicodeArgs),
      "::",
      stringify!(sourceLimit)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<UConverterFromUnicodeArgs>())).target as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(UConverterFromUnicodeArgs),
      "::",
      stringify!(target)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<UConverterFromUnicodeArgs>())).targetLimit as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(UConverterFromUnicodeArgs),
      "::",
      stringify!(targetLimit)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<UConverterFromUnicodeArgs>())).offsets as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(UConverterFromUnicodeArgs),
      "::",
      stringify!(offsets)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UConverterToUnicodeArgs {
  pub size: u16,
  pub flush: UBool,
  pub converter: *mut UConverter,
  pub source: *const ::std::os::raw::c_char,
  pub sourceLimit: *const ::std::os::raw::c_char,
  pub target: *mut UChar,
  pub targetLimit: *const UChar,
  pub offsets: *mut i32,
}
#[test]
fn bindgen_test_layout_UConverterToUnicodeArgs() {
  assert_eq!(
    ::std::mem::size_of::<UConverterToUnicodeArgs>(),
    56usize,
    concat!("Size of: ", stringify!(UConverterToUnicodeArgs))
  );
  assert_eq!(
    ::std::mem::align_of::<UConverterToUnicodeArgs>(),
    8usize,
    concat!("Alignment of ", stringify!(UConverterToUnicodeArgs))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<UConverterToUnicodeArgs>())).size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(UConverterToUnicodeArgs),
      "::",
      stringify!(size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<UConverterToUnicodeArgs>())).flush as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(UConverterToUnicodeArgs),
      "::",
      stringify!(flush)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<UConverterToUnicodeArgs>())).converter as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(UConverterToUnicodeArgs),
      "::",
      stringify!(converter)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<UConverterToUnicodeArgs>())).source as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(UConverterToUnicodeArgs),
      "::",
      stringify!(source)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<UConverterToUnicodeArgs>())).sourceLimit as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(UConverterToUnicodeArgs),
      "::",
      stringify!(sourceLimit)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<UConverterToUnicodeArgs>())).target as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(UConverterToUnicodeArgs),
      "::",
      stringify!(target)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<UConverterToUnicodeArgs>())).targetLimit as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(UConverterToUnicodeArgs),
      "::",
      stringify!(targetLimit)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<UConverterToUnicodeArgs>())).offsets as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(UConverterToUnicodeArgs),
      "::",
      stringify!(offsets)
    )
  );
}
extern "C" {
  pub fn UCNV_FROM_U_CALLBACK_STOP_60(
    context: *const ::std::os::raw::c_void,
    fromUArgs: *mut UConverterFromUnicodeArgs,
    codeUnits: *const UChar,
    length: i32,
    codePoint: UChar32,
    reason: UConverterCallbackReason,
    err: *mut UErrorCode,
  );
}
extern "C" {
  pub fn UCNV_TO_U_CALLBACK_STOP_60(
    context: *const ::std::os::raw::c_void,
    toUArgs: *mut UConverterToUnicodeArgs,
    codeUnits: *const ::std::os::raw::c_char,
    length: i32,
    reason: UConverterCallbackReason,
    err: *mut UErrorCode,
  );
}
extern "C" {
  pub fn UCNV_FROM_U_CALLBACK_SKIP_60(
    context: *const ::std::os::raw::c_void,
    fromUArgs: *mut UConverterFromUnicodeArgs,
    codeUnits: *const UChar,
    length: i32,
    codePoint: UChar32,
    reason: UConverterCallbackReason,
    err: *mut UErrorCode,
  );
}
extern "C" {
  pub fn UCNV_FROM_U_CALLBACK_SUBSTITUTE_60(
    context: *const ::std::os::raw::c_void,
    fromUArgs: *mut UConverterFromUnicodeArgs,
    codeUnits: *const UChar,
    length: i32,
    codePoint: UChar32,
    reason: UConverterCallbackReason,
    err: *mut UErrorCode,
  );
}
extern "C" {
  pub fn UCNV_FROM_U_CALLBACK_ESCAPE_60(
    context: *const ::std::os::raw::c_void,
    fromUArgs: *mut UConverterFromUnicodeArgs,
    codeUnits: *const UChar,
    length: i32,
    codePoint: UChar32,
    reason: UConverterCallbackReason,
    err: *mut UErrorCode,
  );
}
extern "C" {
  pub fn UCNV_TO_U_CALLBACK_SKIP_60(
    context: *const ::std::os::raw::c_void,
    toUArgs: *mut UConverterToUnicodeArgs,
    codeUnits: *const ::std::os::raw::c_char,
    length: i32,
    reason: UConverterCallbackReason,
    err: *mut UErrorCode,
  );
}
extern "C" {
  pub fn UCNV_TO_U_CALLBACK_SUBSTITUTE_60(
    context: *const ::std::os::raw::c_void,
    toUArgs: *mut UConverterToUnicodeArgs,
    codeUnits: *const ::std::os::raw::c_char,
    length: i32,
    reason: UConverterCallbackReason,
    err: *mut UErrorCode,
  );
}
extern "C" {
  pub fn UCNV_TO_U_CALLBACK_ESCAPE_60(
    context: *const ::std::os::raw::c_void,
    toUArgs: *mut UConverterToUnicodeArgs,
    codeUnits: *const ::std::os::raw::c_char,
    length: i32,
    reason: UConverterCallbackReason,
    err: *mut UErrorCode,
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UEnumeration {
  _unused: [u8; 0],
}
extern "C" {
  pub fn uenum_close_60(en: *mut UEnumeration);
}
extern "C" {
  pub fn uenum_count_60(en: *mut UEnumeration, status: *mut UErrorCode) -> i32;
}
extern "C" {
  pub fn uenum_unext_60(
    en: *mut UEnumeration,
    resultLength: *mut i32,
    status: *mut UErrorCode,
  ) -> *const UChar;
}
extern "C" {
  pub fn uenum_next_60(
    en: *mut UEnumeration,
    resultLength: *mut i32,
    status: *mut UErrorCode,
  ) -> *const ::std::os::raw::c_char;
}
extern "C" {
  pub fn uenum_reset_60(en: *mut UEnumeration, status: *mut UErrorCode);
}
extern "C" {
  pub fn uenum_openUCharStringsEnumeration_60(
    strings: *const *const UChar,
    count: i32,
    ec: *mut UErrorCode,
  ) -> *mut UEnumeration;
}
extern "C" {
  pub fn uenum_openCharStringsEnumeration_60(
    strings: *const *const ::std::os::raw::c_char,
    count: i32,
    ec: *mut UErrorCode,
  ) -> *mut UEnumeration;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USet {
  _unused: [u8; 0],
}
pub const UConverterType_UCNV_UNSUPPORTED_CONVERTER: UConverterType = -1;
pub const UConverterType_UCNV_SBCS: UConverterType = 0;
pub const UConverterType_UCNV_DBCS: UConverterType = 1;
pub const UConverterType_UCNV_MBCS: UConverterType = 2;
pub const UConverterType_UCNV_LATIN_1: UConverterType = 3;
pub const UConverterType_UCNV_UTF8: UConverterType = 4;
pub const UConverterType_UCNV_UTF16_BigEndian: UConverterType = 5;
pub const UConverterType_UCNV_UTF16_LittleEndian: UConverterType = 6;
pub const UConverterType_UCNV_UTF32_BigEndian: UConverterType = 7;
pub const UConverterType_UCNV_UTF32_LittleEndian: UConverterType = 8;
pub const UConverterType_UCNV_EBCDIC_STATEFUL: UConverterType = 9;
pub const UConverterType_UCNV_ISO_2022: UConverterType = 10;
pub const UConverterType_UCNV_LMBCS_1: UConverterType = 11;
pub const UConverterType_UCNV_LMBCS_2: UConverterType = 12;
pub const UConverterType_UCNV_LMBCS_3: UConverterType = 13;
pub const UConverterType_UCNV_LMBCS_4: UConverterType = 14;
pub const UConverterType_UCNV_LMBCS_5: UConverterType = 15;
pub const UConverterType_UCNV_LMBCS_6: UConverterType = 16;
pub const UConverterType_UCNV_LMBCS_8: UConverterType = 17;
pub const UConverterType_UCNV_LMBCS_11: UConverterType = 18;
pub const UConverterType_UCNV_LMBCS_16: UConverterType = 19;
pub const UConverterType_UCNV_LMBCS_17: UConverterType = 20;
pub const UConverterType_UCNV_LMBCS_18: UConverterType = 21;
pub const UConverterType_UCNV_LMBCS_19: UConverterType = 22;
pub const UConverterType_UCNV_LMBCS_LAST: UConverterType = 22;
pub const UConverterType_UCNV_HZ: UConverterType = 23;
pub const UConverterType_UCNV_SCSU: UConverterType = 24;
pub const UConverterType_UCNV_ISCII: UConverterType = 25;
pub const UConverterType_UCNV_US_ASCII: UConverterType = 26;
pub const UConverterType_UCNV_UTF7: UConverterType = 27;
pub const UConverterType_UCNV_BOCU1: UConverterType = 28;
pub const UConverterType_UCNV_UTF16: UConverterType = 29;
pub const UConverterType_UCNV_UTF32: UConverterType = 30;
pub const UConverterType_UCNV_CESU8: UConverterType = 31;
pub const UConverterType_UCNV_IMAP_MAILBOX: UConverterType = 32;
pub const UConverterType_UCNV_COMPOUND_TEXT: UConverterType = 33;
pub const UConverterType_UCNV_NUMBER_OF_SUPPORTED_CONVERTER_TYPES: UConverterType = 34;
pub type UConverterType = i32;
pub const UConverterPlatform_UCNV_UNKNOWN: UConverterPlatform = -1;
pub const UConverterPlatform_UCNV_IBM: UConverterPlatform = 0;
pub type UConverterPlatform = i32;
pub type UConverterToUCallback = ::std::option::Option<
  unsafe extern "C" fn(
    context: *const ::std::os::raw::c_void,
    args: *mut UConverterToUnicodeArgs,
    codeUnits: *const ::std::os::raw::c_char,
    length: i32,
    reason: UConverterCallbackReason,
    pErrorCode: *mut UErrorCode,
  ),
>;
pub type UConverterFromUCallback = ::std::option::Option<
  unsafe extern "C" fn(
    context: *const ::std::os::raw::c_void,
    args: *mut UConverterFromUnicodeArgs,
    codeUnits: *const UChar,
    length: i32,
    codePoint: UChar32,
    reason: UConverterCallbackReason,
    pErrorCode: *mut UErrorCode,
  ),
>;
extern "C" {
  pub fn ucnv_compareNames_60(
    name1: *const ::std::os::raw::c_char,
    name2: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn ucnv_open_60(
    converterName: *const ::std::os::raw::c_char,
    err: *mut UErrorCode,
  ) -> *mut UConverter;
}
extern "C" {
  pub fn ucnv_openU_60(name: *const UChar, err: *mut UErrorCode) -> *mut UConverter;
}
extern "C" {
  pub fn ucnv_openCCSID_60(
    codepage: i32,
    platform: UConverterPlatform,
    err: *mut UErrorCode,
  ) -> *mut UConverter;
}
extern "C" {
  pub fn ucnv_openPackage_60(
    packageName: *const ::std::os::raw::c_char,
    converterName: *const ::std::os::raw::c_char,
    err: *mut UErrorCode,
  ) -> *mut UConverter;
}
extern "C" {
  pub fn ucnv_safeClone_60(
    cnv: *const UConverter,
    stackBuffer: *mut ::std::os::raw::c_void,
    pBufferSize: *mut i32,
    status: *mut UErrorCode,
  ) -> *mut UConverter;
}
extern "C" {
  pub fn ucnv_close_60(converter: *mut UConverter);
}
extern "C" {
  pub fn ucnv_getSubstChars_60(
    converter: *const UConverter,
    subChars: *mut ::std::os::raw::c_char,
    len: *mut i8,
    err: *mut UErrorCode,
  );
}
extern "C" {
  pub fn ucnv_setSubstChars_60(
    converter: *mut UConverter,
    subChars: *const ::std::os::raw::c_char,
    len: i8,
    err: *mut UErrorCode,
  );
}
extern "C" {
  pub fn ucnv_setSubstString_60(
    cnv: *mut UConverter,
    s: *const UChar,
    length: i32,
    err: *mut UErrorCode,
  );
}
extern "C" {
  pub fn ucnv_getInvalidChars_60(
    converter: *const UConverter,
    errBytes: *mut ::std::os::raw::c_char,
    len: *mut i8,
    err: *mut UErrorCode,
  );
}
extern "C" {
  pub fn ucnv_getInvalidUChars_60(
    converter: *const UConverter,
    errUChars: *mut UChar,
    len: *mut i8,
    err: *mut UErrorCode,
  );
}
extern "C" {
  pub fn ucnv_reset_60(converter: *mut UConverter);
}
extern "C" {
  pub fn ucnv_resetToUnicode_60(converter: *mut UConverter);
}
extern "C" {
  pub fn ucnv_resetFromUnicode_60(converter: *mut UConverter);
}
extern "C" {
  pub fn ucnv_getMaxCharSize_60(converter: *const UConverter) -> i8;
}
extern "C" {
  pub fn ucnv_getMinCharSize_60(converter: *const UConverter) -> i8;
}
extern "C" {
  pub fn ucnv_getDisplayName_60(
    converter: *const UConverter,
    displayLocale: *const ::std::os::raw::c_char,
    displayName: *mut UChar,
    displayNameCapacity: i32,
    err: *mut UErrorCode,
  ) -> i32;
}
extern "C" {
  pub fn ucnv_getName_60(
    converter: *const UConverter,
    err: *mut UErrorCode,
  ) -> *const ::std::os::raw::c_char;
}
extern "C" {
  pub fn ucnv_getCCSID_60(converter: *const UConverter, err: *mut UErrorCode) -> i32;
}
extern "C" {
  pub fn ucnv_getPlatform_60(
    converter: *const UConverter,
    err: *mut UErrorCode,
  ) -> UConverterPlatform;
}
extern "C" {
  pub fn ucnv_getType_60(converter: *const UConverter) -> UConverterType;
}
extern "C" {
  pub fn ucnv_getStarters_60(
    converter: *const UConverter,
    starters: *mut UBool,
    err: *mut UErrorCode,
  );
}
pub const UConverterUnicodeSet_UCNV_ROUNDTRIP_SET: UConverterUnicodeSet = 0;
pub const UConverterUnicodeSet_UCNV_ROUNDTRIP_AND_FALLBACK_SET: UConverterUnicodeSet = 1;
pub const UConverterUnicodeSet_UCNV_SET_COUNT: UConverterUnicodeSet = 2;
pub type UConverterUnicodeSet = u32;
extern "C" {
  pub fn ucnv_getUnicodeSet_60(
    cnv: *const UConverter,
    setFillIn: *mut USet,
    whichSet: UConverterUnicodeSet,
    pErrorCode: *mut UErrorCode,
  );
}
extern "C" {
  pub fn ucnv_getToUCallBack_60(
    converter: *const UConverter,
    action: *mut UConverterToUCallback,
    context: *mut *const ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn ucnv_getFromUCallBack_60(
    converter: *const UConverter,
    action: *mut UConverterFromUCallback,
    context: *mut *const ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn ucnv_setToUCallBack_60(
    converter: *mut UConverter,
    newAction: UConverterToUCallback,
    newContext: *const ::std::os::raw::c_void,
    oldAction: *mut UConverterToUCallback,
    oldContext: *mut *const ::std::os::raw::c_void,
    err: *mut UErrorCode,
  );
}
extern "C" {
  pub fn ucnv_setFromUCallBack_60(
    converter: *mut UConverter,
    newAction: UConverterFromUCallback,
    newContext: *const ::std::os::raw::c_void,
    oldAction: *mut UConverterFromUCallback,
    oldContext: *mut *const ::std::os::raw::c_void,
    err: *mut UErrorCode,
  );
}
extern "C" {
  pub fn ucnv_fromUnicode_60(
    converter: *mut UConverter,
    target: *mut *mut ::std::os::raw::c_char,
    targetLimit: *const ::std::os::raw::c_char,
    source: *mut *const UChar,
    sourceLimit: *const UChar,
    offsets: *mut i32,
    flush: UBool,
    err: *mut UErrorCode,
  );
}
extern "C" {
  pub fn ucnv_toUnicode_60(
    converter: *mut UConverter,
    target: *mut *mut UChar,
    targetLimit: *const UChar,
    source: *mut *const ::std::os::raw::c_char,
    sourceLimit: *const ::std::os::raw::c_char,
    offsets: *mut i32,
    flush: UBool,
    err: *mut UErrorCode,
  );
}
extern "C" {
  pub fn ucnv_fromUChars_60(
    cnv: *mut UConverter,
    dest: *mut ::std::os::raw::c_char,
    destCapacity: i32,
    src: *const UChar,
    srcLength: i32,
    pErrorCode: *mut UErrorCode,
  ) -> i32;
}
extern "C" {
  pub fn ucnv_toUChars_60(
    cnv: *mut UConverter,
    dest: *mut UChar,
    destCapacity: i32,
    src: *const ::std::os::raw::c_char,
    srcLength: i32,
    pErrorCode: *mut UErrorCode,
  ) -> i32;
}
extern "C" {
  pub fn ucnv_getNextUChar_60(
    converter: *mut UConverter,
    source: *mut *const ::std::os::raw::c_char,
    sourceLimit: *const ::std::os::raw::c_char,
    err: *mut UErrorCode,
  ) -> UChar32;
}
extern "C" {
  pub fn ucnv_convertEx_60(
    targetCnv: *mut UConverter,
    sourceCnv: *mut UConverter,
    target: *mut *mut ::std::os::raw::c_char,
    targetLimit: *const ::std::os::raw::c_char,
    source: *mut *const ::std::os::raw::c_char,
    sourceLimit: *const ::std::os::raw::c_char,
    pivotStart: *mut UChar,
    pivotSource: *mut *mut UChar,
    pivotTarget: *mut *mut UChar,
    pivotLimit: *const UChar,
    reset: UBool,
    flush: UBool,
    pErrorCode: *mut UErrorCode,
  );
}
extern "C" {
  pub fn ucnv_convert_60(
    toConverterName: *const ::std::os::raw::c_char,
    fromConverterName: *const ::std::os::raw::c_char,
    target: *mut ::std::os::raw::c_char,
    targetCapacity: i32,
    source: *const ::std::os::raw::c_char,
    sourceLength: i32,
    pErrorCode: *mut UErrorCode,
  ) -> i32;
}
extern "C" {
  pub fn ucnv_toAlgorithmic_60(
    algorithmicType: UConverterType,
    cnv: *mut UConverter,
    target: *mut ::std::os::raw::c_char,
    targetCapacity: i32,
    source: *const ::std::os::raw::c_char,
    sourceLength: i32,
    pErrorCode: *mut UErrorCode,
  ) -> i32;
}
extern "C" {
  pub fn ucnv_fromAlgorithmic_60(
    cnv: *mut UConverter,
    algorithmicType: UConverterType,
    target: *mut ::std::os::raw::c_char,
    targetCapacity: i32,
    source: *const ::std::os::raw::c_char,
    sourceLength: i32,
    pErrorCode: *mut UErrorCode,
  ) -> i32;
}
extern "C" {
  pub fn ucnv_flushCache_60() -> i32;
}
extern "C" {
  pub fn ucnv_countAvailable_60() -> i32;
}
extern "C" {
  pub fn ucnv_getAvailableName_60(n: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
  pub fn ucnv_openAllNames_60(pErrorCode: *mut UErrorCode) -> *mut UEnumeration;
}
extern "C" {
  pub fn ucnv_countAliases_60(
    alias: *const ::std::os::raw::c_char,
    pErrorCode: *mut UErrorCode,
  ) -> u16;
}
extern "C" {
  pub fn ucnv_getAlias_60(
    alias: *const ::std::os::raw::c_char,
    n: u16,
    pErrorCode: *mut UErrorCode,
  ) -> *const ::std::os::raw::c_char;
}
extern "C" {
  pub fn ucnv_getAliases_60(
    alias: *const ::std::os::raw::c_char,
    aliases: *mut *const ::std::os::raw::c_char,
    pErrorCode: *mut UErrorCode,
  );
}
extern "C" {
  pub fn ucnv_openStandardNames_60(
    convName: *const ::std::os::raw::c_char,
    standard: *const ::std::os::raw::c_char,
    pErrorCode: *mut UErrorCode,
  ) -> *mut UEnumeration;
}
extern "C" {
  pub fn ucnv_countStandards_60() -> u16;
}
extern "C" {
  pub fn ucnv_getStandard_60(n: u16, pErrorCode: *mut UErrorCode) -> *const ::std::os::raw::c_char;
}
extern "C" {
  pub fn ucnv_getStandardName_60(
    name: *const ::std::os::raw::c_char,
    standard: *const ::std::os::raw::c_char,
    pErrorCode: *mut UErrorCode,
  ) -> *const ::std::os::raw::c_char;
}
extern "C" {
  pub fn ucnv_getCanonicalName_60(
    alias: *const ::std::os::raw::c_char,
    standard: *const ::std::os::raw::c_char,
    pErrorCode: *mut UErrorCode,
  ) -> *const ::std::os::raw::c_char;
}
extern "C" {
  pub fn ucnv_getDefaultName_60() -> *const ::std::os::raw::c_char;
}
extern "C" {
  pub fn ucnv_setDefaultName_60(name: *const ::std::os::raw::c_char);
}
extern "C" {
  pub fn ucnv_fixFileSeparator_60(cnv: *const UConverter, source: *mut UChar, sourceLen: i32);
}
extern "C" {
  pub fn ucnv_isAmbiguous_60(cnv: *const UConverter) -> UBool;
}
extern "C" {
  pub fn ucnv_setFallback_60(cnv: *mut UConverter, usesFallback: UBool);
}
extern "C" {
  pub fn ucnv_usesFallback_60(cnv: *const UConverter) -> UBool;
}
extern "C" {
  pub fn ucnv_detectUnicodeSignature_60(
    source: *const ::std::os::raw::c_char,
    sourceLength: i32,
    signatureLength: *mut i32,
    pErrorCode: *mut UErrorCode,
  ) -> *const ::std::os::raw::c_char;
}
extern "C" {
  pub fn ucnv_fromUCountPending_60(cnv: *const UConverter, status: *mut UErrorCode) -> i32;
}
extern "C" {
  pub fn ucnv_toUCountPending_60(cnv: *const UConverter, status: *mut UErrorCode) -> i32;
}
extern "C" {
  pub fn ucnv_isFixedWidth_60(cnv: *mut UConverter, status: *mut UErrorCode) -> UBool;
}
pub const xmlCharEncoding_XML_CHAR_ENCODING_ERROR: xmlCharEncoding = -1;
pub const xmlCharEncoding_XML_CHAR_ENCODING_NONE: xmlCharEncoding = 0;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UTF8: xmlCharEncoding = 1;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UTF16LE: xmlCharEncoding = 2;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UTF16BE: xmlCharEncoding = 3;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UCS4LE: xmlCharEncoding = 4;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UCS4BE: xmlCharEncoding = 5;
pub const xmlCharEncoding_XML_CHAR_ENCODING_EBCDIC: xmlCharEncoding = 6;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UCS4_2143: xmlCharEncoding = 7;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UCS4_3412: xmlCharEncoding = 8;
pub const xmlCharEncoding_XML_CHAR_ENCODING_UCS2: xmlCharEncoding = 9;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_1: xmlCharEncoding = 10;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_2: xmlCharEncoding = 11;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_3: xmlCharEncoding = 12;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_4: xmlCharEncoding = 13;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_5: xmlCharEncoding = 14;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_6: xmlCharEncoding = 15;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_7: xmlCharEncoding = 16;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_8: xmlCharEncoding = 17;
pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_9: xmlCharEncoding = 18;
pub const xmlCharEncoding_XML_CHAR_ENCODING_2022_JP: xmlCharEncoding = 19;
pub const xmlCharEncoding_XML_CHAR_ENCODING_SHIFT_JIS: xmlCharEncoding = 20;
pub const xmlCharEncoding_XML_CHAR_ENCODING_EUC_JP: xmlCharEncoding = 21;
pub const xmlCharEncoding_XML_CHAR_ENCODING_ASCII: xmlCharEncoding = 22;
pub type xmlCharEncoding = i32;
/// xmlCharEncodingInputFunc:
/// @out:  a pointer to an array of bytes to store the UTF-8 result
/// @outlen:  the length of @out
/// @in:  a pointer to an array of chars in the original encoding
/// @inlen:  the length of @in
///
/// Take a block of chars in the original encoding and try to convert
/// it to an UTF-8 block of chars out.
///
/// Returns the number of bytes written, -1 if lack of space, or -2
/// if the transcoding failed.
/// The value of @inlen after return is the number of octets consumed
/// if the return value is positive, else unpredictiable.
/// The value of @outlen after return is the number of octets consumed.
pub type xmlCharEncodingInputFunc = ::std::option::Option<
  unsafe extern "C" fn(
    out: *mut ::std::os::raw::c_uchar,
    outlen: *mut ::std::os::raw::c_int,
    in_: *const ::std::os::raw::c_uchar,
    inlen: *mut ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int,
>;
/// xmlCharEncodingOutputFunc:
/// @out:  a pointer to an array of bytes to store the result
/// @outlen:  the length of @out
/// @in:  a pointer to an array of UTF-8 chars
/// @inlen:  the length of @in
///
/// Take a block of UTF-8 chars in and try to convert it to another
/// encoding.
/// Note: a first call designed to produce heading info is called with
/// in = NULL. If stateful this should also initialize the encoder state.
///
/// Returns the number of bytes written, -1 if lack of space, or -2
/// if the transcoding failed.
/// The value of @inlen after return is the number of octets consumed
/// if the return value is positive, else unpredictiable.
/// The value of @outlen after return is the number of octets produced.
pub type xmlCharEncodingOutputFunc = ::std::option::Option<
  unsafe extern "C" fn(
    out: *mut ::std::os::raw::c_uchar,
    outlen: *mut ::std::os::raw::c_int,
    in_: *const ::std::os::raw::c_uchar,
    inlen: *mut ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _uconv_t {
  pub uconv: *mut UConverter,
  pub utf8: *mut UConverter,
}
#[test]
fn bindgen_test_layout__uconv_t() {
  assert_eq!(
    ::std::mem::size_of::<_uconv_t>(),
    16usize,
    concat!("Size of: ", stringify!(_uconv_t))
  );
  assert_eq!(
    ::std::mem::align_of::<_uconv_t>(),
    8usize,
    concat!("Alignment of ", stringify!(_uconv_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_uconv_t>())).uconv as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_uconv_t),
      "::",
      stringify!(uconv)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_uconv_t>())).utf8 as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_uconv_t),
      "::",
      stringify!(utf8)
    )
  );
}
pub type uconv_t = _uconv_t;
pub type xmlCharEncodingHandler = _xmlCharEncodingHandler;
pub type xmlCharEncodingHandlerPtr = *mut xmlCharEncodingHandler;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlCharEncodingHandler {
  pub name: *mut ::std::os::raw::c_char,
  pub input: xmlCharEncodingInputFunc,
  pub output: xmlCharEncodingOutputFunc,
  pub iconv_in: iconv_t,
  pub iconv_out: iconv_t,
  pub uconv_in: *mut uconv_t,
  pub uconv_out: *mut uconv_t,
}
#[test]
fn bindgen_test_layout__xmlCharEncodingHandler() {
  assert_eq!(
    ::std::mem::size_of::<_xmlCharEncodingHandler>(),
    56usize,
    concat!("Size of: ", stringify!(_xmlCharEncodingHandler))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlCharEncodingHandler>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlCharEncodingHandler))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlCharEncodingHandler>())).name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlCharEncodingHandler),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlCharEncodingHandler>())).input as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlCharEncodingHandler),
      "::",
      stringify!(input)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlCharEncodingHandler>())).output as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlCharEncodingHandler),
      "::",
      stringify!(output)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlCharEncodingHandler>())).iconv_in as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlCharEncodingHandler),
      "::",
      stringify!(iconv_in)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlCharEncodingHandler>())).iconv_out as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlCharEncodingHandler),
      "::",
      stringify!(iconv_out)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlCharEncodingHandler>())).uconv_in as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlCharEncodingHandler),
      "::",
      stringify!(uconv_in)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlCharEncodingHandler>())).uconv_out as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlCharEncodingHandler),
      "::",
      stringify!(uconv_out)
    )
  );
}
extern "C" {
  pub fn xmlInitCharEncodingHandlers();
}
extern "C" {
  pub fn xmlCleanupCharEncodingHandlers();
}
extern "C" {
  pub fn xmlRegisterCharEncodingHandler(handler: xmlCharEncodingHandlerPtr);
}
extern "C" {
  pub fn xmlGetCharEncodingHandler(enc: xmlCharEncoding) -> xmlCharEncodingHandlerPtr;
}
extern "C" {
  pub fn xmlFindCharEncodingHandler(
    name: *const ::std::os::raw::c_char,
  ) -> xmlCharEncodingHandlerPtr;
}
extern "C" {
  pub fn xmlNewCharEncodingHandler(
    name: *const ::std::os::raw::c_char,
    input: xmlCharEncodingInputFunc,
    output: xmlCharEncodingOutputFunc,
  ) -> xmlCharEncodingHandlerPtr;
}
extern "C" {
  pub fn xmlAddEncodingAlias(
    name: *const ::std::os::raw::c_char,
    alias: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlDelEncodingAlias(alias: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlGetEncodingAlias(alias: *const ::std::os::raw::c_char)
    -> *const ::std::os::raw::c_char;
}
extern "C" {
  pub fn xmlCleanupEncodingAliases();
}
extern "C" {
  pub fn xmlParseCharEncoding(name: *const ::std::os::raw::c_char) -> xmlCharEncoding;
}
extern "C" {
  pub fn xmlGetCharEncodingName(enc: xmlCharEncoding) -> *const ::std::os::raw::c_char;
}
extern "C" {
  pub fn xmlDetectCharEncoding(
    in_: *const ::std::os::raw::c_uchar,
    len: ::std::os::raw::c_int,
  ) -> xmlCharEncoding;
}
extern "C" {
  pub fn xmlCharEncOutFunc(
    handler: *mut xmlCharEncodingHandler,
    out: xmlBufferPtr,
    in_: xmlBufferPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlCharEncInFunc(
    handler: *mut xmlCharEncodingHandler,
    out: xmlBufferPtr,
    in_: xmlBufferPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlCharEncFirstLine(
    handler: *mut xmlCharEncodingHandler,
    out: xmlBufferPtr,
    in_: xmlBufferPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlCharEncCloseFunc(handler: *mut xmlCharEncodingHandler) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn UTF8Toisolat1(
    out: *mut ::std::os::raw::c_uchar,
    outlen: *mut ::std::os::raw::c_int,
    in_: *const ::std::os::raw::c_uchar,
    inlen: *mut ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn isolat1ToUTF8(
    out: *mut ::std::os::raw::c_uchar,
    outlen: *mut ::std::os::raw::c_int,
    in_: *const ::std::os::raw::c_uchar,
    inlen: *mut ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
/// xmlInputMatchCallback:
/// @filename: the filename or URI
///
/// Callback used in the I/O Input API to detect if the current handler
/// can provide input fonctionnalities for this resource.
///
/// Returns 1 if yes and 0 if another Input module should be used
pub type xmlInputMatchCallback = ::std::option::Option<
  unsafe extern "C" fn(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
>;
/// xmlInputOpenCallback:
/// @filename: the filename or URI
///
/// Callback used in the I/O Input API to open the resource
///
/// Returns an Input context or NULL in case or error
pub type xmlInputOpenCallback = ::std::option::Option<
  unsafe extern "C" fn(filename: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void,
>;
/// xmlInputReadCallback:
/// @context:  an Input context
/// @buffer:  the buffer to store data read
/// @len:  the length of the buffer in bytes
///
/// Callback used in the I/O Input API to read the resource
///
/// Returns the number of bytes read or -1 in case of error
pub type xmlInputReadCallback = ::std::option::Option<
  unsafe extern "C" fn(
    context: *mut ::std::os::raw::c_void,
    buffer: *mut ::std::os::raw::c_char,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int,
>;
/// xmlInputCloseCallback:
/// @context:  an Input context
///
/// Callback used in the I/O Input API to close the resource
///
/// Returns 0 or -1 in case of error
pub type xmlInputCloseCallback = ::std::option::Option<
  unsafe extern "C" fn(context: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
/// xmlOutputMatchCallback:
/// @filename: the filename or URI
///
/// Callback used in the I/O Output API to detect if the current handler
/// can provide output fonctionnalities for this resource.
///
/// Returns 1 if yes and 0 if another Output module should be used
pub type xmlOutputMatchCallback = ::std::option::Option<
  unsafe extern "C" fn(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
>;
/// xmlOutputOpenCallback:
/// @filename: the filename or URI
///
/// Callback used in the I/O Output API to open the resource
///
/// Returns an Output context or NULL in case or error
pub type xmlOutputOpenCallback = ::std::option::Option<
  unsafe extern "C" fn(filename: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void,
>;
/// xmlOutputWriteCallback:
/// @context:  an Output context
/// @buffer:  the buffer of data to write
/// @len:  the length of the buffer in bytes
///
/// Callback used in the I/O Output API to write to the resource
///
/// Returns the number of bytes written or -1 in case of error
pub type xmlOutputWriteCallback = ::std::option::Option<
  unsafe extern "C" fn(
    context: *mut ::std::os::raw::c_void,
    buffer: *const ::std::os::raw::c_char,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int,
>;
/// xmlOutputCloseCallback:
/// @context:  an Output context
///
/// Callback used in the I/O Output API to close the resource
///
/// Returns 0 or -1 in case of error
pub type xmlOutputCloseCallback = ::std::option::Option<
  unsafe extern "C" fn(context: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = u32;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = f64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
  pub quot: ::std::os::raw::c_int,
  pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
  assert_eq!(
    ::std::mem::size_of::<div_t>(),
    8usize,
    concat!("Size of: ", stringify!(div_t))
  );
  assert_eq!(
    ::std::mem::align_of::<div_t>(),
    4usize,
    concat!("Alignment of ", stringify!(div_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(div_t),
      "::",
      stringify!(quot)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(div_t),
      "::",
      stringify!(rem)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
  pub quot: ::std::os::raw::c_long,
  pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
  assert_eq!(
    ::std::mem::size_of::<ldiv_t>(),
    16usize,
    concat!("Size of: ", stringify!(ldiv_t))
  );
  assert_eq!(
    ::std::mem::align_of::<ldiv_t>(),
    8usize,
    concat!("Alignment of ", stringify!(ldiv_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(ldiv_t),
      "::",
      stringify!(quot)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(ldiv_t),
      "::",
      stringify!(rem)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
  pub quot: ::std::os::raw::c_longlong,
  pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
  assert_eq!(
    ::std::mem::size_of::<lldiv_t>(),
    16usize,
    concat!("Size of: ", stringify!(lldiv_t))
  );
  assert_eq!(
    ::std::mem::align_of::<lldiv_t>(),
    8usize,
    concat!("Alignment of ", stringify!(lldiv_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(lldiv_t),
      "::",
      stringify!(quot)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(lldiv_t),
      "::",
      stringify!(rem)
    )
  );
}
extern "C" {
  pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
  pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
  pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn strtod(
    __nptr: *const ::std::os::raw::c_char,
    __endptr: *mut *mut ::std::os::raw::c_char,
  ) -> f64;
}
extern "C" {
  pub fn strtof(
    __nptr: *const ::std::os::raw::c_char,
    __endptr: *mut *mut ::std::os::raw::c_char,
  ) -> f32;
}
extern "C" {
  pub fn strtold(
    __nptr: *const ::std::os::raw::c_char,
    __endptr: *mut *mut ::std::os::raw::c_char,
  ) -> f64;
}
extern "C" {
  pub fn strtol(
    __nptr: *const ::std::os::raw::c_char,
    __endptr: *mut *mut ::std::os::raw::c_char,
    __base: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn strtoul(
    __nptr: *const ::std::os::raw::c_char,
    __endptr: *mut *mut ::std::os::raw::c_char,
    __base: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn strtoq(
    __nptr: *const ::std::os::raw::c_char,
    __endptr: *mut *mut ::std::os::raw::c_char,
    __base: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn strtouq(
    __nptr: *const ::std::os::raw::c_char,
    __endptr: *mut *mut ::std::os::raw::c_char,
    __base: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
  pub fn strtoll(
    __nptr: *const ::std::os::raw::c_char,
    __endptr: *mut *mut ::std::os::raw::c_char,
    __base: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn strtoull(
    __nptr: *const ::std::os::raw::c_char,
    __endptr: *mut *mut ::std::os::raw::c_char,
    __base: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
  pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
  pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
  assert_eq!(
    ::std::mem::size_of::<__sigset_t>(),
    128usize,
    concat!("Size of: ", stringify!(__sigset_t))
  );
  assert_eq!(
    ::std::mem::align_of::<__sigset_t>(),
    8usize,
    concat!("Alignment of ", stringify!(__sigset_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__sigset_t),
      "::",
      stringify!(__val)
    )
  );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
  pub tv_sec: __time_t,
  pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
  assert_eq!(
    ::std::mem::size_of::<timeval>(),
    16usize,
    concat!("Size of: ", stringify!(timeval))
  );
  assert_eq!(
    ::std::mem::align_of::<timeval>(),
    8usize,
    concat!("Alignment of ", stringify!(timeval))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(timeval),
      "::",
      stringify!(tv_sec)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(timeval),
      "::",
      stringify!(tv_usec)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
  pub tv_sec: __time_t,
  pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
  assert_eq!(
    ::std::mem::size_of::<timespec>(),
    16usize,
    concat!("Size of: ", stringify!(timespec))
  );
  assert_eq!(
    ::std::mem::align_of::<timespec>(),
    8usize,
    concat!("Alignment of ", stringify!(timespec))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(timespec),
      "::",
      stringify!(tv_sec)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(timespec),
      "::",
      stringify!(tv_nsec)
    )
  );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
  pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
  assert_eq!(
    ::std::mem::size_of::<fd_set>(),
    128usize,
    concat!("Size of: ", stringify!(fd_set))
  );
  assert_eq!(
    ::std::mem::align_of::<fd_set>(),
    8usize,
    concat!("Alignment of ", stringify!(fd_set))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(fd_set),
      "::",
      stringify!(__fds_bits)
    )
  );
}
pub type fd_mask = __fd_mask;
extern "C" {
  pub fn select(
    __nfds: ::std::os::raw::c_int,
    __readfds: *mut fd_set,
    __writefds: *mut fd_set,
    __exceptfds: *mut fd_set,
    __timeout: *mut timeval,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn pselect(
    __nfds: ::std::os::raw::c_int,
    __readfds: *mut fd_set,
    __writefds: *mut fd_set,
    __exceptfds: *mut fd_set,
    __timeout: *const timespec,
    __sigmask: *const __sigset_t,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn gnu_dev_major(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
  pub fn gnu_dev_minor(__dev: __dev_t) -> ::std::os::raw::c_uint;
}
extern "C" {
  pub fn gnu_dev_makedev(
    __major: ::std::os::raw::c_uint,
    __minor: ::std::os::raw::c_uint,
  ) -> __dev_t;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
  pub __readers: ::std::os::raw::c_uint,
  pub __writers: ::std::os::raw::c_uint,
  pub __wrphase_futex: ::std::os::raw::c_uint,
  pub __writers_futex: ::std::os::raw::c_uint,
  pub __pad3: ::std::os::raw::c_uint,
  pub __pad4: ::std::os::raw::c_uint,
  pub __cur_writer: ::std::os::raw::c_int,
  pub __shared: ::std::os::raw::c_int,
  pub __rwelision: ::std::os::raw::c_schar,
  pub __pad1: [::std::os::raw::c_uchar; 7usize],
  pub __pad2: ::std::os::raw::c_ulong,
  pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
  assert_eq!(
    ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
    56usize,
    concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
  );
  assert_eq!(
    ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
    8usize,
    concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_rwlock_arch_t),
      "::",
      stringify!(__readers)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_rwlock_arch_t),
      "::",
      stringify!(__writers)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_rwlock_arch_t),
      "::",
      stringify!(__wrphase_futex)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
    },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_rwlock_arch_t),
      "::",
      stringify!(__writers_futex)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_rwlock_arch_t),
      "::",
      stringify!(__pad3)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_rwlock_arch_t),
      "::",
      stringify!(__pad4)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
    },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_rwlock_arch_t),
      "::",
      stringify!(__cur_writer)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_rwlock_arch_t),
      "::",
      stringify!(__shared)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_rwlock_arch_t),
      "::",
      stringify!(__rwelision)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
    33usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_rwlock_arch_t),
      "::",
      stringify!(__pad1)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_rwlock_arch_t),
      "::",
      stringify!(__pad2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_rwlock_arch_t),
      "::",
      stringify!(__flags)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
  pub __prev: *mut __pthread_internal_list,
  pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
  assert_eq!(
    ::std::mem::size_of::<__pthread_internal_list>(),
    16usize,
    concat!("Size of: ", stringify!(__pthread_internal_list))
  );
  assert_eq!(
    ::std::mem::align_of::<__pthread_internal_list>(),
    8usize,
    concat!("Alignment of ", stringify!(__pthread_internal_list))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_internal_list),
      "::",
      stringify!(__prev)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_internal_list),
      "::",
      stringify!(__next)
    )
  );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
  pub __lock: ::std::os::raw::c_int,
  pub __count: ::std::os::raw::c_uint,
  pub __owner: ::std::os::raw::c_int,
  pub __nusers: ::std::os::raw::c_uint,
  pub __kind: ::std::os::raw::c_int,
  pub __spins: ::std::os::raw::c_short,
  pub __elision: ::std::os::raw::c_short,
  pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
  assert_eq!(
    ::std::mem::size_of::<__pthread_mutex_s>(),
    40usize,
    concat!("Size of: ", stringify!(__pthread_mutex_s))
  );
  assert_eq!(
    ::std::mem::align_of::<__pthread_mutex_s>(),
    8usize,
    concat!("Alignment of ", stringify!(__pthread_mutex_s))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_mutex_s),
      "::",
      stringify!(__lock)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_mutex_s),
      "::",
      stringify!(__count)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_mutex_s),
      "::",
      stringify!(__owner)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_mutex_s),
      "::",
      stringify!(__nusers)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_mutex_s),
      "::",
      stringify!(__kind)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_mutex_s),
      "::",
      stringify!(__spins)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
    22usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_mutex_s),
      "::",
      stringify!(__elision)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_mutex_s),
      "::",
      stringify!(__list)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
  pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
  pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
  pub __g_refs: [::std::os::raw::c_uint; 2usize],
  pub __g_size: [::std::os::raw::c_uint; 2usize],
  pub __g1_orig_size: ::std::os::raw::c_uint,
  pub __wrefs: ::std::os::raw::c_uint,
  pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
  pub __wseq: ::std::os::raw::c_ulonglong,
  pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
  _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
  pub __low: ::std::os::raw::c_uint,
  pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(__low)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
      "::",
      stringify!(__high)
    )
  );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
    8usize,
    concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
  );
  assert_eq!(
    ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
    8usize,
    concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_cond_s__bindgen_ty_1),
      "::",
      stringify!(__wseq)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_cond_s__bindgen_ty_1),
      "::",
      stringify!(__wseq32)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
  pub __g1_start: ::std::os::raw::c_ulonglong,
  pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
  _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
  pub __low: ::std::os::raw::c_uint,
  pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
  assert_eq!(
    ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
    8usize,
    concat!(
      "Size of: ",
      stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
    )
  );
  assert_eq!(
    ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
    4usize,
    concat!(
      "Alignment of ",
      stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low as *const _
        as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(__low)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high as *const _
        as usize
    },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
      "::",
      stringify!(__high)
    )
  );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
  assert_eq!(
    ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
    8usize,
    concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
  );
  assert_eq!(
    ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
    8usize,
    concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_cond_s__bindgen_ty_2),
      "::",
      stringify!(__g1_start)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_cond_s__bindgen_ty_2),
      "::",
      stringify!(__g1_start32)
    )
  );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
  assert_eq!(
    ::std::mem::size_of::<__pthread_cond_s>(),
    48usize,
    concat!("Size of: ", stringify!(__pthread_cond_s))
  );
  assert_eq!(
    ::std::mem::align_of::<__pthread_cond_s>(),
    8usize,
    concat!("Alignment of ", stringify!(__pthread_cond_s))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_cond_s),
      "::",
      stringify!(__g_refs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_cond_s),
      "::",
      stringify!(__g_size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_cond_s),
      "::",
      stringify!(__g1_orig_size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_cond_s),
      "::",
      stringify!(__wrefs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(__pthread_cond_s),
      "::",
      stringify!(__g_signals)
    )
  );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
  pub __size: [::std::os::raw::c_char; 4usize],
  pub __align: ::std::os::raw::c_int,
  _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
  assert_eq!(
    ::std::mem::size_of::<pthread_mutexattr_t>(),
    4usize,
    concat!("Size of: ", stringify!(pthread_mutexattr_t))
  );
  assert_eq!(
    ::std::mem::align_of::<pthread_mutexattr_t>(),
    4usize,
    concat!("Alignment of ", stringify!(pthread_mutexattr_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(pthread_mutexattr_t),
      "::",
      stringify!(__size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(pthread_mutexattr_t),
      "::",
      stringify!(__align)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
  pub __size: [::std::os::raw::c_char; 4usize],
  pub __align: ::std::os::raw::c_int,
  _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
  assert_eq!(
    ::std::mem::size_of::<pthread_condattr_t>(),
    4usize,
    concat!("Size of: ", stringify!(pthread_condattr_t))
  );
  assert_eq!(
    ::std::mem::align_of::<pthread_condattr_t>(),
    4usize,
    concat!("Alignment of ", stringify!(pthread_condattr_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(pthread_condattr_t),
      "::",
      stringify!(__size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(pthread_condattr_t),
      "::",
      stringify!(__align)
    )
  );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
  pub __size: [::std::os::raw::c_char; 56usize],
  pub __align: ::std::os::raw::c_long,
  _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
  assert_eq!(
    ::std::mem::size_of::<pthread_attr_t>(),
    56usize,
    concat!("Size of: ", stringify!(pthread_attr_t))
  );
  assert_eq!(
    ::std::mem::align_of::<pthread_attr_t>(),
    8usize,
    concat!("Alignment of ", stringify!(pthread_attr_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(pthread_attr_t),
      "::",
      stringify!(__size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(pthread_attr_t),
      "::",
      stringify!(__align)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
  pub __data: __pthread_mutex_s,
  pub __size: [::std::os::raw::c_char; 40usize],
  pub __align: ::std::os::raw::c_long,
  _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
  assert_eq!(
    ::std::mem::size_of::<pthread_mutex_t>(),
    40usize,
    concat!("Size of: ", stringify!(pthread_mutex_t))
  );
  assert_eq!(
    ::std::mem::align_of::<pthread_mutex_t>(),
    8usize,
    concat!("Alignment of ", stringify!(pthread_mutex_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(pthread_mutex_t),
      "::",
      stringify!(__data)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(pthread_mutex_t),
      "::",
      stringify!(__size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(pthread_mutex_t),
      "::",
      stringify!(__align)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
  pub __data: __pthread_cond_s,
  pub __size: [::std::os::raw::c_char; 48usize],
  pub __align: ::std::os::raw::c_longlong,
  _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
  assert_eq!(
    ::std::mem::size_of::<pthread_cond_t>(),
    48usize,
    concat!("Size of: ", stringify!(pthread_cond_t))
  );
  assert_eq!(
    ::std::mem::align_of::<pthread_cond_t>(),
    8usize,
    concat!("Alignment of ", stringify!(pthread_cond_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(pthread_cond_t),
      "::",
      stringify!(__data)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(pthread_cond_t),
      "::",
      stringify!(__size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(pthread_cond_t),
      "::",
      stringify!(__align)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
  pub __data: __pthread_rwlock_arch_t,
  pub __size: [::std::os::raw::c_char; 56usize],
  pub __align: ::std::os::raw::c_long,
  _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
  assert_eq!(
    ::std::mem::size_of::<pthread_rwlock_t>(),
    56usize,
    concat!("Size of: ", stringify!(pthread_rwlock_t))
  );
  assert_eq!(
    ::std::mem::align_of::<pthread_rwlock_t>(),
    8usize,
    concat!("Alignment of ", stringify!(pthread_rwlock_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(pthread_rwlock_t),
      "::",
      stringify!(__data)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(pthread_rwlock_t),
      "::",
      stringify!(__size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(pthread_rwlock_t),
      "::",
      stringify!(__align)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
  pub __size: [::std::os::raw::c_char; 8usize],
  pub __align: ::std::os::raw::c_long,
  _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
  assert_eq!(
    ::std::mem::size_of::<pthread_rwlockattr_t>(),
    8usize,
    concat!("Size of: ", stringify!(pthread_rwlockattr_t))
  );
  assert_eq!(
    ::std::mem::align_of::<pthread_rwlockattr_t>(),
    8usize,
    concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(pthread_rwlockattr_t),
      "::",
      stringify!(__size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(pthread_rwlockattr_t),
      "::",
      stringify!(__align)
    )
  );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
  pub __size: [::std::os::raw::c_char; 32usize],
  pub __align: ::std::os::raw::c_long,
  _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
  assert_eq!(
    ::std::mem::size_of::<pthread_barrier_t>(),
    32usize,
    concat!("Size of: ", stringify!(pthread_barrier_t))
  );
  assert_eq!(
    ::std::mem::align_of::<pthread_barrier_t>(),
    8usize,
    concat!("Alignment of ", stringify!(pthread_barrier_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(pthread_barrier_t),
      "::",
      stringify!(__size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(pthread_barrier_t),
      "::",
      stringify!(__align)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
  pub __size: [::std::os::raw::c_char; 4usize],
  pub __align: ::std::os::raw::c_int,
  _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
  assert_eq!(
    ::std::mem::size_of::<pthread_barrierattr_t>(),
    4usize,
    concat!("Size of: ", stringify!(pthread_barrierattr_t))
  );
  assert_eq!(
    ::std::mem::align_of::<pthread_barrierattr_t>(),
    4usize,
    concat!("Alignment of ", stringify!(pthread_barrierattr_t))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(pthread_barrierattr_t),
      "::",
      stringify!(__size)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(pthread_barrierattr_t),
      "::",
      stringify!(__align)
    )
  );
}
extern "C" {
  pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
  pub fn initstate(
    __seed: ::std::os::raw::c_uint,
    __statebuf: *mut ::std::os::raw::c_char,
    __statelen: usize,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
  pub fptr: *mut i32,
  pub rptr: *mut i32,
  pub state: *mut i32,
  pub rand_type: ::std::os::raw::c_int,
  pub rand_deg: ::std::os::raw::c_int,
  pub rand_sep: ::std::os::raw::c_int,
  pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
  assert_eq!(
    ::std::mem::size_of::<random_data>(),
    48usize,
    concat!("Size of: ", stringify!(random_data))
  );
  assert_eq!(
    ::std::mem::align_of::<random_data>(),
    8usize,
    concat!("Alignment of ", stringify!(random_data))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(random_data),
      "::",
      stringify!(fptr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(random_data),
      "::",
      stringify!(rptr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(random_data),
      "::",
      stringify!(state)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(random_data),
      "::",
      stringify!(rand_type)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
    28usize,
    concat!(
      "Offset of field: ",
      stringify!(random_data),
      "::",
      stringify!(rand_deg)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(random_data),
      "::",
      stringify!(rand_sep)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(random_data),
      "::",
      stringify!(end_ptr)
    )
  );
}
extern "C" {
  pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn srandom_r(
    __seed: ::std::os::raw::c_uint,
    __buf: *mut random_data,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn initstate_r(
    __seed: ::std::os::raw::c_uint,
    __statebuf: *mut ::std::os::raw::c_char,
    __statelen: usize,
    __buf: *mut random_data,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn setstate_r(
    __statebuf: *mut ::std::os::raw::c_char,
    __buf: *mut random_data,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
  pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn drand48() -> f64;
}
extern "C" {
  pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
  pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
  pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
  pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
  pub __x: [::std::os::raw::c_ushort; 3usize],
  pub __old_x: [::std::os::raw::c_ushort; 3usize],
  pub __c: ::std::os::raw::c_ushort,
  pub __init: ::std::os::raw::c_ushort,
  pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
  assert_eq!(
    ::std::mem::size_of::<drand48_data>(),
    24usize,
    concat!("Size of: ", stringify!(drand48_data))
  );
  assert_eq!(
    ::std::mem::align_of::<drand48_data>(),
    8usize,
    concat!("Alignment of ", stringify!(drand48_data))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(drand48_data),
      "::",
      stringify!(__x)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
    6usize,
    concat!(
      "Offset of field: ",
      stringify!(drand48_data),
      "::",
      stringify!(__old_x)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(drand48_data),
      "::",
      stringify!(__c)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(drand48_data),
      "::",
      stringify!(__init)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(drand48_data),
      "::",
      stringify!(__a)
    )
  );
}
extern "C" {
  pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn erand48_r(
    __xsubi: *mut ::std::os::raw::c_ushort,
    __buffer: *mut drand48_data,
    __result: *mut f64,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn lrand48_r(
    __buffer: *mut drand48_data,
    __result: *mut ::std::os::raw::c_long,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nrand48_r(
    __xsubi: *mut ::std::os::raw::c_ushort,
    __buffer: *mut drand48_data,
    __result: *mut ::std::os::raw::c_long,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn mrand48_r(
    __buffer: *mut drand48_data,
    __result: *mut ::std::os::raw::c_long,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn jrand48_r(
    __xsubi: *mut ::std::os::raw::c_ushort,
    __buffer: *mut drand48_data,
    __result: *mut ::std::os::raw::c_long,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn srand48_r(
    __seedval: ::std::os::raw::c_long,
    __buffer: *mut drand48_data,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn seed48_r(
    __seed16v: *mut ::std::os::raw::c_ushort,
    __buffer: *mut drand48_data,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn lcong48_r(
    __param: *mut ::std::os::raw::c_ushort,
    __buffer: *mut drand48_data,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn calloc(__nmemb: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
  pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn posix_memalign(
    __memptr: *mut *mut ::std::os::raw::c_void,
    __alignment: usize,
    __size: usize,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn abort();
}
extern "C" {
  pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn at_quick_exit(
    __func: ::std::option::Option<unsafe extern "C" fn()>,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn on_exit(
    __func: ::std::option::Option<
      unsafe extern "C" fn(__status: ::std::os::raw::c_int, __arg: *mut ::std::os::raw::c_void),
    >,
    __arg: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
  pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
  pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
  pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn setenv(
    __name: *const ::std::os::raw::c_char,
    __value: *const ::std::os::raw::c_char,
    __replace: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn mkstemps(
    __template: *mut ::std::os::raw::c_char,
    __suffixlen: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn realpath(
    __name: *const ::std::os::raw::c_char,
    __resolved: *mut ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
  unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void, arg2: *const ::std::os::raw::c_void)
    -> ::std::os::raw::c_int,
>;
extern "C" {
  pub fn bsearch(
    __key: *const ::std::os::raw::c_void,
    __base: *const ::std::os::raw::c_void,
    __nmemb: usize,
    __size: usize,
    __compar: __compar_fn_t,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn qsort(
    __base: *mut ::std::os::raw::c_void,
    __nmemb: usize,
    __size: usize,
    __compar: __compar_fn_t,
  );
}
extern "C" {
  pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
  pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
  pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
  pub fn lldiv(__numer: ::std::os::raw::c_longlong, __denom: ::std::os::raw::c_longlong)
    -> lldiv_t;
}
extern "C" {
  pub fn ecvt(
    __value: f64,
    __ndigit: ::std::os::raw::c_int,
    __decpt: *mut ::std::os::raw::c_int,
    __sign: *mut ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn fcvt(
    __value: f64,
    __ndigit: ::std::os::raw::c_int,
    __decpt: *mut ::std::os::raw::c_int,
    __sign: *mut ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn gcvt(
    __value: f64,
    __ndigit: ::std::os::raw::c_int,
    __buf: *mut ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn qecvt(
    __value: f64,
    __ndigit: ::std::os::raw::c_int,
    __decpt: *mut ::std::os::raw::c_int,
    __sign: *mut ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn qfcvt(
    __value: f64,
    __ndigit: ::std::os::raw::c_int,
    __decpt: *mut ::std::os::raw::c_int,
    __sign: *mut ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn qgcvt(
    __value: f64,
    __ndigit: ::std::os::raw::c_int,
    __buf: *mut ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn ecvt_r(
    __value: f64,
    __ndigit: ::std::os::raw::c_int,
    __decpt: *mut ::std::os::raw::c_int,
    __sign: *mut ::std::os::raw::c_int,
    __buf: *mut ::std::os::raw::c_char,
    __len: usize,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn fcvt_r(
    __value: f64,
    __ndigit: ::std::os::raw::c_int,
    __decpt: *mut ::std::os::raw::c_int,
    __sign: *mut ::std::os::raw::c_int,
    __buf: *mut ::std::os::raw::c_char,
    __len: usize,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn qecvt_r(
    __value: f64,
    __ndigit: ::std::os::raw::c_int,
    __decpt: *mut ::std::os::raw::c_int,
    __sign: *mut ::std::os::raw::c_int,
    __buf: *mut ::std::os::raw::c_char,
    __len: usize,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn qfcvt_r(
    __value: f64,
    __ndigit: ::std::os::raw::c_int,
    __decpt: *mut ::std::os::raw::c_int,
    __sign: *mut ::std::os::raw::c_int,
    __buf: *mut ::std::os::raw::c_char,
    __len: usize,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn mbtowc(
    __pwc: *mut wchar_t,
    __s: *const ::std::os::raw::c_char,
    __n: usize,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
  pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
  pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn getsubopt(
    __optionp: *mut *mut ::std::os::raw::c_char,
    __tokens: *const *const ::std::os::raw::c_char,
    __valuep: *mut *mut ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
/// Various defines for the various Link properties.
///
/// NOTE: the link detection layer will try to resolve QName expansion
/// of namespaces. If "foo" is the prefix for "http://foo.com/"
/// then the link detection layer will expand role="foo:myrole"
/// to "http://foo.com/:myrole".
/// NOTE: the link detection layer will expand URI-Refences found on
/// href attributes by using the base mechanism if found.
pub type xlinkHRef = *mut xmlChar;
pub type xlinkRole = *mut xmlChar;
pub type xlinkTitle = *mut xmlChar;
pub const xlinkType_XLINK_TYPE_NONE: xlinkType = 0;
pub const xlinkType_XLINK_TYPE_SIMPLE: xlinkType = 1;
pub const xlinkType_XLINK_TYPE_EXTENDED: xlinkType = 2;
pub const xlinkType_XLINK_TYPE_EXTENDED_SET: xlinkType = 3;
pub type xlinkType = u32;
pub const xlinkShow_XLINK_SHOW_NONE: xlinkShow = 0;
pub const xlinkShow_XLINK_SHOW_NEW: xlinkShow = 1;
pub const xlinkShow_XLINK_SHOW_EMBED: xlinkShow = 2;
pub const xlinkShow_XLINK_SHOW_REPLACE: xlinkShow = 3;
pub type xlinkShow = u32;
pub const xlinkActuate_XLINK_ACTUATE_NONE: xlinkActuate = 0;
pub const xlinkActuate_XLINK_ACTUATE_AUTO: xlinkActuate = 1;
pub const xlinkActuate_XLINK_ACTUATE_ONREQUEST: xlinkActuate = 2;
pub type xlinkActuate = u32;
/// xlinkNodeDetectFunc:
/// @ctx:  user data pointer
/// @node:  the node to check
///
/// This is the prototype for the link detection routine.
/// It calls the default link detection callbacks upon link detection.
pub type xlinkNodeDetectFunc =
  ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, node: xmlNodePtr)>;
/// xlinkSimpleLinkFunk:
/// @ctx:  user data pointer
/// @node:  the node carrying the link
/// @href:  the target of the link
/// @role:  the role string
/// @title:  the link title
///
/// This is the prototype for a simple link detection callback.
pub type xlinkSimpleLinkFunk = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    node: xmlNodePtr,
    href: xlinkHRef,
    role: xlinkRole,
    title: xlinkTitle,
  ),
>;
/// xlinkExtendedLinkFunk:
/// @ctx:  user data pointer
/// @node:  the node carrying the link
/// @nbLocators: the number of locators detected on the link
/// @hrefs:  pointer to the array of locator hrefs
/// @roles:  pointer to the array of locator roles
/// @nbArcs: the number of arcs detected on the link
/// @from:  pointer to the array of source roles found on the arcs
/// @to:  pointer to the array of target roles found on the arcs
/// @show:  array of values for the show attributes found on the arcs
/// @actuate:  array of values for the actuate attributes found on the arcs
/// @nbTitles: the number of titles detected on the link
/// @title:  array of titles detected on the link
/// @langs:  array of xml:lang values for the titles
///
/// This is the prototype for a extended link detection callback.
pub type xlinkExtendedLinkFunk = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    node: xmlNodePtr,
    nbLocators: ::std::os::raw::c_int,
    hrefs: *const xlinkHRef,
    roles: *const xlinkRole,
    nbArcs: ::std::os::raw::c_int,
    from: *const xlinkRole,
    to: *const xlinkRole,
    show: *mut xlinkShow,
    actuate: *mut xlinkActuate,
    nbTitles: ::std::os::raw::c_int,
    titles: *const xlinkTitle,
    langs: *mut *const xmlChar,
  ),
>;
/// xlinkExtendedLinkSetFunk:
/// @ctx:  user data pointer
/// @node:  the node carrying the link
/// @nbLocators: the number of locators detected on the link
/// @hrefs:  pointer to the array of locator hrefs
/// @roles:  pointer to the array of locator roles
/// @nbTitles: the number of titles detected on the link
/// @title:  array of titles detected on the link
/// @langs:  array of xml:lang values for the titles
///
/// This is the prototype for a extended link set detection callback.
pub type xlinkExtendedLinkSetFunk = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    node: xmlNodePtr,
    nbLocators: ::std::os::raw::c_int,
    hrefs: *const xlinkHRef,
    roles: *const xlinkRole,
    nbTitles: ::std::os::raw::c_int,
    titles: *const xlinkTitle,
    langs: *mut *const xmlChar,
  ),
>;
/// This is the structure containing a set of Links detection callbacks.
///
/// There is no default xlink callbacks, if one want to get link
/// recognition activated, those call backs must be provided before parsing.
pub type xlinkHandler = _xlinkHandler;
pub type xlinkHandlerPtr = *mut xlinkHandler;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _xlinkHandler {
  pub simple: xlinkSimpleLinkFunk,
  pub extended: xlinkExtendedLinkFunk,
  pub set: xlinkExtendedLinkSetFunk,
}
#[test]
fn bindgen_test_layout__xlinkHandler() {
  assert_eq!(
    ::std::mem::size_of::<_xlinkHandler>(),
    24usize,
    concat!("Size of: ", stringify!(_xlinkHandler))
  );
  assert_eq!(
    ::std::mem::align_of::<_xlinkHandler>(),
    8usize,
    concat!("Alignment of ", stringify!(_xlinkHandler))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xlinkHandler>())).simple as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xlinkHandler),
      "::",
      stringify!(simple)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xlinkHandler>())).extended as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xlinkHandler),
      "::",
      stringify!(extended)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xlinkHandler>())).set as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xlinkHandler),
      "::",
      stringify!(set)
    )
  );
}
extern "C" {
  pub fn xlinkGetDefaultDetect() -> xlinkNodeDetectFunc;
}
extern "C" {
  pub fn xlinkSetDefaultDetect(func: xlinkNodeDetectFunc);
}
extern "C" {
  pub fn xlinkGetDefaultHandler() -> xlinkHandlerPtr;
}
extern "C" {
  pub fn xlinkSetDefaultHandler(handler: xlinkHandlerPtr);
}
extern "C" {
  pub fn xlinkIsLink(doc: xmlDocPtr, node: xmlNodePtr) -> xlinkType;
}
extern "C" {
  pub fn getPublicId(ctx: *mut ::std::os::raw::c_void) -> *const xmlChar;
}
extern "C" {
  pub fn getSystemId(ctx: *mut ::std::os::raw::c_void) -> *const xmlChar;
}
extern "C" {
  pub fn setDocumentLocator(ctx: *mut ::std::os::raw::c_void, loc: xmlSAXLocatorPtr);
}
extern "C" {
  pub fn getLineNumber(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn getColumnNumber(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn isStandalone(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn hasInternalSubset(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn hasExternalSubset(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn internalSubset(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    ExternalID: *const xmlChar,
    SystemID: *const xmlChar,
  );
}
extern "C" {
  pub fn externalSubset(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    ExternalID: *const xmlChar,
    SystemID: *const xmlChar,
  );
}
extern "C" {
  pub fn getEntity(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar) -> xmlEntityPtr;
}
extern "C" {
  pub fn getParameterEntity(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar)
    -> xmlEntityPtr;
}
extern "C" {
  pub fn resolveEntity(
    ctx: *mut ::std::os::raw::c_void,
    publicId: *const xmlChar,
    systemId: *const xmlChar,
  ) -> xmlParserInputPtr;
}
extern "C" {
  pub fn entityDecl(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    type_: ::std::os::raw::c_int,
    publicId: *const xmlChar,
    systemId: *const xmlChar,
    content: *mut xmlChar,
  );
}
extern "C" {
  pub fn attributeDecl(
    ctx: *mut ::std::os::raw::c_void,
    elem: *const xmlChar,
    fullname: *const xmlChar,
    type_: ::std::os::raw::c_int,
    def: ::std::os::raw::c_int,
    defaultValue: *const xmlChar,
    tree: xmlEnumerationPtr,
  );
}
extern "C" {
  pub fn elementDecl(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    type_: ::std::os::raw::c_int,
    content: xmlElementContentPtr,
  );
}
extern "C" {
  pub fn notationDecl(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    publicId: *const xmlChar,
    systemId: *const xmlChar,
  );
}
extern "C" {
  pub fn unparsedEntityDecl(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    publicId: *const xmlChar,
    systemId: *const xmlChar,
    notationName: *const xmlChar,
  );
}
extern "C" {
  pub fn startDocument(ctx: *mut ::std::os::raw::c_void);
}
extern "C" {
  pub fn endDocument(ctx: *mut ::std::os::raw::c_void);
}
extern "C" {
  pub fn attribute(
    ctx: *mut ::std::os::raw::c_void,
    fullname: *const xmlChar,
    value: *const xmlChar,
  );
}
extern "C" {
  pub fn startElement(
    ctx: *mut ::std::os::raw::c_void,
    fullname: *const xmlChar,
    atts: *mut *const xmlChar,
  );
}
extern "C" {
  pub fn endElement(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar);
}
extern "C" {
  pub fn reference(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar);
}
extern "C" {
  pub fn characters(
    ctx: *mut ::std::os::raw::c_void,
    ch: *const xmlChar,
    len: ::std::os::raw::c_int,
  );
}
extern "C" {
  pub fn ignorableWhitespace(
    ctx: *mut ::std::os::raw::c_void,
    ch: *const xmlChar,
    len: ::std::os::raw::c_int,
  );
}
extern "C" {
  pub fn processingInstruction(
    ctx: *mut ::std::os::raw::c_void,
    target: *const xmlChar,
    data: *const xmlChar,
  );
}
extern "C" {
  pub fn globalNamespace(
    ctx: *mut ::std::os::raw::c_void,
    href: *const xmlChar,
    prefix: *const xmlChar,
  );
}
extern "C" {
  pub fn setNamespace(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar);
}
extern "C" {
  pub fn getNamespace(ctx: *mut ::std::os::raw::c_void) -> xmlNsPtr;
}
extern "C" {
  pub fn checkNamespace(
    ctx: *mut ::std::os::raw::c_void,
    nameSpace: *mut xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn namespaceDecl(
    ctx: *mut ::std::os::raw::c_void,
    href: *const xmlChar,
    prefix: *const xmlChar,
  );
}
extern "C" {
  pub fn comment(ctx: *mut ::std::os::raw::c_void, value: *const xmlChar);
}
extern "C" {
  pub fn cdataBlock(
    ctx: *mut ::std::os::raw::c_void,
    value: *const xmlChar,
    len: ::std::os::raw::c_int,
  );
}
extern "C" {
  pub fn initxmlDefaultSAXHandler(hdlr: *mut xmlSAXHandlerV1, warning: ::std::os::raw::c_int);
}
extern "C" {
  pub fn inithtmlDefaultSAXHandler(hdlr: *mut xmlSAXHandlerV1);
}
extern "C" {
  pub fn initdocbDefaultSAXHandler(hdlr: *mut xmlSAXHandlerV1);
}
extern "C" {
  pub fn xmlSAX2GetPublicId(ctx: *mut ::std::os::raw::c_void) -> *const xmlChar;
}
extern "C" {
  pub fn xmlSAX2GetSystemId(ctx: *mut ::std::os::raw::c_void) -> *const xmlChar;
}
extern "C" {
  pub fn xmlSAX2SetDocumentLocator(ctx: *mut ::std::os::raw::c_void, loc: xmlSAXLocatorPtr);
}
extern "C" {
  pub fn xmlSAX2GetLineNumber(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSAX2GetColumnNumber(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSAX2IsStandalone(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSAX2HasInternalSubset(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSAX2HasExternalSubset(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSAX2InternalSubset(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    ExternalID: *const xmlChar,
    SystemID: *const xmlChar,
  );
}
extern "C" {
  pub fn xmlSAX2ExternalSubset(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    ExternalID: *const xmlChar,
    SystemID: *const xmlChar,
  );
}
extern "C" {
  pub fn xmlSAX2GetEntity(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar) -> xmlEntityPtr;
}
extern "C" {
  pub fn xmlSAX2GetParameterEntity(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
  ) -> xmlEntityPtr;
}
extern "C" {
  pub fn xmlSAX2ResolveEntity(
    ctx: *mut ::std::os::raw::c_void,
    publicId: *const xmlChar,
    systemId: *const xmlChar,
  ) -> xmlParserInputPtr;
}
extern "C" {
  pub fn xmlSAX2EntityDecl(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    type_: ::std::os::raw::c_int,
    publicId: *const xmlChar,
    systemId: *const xmlChar,
    content: *mut xmlChar,
  );
}
extern "C" {
  pub fn xmlSAX2AttributeDecl(
    ctx: *mut ::std::os::raw::c_void,
    elem: *const xmlChar,
    fullname: *const xmlChar,
    type_: ::std::os::raw::c_int,
    def: ::std::os::raw::c_int,
    defaultValue: *const xmlChar,
    tree: xmlEnumerationPtr,
  );
}
extern "C" {
  pub fn xmlSAX2ElementDecl(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    type_: ::std::os::raw::c_int,
    content: xmlElementContentPtr,
  );
}
extern "C" {
  pub fn xmlSAX2NotationDecl(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    publicId: *const xmlChar,
    systemId: *const xmlChar,
  );
}
extern "C" {
  pub fn xmlSAX2UnparsedEntityDecl(
    ctx: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    publicId: *const xmlChar,
    systemId: *const xmlChar,
    notationName: *const xmlChar,
  );
}
extern "C" {
  pub fn xmlSAX2StartDocument(ctx: *mut ::std::os::raw::c_void);
}
extern "C" {
  pub fn xmlSAX2EndDocument(ctx: *mut ::std::os::raw::c_void);
}
extern "C" {
  pub fn xmlSAX2StartElement(
    ctx: *mut ::std::os::raw::c_void,
    fullname: *const xmlChar,
    atts: *mut *const xmlChar,
  );
}
extern "C" {
  pub fn xmlSAX2EndElement(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar);
}
extern "C" {
  pub fn xmlSAX2StartElementNs(
    ctx: *mut ::std::os::raw::c_void,
    localname: *const xmlChar,
    prefix: *const xmlChar,
    URI: *const xmlChar,
    nb_namespaces: ::std::os::raw::c_int,
    namespaces: *mut *const xmlChar,
    nb_attributes: ::std::os::raw::c_int,
    nb_defaulted: ::std::os::raw::c_int,
    attributes: *mut *const xmlChar,
  );
}
extern "C" {
  pub fn xmlSAX2EndElementNs(
    ctx: *mut ::std::os::raw::c_void,
    localname: *const xmlChar,
    prefix: *const xmlChar,
    URI: *const xmlChar,
  );
}
extern "C" {
  pub fn xmlSAX2Reference(ctx: *mut ::std::os::raw::c_void, name: *const xmlChar);
}
extern "C" {
  pub fn xmlSAX2Characters(
    ctx: *mut ::std::os::raw::c_void,
    ch: *const xmlChar,
    len: ::std::os::raw::c_int,
  );
}
extern "C" {
  pub fn xmlSAX2IgnorableWhitespace(
    ctx: *mut ::std::os::raw::c_void,
    ch: *const xmlChar,
    len: ::std::os::raw::c_int,
  );
}
extern "C" {
  pub fn xmlSAX2ProcessingInstruction(
    ctx: *mut ::std::os::raw::c_void,
    target: *const xmlChar,
    data: *const xmlChar,
  );
}
extern "C" {
  pub fn xmlSAX2Comment(ctx: *mut ::std::os::raw::c_void, value: *const xmlChar);
}
extern "C" {
  pub fn xmlSAX2CDataBlock(
    ctx: *mut ::std::os::raw::c_void,
    value: *const xmlChar,
    len: ::std::os::raw::c_int,
  );
}
extern "C" {
  pub fn xmlSAXDefaultVersion(version: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSAXVersion(
    hdlr: *mut xmlSAXHandler,
    version: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSAX2InitDefaultSAXHandler(hdlr: *mut xmlSAXHandler, warning: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlSAX2InitHtmlDefaultSAXHandler(hdlr: *mut xmlSAXHandler);
}
extern "C" {
  pub fn htmlDefaultSAXHandlerInit();
}
extern "C" {
  pub fn xmlSAX2InitDocbDefaultSAXHandler(hdlr: *mut xmlSAXHandler);
}
extern "C" {
  pub fn docbDefaultSAXHandlerInit();
}
extern "C" {
  pub fn xmlDefaultSAXHandlerInit();
}
/// xmlFreeFunc:
/// @mem: an already allocated block of memory
///
/// Signature for a free() implementation.
pub type xmlFreeFunc =
  ::std::option::Option<unsafe extern "C" fn(mem: *mut ::std::os::raw::c_void)>;
/// xmlMallocFunc:
/// @size:  the size requested in bytes
///
/// Signature for a malloc() implementation.
///
/// Returns a pointer to the newly allocated block or NULL in case of error.
pub type xmlMallocFunc =
  ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void>;
/// xmlReallocFunc:
/// @mem: an already allocated block of memory
/// @size:  the new size requested in bytes
///
/// Signature for a realloc() implementation.
///
/// Returns a pointer to the newly reallocated block or NULL in case of error.
pub type xmlReallocFunc = ::std::option::Option<
  unsafe extern "C" fn(mem: *mut ::std::os::raw::c_void, size: usize)
    -> *mut ::std::os::raw::c_void,
>;
/// xmlStrdupFunc:
/// @str: a zero terminated string
///
/// Signature for an strdup() implementation.
///
/// Returns the copy of the string or NULL in case of error.
pub type xmlStrdupFunc = ::std::option::Option<
  unsafe extern "C" fn(str: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
>;
extern "C" {
  pub fn xmlMemSetup(
    freeFunc: xmlFreeFunc,
    mallocFunc: xmlMallocFunc,
    reallocFunc: xmlReallocFunc,
    strdupFunc: xmlStrdupFunc,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlMemGet(
    freeFunc: *mut xmlFreeFunc,
    mallocFunc: *mut xmlMallocFunc,
    reallocFunc: *mut xmlReallocFunc,
    strdupFunc: *mut xmlStrdupFunc,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlGcMemSetup(
    freeFunc: xmlFreeFunc,
    mallocFunc: xmlMallocFunc,
    mallocAtomicFunc: xmlMallocFunc,
    reallocFunc: xmlReallocFunc,
    strdupFunc: xmlStrdupFunc,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlGcMemGet(
    freeFunc: *mut xmlFreeFunc,
    mallocFunc: *mut xmlMallocFunc,
    mallocAtomicFunc: *mut xmlMallocFunc,
    reallocFunc: *mut xmlReallocFunc,
    strdupFunc: *mut xmlStrdupFunc,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlInitMemory() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlCleanupMemory();
}
extern "C" {
  pub fn xmlMemUsed() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlMemBlocks() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlMemDisplay(fp: *mut FILE);
}
extern "C" {
  pub fn xmlMemDisplayLast(fp: *mut FILE, nbBytes: ::std::os::raw::c_long);
}
extern "C" {
  pub fn xmlMemShow(fp: *mut FILE, nr: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlMemoryDump();
}
extern "C" {
  pub fn xmlMemMalloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlMemRealloc(
    ptr: *mut ::std::os::raw::c_void,
    size: usize,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlMemFree(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
  pub fn xmlMemoryStrdup(str: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn xmlMallocLoc(
    size: usize,
    file: *const ::std::os::raw::c_char,
    line: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlReallocLoc(
    ptr: *mut ::std::os::raw::c_void,
    size: usize,
    file: *const ::std::os::raw::c_char,
    line: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlMallocAtomicLoc(
    size: usize,
    file: *const ::std::os::raw::c_char,
    line: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlMemStrdupLoc(
    str: *const ::std::os::raw::c_char,
    file: *const ::std::os::raw::c_char,
    line: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn xmlInitGlobals();
}
extern "C" {
  pub fn xmlCleanupGlobals();
}
/// xmlParserInputBufferCreateFilenameFunc:
/// @URI: the URI to read from
/// @enc: the requested source encoding
///
/// Signature for the function doing the lookup for a suitable input method
/// corresponding to an URI.
///
/// Returns the new xmlParserInputBufferPtr in case of success or NULL if no
/// method was found.
pub type xmlParserInputBufferCreateFilenameFunc = ::std::option::Option<
  unsafe extern "C" fn(URI: *const ::std::os::raw::c_char, enc: xmlCharEncoding)
    -> xmlParserInputBufferPtr,
>;
/// xmlOutputBufferCreateFilenameFunc:
/// @URI: the URI to write to
/// @enc: the requested target encoding
///
/// Signature for the function doing the lookup for a suitable output method
/// corresponding to an URI.
///
/// Returns the new xmlOutputBufferPtr in case of success or NULL if no
/// method was found.
pub type xmlOutputBufferCreateFilenameFunc = ::std::option::Option<
  unsafe extern "C" fn(
    URI: *const ::std::os::raw::c_char,
    encoder: xmlCharEncodingHandlerPtr,
    compression: ::std::os::raw::c_int,
  ) -> xmlOutputBufferPtr,
>;
extern "C" {
  pub fn xmlParserInputBufferCreateFilenameDefault(
    func: xmlParserInputBufferCreateFilenameFunc,
  ) -> xmlParserInputBufferCreateFilenameFunc;
}
extern "C" {
  pub fn xmlOutputBufferCreateFilenameDefault(
    func: xmlOutputBufferCreateFilenameFunc,
  ) -> xmlOutputBufferCreateFilenameFunc;
}
/// xmlRegisterNodeFunc:
/// @node: the current node
///
/// Signature for the registration callback of a created node
pub type xmlRegisterNodeFunc = ::std::option::Option<unsafe extern "C" fn(node: xmlNodePtr)>;
/// xmlDeregisterNodeFunc:
/// @node: the current node
///
/// Signature for the deregistration callback of a discarded node
pub type xmlDeregisterNodeFunc = ::std::option::Option<unsafe extern "C" fn(node: xmlNodePtr)>;
pub type xmlGlobalState = _xmlGlobalState;
pub type xmlGlobalStatePtr = *mut xmlGlobalState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlGlobalState {
  pub xmlParserVersion: *const ::std::os::raw::c_char,
  pub xmlDefaultSAXLocator: xmlSAXLocator,
  pub xmlDefaultSAXHandler: xmlSAXHandlerV1,
  pub docbDefaultSAXHandler: xmlSAXHandlerV1,
  pub htmlDefaultSAXHandler: xmlSAXHandlerV1,
  pub xmlFree: xmlFreeFunc,
  pub xmlMalloc: xmlMallocFunc,
  pub xmlMemStrdup: xmlStrdupFunc,
  pub xmlRealloc: xmlReallocFunc,
  pub xmlGenericError: xmlGenericErrorFunc,
  pub xmlStructuredError: xmlStructuredErrorFunc,
  pub xmlGenericErrorContext: *mut ::std::os::raw::c_void,
  pub oldXMLWDcompatibility: ::std::os::raw::c_int,
  pub xmlBufferAllocScheme: xmlBufferAllocationScheme,
  pub xmlDefaultBufferSize: ::std::os::raw::c_int,
  pub xmlSubstituteEntitiesDefaultValue: ::std::os::raw::c_int,
  pub xmlDoValidityCheckingDefaultValue: ::std::os::raw::c_int,
  pub xmlGetWarningsDefaultValue: ::std::os::raw::c_int,
  pub xmlKeepBlanksDefaultValue: ::std::os::raw::c_int,
  pub xmlLineNumbersDefaultValue: ::std::os::raw::c_int,
  pub xmlLoadExtDtdDefaultValue: ::std::os::raw::c_int,
  pub xmlParserDebugEntities: ::std::os::raw::c_int,
  pub xmlPedanticParserDefaultValue: ::std::os::raw::c_int,
  pub xmlSaveNoEmptyTags: ::std::os::raw::c_int,
  pub xmlIndentTreeOutput: ::std::os::raw::c_int,
  pub xmlTreeIndentString: *const ::std::os::raw::c_char,
  pub xmlRegisterNodeDefaultValue: xmlRegisterNodeFunc,
  pub xmlDeregisterNodeDefaultValue: xmlDeregisterNodeFunc,
  pub xmlMallocAtomic: xmlMallocFunc,
  pub xmlLastError: xmlError,
  pub xmlParserInputBufferCreateFilenameValue: xmlParserInputBufferCreateFilenameFunc,
  pub xmlOutputBufferCreateFilenameValue: xmlOutputBufferCreateFilenameFunc,
  pub xmlStructuredErrorContext: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlGlobalState() {
  assert_eq!(
    ::std::mem::size_of::<_xmlGlobalState>(),
    968usize,
    concat!("Size of: ", stringify!(_xmlGlobalState))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlGlobalState>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlGlobalState))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlGlobalState>())).xmlParserVersion as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlParserVersion)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlGlobalState>())).xmlDefaultSAXLocator as *const _ as usize
    },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlDefaultSAXLocator)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlGlobalState>())).xmlDefaultSAXHandler as *const _ as usize
    },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlDefaultSAXHandler)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlGlobalState>())).docbDefaultSAXHandler as *const _ as usize
    },
    264usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(docbDefaultSAXHandler)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlGlobalState>())).htmlDefaultSAXHandler as *const _ as usize
    },
    488usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(htmlDefaultSAXHandler)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlGlobalState>())).xmlFree as *const _ as usize },
    712usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlFree)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlGlobalState>())).xmlMalloc as *const _ as usize },
    720usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlMalloc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlGlobalState>())).xmlMemStrdup as *const _ as usize },
    728usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlMemStrdup)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlGlobalState>())).xmlRealloc as *const _ as usize },
    736usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlRealloc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlGlobalState>())).xmlGenericError as *const _ as usize },
    744usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlGenericError)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlGlobalState>())).xmlStructuredError as *const _ as usize },
    752usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlStructuredError)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlGlobalState>())).xmlGenericErrorContext as *const _ as usize
    },
    760usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlGenericErrorContext)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlGlobalState>())).oldXMLWDcompatibility as *const _ as usize
    },
    768usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(oldXMLWDcompatibility)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlGlobalState>())).xmlBufferAllocScheme as *const _ as usize
    },
    772usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlBufferAllocScheme)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlGlobalState>())).xmlDefaultBufferSize as *const _ as usize
    },
    776usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlDefaultBufferSize)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlGlobalState>())).xmlSubstituteEntitiesDefaultValue as *const _
        as usize
    },
    780usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlSubstituteEntitiesDefaultValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlGlobalState>())).xmlDoValidityCheckingDefaultValue as *const _
        as usize
    },
    784usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlDoValidityCheckingDefaultValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlGlobalState>())).xmlGetWarningsDefaultValue as *const _ as usize
    },
    788usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlGetWarningsDefaultValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlGlobalState>())).xmlKeepBlanksDefaultValue as *const _ as usize
    },
    792usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlKeepBlanksDefaultValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlGlobalState>())).xmlLineNumbersDefaultValue as *const _ as usize
    },
    796usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlLineNumbersDefaultValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlGlobalState>())).xmlLoadExtDtdDefaultValue as *const _ as usize
    },
    800usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlLoadExtDtdDefaultValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlGlobalState>())).xmlParserDebugEntities as *const _ as usize
    },
    804usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlParserDebugEntities)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlGlobalState>())).xmlPedanticParserDefaultValue as *const _ as usize
    },
    808usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlPedanticParserDefaultValue)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlGlobalState>())).xmlSaveNoEmptyTags as *const _ as usize },
    812usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlSaveNoEmptyTags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlGlobalState>())).xmlIndentTreeOutput as *const _ as usize },
    816usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlIndentTreeOutput)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlGlobalState>())).xmlTreeIndentString as *const _ as usize },
    824usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlTreeIndentString)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlGlobalState>())).xmlRegisterNodeDefaultValue as *const _ as usize
    },
    832usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlRegisterNodeDefaultValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlGlobalState>())).xmlDeregisterNodeDefaultValue as *const _ as usize
    },
    840usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlDeregisterNodeDefaultValue)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlGlobalState>())).xmlMallocAtomic as *const _ as usize },
    848usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlMallocAtomic)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlGlobalState>())).xmlLastError as *const _ as usize },
    856usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlLastError)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlGlobalState>())).xmlParserInputBufferCreateFilenameValue
        as *const _ as usize
    },
    944usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlParserInputBufferCreateFilenameValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlGlobalState>())).xmlOutputBufferCreateFilenameValue as *const _
        as usize
    },
    952usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlOutputBufferCreateFilenameValue)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlGlobalState>())).xmlStructuredErrorContext as *const _ as usize
    },
    960usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlGlobalState),
      "::",
      stringify!(xmlStructuredErrorContext)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlMutex {
  _unused: [u8; 0],
}
pub type xmlMutex = _xmlMutex;
pub type xmlMutexPtr = *mut xmlMutex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlRMutex {
  _unused: [u8; 0],
}
pub type xmlRMutex = _xmlRMutex;
pub type xmlRMutexPtr = *mut xmlRMutex;
extern "C" {
  pub fn xmlNewMutex() -> xmlMutexPtr;
}
extern "C" {
  pub fn xmlMutexLock(tok: xmlMutexPtr);
}
extern "C" {
  pub fn xmlMutexUnlock(tok: xmlMutexPtr);
}
extern "C" {
  pub fn xmlFreeMutex(tok: xmlMutexPtr);
}
extern "C" {
  pub fn xmlNewRMutex() -> xmlRMutexPtr;
}
extern "C" {
  pub fn xmlRMutexLock(tok: xmlRMutexPtr);
}
extern "C" {
  pub fn xmlRMutexUnlock(tok: xmlRMutexPtr);
}
extern "C" {
  pub fn xmlFreeRMutex(tok: xmlRMutexPtr);
}
extern "C" {
  pub fn xmlInitThreads();
}
extern "C" {
  pub fn xmlLockLibrary();
}
extern "C" {
  pub fn xmlUnlockLibrary();
}
extern "C" {
  pub fn xmlGetThreadId() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlIsMainThread() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlCleanupThreads();
}
extern "C" {
  pub fn xmlGetGlobalState() -> xmlGlobalStatePtr;
}
extern "C" {
  pub fn xmlInitializeGlobalState(gs: xmlGlobalStatePtr);
}
extern "C" {
  pub fn xmlThrDefSetGenericErrorFunc(
    ctx: *mut ::std::os::raw::c_void,
    handler: xmlGenericErrorFunc,
  );
}
extern "C" {
  pub fn xmlThrDefSetStructuredErrorFunc(
    ctx: *mut ::std::os::raw::c_void,
    handler: xmlStructuredErrorFunc,
  );
}
extern "C" {
  pub fn xmlRegisterNodeDefault(func: xmlRegisterNodeFunc) -> xmlRegisterNodeFunc;
}
extern "C" {
  pub fn xmlThrDefRegisterNodeDefault(func: xmlRegisterNodeFunc) -> xmlRegisterNodeFunc;
}
extern "C" {
  pub fn xmlDeregisterNodeDefault(func: xmlDeregisterNodeFunc) -> xmlDeregisterNodeFunc;
}
extern "C" {
  pub fn xmlThrDefDeregisterNodeDefault(func: xmlDeregisterNodeFunc) -> xmlDeregisterNodeFunc;
}
extern "C" {
  pub fn xmlThrDefOutputBufferCreateFilenameDefault(
    func: xmlOutputBufferCreateFilenameFunc,
  ) -> xmlOutputBufferCreateFilenameFunc;
}
extern "C" {
  pub fn xmlThrDefParserInputBufferCreateFilenameDefault(
    func: xmlParserInputBufferCreateFilenameFunc,
  ) -> xmlParserInputBufferCreateFilenameFunc;
}
extern "C" {
  #[link_name = "\u{1}xmlMalloc"]
  pub static mut xmlMalloc: xmlMallocFunc;
}
extern "C" {
  #[link_name = "\u{1}xmlMallocAtomic"]
  pub static mut xmlMallocAtomic: xmlMallocFunc;
}
extern "C" {
  #[link_name = "\u{1}xmlRealloc"]
  pub static mut xmlRealloc: xmlReallocFunc;
}
extern "C" {
  #[link_name = "\u{1}xmlFree"]
  pub static mut xmlFree: xmlFreeFunc;
}
extern "C" {
  #[link_name = "\u{1}xmlMemStrdup"]
  pub static mut xmlMemStrdup: xmlStrdupFunc;
}
extern "C" {
  pub fn __docbDefaultSAXHandler() -> *mut xmlSAXHandlerV1;
}
extern "C" {
  #[link_name = "\u{1}docbDefaultSAXHandler"]
  pub static mut docbDefaultSAXHandler: xmlSAXHandlerV1;
}
extern "C" {
  pub fn __htmlDefaultSAXHandler() -> *mut xmlSAXHandlerV1;
}
extern "C" {
  #[link_name = "\u{1}htmlDefaultSAXHandler"]
  pub static mut htmlDefaultSAXHandler: xmlSAXHandlerV1;
}
extern "C" {
  pub fn __xmlLastError() -> *mut xmlError;
}
extern "C" {
  #[link_name = "\u{1}xmlLastError"]
  pub static mut xmlLastError: xmlError;
}
extern "C" {
  pub fn __oldXMLWDcompatibility() -> *mut ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}oldXMLWDcompatibility"]
  pub static mut oldXMLWDcompatibility: ::std::os::raw::c_int;
}
extern "C" {
  pub fn __xmlBufferAllocScheme() -> *mut xmlBufferAllocationScheme;
}
extern "C" {
  #[link_name = "\u{1}xmlBufferAllocScheme"]
  pub static mut xmlBufferAllocScheme: xmlBufferAllocationScheme;
}
extern "C" {
  pub fn xmlThrDefBufferAllocScheme(v: xmlBufferAllocationScheme) -> xmlBufferAllocationScheme;
}
extern "C" {
  pub fn __xmlDefaultBufferSize() -> *mut ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}xmlDefaultBufferSize"]
  pub static mut xmlDefaultBufferSize: ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlThrDefDefaultBufferSize(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __xmlDefaultSAXHandler() -> *mut xmlSAXHandlerV1;
}
extern "C" {
  #[link_name = "\u{1}xmlDefaultSAXHandler"]
  pub static mut xmlDefaultSAXHandler: xmlSAXHandlerV1;
}
extern "C" {
  pub fn __xmlDefaultSAXLocator() -> *mut xmlSAXLocator;
}
extern "C" {
  #[link_name = "\u{1}xmlDefaultSAXLocator"]
  pub static mut xmlDefaultSAXLocator: xmlSAXLocator;
}
extern "C" {
  pub fn __xmlDoValidityCheckingDefaultValue() -> *mut ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}xmlDoValidityCheckingDefaultValue"]
  pub static mut xmlDoValidityCheckingDefaultValue: ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlThrDefDoValidityCheckingDefaultValue(v: ::std::os::raw::c_int)
    -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __xmlGenericError() -> *mut xmlGenericErrorFunc;
}
extern "C" {
  #[link_name = "\u{1}xmlGenericError"]
  pub static mut xmlGenericError: xmlGenericErrorFunc;
}
extern "C" {
  pub fn __xmlStructuredError() -> *mut xmlStructuredErrorFunc;
}
extern "C" {
  #[link_name = "\u{1}xmlStructuredError"]
  pub static mut xmlStructuredError: xmlStructuredErrorFunc;
}
extern "C" {
  pub fn __xmlGenericErrorContext() -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
  #[link_name = "\u{1}xmlGenericErrorContext"]
  pub static mut xmlGenericErrorContext: *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn __xmlStructuredErrorContext() -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
  #[link_name = "\u{1}xmlStructuredErrorContext"]
  pub static mut xmlStructuredErrorContext: *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn __xmlGetWarningsDefaultValue() -> *mut ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}xmlGetWarningsDefaultValue"]
  pub static mut xmlGetWarningsDefaultValue: ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlThrDefGetWarningsDefaultValue(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __xmlIndentTreeOutput() -> *mut ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}xmlIndentTreeOutput"]
  pub static mut xmlIndentTreeOutput: ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlThrDefIndentTreeOutput(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __xmlTreeIndentString() -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
  #[link_name = "\u{1}xmlTreeIndentString"]
  pub static mut xmlTreeIndentString: *const ::std::os::raw::c_char;
}
extern "C" {
  pub fn xmlThrDefTreeIndentString(
    v: *const ::std::os::raw::c_char,
  ) -> *const ::std::os::raw::c_char;
}
extern "C" {
  pub fn __xmlKeepBlanksDefaultValue() -> *mut ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}xmlKeepBlanksDefaultValue"]
  pub static mut xmlKeepBlanksDefaultValue: ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlThrDefKeepBlanksDefaultValue(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __xmlLineNumbersDefaultValue() -> *mut ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}xmlLineNumbersDefaultValue"]
  pub static mut xmlLineNumbersDefaultValue: ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlThrDefLineNumbersDefaultValue(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __xmlLoadExtDtdDefaultValue() -> *mut ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}xmlLoadExtDtdDefaultValue"]
  pub static mut xmlLoadExtDtdDefaultValue: ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlThrDefLoadExtDtdDefaultValue(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __xmlParserDebugEntities() -> *mut ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}xmlParserDebugEntities"]
  pub static mut xmlParserDebugEntities: ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlThrDefParserDebugEntities(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __xmlParserVersion() -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
  #[link_name = "\u{1}xmlParserVersion"]
  pub static mut xmlParserVersion: *const ::std::os::raw::c_char;
}
extern "C" {
  pub fn __xmlPedanticParserDefaultValue() -> *mut ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}xmlPedanticParserDefaultValue"]
  pub static mut xmlPedanticParserDefaultValue: ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlThrDefPedanticParserDefaultValue(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __xmlSaveNoEmptyTags() -> *mut ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}xmlSaveNoEmptyTags"]
  pub static mut xmlSaveNoEmptyTags: ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlThrDefSaveNoEmptyTags(v: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __xmlSubstituteEntitiesDefaultValue() -> *mut ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}xmlSubstituteEntitiesDefaultValue"]
  pub static mut xmlSubstituteEntitiesDefaultValue: ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlThrDefSubstituteEntitiesDefaultValue(v: ::std::os::raw::c_int)
    -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __xmlRegisterNodeDefaultValue() -> *mut xmlRegisterNodeFunc;
}
extern "C" {
  #[link_name = "\u{1}xmlRegisterNodeDefaultValue"]
  pub static mut xmlRegisterNodeDefaultValue: xmlRegisterNodeFunc;
}
extern "C" {
  pub fn __xmlDeregisterNodeDefaultValue() -> *mut xmlDeregisterNodeFunc;
}
extern "C" {
  #[link_name = "\u{1}xmlDeregisterNodeDefaultValue"]
  pub static mut xmlDeregisterNodeDefaultValue: xmlDeregisterNodeFunc;
}
extern "C" {
  pub fn __xmlParserInputBufferCreateFilenameValue() -> *mut xmlParserInputBufferCreateFilenameFunc;
}
extern "C" {
  #[link_name = "\u{1}xmlParserInputBufferCreateFilenameValue"]
  pub static mut xmlParserInputBufferCreateFilenameValue: xmlParserInputBufferCreateFilenameFunc;
}
extern "C" {
  pub fn __xmlOutputBufferCreateFilenameValue() -> *mut xmlOutputBufferCreateFilenameFunc;
}
extern "C" {
  #[link_name = "\u{1}xmlOutputBufferCreateFilenameValue"]
  pub static mut xmlOutputBufferCreateFilenameValue: xmlOutputBufferCreateFilenameFunc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlParserInputBuffer {
  pub context: *mut ::std::os::raw::c_void,
  pub readcallback: xmlInputReadCallback,
  pub closecallback: xmlInputCloseCallback,
  pub encoder: xmlCharEncodingHandlerPtr,
  pub buffer: xmlBufPtr,
  pub raw: xmlBufPtr,
  pub compressed: ::std::os::raw::c_int,
  pub error: ::std::os::raw::c_int,
  pub rawconsumed: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout__xmlParserInputBuffer() {
  assert_eq!(
    ::std::mem::size_of::<_xmlParserInputBuffer>(),
    64usize,
    concat!("Size of: ", stringify!(_xmlParserInputBuffer))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlParserInputBuffer>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlParserInputBuffer))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInputBuffer>())).context as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInputBuffer),
      "::",
      stringify!(context)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInputBuffer>())).readcallback as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInputBuffer),
      "::",
      stringify!(readcallback)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInputBuffer>())).closecallback as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInputBuffer),
      "::",
      stringify!(closecallback)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInputBuffer>())).encoder as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInputBuffer),
      "::",
      stringify!(encoder)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInputBuffer>())).buffer as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInputBuffer),
      "::",
      stringify!(buffer)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInputBuffer>())).raw as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInputBuffer),
      "::",
      stringify!(raw)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInputBuffer>())).compressed as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInputBuffer),
      "::",
      stringify!(compressed)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInputBuffer>())).error as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInputBuffer),
      "::",
      stringify!(error)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlParserInputBuffer>())).rawconsumed as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlParserInputBuffer),
      "::",
      stringify!(rawconsumed)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlOutputBuffer {
  pub context: *mut ::std::os::raw::c_void,
  pub writecallback: xmlOutputWriteCallback,
  pub closecallback: xmlOutputCloseCallback,
  pub encoder: xmlCharEncodingHandlerPtr,
  pub buffer: xmlBufPtr,
  pub conv: xmlBufPtr,
  pub written: ::std::os::raw::c_int,
  pub error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__xmlOutputBuffer() {
  assert_eq!(
    ::std::mem::size_of::<_xmlOutputBuffer>(),
    56usize,
    concat!("Size of: ", stringify!(_xmlOutputBuffer))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlOutputBuffer>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlOutputBuffer))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlOutputBuffer>())).context as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlOutputBuffer),
      "::",
      stringify!(context)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlOutputBuffer>())).writecallback as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlOutputBuffer),
      "::",
      stringify!(writecallback)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlOutputBuffer>())).closecallback as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlOutputBuffer),
      "::",
      stringify!(closecallback)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlOutputBuffer>())).encoder as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlOutputBuffer),
      "::",
      stringify!(encoder)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlOutputBuffer>())).buffer as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlOutputBuffer),
      "::",
      stringify!(buffer)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlOutputBuffer>())).conv as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlOutputBuffer),
      "::",
      stringify!(conv)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlOutputBuffer>())).written as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlOutputBuffer),
      "::",
      stringify!(written)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlOutputBuffer>())).error as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlOutputBuffer),
      "::",
      stringify!(error)
    )
  );
}
extern "C" {
  pub fn xmlCleanupInputCallbacks();
}
extern "C" {
  pub fn xmlPopInputCallbacks() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlRegisterDefaultInputCallbacks();
}
extern "C" {
  pub fn xmlAllocParserInputBuffer(enc: xmlCharEncoding) -> xmlParserInputBufferPtr;
}
extern "C" {
  pub fn xmlParserInputBufferCreateFilename(
    URI: *const ::std::os::raw::c_char,
    enc: xmlCharEncoding,
  ) -> xmlParserInputBufferPtr;
}
extern "C" {
  pub fn xmlParserInputBufferCreateFile(
    file: *mut FILE,
    enc: xmlCharEncoding,
  ) -> xmlParserInputBufferPtr;
}
extern "C" {
  pub fn xmlParserInputBufferCreateFd(
    fd: ::std::os::raw::c_int,
    enc: xmlCharEncoding,
  ) -> xmlParserInputBufferPtr;
}
extern "C" {
  pub fn xmlParserInputBufferCreateMem(
    mem: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    enc: xmlCharEncoding,
  ) -> xmlParserInputBufferPtr;
}
extern "C" {
  pub fn xmlParserInputBufferCreateStatic(
    mem: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    enc: xmlCharEncoding,
  ) -> xmlParserInputBufferPtr;
}
extern "C" {
  pub fn xmlParserInputBufferCreateIO(
    ioread: xmlInputReadCallback,
    ioclose: xmlInputCloseCallback,
    ioctx: *mut ::std::os::raw::c_void,
    enc: xmlCharEncoding,
  ) -> xmlParserInputBufferPtr;
}
extern "C" {
  pub fn xmlParserInputBufferRead(
    in_: xmlParserInputBufferPtr,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlParserInputBufferGrow(
    in_: xmlParserInputBufferPtr,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlParserInputBufferPush(
    in_: xmlParserInputBufferPtr,
    len: ::std::os::raw::c_int,
    buf: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlFreeParserInputBuffer(in_: xmlParserInputBufferPtr);
}
extern "C" {
  pub fn xmlParserGetDirectory(
    filename: *const ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn xmlRegisterInputCallbacks(
    matchFunc: xmlInputMatchCallback,
    openFunc: xmlInputOpenCallback,
    readFunc: xmlInputReadCallback,
    closeFunc: xmlInputCloseCallback,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __xmlParserInputBufferCreateFilename(
    URI: *const ::std::os::raw::c_char,
    enc: xmlCharEncoding,
  ) -> xmlParserInputBufferPtr;
}
extern "C" {
  pub fn xmlCleanupOutputCallbacks();
}
extern "C" {
  pub fn xmlRegisterDefaultOutputCallbacks();
}
extern "C" {
  pub fn xmlAllocOutputBuffer(encoder: xmlCharEncodingHandlerPtr) -> xmlOutputBufferPtr;
}
extern "C" {
  pub fn xmlOutputBufferCreateFilename(
    URI: *const ::std::os::raw::c_char,
    encoder: xmlCharEncodingHandlerPtr,
    compression: ::std::os::raw::c_int,
  ) -> xmlOutputBufferPtr;
}
extern "C" {
  pub fn xmlOutputBufferCreateFile(
    file: *mut FILE,
    encoder: xmlCharEncodingHandlerPtr,
  ) -> xmlOutputBufferPtr;
}
extern "C" {
  pub fn xmlOutputBufferCreateBuffer(
    buffer: xmlBufferPtr,
    encoder: xmlCharEncodingHandlerPtr,
  ) -> xmlOutputBufferPtr;
}
extern "C" {
  pub fn xmlOutputBufferCreateFd(
    fd: ::std::os::raw::c_int,
    encoder: xmlCharEncodingHandlerPtr,
  ) -> xmlOutputBufferPtr;
}
extern "C" {
  pub fn xmlOutputBufferCreateIO(
    iowrite: xmlOutputWriteCallback,
    ioclose: xmlOutputCloseCallback,
    ioctx: *mut ::std::os::raw::c_void,
    encoder: xmlCharEncodingHandlerPtr,
  ) -> xmlOutputBufferPtr;
}
extern "C" {
  pub fn xmlOutputBufferGetContent(out: xmlOutputBufferPtr) -> *const xmlChar;
}
extern "C" {
  pub fn xmlOutputBufferGetSize(out: xmlOutputBufferPtr) -> usize;
}
extern "C" {
  pub fn xmlOutputBufferWrite(
    out: xmlOutputBufferPtr,
    len: ::std::os::raw::c_int,
    buf: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlOutputBufferWriteString(
    out: xmlOutputBufferPtr,
    str: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlOutputBufferWriteEscape(
    out: xmlOutputBufferPtr,
    str: *const xmlChar,
    escaping: xmlCharEncodingOutputFunc,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlOutputBufferFlush(out: xmlOutputBufferPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlOutputBufferClose(out: xmlOutputBufferPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlRegisterOutputCallbacks(
    matchFunc: xmlOutputMatchCallback,
    openFunc: xmlOutputOpenCallback,
    writeFunc: xmlOutputWriteCallback,
    closeFunc: xmlOutputCloseCallback,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn __xmlOutputBufferCreateFilename(
    URI: *const ::std::os::raw::c_char,
    encoder: xmlCharEncodingHandlerPtr,
    compression: ::std::os::raw::c_int,
  ) -> xmlOutputBufferPtr;
}
extern "C" {
  pub fn xmlRegisterHTTPPostCallbacks();
}
extern "C" {
  pub fn xmlCheckHTTPInput(ctxt: xmlParserCtxtPtr, ret: xmlParserInputPtr) -> xmlParserInputPtr;
}
extern "C" {
  pub fn xmlNoNetExternalEntityLoader(
    URL: *const ::std::os::raw::c_char,
    ID: *const ::std::os::raw::c_char,
    ctxt: xmlParserCtxtPtr,
  ) -> xmlParserInputPtr;
}
extern "C" {
  pub fn xmlNormalizeWindowsPath(path: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlCheckFilename(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  /// Default 'file://' protocol callbacks
  pub fn xmlFileMatch(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlFileOpen(filename: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlFileRead(
    context: *mut ::std::os::raw::c_void,
    buffer: *mut ::std::os::raw::c_char,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlFileClose(context: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlIOHTTPMatch(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlIOHTTPOpen(filename: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlIOHTTPOpenW(
    post_uri: *const ::std::os::raw::c_char,
    compression: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlIOHTTPRead(
    context: *mut ::std::os::raw::c_void,
    buffer: *mut ::std::os::raw::c_char,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlIOHTTPClose(context: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlIOFTPMatch(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlIOFTPOpen(filename: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlIOFTPRead(
    context: *mut ::std::os::raw::c_void,
    buffer: *mut ::std::os::raw::c_char,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlIOFTPClose(context: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlInitParser();
}
extern "C" {
  pub fn xmlCleanupParser();
}
extern "C" {
  pub fn xmlParserInputRead(
    in_: xmlParserInputPtr,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlParserInputGrow(
    in_: xmlParserInputPtr,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlParseDoc(cur: *const xmlChar) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlParseFile(filename: *const ::std::os::raw::c_char) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlParseMemory(
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlSubstituteEntitiesDefault(val: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlKeepBlanksDefault(val: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlStopParser(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlPedanticParserDefault(val: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlLineNumbersDefault(val: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlRecoverDoc(cur: *const xmlChar) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlRecoverMemory(
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlRecoverFile(filename: *const ::std::os::raw::c_char) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlParseDocument(ctxt: xmlParserCtxtPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlParseExtParsedEnt(ctxt: xmlParserCtxtPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSAXUserParseFile(
    sax: xmlSAXHandlerPtr,
    user_data: *mut ::std::os::raw::c_void,
    filename: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSAXUserParseMemory(
    sax: xmlSAXHandlerPtr,
    user_data: *mut ::std::os::raw::c_void,
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSAXParseDoc(
    sax: xmlSAXHandlerPtr,
    cur: *const xmlChar,
    recovery: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlSAXParseMemory(
    sax: xmlSAXHandlerPtr,
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    recovery: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlSAXParseMemoryWithData(
    sax: xmlSAXHandlerPtr,
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    recovery: ::std::os::raw::c_int,
    data: *mut ::std::os::raw::c_void,
  ) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlSAXParseFile(
    sax: xmlSAXHandlerPtr,
    filename: *const ::std::os::raw::c_char,
    recovery: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlSAXParseFileWithData(
    sax: xmlSAXHandlerPtr,
    filename: *const ::std::os::raw::c_char,
    recovery: ::std::os::raw::c_int,
    data: *mut ::std::os::raw::c_void,
  ) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlSAXParseEntity(
    sax: xmlSAXHandlerPtr,
    filename: *const ::std::os::raw::c_char,
  ) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlParseEntity(filename: *const ::std::os::raw::c_char) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlSAXParseDTD(
    sax: xmlSAXHandlerPtr,
    ExternalID: *const xmlChar,
    SystemID: *const xmlChar,
  ) -> xmlDtdPtr;
}
extern "C" {
  pub fn xmlParseDTD(ExternalID: *const xmlChar, SystemID: *const xmlChar) -> xmlDtdPtr;
}
extern "C" {
  pub fn xmlIOParseDTD(
    sax: xmlSAXHandlerPtr,
    input: xmlParserInputBufferPtr,
    enc: xmlCharEncoding,
  ) -> xmlDtdPtr;
}
extern "C" {
  pub fn xmlParseBalancedChunkMemory(
    doc: xmlDocPtr,
    sax: xmlSAXHandlerPtr,
    user_data: *mut ::std::os::raw::c_void,
    depth: ::std::os::raw::c_int,
    string: *const xmlChar,
    lst: *mut xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlParseInNodeContext(
    node: xmlNodePtr,
    data: *const ::std::os::raw::c_char,
    datalen: ::std::os::raw::c_int,
    options: ::std::os::raw::c_int,
    lst: *mut xmlNodePtr,
  ) -> xmlParserErrors;
}
extern "C" {
  pub fn xmlParseBalancedChunkMemoryRecover(
    doc: xmlDocPtr,
    sax: xmlSAXHandlerPtr,
    user_data: *mut ::std::os::raw::c_void,
    depth: ::std::os::raw::c_int,
    string: *const xmlChar,
    lst: *mut xmlNodePtr,
    recover: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlParseExternalEntity(
    doc: xmlDocPtr,
    sax: xmlSAXHandlerPtr,
    user_data: *mut ::std::os::raw::c_void,
    depth: ::std::os::raw::c_int,
    URL: *const xmlChar,
    ID: *const xmlChar,
    lst: *mut xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlParseCtxtExternalEntity(
    ctx: xmlParserCtxtPtr,
    URL: *const xmlChar,
    ID: *const xmlChar,
    lst: *mut xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNewParserCtxt() -> xmlParserCtxtPtr;
}
extern "C" {
  pub fn xmlInitParserCtxt(ctxt: xmlParserCtxtPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlClearParserCtxt(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlFreeParserCtxt(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlSetupParserForBuffer(
    ctxt: xmlParserCtxtPtr,
    buffer: *const xmlChar,
    filename: *const ::std::os::raw::c_char,
  );
}
extern "C" {
  pub fn xmlCreateDocParserCtxt(cur: *const xmlChar) -> xmlParserCtxtPtr;
}
extern "C" {
  pub fn xmlGetFeaturesList(
    len: *mut ::std::os::raw::c_int,
    result: *mut *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlGetFeature(
    ctxt: xmlParserCtxtPtr,
    name: *const ::std::os::raw::c_char,
    result: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSetFeature(
    ctxt: xmlParserCtxtPtr,
    name: *const ::std::os::raw::c_char,
    value: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlCreatePushParserCtxt(
    sax: xmlSAXHandlerPtr,
    user_data: *mut ::std::os::raw::c_void,
    chunk: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    filename: *const ::std::os::raw::c_char,
  ) -> xmlParserCtxtPtr;
}
extern "C" {
  pub fn xmlParseChunk(
    ctxt: xmlParserCtxtPtr,
    chunk: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    terminate: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlCreateIOParserCtxt(
    sax: xmlSAXHandlerPtr,
    user_data: *mut ::std::os::raw::c_void,
    ioread: xmlInputReadCallback,
    ioclose: xmlInputCloseCallback,
    ioctx: *mut ::std::os::raw::c_void,
    enc: xmlCharEncoding,
  ) -> xmlParserCtxtPtr;
}
extern "C" {
  pub fn xmlNewIOInputStream(
    ctxt: xmlParserCtxtPtr,
    input: xmlParserInputBufferPtr,
    enc: xmlCharEncoding,
  ) -> xmlParserInputPtr;
}
extern "C" {
  pub fn xmlParserFindNodeInfo(
    ctxt: xmlParserCtxtPtr,
    node: xmlNodePtr,
  ) -> *const xmlParserNodeInfo;
}
extern "C" {
  pub fn xmlInitNodeInfoSeq(seq: xmlParserNodeInfoSeqPtr);
}
extern "C" {
  pub fn xmlClearNodeInfoSeq(seq: xmlParserNodeInfoSeqPtr);
}
extern "C" {
  pub fn xmlParserFindNodeInfoIndex(
    seq: xmlParserNodeInfoSeqPtr,
    node: xmlNodePtr,
  ) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn xmlParserAddNodeInfo(ctxt: xmlParserCtxtPtr, info: xmlParserNodeInfoPtr);
}
extern "C" {
  pub fn xmlSetExternalEntityLoader(f: xmlExternalEntityLoader);
}
extern "C" {
  pub fn xmlGetExternalEntityLoader() -> xmlExternalEntityLoader;
}
extern "C" {
  pub fn xmlLoadExternalEntity(
    URL: *const ::std::os::raw::c_char,
    ID: *const ::std::os::raw::c_char,
    ctxt: xmlParserCtxtPtr,
  ) -> xmlParserInputPtr;
}
extern "C" {
  pub fn xmlByteConsumed(ctxt: xmlParserCtxtPtr) -> ::std::os::raw::c_long;
}
pub const xmlParserOption_XML_PARSE_RECOVER: xmlParserOption = 1;
pub const xmlParserOption_XML_PARSE_NOENT: xmlParserOption = 2;
pub const xmlParserOption_XML_PARSE_DTDLOAD: xmlParserOption = 4;
pub const xmlParserOption_XML_PARSE_DTDATTR: xmlParserOption = 8;
pub const xmlParserOption_XML_PARSE_DTDVALID: xmlParserOption = 16;
pub const xmlParserOption_XML_PARSE_NOERROR: xmlParserOption = 32;
pub const xmlParserOption_XML_PARSE_NOWARNING: xmlParserOption = 64;
pub const xmlParserOption_XML_PARSE_PEDANTIC: xmlParserOption = 128;
pub const xmlParserOption_XML_PARSE_NOBLANKS: xmlParserOption = 256;
pub const xmlParserOption_XML_PARSE_SAX1: xmlParserOption = 512;
pub const xmlParserOption_XML_PARSE_XINCLUDE: xmlParserOption = 1024;
pub const xmlParserOption_XML_PARSE_NONET: xmlParserOption = 2048;
pub const xmlParserOption_XML_PARSE_NODICT: xmlParserOption = 4096;
pub const xmlParserOption_XML_PARSE_NSCLEAN: xmlParserOption = 8192;
pub const xmlParserOption_XML_PARSE_NOCDATA: xmlParserOption = 16384;
pub const xmlParserOption_XML_PARSE_NOXINCNODE: xmlParserOption = 32768;
pub const xmlParserOption_XML_PARSE_COMPACT: xmlParserOption = 65536;
pub const xmlParserOption_XML_PARSE_OLD10: xmlParserOption = 131072;
pub const xmlParserOption_XML_PARSE_NOBASEFIX: xmlParserOption = 262144;
pub const xmlParserOption_XML_PARSE_HUGE: xmlParserOption = 524288;
pub const xmlParserOption_XML_PARSE_OLDSAX: xmlParserOption = 1048576;
pub const xmlParserOption_XML_PARSE_IGNORE_ENC: xmlParserOption = 2097152;
pub const xmlParserOption_XML_PARSE_BIG_LINES: xmlParserOption = 4194304;
/// xmlParserOption:
///
/// This is the set of XML parser options that can be passed down
/// to the xmlReadDoc() and similar calls.
pub type xmlParserOption = u32;
extern "C" {
  pub fn xmlCtxtReset(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlCtxtResetPush(
    ctxt: xmlParserCtxtPtr,
    chunk: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    filename: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlCtxtUseOptions(
    ctxt: xmlParserCtxtPtr,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlReadDoc(
    cur: *const xmlChar,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlReadFile(
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlReadMemory(
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlReadFd(
    fd: ::std::os::raw::c_int,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlReadIO(
    ioread: xmlInputReadCallback,
    ioclose: xmlInputCloseCallback,
    ioctx: *mut ::std::os::raw::c_void,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlCtxtReadDoc(
    ctxt: xmlParserCtxtPtr,
    cur: *const xmlChar,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlCtxtReadFile(
    ctxt: xmlParserCtxtPtr,
    filename: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlCtxtReadMemory(
    ctxt: xmlParserCtxtPtr,
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlCtxtReadFd(
    ctxt: xmlParserCtxtPtr,
    fd: ::std::os::raw::c_int,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlCtxtReadIO(
    ctxt: xmlParserCtxtPtr,
    ioread: xmlInputReadCallback,
    ioclose: xmlInputCloseCallback,
    ioctx: *mut ::std::os::raw::c_void,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlDocPtr;
}
pub const xmlFeature_XML_WITH_THREAD: xmlFeature = 1;
pub const xmlFeature_XML_WITH_TREE: xmlFeature = 2;
pub const xmlFeature_XML_WITH_OUTPUT: xmlFeature = 3;
pub const xmlFeature_XML_WITH_PUSH: xmlFeature = 4;
pub const xmlFeature_XML_WITH_READER: xmlFeature = 5;
pub const xmlFeature_XML_WITH_PATTERN: xmlFeature = 6;
pub const xmlFeature_XML_WITH_WRITER: xmlFeature = 7;
pub const xmlFeature_XML_WITH_SAX1: xmlFeature = 8;
pub const xmlFeature_XML_WITH_FTP: xmlFeature = 9;
pub const xmlFeature_XML_WITH_HTTP: xmlFeature = 10;
pub const xmlFeature_XML_WITH_VALID: xmlFeature = 11;
pub const xmlFeature_XML_WITH_HTML: xmlFeature = 12;
pub const xmlFeature_XML_WITH_LEGACY: xmlFeature = 13;
pub const xmlFeature_XML_WITH_C14N: xmlFeature = 14;
pub const xmlFeature_XML_WITH_CATALOG: xmlFeature = 15;
pub const xmlFeature_XML_WITH_XPATH: xmlFeature = 16;
pub const xmlFeature_XML_WITH_XPTR: xmlFeature = 17;
pub const xmlFeature_XML_WITH_XINCLUDE: xmlFeature = 18;
pub const xmlFeature_XML_WITH_ICONV: xmlFeature = 19;
pub const xmlFeature_XML_WITH_ISO8859X: xmlFeature = 20;
pub const xmlFeature_XML_WITH_UNICODE: xmlFeature = 21;
pub const xmlFeature_XML_WITH_REGEXP: xmlFeature = 22;
pub const xmlFeature_XML_WITH_AUTOMATA: xmlFeature = 23;
pub const xmlFeature_XML_WITH_EXPR: xmlFeature = 24;
pub const xmlFeature_XML_WITH_SCHEMAS: xmlFeature = 25;
pub const xmlFeature_XML_WITH_SCHEMATRON: xmlFeature = 26;
pub const xmlFeature_XML_WITH_MODULES: xmlFeature = 27;
pub const xmlFeature_XML_WITH_DEBUG: xmlFeature = 28;
pub const xmlFeature_XML_WITH_DEBUG_MEM: xmlFeature = 29;
pub const xmlFeature_XML_WITH_DEBUG_RUN: xmlFeature = 30;
pub const xmlFeature_XML_WITH_ZLIB: xmlFeature = 31;
pub const xmlFeature_XML_WITH_ICU: xmlFeature = 32;
pub const xmlFeature_XML_WITH_LZMA: xmlFeature = 33;
pub const xmlFeature_XML_WITH_NONE: xmlFeature = 99999;
/// xmlFeature:
///
/// Used to examine the existance of features that can be enabled
/// or disabled at compile-time.
/// They used to be called XML_FEATURE_xxx but this clashed with Expat
pub type xmlFeature = u32;
extern "C" {
  pub fn xmlHasFeature(feature: xmlFeature) -> ::std::os::raw::c_int;
}
pub type htmlParserCtxt = xmlParserCtxt;
pub type htmlParserCtxtPtr = xmlParserCtxtPtr;
pub type htmlParserNodeInfo = xmlParserNodeInfo;
pub type htmlSAXHandler = xmlSAXHandler;
pub type htmlSAXHandlerPtr = xmlSAXHandlerPtr;
pub type htmlParserInput = xmlParserInput;
pub type htmlParserInputPtr = xmlParserInputPtr;
pub type htmlDocPtr = xmlDocPtr;
pub type htmlNodePtr = xmlNodePtr;
pub type htmlElemDesc = _htmlElemDesc;
pub type htmlElemDescPtr = *mut htmlElemDesc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _htmlElemDesc {
  pub name: *const ::std::os::raw::c_char,
  pub startTag: ::std::os::raw::c_char,
  pub endTag: ::std::os::raw::c_char,
  pub saveEndTag: ::std::os::raw::c_char,
  pub empty: ::std::os::raw::c_char,
  pub depr: ::std::os::raw::c_char,
  pub dtd: ::std::os::raw::c_char,
  pub isinline: ::std::os::raw::c_char,
  pub desc: *const ::std::os::raw::c_char,
  pub subelts: *mut *const ::std::os::raw::c_char,
  pub defaultsubelt: *const ::std::os::raw::c_char,
  pub attrs_opt: *mut *const ::std::os::raw::c_char,
  pub attrs_depr: *mut *const ::std::os::raw::c_char,
  pub attrs_req: *mut *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__htmlElemDesc() {
  assert_eq!(
    ::std::mem::size_of::<_htmlElemDesc>(),
    64usize,
    concat!("Size of: ", stringify!(_htmlElemDesc))
  );
  assert_eq!(
    ::std::mem::align_of::<_htmlElemDesc>(),
    8usize,
    concat!("Alignment of ", stringify!(_htmlElemDesc))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_htmlElemDesc>())).name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_htmlElemDesc),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_htmlElemDesc>())).startTag as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_htmlElemDesc),
      "::",
      stringify!(startTag)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_htmlElemDesc>())).endTag as *const _ as usize },
    9usize,
    concat!(
      "Offset of field: ",
      stringify!(_htmlElemDesc),
      "::",
      stringify!(endTag)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_htmlElemDesc>())).saveEndTag as *const _ as usize },
    10usize,
    concat!(
      "Offset of field: ",
      stringify!(_htmlElemDesc),
      "::",
      stringify!(saveEndTag)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_htmlElemDesc>())).empty as *const _ as usize },
    11usize,
    concat!(
      "Offset of field: ",
      stringify!(_htmlElemDesc),
      "::",
      stringify!(empty)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_htmlElemDesc>())).depr as *const _ as usize },
    12usize,
    concat!(
      "Offset of field: ",
      stringify!(_htmlElemDesc),
      "::",
      stringify!(depr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_htmlElemDesc>())).dtd as *const _ as usize },
    13usize,
    concat!(
      "Offset of field: ",
      stringify!(_htmlElemDesc),
      "::",
      stringify!(dtd)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_htmlElemDesc>())).isinline as *const _ as usize },
    14usize,
    concat!(
      "Offset of field: ",
      stringify!(_htmlElemDesc),
      "::",
      stringify!(isinline)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_htmlElemDesc>())).desc as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_htmlElemDesc),
      "::",
      stringify!(desc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_htmlElemDesc>())).subelts as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_htmlElemDesc),
      "::",
      stringify!(subelts)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_htmlElemDesc>())).defaultsubelt as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_htmlElemDesc),
      "::",
      stringify!(defaultsubelt)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_htmlElemDesc>())).attrs_opt as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_htmlElemDesc),
      "::",
      stringify!(attrs_opt)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_htmlElemDesc>())).attrs_depr as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_htmlElemDesc),
      "::",
      stringify!(attrs_depr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_htmlElemDesc>())).attrs_req as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_htmlElemDesc),
      "::",
      stringify!(attrs_req)
    )
  );
}
pub type htmlEntityDesc = _htmlEntityDesc;
pub type htmlEntityDescPtr = *mut htmlEntityDesc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _htmlEntityDesc {
  pub value: ::std::os::raw::c_uint,
  pub name: *const ::std::os::raw::c_char,
  pub desc: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__htmlEntityDesc() {
  assert_eq!(
    ::std::mem::size_of::<_htmlEntityDesc>(),
    24usize,
    concat!("Size of: ", stringify!(_htmlEntityDesc))
  );
  assert_eq!(
    ::std::mem::align_of::<_htmlEntityDesc>(),
    8usize,
    concat!("Alignment of ", stringify!(_htmlEntityDesc))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_htmlEntityDesc>())).value as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_htmlEntityDesc),
      "::",
      stringify!(value)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_htmlEntityDesc>())).name as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_htmlEntityDesc),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_htmlEntityDesc>())).desc as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_htmlEntityDesc),
      "::",
      stringify!(desc)
    )
  );
}
extern "C" {
  pub fn htmlTagLookup(tag: *const xmlChar) -> *const htmlElemDesc;
}
extern "C" {
  pub fn htmlEntityLookup(name: *const xmlChar) -> *const htmlEntityDesc;
}
extern "C" {
  pub fn htmlEntityValueLookup(value: ::std::os::raw::c_uint) -> *const htmlEntityDesc;
}
extern "C" {
  pub fn htmlIsAutoClosed(doc: htmlDocPtr, elem: htmlNodePtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn htmlAutoCloseTag(
    doc: htmlDocPtr,
    name: *const xmlChar,
    elem: htmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn htmlParseEntityRef(
    ctxt: htmlParserCtxtPtr,
    str: *mut *const xmlChar,
  ) -> *const htmlEntityDesc;
}
extern "C" {
  pub fn htmlParseCharRef(ctxt: htmlParserCtxtPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn htmlParseElement(ctxt: htmlParserCtxtPtr);
}
extern "C" {
  pub fn htmlNewParserCtxt() -> htmlParserCtxtPtr;
}
extern "C" {
  pub fn htmlCreateMemoryParserCtxt(
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
  ) -> htmlParserCtxtPtr;
}
extern "C" {
  pub fn htmlParseDocument(ctxt: htmlParserCtxtPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn htmlSAXParseDoc(
    cur: *mut xmlChar,
    encoding: *const ::std::os::raw::c_char,
    sax: htmlSAXHandlerPtr,
    userData: *mut ::std::os::raw::c_void,
  ) -> htmlDocPtr;
}
extern "C" {
  pub fn htmlParseDoc(cur: *mut xmlChar, encoding: *const ::std::os::raw::c_char) -> htmlDocPtr;
}
extern "C" {
  pub fn htmlSAXParseFile(
    filename: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    sax: htmlSAXHandlerPtr,
    userData: *mut ::std::os::raw::c_void,
  ) -> htmlDocPtr;
}
extern "C" {
  pub fn htmlParseFile(
    filename: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
  ) -> htmlDocPtr;
}
extern "C" {
  pub fn UTF8ToHtml(
    out: *mut ::std::os::raw::c_uchar,
    outlen: *mut ::std::os::raw::c_int,
    in_: *const ::std::os::raw::c_uchar,
    inlen: *mut ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn htmlEncodeEntities(
    out: *mut ::std::os::raw::c_uchar,
    outlen: *mut ::std::os::raw::c_int,
    in_: *const ::std::os::raw::c_uchar,
    inlen: *mut ::std::os::raw::c_int,
    quoteChar: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn htmlIsScriptAttribute(name: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn htmlHandleOmittedElem(val: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  /// Interfaces for the Push mode.
  pub fn htmlCreatePushParserCtxt(
    sax: htmlSAXHandlerPtr,
    user_data: *mut ::std::os::raw::c_void,
    chunk: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    filename: *const ::std::os::raw::c_char,
    enc: xmlCharEncoding,
  ) -> htmlParserCtxtPtr;
}
extern "C" {
  pub fn htmlParseChunk(
    ctxt: htmlParserCtxtPtr,
    chunk: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    terminate: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn htmlFreeParserCtxt(ctxt: htmlParserCtxtPtr);
}
pub const htmlParserOption_HTML_PARSE_RECOVER: htmlParserOption = 1;
pub const htmlParserOption_HTML_PARSE_NODEFDTD: htmlParserOption = 4;
pub const htmlParserOption_HTML_PARSE_NOERROR: htmlParserOption = 32;
pub const htmlParserOption_HTML_PARSE_NOWARNING: htmlParserOption = 64;
pub const htmlParserOption_HTML_PARSE_PEDANTIC: htmlParserOption = 128;
pub const htmlParserOption_HTML_PARSE_NOBLANKS: htmlParserOption = 256;
pub const htmlParserOption_HTML_PARSE_NONET: htmlParserOption = 2048;
pub const htmlParserOption_HTML_PARSE_NOIMPLIED: htmlParserOption = 8192;
pub const htmlParserOption_HTML_PARSE_COMPACT: htmlParserOption = 65536;
pub const htmlParserOption_HTML_PARSE_IGNORE_ENC: htmlParserOption = 2097152;
/// xmlParserOption:
///
/// This is the set of XML parser options that can be passed down
/// to the xmlReadDoc() and similar calls.
pub type htmlParserOption = u32;
extern "C" {
  pub fn htmlCtxtReset(ctxt: htmlParserCtxtPtr);
}
extern "C" {
  pub fn htmlCtxtUseOptions(
    ctxt: htmlParserCtxtPtr,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn htmlReadDoc(
    cur: *const xmlChar,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> htmlDocPtr;
}
extern "C" {
  pub fn htmlReadFile(
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> htmlDocPtr;
}
extern "C" {
  pub fn htmlReadMemory(
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> htmlDocPtr;
}
extern "C" {
  pub fn htmlReadFd(
    fd: ::std::os::raw::c_int,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> htmlDocPtr;
}
extern "C" {
  pub fn htmlReadIO(
    ioread: xmlInputReadCallback,
    ioclose: xmlInputCloseCallback,
    ioctx: *mut ::std::os::raw::c_void,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> htmlDocPtr;
}
extern "C" {
  pub fn htmlCtxtReadDoc(
    ctxt: xmlParserCtxtPtr,
    cur: *const xmlChar,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> htmlDocPtr;
}
extern "C" {
  pub fn htmlCtxtReadFile(
    ctxt: xmlParserCtxtPtr,
    filename: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> htmlDocPtr;
}
extern "C" {
  pub fn htmlCtxtReadMemory(
    ctxt: xmlParserCtxtPtr,
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> htmlDocPtr;
}
extern "C" {
  pub fn htmlCtxtReadFd(
    ctxt: xmlParserCtxtPtr,
    fd: ::std::os::raw::c_int,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> htmlDocPtr;
}
extern "C" {
  pub fn htmlCtxtReadIO(
    ctxt: xmlParserCtxtPtr,
    ioread: xmlInputReadCallback,
    ioclose: xmlInputCloseCallback,
    ioctx: *mut ::std::os::raw::c_void,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> htmlDocPtr;
}
pub const htmlStatus_HTML_NA: htmlStatus = 0;
pub const htmlStatus_HTML_INVALID: htmlStatus = 1;
pub const htmlStatus_HTML_DEPRECATED: htmlStatus = 2;
pub const htmlStatus_HTML_VALID: htmlStatus = 4;
pub const htmlStatus_HTML_REQUIRED: htmlStatus = 12;
pub type htmlStatus = u32;
extern "C" {
  pub fn htmlAttrAllowed(
    arg1: *const htmlElemDesc,
    arg2: *const xmlChar,
    arg3: ::std::os::raw::c_int,
  ) -> htmlStatus;
}
extern "C" {
  pub fn htmlElementAllowedHere(
    arg1: *const htmlElemDesc,
    arg2: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn htmlElementStatusHere(arg1: *const htmlElemDesc, arg2: *const htmlElemDesc) -> htmlStatus;
}
extern "C" {
  pub fn htmlNodeStatus(arg1: htmlNodePtr, arg2: ::std::os::raw::c_int) -> htmlStatus;
}
pub type xmlChSRange = _xmlChSRange;
pub type xmlChSRangePtr = *mut xmlChSRange;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlChSRange {
  pub low: ::std::os::raw::c_ushort,
  pub high: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__xmlChSRange() {
  assert_eq!(
    ::std::mem::size_of::<_xmlChSRange>(),
    4usize,
    concat!("Size of: ", stringify!(_xmlChSRange))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlChSRange>(),
    2usize,
    concat!("Alignment of ", stringify!(_xmlChSRange))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlChSRange>())).low as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlChSRange),
      "::",
      stringify!(low)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlChSRange>())).high as *const _ as usize },
    2usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlChSRange),
      "::",
      stringify!(high)
    )
  );
}
pub type xmlChLRange = _xmlChLRange;
pub type xmlChLRangePtr = *mut xmlChLRange;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlChLRange {
  pub low: ::std::os::raw::c_uint,
  pub high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__xmlChLRange() {
  assert_eq!(
    ::std::mem::size_of::<_xmlChLRange>(),
    8usize,
    concat!("Size of: ", stringify!(_xmlChLRange))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlChLRange>(),
    4usize,
    concat!("Alignment of ", stringify!(_xmlChLRange))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlChLRange>())).low as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlChLRange),
      "::",
      stringify!(low)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlChLRange>())).high as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlChLRange),
      "::",
      stringify!(high)
    )
  );
}
pub type xmlChRangeGroup = _xmlChRangeGroup;
pub type xmlChRangeGroupPtr = *mut xmlChRangeGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlChRangeGroup {
  pub nbShortRange: ::std::os::raw::c_int,
  pub nbLongRange: ::std::os::raw::c_int,
  pub shortRange: *const xmlChSRange,
  pub longRange: *const xmlChLRange,
}
#[test]
fn bindgen_test_layout__xmlChRangeGroup() {
  assert_eq!(
    ::std::mem::size_of::<_xmlChRangeGroup>(),
    24usize,
    concat!("Size of: ", stringify!(_xmlChRangeGroup))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlChRangeGroup>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlChRangeGroup))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlChRangeGroup>())).nbShortRange as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlChRangeGroup),
      "::",
      stringify!(nbShortRange)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlChRangeGroup>())).nbLongRange as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlChRangeGroup),
      "::",
      stringify!(nbLongRange)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlChRangeGroup>())).shortRange as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlChRangeGroup),
      "::",
      stringify!(shortRange)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlChRangeGroup>())).longRange as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlChRangeGroup),
      "::",
      stringify!(longRange)
    )
  );
}
extern "C" {
  /// Range checking routine
  pub fn xmlCharInRange(
    val: ::std::os::raw::c_uint,
    group: *const xmlChRangeGroup,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}xmlIsBaseCharGroup"]
  pub static mut xmlIsBaseCharGroup: xmlChRangeGroup;
}
extern "C" {
  #[link_name = "\u{1}xmlIsCharGroup"]
  pub static mut xmlIsCharGroup: xmlChRangeGroup;
}
extern "C" {
  #[link_name = "\u{1}xmlIsCombiningGroup"]
  pub static mut xmlIsCombiningGroup: xmlChRangeGroup;
}
extern "C" {
  #[link_name = "\u{1}xmlIsDigitGroup"]
  pub static mut xmlIsDigitGroup: xmlChRangeGroup;
}
extern "C" {
  #[link_name = "\u{1}xmlIsExtenderGroup"]
  pub static mut xmlIsExtenderGroup: xmlChRangeGroup;
}
extern "C" {
  #[link_name = "\u{1}xmlIsIdeographicGroup"]
  pub static mut xmlIsIdeographicGroup: xmlChRangeGroup;
}
extern "C" {
  #[link_name = "\u{1}xmlIsPubidChar_tab"]
  pub static mut xmlIsPubidChar_tab: [::std::os::raw::c_uchar; 256usize];
}
extern "C" {
  pub fn xmlIsBaseChar(ch: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlIsBlank(ch: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlIsChar(ch: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlIsCombining(ch: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlIsDigit(ch: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlIsExtender(ch: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlIsIdeographic(ch: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlIsPubidChar(ch: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
  #[link_name = "\u{1}xmlParserMaxDepth"]
  pub static mut xmlParserMaxDepth: ::std::os::raw::c_uint;
}
extern "C" {
  #[link_name = "\u{1}xmlStringText"]
  pub static mut xmlStringText: [xmlChar; 0usize];
}
extern "C" {
  #[link_name = "\u{1}xmlStringTextNoenc"]
  pub static mut xmlStringTextNoenc: [xmlChar; 0usize];
}
extern "C" {
  #[link_name = "\u{1}xmlStringComment"]
  pub static mut xmlStringComment: [xmlChar; 0usize];
}
extern "C" {
  pub fn xmlIsLetter(c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  /// Parser context.
  pub fn xmlCreateFileParserCtxt(filename: *const ::std::os::raw::c_char) -> xmlParserCtxtPtr;
}
extern "C" {
  pub fn xmlCreateURLParserCtxt(
    filename: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlParserCtxtPtr;
}
extern "C" {
  pub fn xmlCreateMemoryParserCtxt(
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
  ) -> xmlParserCtxtPtr;
}
extern "C" {
  pub fn xmlCreateEntityParserCtxt(
    URL: *const xmlChar,
    ID: *const xmlChar,
    base: *const xmlChar,
  ) -> xmlParserCtxtPtr;
}
extern "C" {
  pub fn xmlSwitchEncoding(ctxt: xmlParserCtxtPtr, enc: xmlCharEncoding) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSwitchToEncoding(
    ctxt: xmlParserCtxtPtr,
    handler: xmlCharEncodingHandlerPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSwitchInputEncoding(
    ctxt: xmlParserCtxtPtr,
    input: xmlParserInputPtr,
    handler: xmlCharEncodingHandlerPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  /// Input Streams.
  pub fn xmlNewStringInputStream(
    ctxt: xmlParserCtxtPtr,
    buffer: *const xmlChar,
  ) -> xmlParserInputPtr;
}
extern "C" {
  pub fn xmlNewEntityInputStream(ctxt: xmlParserCtxtPtr, entity: xmlEntityPtr)
    -> xmlParserInputPtr;
}
extern "C" {
  pub fn xmlPushInput(ctxt: xmlParserCtxtPtr, input: xmlParserInputPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlPopInput(ctxt: xmlParserCtxtPtr) -> xmlChar;
}
extern "C" {
  pub fn xmlFreeInputStream(input: xmlParserInputPtr);
}
extern "C" {
  pub fn xmlNewInputFromFile(
    ctxt: xmlParserCtxtPtr,
    filename: *const ::std::os::raw::c_char,
  ) -> xmlParserInputPtr;
}
extern "C" {
  pub fn xmlNewInputStream(ctxt: xmlParserCtxtPtr) -> xmlParserInputPtr;
}
extern "C" {
  /// Namespaces.
  pub fn xmlSplitQName(
    ctxt: xmlParserCtxtPtr,
    name: *const xmlChar,
    prefix: *mut *mut xmlChar,
  ) -> *mut xmlChar;
}
extern "C" {
  /// Generic production rules.
  pub fn xmlParseName(ctxt: xmlParserCtxtPtr) -> *const xmlChar;
}
extern "C" {
  pub fn xmlParseNmtoken(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlParseEntityValue(ctxt: xmlParserCtxtPtr, orig: *mut *mut xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlParseAttValue(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlParseSystemLiteral(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlParsePubidLiteral(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlParseCharData(ctxt: xmlParserCtxtPtr, cdata: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlParseExternalID(
    ctxt: xmlParserCtxtPtr,
    publicID: *mut *mut xmlChar,
    strict: ::std::os::raw::c_int,
  ) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlParseComment(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlParsePITarget(ctxt: xmlParserCtxtPtr) -> *const xmlChar;
}
extern "C" {
  pub fn xmlParsePI(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlParseNotationDecl(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlParseEntityDecl(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlParseDefaultDecl(
    ctxt: xmlParserCtxtPtr,
    value: *mut *mut xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlParseNotationType(ctxt: xmlParserCtxtPtr) -> xmlEnumerationPtr;
}
extern "C" {
  pub fn xmlParseEnumerationType(ctxt: xmlParserCtxtPtr) -> xmlEnumerationPtr;
}
extern "C" {
  pub fn xmlParseEnumeratedType(
    ctxt: xmlParserCtxtPtr,
    tree: *mut xmlEnumerationPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlParseAttributeType(
    ctxt: xmlParserCtxtPtr,
    tree: *mut xmlEnumerationPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlParseAttributeListDecl(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlParseElementMixedContentDecl(
    ctxt: xmlParserCtxtPtr,
    inputchk: ::std::os::raw::c_int,
  ) -> xmlElementContentPtr;
}
extern "C" {
  pub fn xmlParseElementChildrenContentDecl(
    ctxt: xmlParserCtxtPtr,
    inputchk: ::std::os::raw::c_int,
  ) -> xmlElementContentPtr;
}
extern "C" {
  pub fn xmlParseElementContentDecl(
    ctxt: xmlParserCtxtPtr,
    name: *const xmlChar,
    result: *mut xmlElementContentPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlParseElementDecl(ctxt: xmlParserCtxtPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlParseMarkupDecl(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlParseCharRef(ctxt: xmlParserCtxtPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlParseEntityRef(ctxt: xmlParserCtxtPtr) -> xmlEntityPtr;
}
extern "C" {
  pub fn xmlParseReference(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlParsePEReference(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlParseDocTypeDecl(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlParseAttribute(ctxt: xmlParserCtxtPtr, value: *mut *mut xmlChar) -> *const xmlChar;
}
extern "C" {
  pub fn xmlParseStartTag(ctxt: xmlParserCtxtPtr) -> *const xmlChar;
}
extern "C" {
  pub fn xmlParseEndTag(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlParseCDSect(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlParseContent(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlParseElement(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlParseVersionNum(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlParseVersionInfo(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlParseEncName(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlParseEncodingDecl(ctxt: xmlParserCtxtPtr) -> *const xmlChar;
}
extern "C" {
  pub fn xmlParseSDDecl(ctxt: xmlParserCtxtPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlParseXMLDecl(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlParseTextDecl(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlParseMisc(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlParseExternalSubset(
    ctxt: xmlParserCtxtPtr,
    ExternalID: *const xmlChar,
    SystemID: *const xmlChar,
  );
}
extern "C" {
  pub fn xmlStringDecodeEntities(
    ctxt: xmlParserCtxtPtr,
    str: *const xmlChar,
    what: ::std::os::raw::c_int,
    end: xmlChar,
    end2: xmlChar,
    end3: xmlChar,
  ) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlStringLenDecodeEntities(
    ctxt: xmlParserCtxtPtr,
    str: *const xmlChar,
    len: ::std::os::raw::c_int,
    what: ::std::os::raw::c_int,
    end: xmlChar,
    end2: xmlChar,
    end3: xmlChar,
  ) -> *mut xmlChar;
}
extern "C" {
  pub fn nodePush(ctxt: xmlParserCtxtPtr, value: xmlNodePtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn nodePop(ctxt: xmlParserCtxtPtr) -> xmlNodePtr;
}
extern "C" {
  pub fn inputPush(ctxt: xmlParserCtxtPtr, value: xmlParserInputPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn inputPop(ctxt: xmlParserCtxtPtr) -> xmlParserInputPtr;
}
extern "C" {
  pub fn namePop(ctxt: xmlParserCtxtPtr) -> *const xmlChar;
}
extern "C" {
  pub fn namePush(ctxt: xmlParserCtxtPtr, value: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSkipBlankChars(ctxt: xmlParserCtxtPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlStringCurrentChar(
    ctxt: xmlParserCtxtPtr,
    cur: *const xmlChar,
    len: *mut ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlParserHandlePEReference(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlCheckLanguageID(lang: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlCurrentChar(
    ctxt: xmlParserCtxtPtr,
    len: *mut ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlCopyCharMultiByte(
    out: *mut xmlChar,
    val: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlCopyChar(
    len: ::std::os::raw::c_int,
    out: *mut xmlChar,
    val: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNextChar(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlParserInputShrink(in_: xmlParserInputPtr);
}
extern "C" {
  pub fn htmlInitAutoClose();
}
extern "C" {
  pub fn htmlCreateFileParserCtxt(
    filename: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
  ) -> htmlParserCtxtPtr;
}
/// xmlEntityReferenceFunc:
/// @ent: the entity
/// @firstNode:  the fist node in the chunk
/// @lastNode:  the last nod in the chunk
///
/// Callback function used when one needs to be able to track back the
/// provenance of a chunk of nodes inherited from an entity replacement.
pub type xmlEntityReferenceFunc = ::std::option::Option<
  unsafe extern "C" fn(ent: xmlEntityPtr, firstNode: xmlNodePtr, lastNode: xmlNodePtr),
>;
extern "C" {
  pub fn xmlSetEntityReferenceFunc(func: xmlEntityReferenceFunc);
}
extern "C" {
  pub fn xmlParseQuotedString(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlParseNamespace(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlNamespaceParseNSDef(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlScanName(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlNamespaceParseNCName(ctxt: xmlParserCtxtPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlParserHandleReference(ctxt: xmlParserCtxtPtr);
}
extern "C" {
  pub fn xmlNamespaceParseQName(ctxt: xmlParserCtxtPtr, prefix: *mut *mut xmlChar) -> *mut xmlChar;
}
extern "C" {
  /// Entities
  pub fn xmlDecodeEntities(
    ctxt: xmlParserCtxtPtr,
    len: ::std::os::raw::c_int,
    what: ::std::os::raw::c_int,
    end: xmlChar,
    end2: xmlChar,
    end3: xmlChar,
  ) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlHandleEntity(ctxt: xmlParserCtxtPtr, entity: xmlEntityPtr);
}
pub type docbParserCtxt = xmlParserCtxt;
pub type docbParserCtxtPtr = xmlParserCtxtPtr;
pub type docbSAXHandler = xmlSAXHandler;
pub type docbSAXHandlerPtr = xmlSAXHandlerPtr;
pub type docbParserInput = xmlParserInput;
pub type docbParserInputPtr = xmlParserInputPtr;
pub type docbDocPtr = xmlDocPtr;
extern "C" {
  pub fn docbEncodeEntities(
    out: *mut ::std::os::raw::c_uchar,
    outlen: *mut ::std::os::raw::c_int,
    in_: *const ::std::os::raw::c_uchar,
    inlen: *mut ::std::os::raw::c_int,
    quoteChar: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn docbSAXParseDoc(
    cur: *mut xmlChar,
    encoding: *const ::std::os::raw::c_char,
    sax: docbSAXHandlerPtr,
    userData: *mut ::std::os::raw::c_void,
  ) -> docbDocPtr;
}
extern "C" {
  pub fn docbParseDoc(cur: *mut xmlChar, encoding: *const ::std::os::raw::c_char) -> docbDocPtr;
}
extern "C" {
  pub fn docbSAXParseFile(
    filename: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    sax: docbSAXHandlerPtr,
    userData: *mut ::std::os::raw::c_void,
  ) -> docbDocPtr;
}
extern "C" {
  pub fn docbParseFile(
    filename: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
  ) -> docbDocPtr;
}
extern "C" {
  /// Interfaces for the Push mode.
  pub fn docbFreeParserCtxt(ctxt: docbParserCtxtPtr);
}
extern "C" {
  pub fn docbCreatePushParserCtxt(
    sax: docbSAXHandlerPtr,
    user_data: *mut ::std::os::raw::c_void,
    chunk: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    filename: *const ::std::os::raw::c_char,
    enc: xmlCharEncoding,
  ) -> docbParserCtxtPtr;
}
extern "C" {
  pub fn docbParseChunk(
    ctxt: docbParserCtxtPtr,
    chunk: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    terminate: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn docbCreateFileParserCtxt(
    filename: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
  ) -> docbParserCtxtPtr;
}
extern "C" {
  pub fn docbParseDocument(ctxt: docbParserCtxtPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn htmlNewDoc(URI: *const xmlChar, ExternalID: *const xmlChar) -> htmlDocPtr;
}
extern "C" {
  pub fn htmlNewDocNoDtD(URI: *const xmlChar, ExternalID: *const xmlChar) -> htmlDocPtr;
}
extern "C" {
  pub fn htmlGetMetaEncoding(doc: htmlDocPtr) -> *const xmlChar;
}
extern "C" {
  pub fn htmlSetMetaEncoding(doc: htmlDocPtr, encoding: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn htmlDocDumpMemory(
    cur: xmlDocPtr,
    mem: *mut *mut xmlChar,
    size: *mut ::std::os::raw::c_int,
  );
}
extern "C" {
  pub fn htmlDocDumpMemoryFormat(
    cur: xmlDocPtr,
    mem: *mut *mut xmlChar,
    size: *mut ::std::os::raw::c_int,
    format: ::std::os::raw::c_int,
  );
}
extern "C" {
  pub fn htmlDocDump(f: *mut FILE, cur: xmlDocPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn htmlSaveFile(
    filename: *const ::std::os::raw::c_char,
    cur: xmlDocPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn htmlNodeDump(buf: xmlBufferPtr, doc: xmlDocPtr, cur: xmlNodePtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn htmlNodeDumpFile(out: *mut FILE, doc: xmlDocPtr, cur: xmlNodePtr);
}
extern "C" {
  pub fn htmlNodeDumpFileFormat(
    out: *mut FILE,
    doc: xmlDocPtr,
    cur: xmlNodePtr,
    encoding: *const ::std::os::raw::c_char,
    format: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn htmlSaveFileEnc(
    filename: *const ::std::os::raw::c_char,
    cur: xmlDocPtr,
    encoding: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn htmlSaveFileFormat(
    filename: *const ::std::os::raw::c_char,
    cur: xmlDocPtr,
    encoding: *const ::std::os::raw::c_char,
    format: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn htmlNodeDumpFormatOutput(
    buf: xmlOutputBufferPtr,
    doc: xmlDocPtr,
    cur: xmlNodePtr,
    encoding: *const ::std::os::raw::c_char,
    format: ::std::os::raw::c_int,
  );
}
extern "C" {
  pub fn htmlDocContentDumpOutput(
    buf: xmlOutputBufferPtr,
    cur: xmlDocPtr,
    encoding: *const ::std::os::raw::c_char,
  );
}
extern "C" {
  pub fn htmlDocContentDumpFormatOutput(
    buf: xmlOutputBufferPtr,
    cur: xmlDocPtr,
    encoding: *const ::std::os::raw::c_char,
    format: ::std::os::raw::c_int,
  );
}
extern "C" {
  pub fn htmlNodeDumpOutput(
    buf: xmlOutputBufferPtr,
    doc: xmlDocPtr,
    cur: xmlNodePtr,
    encoding: *const ::std::os::raw::c_char,
  );
}
extern "C" {
  pub fn htmlIsBooleanAttr(name: *const xmlChar) -> ::std::os::raw::c_int;
}
pub type xmlXPathContext = _xmlXPathContext;
pub type xmlXPathContextPtr = *mut xmlXPathContext;
pub type xmlXPathParserContext = _xmlXPathParserContext;
pub type xmlXPathParserContextPtr = *mut xmlXPathParserContext;
pub const xmlXPathError_XPATH_EXPRESSION_OK: xmlXPathError = 0;
pub const xmlXPathError_XPATH_NUMBER_ERROR: xmlXPathError = 1;
pub const xmlXPathError_XPATH_UNFINISHED_LITERAL_ERROR: xmlXPathError = 2;
pub const xmlXPathError_XPATH_START_LITERAL_ERROR: xmlXPathError = 3;
pub const xmlXPathError_XPATH_VARIABLE_REF_ERROR: xmlXPathError = 4;
pub const xmlXPathError_XPATH_UNDEF_VARIABLE_ERROR: xmlXPathError = 5;
pub const xmlXPathError_XPATH_INVALID_PREDICATE_ERROR: xmlXPathError = 6;
pub const xmlXPathError_XPATH_EXPR_ERROR: xmlXPathError = 7;
pub const xmlXPathError_XPATH_UNCLOSED_ERROR: xmlXPathError = 8;
pub const xmlXPathError_XPATH_UNKNOWN_FUNC_ERROR: xmlXPathError = 9;
pub const xmlXPathError_XPATH_INVALID_OPERAND: xmlXPathError = 10;
pub const xmlXPathError_XPATH_INVALID_TYPE: xmlXPathError = 11;
pub const xmlXPathError_XPATH_INVALID_ARITY: xmlXPathError = 12;
pub const xmlXPathError_XPATH_INVALID_CTXT_SIZE: xmlXPathError = 13;
pub const xmlXPathError_XPATH_INVALID_CTXT_POSITION: xmlXPathError = 14;
pub const xmlXPathError_XPATH_MEMORY_ERROR: xmlXPathError = 15;
pub const xmlXPathError_XPTR_SYNTAX_ERROR: xmlXPathError = 16;
pub const xmlXPathError_XPTR_RESOURCE_ERROR: xmlXPathError = 17;
pub const xmlXPathError_XPTR_SUB_RESOURCE_ERROR: xmlXPathError = 18;
pub const xmlXPathError_XPATH_UNDEF_PREFIX_ERROR: xmlXPathError = 19;
pub const xmlXPathError_XPATH_ENCODING_ERROR: xmlXPathError = 20;
pub const xmlXPathError_XPATH_INVALID_CHAR_ERROR: xmlXPathError = 21;
pub const xmlXPathError_XPATH_INVALID_CTXT: xmlXPathError = 22;
pub const xmlXPathError_XPATH_STACK_ERROR: xmlXPathError = 23;
pub const xmlXPathError_XPATH_FORBID_VARIABLE_ERROR: xmlXPathError = 24;
/// The set of XPath error codes.
pub type xmlXPathError = u32;
pub type xmlNodeSet = _xmlNodeSet;
pub type xmlNodeSetPtr = *mut xmlNodeSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlNodeSet {
  pub nodeNr: ::std::os::raw::c_int,
  pub nodeMax: ::std::os::raw::c_int,
  pub nodeTab: *mut xmlNodePtr,
}
#[test]
fn bindgen_test_layout__xmlNodeSet() {
  assert_eq!(
    ::std::mem::size_of::<_xmlNodeSet>(),
    16usize,
    concat!("Size of: ", stringify!(_xmlNodeSet))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlNodeSet>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlNodeSet))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNodeSet>())).nodeNr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNodeSet),
      "::",
      stringify!(nodeNr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNodeSet>())).nodeMax as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNodeSet),
      "::",
      stringify!(nodeMax)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlNodeSet>())).nodeTab as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlNodeSet),
      "::",
      stringify!(nodeTab)
    )
  );
}
pub const xmlXPathObjectType_XPATH_UNDEFINED: xmlXPathObjectType = 0;
pub const xmlXPathObjectType_XPATH_NODESET: xmlXPathObjectType = 1;
pub const xmlXPathObjectType_XPATH_BOOLEAN: xmlXPathObjectType = 2;
pub const xmlXPathObjectType_XPATH_NUMBER: xmlXPathObjectType = 3;
pub const xmlXPathObjectType_XPATH_STRING: xmlXPathObjectType = 4;
pub const xmlXPathObjectType_XPATH_POINT: xmlXPathObjectType = 5;
pub const xmlXPathObjectType_XPATH_RANGE: xmlXPathObjectType = 6;
pub const xmlXPathObjectType_XPATH_LOCATIONSET: xmlXPathObjectType = 7;
pub const xmlXPathObjectType_XPATH_USERS: xmlXPathObjectType = 8;
pub const xmlXPathObjectType_XPATH_XSLT_TREE: xmlXPathObjectType = 9;
pub type xmlXPathObjectType = u32;
pub type xmlXPathObject = _xmlXPathObject;
pub type xmlXPathObjectPtr = *mut xmlXPathObject;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathObject {
  pub type_: xmlXPathObjectType,
  pub nodesetval: xmlNodeSetPtr,
  pub boolval: ::std::os::raw::c_int,
  pub floatval: f64,
  pub stringval: *mut xmlChar,
  pub user: *mut ::std::os::raw::c_void,
  pub index: ::std::os::raw::c_int,
  pub user2: *mut ::std::os::raw::c_void,
  pub index2: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__xmlXPathObject() {
  assert_eq!(
    ::std::mem::size_of::<_xmlXPathObject>(),
    72usize,
    concat!("Size of: ", stringify!(_xmlXPathObject))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlXPathObject>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlXPathObject))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathObject>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathObject),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathObject>())).nodesetval as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathObject),
      "::",
      stringify!(nodesetval)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathObject>())).boolval as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathObject),
      "::",
      stringify!(boolval)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathObject>())).floatval as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathObject),
      "::",
      stringify!(floatval)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathObject>())).stringval as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathObject),
      "::",
      stringify!(stringval)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathObject>())).user as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathObject),
      "::",
      stringify!(user)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathObject>())).index as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathObject),
      "::",
      stringify!(index)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathObject>())).user2 as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathObject),
      "::",
      stringify!(user2)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathObject>())).index2 as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathObject),
      "::",
      stringify!(index2)
    )
  );
}
/// xmlXPathConvertFunc:
/// @obj:  an XPath object
/// @type:  the number of the target type
///
/// A conversion function is associated to a type and used to cast
/// the new type to primitive values.
///
/// Returns -1 in case of error, 0 otherwise
pub type xmlXPathConvertFunc = ::std::option::Option<
  unsafe extern "C" fn(obj: xmlXPathObjectPtr, type_: ::std::os::raw::c_int)
    -> ::std::os::raw::c_int,
>;
pub type xmlXPathType = _xmlXPathType;
pub type xmlXPathTypePtr = *mut xmlXPathType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathType {
  pub name: *const xmlChar,
  pub func: xmlXPathConvertFunc,
}
#[test]
fn bindgen_test_layout__xmlXPathType() {
  assert_eq!(
    ::std::mem::size_of::<_xmlXPathType>(),
    16usize,
    concat!("Size of: ", stringify!(_xmlXPathType))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlXPathType>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlXPathType))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathType>())).name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathType),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathType>())).func as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathType),
      "::",
      stringify!(func)
    )
  );
}
pub type xmlXPathVariable = _xmlXPathVariable;
pub type xmlXPathVariablePtr = *mut xmlXPathVariable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathVariable {
  pub name: *const xmlChar,
  pub value: xmlXPathObjectPtr,
}
#[test]
fn bindgen_test_layout__xmlXPathVariable() {
  assert_eq!(
    ::std::mem::size_of::<_xmlXPathVariable>(),
    16usize,
    concat!("Size of: ", stringify!(_xmlXPathVariable))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlXPathVariable>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlXPathVariable))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathVariable>())).name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathVariable),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathVariable>())).value as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathVariable),
      "::",
      stringify!(value)
    )
  );
}
/// xmlXPathEvalFunc:
/// @ctxt: an XPath parser context
/// @nargs: the number of arguments passed to the function
///
/// An XPath evaluation function, the parameters are on the XPath context stack.
pub type xmlXPathEvalFunc = ::std::option::Option<
  unsafe extern "C" fn(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int),
>;
pub type xmlXPathFunct = _xmlXPathFunct;
pub type xmlXPathFuncPtr = *mut xmlXPathFunct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathFunct {
  pub name: *const xmlChar,
  pub func: xmlXPathEvalFunc,
}
#[test]
fn bindgen_test_layout__xmlXPathFunct() {
  assert_eq!(
    ::std::mem::size_of::<_xmlXPathFunct>(),
    16usize,
    concat!("Size of: ", stringify!(_xmlXPathFunct))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlXPathFunct>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlXPathFunct))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathFunct>())).name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathFunct),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathFunct>())).func as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathFunct),
      "::",
      stringify!(func)
    )
  );
}
/// xmlXPathAxisFunc:
/// @ctxt:  the XPath interpreter context
/// @cur:  the previous node being explored on that axis
///
/// An axis traversal function. To traverse an axis, the engine calls
/// the first time with cur == NULL and repeat until the function returns
/// NULL indicating the end of the axis traversal.
///
/// Returns the next node in that axis or NULL if at the end of the axis.
pub type xmlXPathAxisFunc = ::std::option::Option<
  unsafe extern "C" fn(ctxt: xmlXPathParserContextPtr, cur: xmlXPathObjectPtr) -> xmlXPathObjectPtr,
>;
pub type xmlXPathAxis = _xmlXPathAxis;
pub type xmlXPathAxisPtr = *mut xmlXPathAxis;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathAxis {
  pub name: *const xmlChar,
  pub func: xmlXPathAxisFunc,
}
#[test]
fn bindgen_test_layout__xmlXPathAxis() {
  assert_eq!(
    ::std::mem::size_of::<_xmlXPathAxis>(),
    16usize,
    concat!("Size of: ", stringify!(_xmlXPathAxis))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlXPathAxis>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlXPathAxis))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathAxis>())).name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathAxis),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathAxis>())).func as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathAxis),
      "::",
      stringify!(func)
    )
  );
}
/// xmlXPathFunction:
/// @ctxt:  the XPath interprestation context
/// @nargs:  the number of arguments
///
/// An XPath function.
/// The arguments (if any) are popped out from the context stack
/// and the result is pushed on the stack.
pub type xmlXPathFunction = ::std::option::Option<
  unsafe extern "C" fn(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int),
>;
/// xmlXPathVariableLookupFunc:
/// @ctxt:  an XPath context
/// @name:  name of the variable
/// @ns_uri:  the namespace name hosting this variable
///
/// Prototype for callbacks used to plug variable lookup in the XPath
/// engine.
///
/// Returns the XPath object value or NULL if not found.
pub type xmlXPathVariableLookupFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctxt: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    ns_uri: *const xmlChar,
  ) -> xmlXPathObjectPtr,
>;
/// xmlXPathFuncLookupFunc:
/// @ctxt:  an XPath context
/// @name:  name of the function
/// @ns_uri:  the namespace name hosting this function
///
/// Prototype for callbacks used to plug function lookup in the XPath
/// engine.
///
/// Returns the XPath function or NULL if not found.
pub type xmlXPathFuncLookupFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctxt: *mut ::std::os::raw::c_void,
    name: *const xmlChar,
    ns_uri: *const xmlChar,
  ) -> xmlXPathFunction,
>;
/// xmlXPathContext:
///
/// Expression evaluation occurs with respect to a context.
/// he context consists of:
/// - a node (the context node)
/// - a node list (the context node list)
/// - a set of variable bindings
/// - a function library
/// - the set of namespace declarations in scope for the expression
/// Following the switch to hash tables, this need to be trimmed up at
/// the next binary incompatible release.
/// The node may be modified when the context is passed to libxml2
/// for an XPath evaluation so you may need to initialize it again
/// before the next call.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathContext {
  pub doc: xmlDocPtr,
  pub node: xmlNodePtr,
  pub nb_variables_unused: ::std::os::raw::c_int,
  pub max_variables_unused: ::std::os::raw::c_int,
  pub varHash: xmlHashTablePtr,
  pub nb_types: ::std::os::raw::c_int,
  pub max_types: ::std::os::raw::c_int,
  pub types: xmlXPathTypePtr,
  pub nb_funcs_unused: ::std::os::raw::c_int,
  pub max_funcs_unused: ::std::os::raw::c_int,
  pub funcHash: xmlHashTablePtr,
  pub nb_axis: ::std::os::raw::c_int,
  pub max_axis: ::std::os::raw::c_int,
  pub axis: xmlXPathAxisPtr,
  pub namespaces: *mut xmlNsPtr,
  pub nsNr: ::std::os::raw::c_int,
  pub user: *mut ::std::os::raw::c_void,
  pub contextSize: ::std::os::raw::c_int,
  pub proximityPosition: ::std::os::raw::c_int,
  pub xptr: ::std::os::raw::c_int,
  pub here: xmlNodePtr,
  pub origin: xmlNodePtr,
  pub nsHash: xmlHashTablePtr,
  pub varLookupFunc: xmlXPathVariableLookupFunc,
  pub varLookupData: *mut ::std::os::raw::c_void,
  pub extra: *mut ::std::os::raw::c_void,
  pub function: *const xmlChar,
  pub functionURI: *const xmlChar,
  pub funcLookupFunc: xmlXPathFuncLookupFunc,
  pub funcLookupData: *mut ::std::os::raw::c_void,
  pub tmpNsList: *mut xmlNsPtr,
  pub tmpNsNr: ::std::os::raw::c_int,
  pub userData: *mut ::std::os::raw::c_void,
  pub error: xmlStructuredErrorFunc,
  pub lastError: xmlError,
  pub debugNode: xmlNodePtr,
  pub dict: xmlDictPtr,
  pub flags: ::std::os::raw::c_int,
  pub cache: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlXPathContext() {
  assert_eq!(
    ::std::mem::size_of::<_xmlXPathContext>(),
    352usize,
    concat!("Size of: ", stringify!(_xmlXPathContext))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlXPathContext>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlXPathContext))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).doc as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(doc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).node as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(node)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlXPathContext>())).nb_variables_unused as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(nb_variables_unused)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlXPathContext>())).max_variables_unused as *const _ as usize
    },
    20usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(max_variables_unused)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).varHash as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(varHash)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).nb_types as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(nb_types)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).max_types as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(max_types)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).types as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(types)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).nb_funcs_unused as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(nb_funcs_unused)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).max_funcs_unused as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(max_funcs_unused)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).funcHash as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(funcHash)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).nb_axis as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(nb_axis)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).max_axis as *const _ as usize },
    68usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(max_axis)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).axis as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(axis)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).namespaces as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(namespaces)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).nsNr as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(nsNr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).user as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(user)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).contextSize as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(contextSize)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).proximityPosition as *const _ as usize },
    108usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(proximityPosition)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).xptr as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(xptr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).here as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(here)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).origin as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(origin)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).nsHash as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(nsHash)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).varLookupFunc as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(varLookupFunc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).varLookupData as *const _ as usize },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(varLookupData)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).extra as *const _ as usize },
    160usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(extra)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).function as *const _ as usize },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(function)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).functionURI as *const _ as usize },
    176usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(functionURI)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).funcLookupFunc as *const _ as usize },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(funcLookupFunc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).funcLookupData as *const _ as usize },
    192usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(funcLookupData)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).tmpNsList as *const _ as usize },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(tmpNsList)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).tmpNsNr as *const _ as usize },
    208usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(tmpNsNr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).userData as *const _ as usize },
    216usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(userData)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).error as *const _ as usize },
    224usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(error)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).lastError as *const _ as usize },
    232usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(lastError)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).debugNode as *const _ as usize },
    320usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(debugNode)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).dict as *const _ as usize },
    328usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(dict)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).flags as *const _ as usize },
    336usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathContext>())).cache as *const _ as usize },
    344usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathContext),
      "::",
      stringify!(cache)
    )
  );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathCompExpr {
  _unused: [u8; 0],
}
pub type xmlXPathCompExpr = _xmlXPathCompExpr;
pub type xmlXPathCompExprPtr = *mut xmlXPathCompExpr;
/// xmlXPathParserContext:
///
/// An XPath parser context. It contains pure parsing informations,
/// an xmlXPathContext, and the stack of objects.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXPathParserContext {
  pub cur: *const xmlChar,
  pub base: *const xmlChar,
  pub error: ::std::os::raw::c_int,
  pub context: xmlXPathContextPtr,
  pub value: xmlXPathObjectPtr,
  pub valueNr: ::std::os::raw::c_int,
  pub valueMax: ::std::os::raw::c_int,
  pub valueTab: *mut xmlXPathObjectPtr,
  pub comp: xmlXPathCompExprPtr,
  pub xptr: ::std::os::raw::c_int,
  pub ancestor: xmlNodePtr,
  pub valueFrame: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__xmlXPathParserContext() {
  assert_eq!(
    ::std::mem::size_of::<_xmlXPathParserContext>(),
    88usize,
    concat!("Size of: ", stringify!(_xmlXPathParserContext))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlXPathParserContext>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlXPathParserContext))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathParserContext>())).cur as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathParserContext),
      "::",
      stringify!(cur)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathParserContext>())).base as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathParserContext),
      "::",
      stringify!(base)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathParserContext>())).error as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathParserContext),
      "::",
      stringify!(error)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathParserContext>())).context as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathParserContext),
      "::",
      stringify!(context)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathParserContext>())).value as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathParserContext),
      "::",
      stringify!(value)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathParserContext>())).valueNr as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathParserContext),
      "::",
      stringify!(valueNr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathParserContext>())).valueMax as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathParserContext),
      "::",
      stringify!(valueMax)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathParserContext>())).valueTab as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathParserContext),
      "::",
      stringify!(valueTab)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathParserContext>())).comp as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathParserContext),
      "::",
      stringify!(comp)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathParserContext>())).xptr as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathParserContext),
      "::",
      stringify!(xptr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathParserContext>())).ancestor as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathParserContext),
      "::",
      stringify!(ancestor)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlXPathParserContext>())).valueFrame as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlXPathParserContext),
      "::",
      stringify!(valueFrame)
    )
  );
}
extern "C" {
  #[link_name = "\u{1}xmlXPathNAN"]
  pub static mut xmlXPathNAN: f64;
}
extern "C" {
  #[link_name = "\u{1}xmlXPathPINF"]
  pub static mut xmlXPathPINF: f64;
}
extern "C" {
  #[link_name = "\u{1}xmlXPathNINF"]
  pub static mut xmlXPathNINF: f64;
}
extern "C" {
  pub fn xmlXPathFreeObject(obj: xmlXPathObjectPtr);
}
extern "C" {
  pub fn xmlXPathNodeSetCreate(val: xmlNodePtr) -> xmlNodeSetPtr;
}
extern "C" {
  pub fn xmlXPathFreeNodeSetList(obj: xmlXPathObjectPtr);
}
extern "C" {
  pub fn xmlXPathFreeNodeSet(obj: xmlNodeSetPtr);
}
extern "C" {
  pub fn xmlXPathObjectCopy(val: xmlXPathObjectPtr) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPathCmpNodes(node1: xmlNodePtr, node2: xmlNodePtr) -> ::std::os::raw::c_int;
}
extern "C" {
  /// Conversion functions to basic types.
  pub fn xmlXPathCastNumberToBoolean(val: f64) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathCastStringToBoolean(val: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathCastNodeSetToBoolean(ns: xmlNodeSetPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathCastToBoolean(val: xmlXPathObjectPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathCastBooleanToNumber(val: ::std::os::raw::c_int) -> f64;
}
extern "C" {
  pub fn xmlXPathCastStringToNumber(val: *const xmlChar) -> f64;
}
extern "C" {
  pub fn xmlXPathCastNodeToNumber(node: xmlNodePtr) -> f64;
}
extern "C" {
  pub fn xmlXPathCastNodeSetToNumber(ns: xmlNodeSetPtr) -> f64;
}
extern "C" {
  pub fn xmlXPathCastToNumber(val: xmlXPathObjectPtr) -> f64;
}
extern "C" {
  pub fn xmlXPathCastBooleanToString(val: ::std::os::raw::c_int) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlXPathCastNumberToString(val: f64) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlXPathCastNodeToString(node: xmlNodePtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlXPathCastNodeSetToString(ns: xmlNodeSetPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlXPathCastToString(val: xmlXPathObjectPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlXPathConvertBoolean(val: xmlXPathObjectPtr) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPathConvertNumber(val: xmlXPathObjectPtr) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPathConvertString(val: xmlXPathObjectPtr) -> xmlXPathObjectPtr;
}
extern "C" {
  /// Context handling.
  pub fn xmlXPathNewContext(doc: xmlDocPtr) -> xmlXPathContextPtr;
}
extern "C" {
  pub fn xmlXPathFreeContext(ctxt: xmlXPathContextPtr);
}
extern "C" {
  pub fn xmlXPathContextSetCache(
    ctxt: xmlXPathContextPtr,
    active: ::std::os::raw::c_int,
    value: ::std::os::raw::c_int,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  /// Evaluation functions.
  pub fn xmlXPathOrderDocElems(doc: xmlDocPtr) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn xmlXPathSetContextNode(node: xmlNodePtr, ctx: xmlXPathContextPtr)
    -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathNodeEval(
    node: xmlNodePtr,
    str: *const xmlChar,
    ctx: xmlXPathContextPtr,
  ) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPathEval(str: *const xmlChar, ctx: xmlXPathContextPtr) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPathEvalExpression(str: *const xmlChar, ctxt: xmlXPathContextPtr)
    -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPathEvalPredicate(
    ctxt: xmlXPathContextPtr,
    res: xmlXPathObjectPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  /// Separate compilation/evaluation entry points.
  pub fn xmlXPathCompile(str: *const xmlChar) -> xmlXPathCompExprPtr;
}
extern "C" {
  pub fn xmlXPathCtxtCompile(ctxt: xmlXPathContextPtr, str: *const xmlChar) -> xmlXPathCompExprPtr;
}
extern "C" {
  pub fn xmlXPathCompiledEval(
    comp: xmlXPathCompExprPtr,
    ctx: xmlXPathContextPtr,
  ) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPathCompiledEvalToBoolean(
    comp: xmlXPathCompExprPtr,
    ctxt: xmlXPathContextPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathFreeCompExpr(comp: xmlXPathCompExprPtr);
}
extern "C" {
  pub fn xmlXPathInit();
}
extern "C" {
  pub fn xmlXPathIsNaN(val: f64) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathIsInf(val: f64) -> ::std::os::raw::c_int;
}
pub const xmlC14NMode_XML_C14N_1_0: xmlC14NMode = 0;
pub const xmlC14NMode_XML_C14N_EXCLUSIVE_1_0: xmlC14NMode = 1;
pub const xmlC14NMode_XML_C14N_1_1: xmlC14NMode = 2;
pub type xmlC14NMode = u32;
extern "C" {
  pub fn xmlC14NDocSaveTo(
    doc: xmlDocPtr,
    nodes: xmlNodeSetPtr,
    mode: ::std::os::raw::c_int,
    inclusive_ns_prefixes: *mut *mut xmlChar,
    with_comments: ::std::os::raw::c_int,
    buf: xmlOutputBufferPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlC14NDocDumpMemory(
    doc: xmlDocPtr,
    nodes: xmlNodeSetPtr,
    mode: ::std::os::raw::c_int,
    inclusive_ns_prefixes: *mut *mut xmlChar,
    with_comments: ::std::os::raw::c_int,
    doc_txt_ptr: *mut *mut xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlC14NDocSave(
    doc: xmlDocPtr,
    nodes: xmlNodeSetPtr,
    mode: ::std::os::raw::c_int,
    inclusive_ns_prefixes: *mut *mut xmlChar,
    with_comments: ::std::os::raw::c_int,
    filename: *const ::std::os::raw::c_char,
    compression: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
/// This is the core C14N function
/// /
/// /**
/// xmlC14NIsVisibleCallback:
/// @user_data: user data
/// @node: the curent node
/// @parent: the parent node
///
/// Signature for a C14N callback on visible nodes
///
/// Returns 1 if the node should be included
pub type xmlC14NIsVisibleCallback = ::std::option::Option<
  unsafe extern "C" fn(
    user_data: *mut ::std::os::raw::c_void,
    node: xmlNodePtr,
    parent: xmlNodePtr,
  ) -> ::std::os::raw::c_int,
>;
extern "C" {
  pub fn xmlC14NExecute(
    doc: xmlDocPtr,
    is_visible_callback: xmlC14NIsVisibleCallback,
    user_data: *mut ::std::os::raw::c_void,
    mode: ::std::os::raw::c_int,
    inclusive_ns_prefixes: *mut *mut xmlChar,
    with_comments: ::std::os::raw::c_int,
    buf: xmlOutputBufferPtr,
  ) -> ::std::os::raw::c_int;
}
pub const xmlCatalogPrefer_XML_CATA_PREFER_NONE: xmlCatalogPrefer = 0;
pub const xmlCatalogPrefer_XML_CATA_PREFER_PUBLIC: xmlCatalogPrefer = 1;
pub const xmlCatalogPrefer_XML_CATA_PREFER_SYSTEM: xmlCatalogPrefer = 2;
pub type xmlCatalogPrefer = u32;
pub const xmlCatalogAllow_XML_CATA_ALLOW_NONE: xmlCatalogAllow = 0;
pub const xmlCatalogAllow_XML_CATA_ALLOW_GLOBAL: xmlCatalogAllow = 1;
pub const xmlCatalogAllow_XML_CATA_ALLOW_DOCUMENT: xmlCatalogAllow = 2;
pub const xmlCatalogAllow_XML_CATA_ALLOW_ALL: xmlCatalogAllow = 3;
pub type xmlCatalogAllow = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlCatalog {
  _unused: [u8; 0],
}
pub type xmlCatalog = _xmlCatalog;
pub type xmlCatalogPtr = *mut xmlCatalog;
extern "C" {
  pub fn xmlNewCatalog(sgml: ::std::os::raw::c_int) -> xmlCatalogPtr;
}
extern "C" {
  pub fn xmlLoadACatalog(filename: *const ::std::os::raw::c_char) -> xmlCatalogPtr;
}
extern "C" {
  pub fn xmlLoadSGMLSuperCatalog(filename: *const ::std::os::raw::c_char) -> xmlCatalogPtr;
}
extern "C" {
  pub fn xmlConvertSGMLCatalog(catal: xmlCatalogPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlACatalogAdd(
    catal: xmlCatalogPtr,
    type_: *const xmlChar,
    orig: *const xmlChar,
    replace: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlACatalogRemove(catal: xmlCatalogPtr, value: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlACatalogResolve(
    catal: xmlCatalogPtr,
    pubID: *const xmlChar,
    sysID: *const xmlChar,
  ) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlACatalogResolveSystem(catal: xmlCatalogPtr, sysID: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlACatalogResolvePublic(catal: xmlCatalogPtr, pubID: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlACatalogResolveURI(catal: xmlCatalogPtr, URI: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlACatalogDump(catal: xmlCatalogPtr, out: *mut FILE);
}
extern "C" {
  pub fn xmlFreeCatalog(catal: xmlCatalogPtr);
}
extern "C" {
  pub fn xmlCatalogIsEmpty(catal: xmlCatalogPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlInitializeCatalog();
}
extern "C" {
  pub fn xmlLoadCatalog(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlLoadCatalogs(paths: *const ::std::os::raw::c_char);
}
extern "C" {
  pub fn xmlCatalogCleanup();
}
extern "C" {
  pub fn xmlCatalogDump(out: *mut FILE);
}
extern "C" {
  pub fn xmlCatalogResolve(pubID: *const xmlChar, sysID: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlCatalogResolveSystem(sysID: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlCatalogResolvePublic(pubID: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlCatalogResolveURI(URI: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlCatalogAdd(
    type_: *const xmlChar,
    orig: *const xmlChar,
    replace: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlCatalogRemove(value: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlParseCatalogFile(filename: *const ::std::os::raw::c_char) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlCatalogConvert() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlCatalogFreeLocal(catalogs: *mut ::std::os::raw::c_void);
}
extern "C" {
  pub fn xmlCatalogAddLocal(
    catalogs: *mut ::std::os::raw::c_void,
    URL: *const xmlChar,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlCatalogLocalResolve(
    catalogs: *mut ::std::os::raw::c_void,
    pubID: *const xmlChar,
    sysID: *const xmlChar,
  ) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlCatalogLocalResolveURI(
    catalogs: *mut ::std::os::raw::c_void,
    URI: *const xmlChar,
  ) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlCatalogSetDebug(level: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlCatalogSetDefaultPrefer(prefer: xmlCatalogPrefer) -> xmlCatalogPrefer;
}
extern "C" {
  pub fn xmlCatalogSetDefaults(allow: xmlCatalogAllow);
}
extern "C" {
  pub fn xmlCatalogGetDefaults() -> xmlCatalogAllow;
}
extern "C" {
  pub fn xmlCatalogGetSystem(sysID: *const xmlChar) -> *const xmlChar;
}
extern "C" {
  pub fn xmlCatalogGetPublic(pubID: *const xmlChar) -> *const xmlChar;
}
extern "C" {
  pub fn xmlDebugDumpString(output: *mut FILE, str: *const xmlChar);
}
extern "C" {
  pub fn xmlDebugDumpAttr(output: *mut FILE, attr: xmlAttrPtr, depth: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlDebugDumpAttrList(output: *mut FILE, attr: xmlAttrPtr, depth: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlDebugDumpOneNode(output: *mut FILE, node: xmlNodePtr, depth: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlDebugDumpNode(output: *mut FILE, node: xmlNodePtr, depth: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlDebugDumpNodeList(output: *mut FILE, node: xmlNodePtr, depth: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlDebugDumpDocumentHead(output: *mut FILE, doc: xmlDocPtr);
}
extern "C" {
  pub fn xmlDebugDumpDocument(output: *mut FILE, doc: xmlDocPtr);
}
extern "C" {
  pub fn xmlDebugDumpDTD(output: *mut FILE, dtd: xmlDtdPtr);
}
extern "C" {
  pub fn xmlDebugDumpEntities(output: *mut FILE, doc: xmlDocPtr);
}
extern "C" {
  /// *
  /// Checking routines			*
  /// *
  pub fn xmlDebugCheckDocument(output: *mut FILE, doc: xmlDocPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  /// *
  /// XML shell helpers			*
  /// *
  pub fn xmlLsOneNode(output: *mut FILE, node: xmlNodePtr);
}
extern "C" {
  pub fn xmlLsCountNode(node: xmlNodePtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlBoolToText(boolval: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
/// xmlShellReadlineFunc:
/// @prompt:  a string prompt
///
/// This is a generic signature for the XML shell input function.
///
/// Returns a string which will be freed by the Shell.
pub type xmlShellReadlineFunc = ::std::option::Option<
  unsafe extern "C" fn(prompt: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
>;
/// xmlShellCtxt:
///
/// A debugging shell context.
/// TODO: add the defined function tables.
pub type xmlShellCtxt = _xmlShellCtxt;
pub type xmlShellCtxtPtr = *mut xmlShellCtxt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlShellCtxt {
  pub filename: *mut ::std::os::raw::c_char,
  pub doc: xmlDocPtr,
  pub node: xmlNodePtr,
  pub pctxt: xmlXPathContextPtr,
  pub loaded: ::std::os::raw::c_int,
  pub output: *mut FILE,
  pub input: xmlShellReadlineFunc,
}
#[test]
fn bindgen_test_layout__xmlShellCtxt() {
  assert_eq!(
    ::std::mem::size_of::<_xmlShellCtxt>(),
    56usize,
    concat!("Size of: ", stringify!(_xmlShellCtxt))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlShellCtxt>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlShellCtxt))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlShellCtxt>())).filename as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlShellCtxt),
      "::",
      stringify!(filename)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlShellCtxt>())).doc as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlShellCtxt),
      "::",
      stringify!(doc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlShellCtxt>())).node as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlShellCtxt),
      "::",
      stringify!(node)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlShellCtxt>())).pctxt as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlShellCtxt),
      "::",
      stringify!(pctxt)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlShellCtxt>())).loaded as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlShellCtxt),
      "::",
      stringify!(loaded)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlShellCtxt>())).output as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlShellCtxt),
      "::",
      stringify!(output)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlShellCtxt>())).input as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlShellCtxt),
      "::",
      stringify!(input)
    )
  );
}
/// xmlShellCmd:
/// @ctxt:  a shell context
/// @arg:  a string argument
/// @node:  a first node
/// @node2:  a second node
///
/// This is a generic signature for the XML shell functions.
///
/// Returns an int, negative returns indicating errors.
pub type xmlShellCmd = ::std::option::Option<
  unsafe extern "C" fn(
    ctxt: xmlShellCtxtPtr,
    arg: *mut ::std::os::raw::c_char,
    node: xmlNodePtr,
    node2: xmlNodePtr,
  ) -> ::std::os::raw::c_int,
>;
extern "C" {
  pub fn xmlShellPrintXPathError(
    errorType: ::std::os::raw::c_int,
    arg: *const ::std::os::raw::c_char,
  );
}
extern "C" {
  pub fn xmlShellPrintXPathResult(list: xmlXPathObjectPtr);
}
extern "C" {
  pub fn xmlShellList(
    ctxt: xmlShellCtxtPtr,
    arg: *mut ::std::os::raw::c_char,
    node: xmlNodePtr,
    node2: xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlShellBase(
    ctxt: xmlShellCtxtPtr,
    arg: *mut ::std::os::raw::c_char,
    node: xmlNodePtr,
    node2: xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlShellDir(
    ctxt: xmlShellCtxtPtr,
    arg: *mut ::std::os::raw::c_char,
    node: xmlNodePtr,
    node2: xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlShellLoad(
    ctxt: xmlShellCtxtPtr,
    filename: *mut ::std::os::raw::c_char,
    node: xmlNodePtr,
    node2: xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlShellPrintNode(node: xmlNodePtr);
}
extern "C" {
  pub fn xmlShellCat(
    ctxt: xmlShellCtxtPtr,
    arg: *mut ::std::os::raw::c_char,
    node: xmlNodePtr,
    node2: xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlShellWrite(
    ctxt: xmlShellCtxtPtr,
    filename: *mut ::std::os::raw::c_char,
    node: xmlNodePtr,
    node2: xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlShellSave(
    ctxt: xmlShellCtxtPtr,
    filename: *mut ::std::os::raw::c_char,
    node: xmlNodePtr,
    node2: xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlShellValidate(
    ctxt: xmlShellCtxtPtr,
    dtd: *mut ::std::os::raw::c_char,
    node: xmlNodePtr,
    node2: xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlShellDu(
    ctxt: xmlShellCtxtPtr,
    arg: *mut ::std::os::raw::c_char,
    tree: xmlNodePtr,
    node2: xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlShellPwd(
    ctxt: xmlShellCtxtPtr,
    buffer: *mut ::std::os::raw::c_char,
    node: xmlNodePtr,
    node2: xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlShell(
    doc: xmlDocPtr,
    filename: *mut ::std::os::raw::c_char,
    input: xmlShellReadlineFunc,
    output: *mut FILE,
  );
}
/// ftpListCallback:
/// @userData:  user provided data for the callback
/// @filename:  the file name (including "->" when links are shown)
/// @attrib:  the attribute string
/// @owner:  the owner string
/// @group:  the group string
/// @size:  the file size
/// @links:  the link count
/// @year:  the year
/// @month:  the month
/// @day:  the day
/// @hour:  the hour
/// @minute:  the minute
///
/// A callback for the xmlNanoFTPList command.
/// Note that only one of year and day:minute are specified.
pub type ftpListCallback = ::std::option::Option<
  unsafe extern "C" fn(
    userData: *mut ::std::os::raw::c_void,
    filename: *const ::std::os::raw::c_char,
    attrib: *const ::std::os::raw::c_char,
    owner: *const ::std::os::raw::c_char,
    group: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_ulong,
    links: ::std::os::raw::c_int,
    year: ::std::os::raw::c_int,
    month: *const ::std::os::raw::c_char,
    day: ::std::os::raw::c_int,
    hour: ::std::os::raw::c_int,
    minute: ::std::os::raw::c_int,
  ),
>;
/// ftpDataCallback:
/// @userData: the user provided context
/// @data: the data received
/// @len: its size in bytes
///
/// A callback for the xmlNanoFTPGet command.
pub type ftpDataCallback = ::std::option::Option<
  unsafe extern "C" fn(
    userData: *mut ::std::os::raw::c_void,
    data: *const ::std::os::raw::c_char,
    len: ::std::os::raw::c_int,
  ),
>;
extern "C" {
  pub fn xmlNanoFTPInit();
}
extern "C" {
  pub fn xmlNanoFTPCleanup();
}
extern "C" {
  pub fn xmlNanoFTPNewCtxt(URL: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlNanoFTPFreeCtxt(ctx: *mut ::std::os::raw::c_void);
}
extern "C" {
  pub fn xmlNanoFTPConnectTo(
    server: *const ::std::os::raw::c_char,
    port: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlNanoFTPOpen(URL: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlNanoFTPConnect(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNanoFTPClose(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNanoFTPQuit(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNanoFTPScanProxy(URL: *const ::std::os::raw::c_char);
}
extern "C" {
  pub fn xmlNanoFTPProxy(
    host: *const ::std::os::raw::c_char,
    port: ::std::os::raw::c_int,
    user: *const ::std::os::raw::c_char,
    passwd: *const ::std::os::raw::c_char,
    type_: ::std::os::raw::c_int,
  );
}
extern "C" {
  pub fn xmlNanoFTPUpdateURL(
    ctx: *mut ::std::os::raw::c_void,
    URL: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNanoFTPGetResponse(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNanoFTPCheckResponse(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNanoFTPCwd(
    ctx: *mut ::std::os::raw::c_void,
    directory: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNanoFTPDele(
    ctx: *mut ::std::os::raw::c_void,
    file: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNanoFTPGetConnection(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNanoFTPCloseConnection(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNanoFTPList(
    ctx: *mut ::std::os::raw::c_void,
    callback: ftpListCallback,
    userData: *mut ::std::os::raw::c_void,
    filename: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNanoFTPGetSocket(
    ctx: *mut ::std::os::raw::c_void,
    filename: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNanoFTPGet(
    ctx: *mut ::std::os::raw::c_void,
    callback: ftpDataCallback,
    userData: *mut ::std::os::raw::c_void,
    filename: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNanoFTPRead(
    ctx: *mut ::std::os::raw::c_void,
    dest: *mut ::std::os::raw::c_void,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNanoHTTPInit();
}
extern "C" {
  pub fn xmlNanoHTTPCleanup();
}
extern "C" {
  pub fn xmlNanoHTTPScanProxy(URL: *const ::std::os::raw::c_char);
}
extern "C" {
  pub fn xmlNanoHTTPFetch(
    URL: *const ::std::os::raw::c_char,
    filename: *const ::std::os::raw::c_char,
    contentType: *mut *mut ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNanoHTTPMethod(
    URL: *const ::std::os::raw::c_char,
    method: *const ::std::os::raw::c_char,
    input: *const ::std::os::raw::c_char,
    contentType: *mut *mut ::std::os::raw::c_char,
    headers: *const ::std::os::raw::c_char,
    ilen: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlNanoHTTPMethodRedir(
    URL: *const ::std::os::raw::c_char,
    method: *const ::std::os::raw::c_char,
    input: *const ::std::os::raw::c_char,
    contentType: *mut *mut ::std::os::raw::c_char,
    redir: *mut *mut ::std::os::raw::c_char,
    headers: *const ::std::os::raw::c_char,
    ilen: ::std::os::raw::c_int,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlNanoHTTPOpen(
    URL: *const ::std::os::raw::c_char,
    contentType: *mut *mut ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlNanoHTTPOpenRedir(
    URL: *const ::std::os::raw::c_char,
    contentType: *mut *mut ::std::os::raw::c_char,
    redir: *mut *mut ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlNanoHTTPReturnCode(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNanoHTTPAuthHeader(ctx: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
extern "C" {
  pub fn xmlNanoHTTPRedir(ctx: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
extern "C" {
  pub fn xmlNanoHTTPContentLength(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNanoHTTPEncoding(ctx: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
extern "C" {
  pub fn xmlNanoHTTPMimeType(ctx: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
extern "C" {
  pub fn xmlNanoHTTPRead(
    ctx: *mut ::std::os::raw::c_void,
    dest: *mut ::std::os::raw::c_void,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNanoHTTPSave(
    ctxt: *mut ::std::os::raw::c_void,
    filename: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlNanoHTTPClose(ctx: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlPattern {
  _unused: [u8; 0],
}
/// xmlPattern:
///
/// A compiled (XPath based) pattern to select nodes
pub type xmlPattern = _xmlPattern;
pub type xmlPatternPtr = *mut xmlPattern;
pub const xmlPatternFlags_XML_PATTERN_DEFAULT: xmlPatternFlags = 0;
pub const xmlPatternFlags_XML_PATTERN_XPATH: xmlPatternFlags = 1;
pub const xmlPatternFlags_XML_PATTERN_XSSEL: xmlPatternFlags = 2;
pub const xmlPatternFlags_XML_PATTERN_XSFIELD: xmlPatternFlags = 4;
/// xmlPatternFlags:
///
/// This is the set of options affecting the behaviour of pattern
/// matching with this module
///
pub type xmlPatternFlags = u32;
extern "C" {
  pub fn xmlFreePattern(comp: xmlPatternPtr);
}
extern "C" {
  pub fn xmlFreePatternList(comp: xmlPatternPtr);
}
extern "C" {
  pub fn xmlPatterncompile(
    pattern: *const xmlChar,
    dict: *mut xmlDict,
    flags: ::std::os::raw::c_int,
    namespaces: *mut *const xmlChar,
  ) -> xmlPatternPtr;
}
extern "C" {
  pub fn xmlPatternMatch(comp: xmlPatternPtr, node: xmlNodePtr) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlStreamCtxt {
  _unused: [u8; 0],
}
pub type xmlStreamCtxt = _xmlStreamCtxt;
pub type xmlStreamCtxtPtr = *mut xmlStreamCtxt;
extern "C" {
  pub fn xmlPatternStreamable(comp: xmlPatternPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlPatternMaxDepth(comp: xmlPatternPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlPatternMinDepth(comp: xmlPatternPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlPatternFromRoot(comp: xmlPatternPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlPatternGetStreamCtxt(comp: xmlPatternPtr) -> xmlStreamCtxtPtr;
}
extern "C" {
  pub fn xmlFreeStreamCtxt(stream: xmlStreamCtxtPtr);
}
extern "C" {
  pub fn xmlStreamPushNode(
    stream: xmlStreamCtxtPtr,
    name: *const xmlChar,
    ns: *const xmlChar,
    nodeType: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlStreamPush(
    stream: xmlStreamCtxtPtr,
    name: *const xmlChar,
    ns: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlStreamPushAttr(
    stream: xmlStreamCtxtPtr,
    name: *const xmlChar,
    ns: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlStreamPop(stream: xmlStreamCtxtPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlStreamWantsAnyNode(stream: xmlStreamCtxtPtr) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlRelaxNG {
  _unused: [u8; 0],
}
pub type xmlRelaxNG = _xmlRelaxNG;
pub type xmlRelaxNGPtr = *mut xmlRelaxNG;
/// xmlRelaxNGValidityErrorFunc:
/// @ctx: the validation context
/// @msg: the message
/// @...: extra arguments
///
/// Signature of an error callback from a Relax-NG validation
pub type xmlRelaxNGValidityErrorFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
/// xmlRelaxNGValidityWarningFunc:
/// @ctx: the validation context
/// @msg: the message
/// @...: extra arguments
///
/// Signature of a warning callback from a Relax-NG validation
pub type xmlRelaxNGValidityWarningFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlRelaxNGParserCtxt {
  _unused: [u8; 0],
}
/// A schemas validation context
pub type xmlRelaxNGParserCtxt = _xmlRelaxNGParserCtxt;
pub type xmlRelaxNGParserCtxtPtr = *mut xmlRelaxNGParserCtxt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlRelaxNGValidCtxt {
  _unused: [u8; 0],
}
pub type xmlRelaxNGValidCtxt = _xmlRelaxNGValidCtxt;
pub type xmlRelaxNGValidCtxtPtr = *mut xmlRelaxNGValidCtxt;
pub const xmlRelaxNGValidErr_XML_RELAXNG_OK: xmlRelaxNGValidErr = 0;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_MEMORY: xmlRelaxNGValidErr = 1;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_TYPE: xmlRelaxNGValidErr = 2;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_TYPEVAL: xmlRelaxNGValidErr = 3;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_DUPID: xmlRelaxNGValidErr = 4;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_TYPECMP: xmlRelaxNGValidErr = 5;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_NOSTATE: xmlRelaxNGValidErr = 6;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_NODEFINE: xmlRelaxNGValidErr = 7;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_LISTEXTRA: xmlRelaxNGValidErr = 8;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_LISTEMPTY: xmlRelaxNGValidErr = 9;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_INTERNODATA: xmlRelaxNGValidErr = 10;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_INTERSEQ: xmlRelaxNGValidErr = 11;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_INTEREXTRA: xmlRelaxNGValidErr = 12;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_ELEMNAME: xmlRelaxNGValidErr = 13;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_ATTRNAME: xmlRelaxNGValidErr = 14;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_ELEMNONS: xmlRelaxNGValidErr = 15;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_ATTRNONS: xmlRelaxNGValidErr = 16;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_ELEMWRONGNS: xmlRelaxNGValidErr = 17;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_ATTRWRONGNS: xmlRelaxNGValidErr = 18;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_ELEMEXTRANS: xmlRelaxNGValidErr = 19;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_ATTREXTRANS: xmlRelaxNGValidErr = 20;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_ELEMNOTEMPTY: xmlRelaxNGValidErr = 21;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_NOELEM: xmlRelaxNGValidErr = 22;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_NOTELEM: xmlRelaxNGValidErr = 23;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_ATTRVALID: xmlRelaxNGValidErr = 24;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_CONTENTVALID: xmlRelaxNGValidErr = 25;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_EXTRACONTENT: xmlRelaxNGValidErr = 26;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_INVALIDATTR: xmlRelaxNGValidErr = 27;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_DATAELEM: xmlRelaxNGValidErr = 28;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_VALELEM: xmlRelaxNGValidErr = 29;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_LISTELEM: xmlRelaxNGValidErr = 30;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_DATATYPE: xmlRelaxNGValidErr = 31;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_VALUE: xmlRelaxNGValidErr = 32;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_LIST: xmlRelaxNGValidErr = 33;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_NOGRAMMAR: xmlRelaxNGValidErr = 34;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_EXTRADATA: xmlRelaxNGValidErr = 35;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_LACKDATA: xmlRelaxNGValidErr = 36;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_INTERNAL: xmlRelaxNGValidErr = 37;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_ELEMWRONG: xmlRelaxNGValidErr = 38;
pub const xmlRelaxNGValidErr_XML_RELAXNG_ERR_TEXTWRONG: xmlRelaxNGValidErr = 39;
pub type xmlRelaxNGValidErr = u32;
pub const xmlRelaxNGParserFlag_XML_RELAXNGP_NONE: xmlRelaxNGParserFlag = 0;
pub const xmlRelaxNGParserFlag_XML_RELAXNGP_FREE_DOC: xmlRelaxNGParserFlag = 1;
pub const xmlRelaxNGParserFlag_XML_RELAXNGP_CRNG: xmlRelaxNGParserFlag = 2;
pub type xmlRelaxNGParserFlag = u32;
extern "C" {
  pub fn xmlRelaxNGInitTypes() -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlRelaxNGCleanupTypes();
}
extern "C" {
  pub fn xmlRelaxNGNewParserCtxt(URL: *const ::std::os::raw::c_char) -> xmlRelaxNGParserCtxtPtr;
}
extern "C" {
  pub fn xmlRelaxNGNewMemParserCtxt(
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
  ) -> xmlRelaxNGParserCtxtPtr;
}
extern "C" {
  pub fn xmlRelaxNGNewDocParserCtxt(doc: xmlDocPtr) -> xmlRelaxNGParserCtxtPtr;
}
extern "C" {
  pub fn xmlRelaxParserSetFlag(
    ctxt: xmlRelaxNGParserCtxtPtr,
    flag: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlRelaxNGFreeParserCtxt(ctxt: xmlRelaxNGParserCtxtPtr);
}
extern "C" {
  pub fn xmlRelaxNGSetParserErrors(
    ctxt: xmlRelaxNGParserCtxtPtr,
    err: xmlRelaxNGValidityErrorFunc,
    warn: xmlRelaxNGValidityWarningFunc,
    ctx: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn xmlRelaxNGGetParserErrors(
    ctxt: xmlRelaxNGParserCtxtPtr,
    err: *mut xmlRelaxNGValidityErrorFunc,
    warn: *mut xmlRelaxNGValidityWarningFunc,
    ctx: *mut *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlRelaxNGSetParserStructuredErrors(
    ctxt: xmlRelaxNGParserCtxtPtr,
    serror: xmlStructuredErrorFunc,
    ctx: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn xmlRelaxNGParse(ctxt: xmlRelaxNGParserCtxtPtr) -> xmlRelaxNGPtr;
}
extern "C" {
  pub fn xmlRelaxNGFree(schema: xmlRelaxNGPtr);
}
extern "C" {
  pub fn xmlRelaxNGDump(output: *mut FILE, schema: xmlRelaxNGPtr);
}
extern "C" {
  pub fn xmlRelaxNGDumpTree(output: *mut FILE, schema: xmlRelaxNGPtr);
}
extern "C" {
  pub fn xmlRelaxNGSetValidErrors(
    ctxt: xmlRelaxNGValidCtxtPtr,
    err: xmlRelaxNGValidityErrorFunc,
    warn: xmlRelaxNGValidityWarningFunc,
    ctx: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn xmlRelaxNGGetValidErrors(
    ctxt: xmlRelaxNGValidCtxtPtr,
    err: *mut xmlRelaxNGValidityErrorFunc,
    warn: *mut xmlRelaxNGValidityWarningFunc,
    ctx: *mut *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlRelaxNGSetValidStructuredErrors(
    ctxt: xmlRelaxNGValidCtxtPtr,
    serror: xmlStructuredErrorFunc,
    ctx: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn xmlRelaxNGNewValidCtxt(schema: xmlRelaxNGPtr) -> xmlRelaxNGValidCtxtPtr;
}
extern "C" {
  pub fn xmlRelaxNGFreeValidCtxt(ctxt: xmlRelaxNGValidCtxtPtr);
}
extern "C" {
  pub fn xmlRelaxNGValidateDoc(
    ctxt: xmlRelaxNGValidCtxtPtr,
    doc: xmlDocPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlRelaxNGValidatePushElement(
    ctxt: xmlRelaxNGValidCtxtPtr,
    doc: xmlDocPtr,
    elem: xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlRelaxNGValidatePushCData(
    ctxt: xmlRelaxNGValidCtxtPtr,
    data: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlRelaxNGValidatePopElement(
    ctxt: xmlRelaxNGValidCtxtPtr,
    doc: xmlDocPtr,
    elem: xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlRelaxNGValidateFullElement(
    ctxt: xmlRelaxNGValidCtxtPtr,
    doc: xmlDocPtr,
    elem: xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
pub const xmlSchemaValType_XML_SCHEMAS_UNKNOWN: xmlSchemaValType = 0;
pub const xmlSchemaValType_XML_SCHEMAS_STRING: xmlSchemaValType = 1;
pub const xmlSchemaValType_XML_SCHEMAS_NORMSTRING: xmlSchemaValType = 2;
pub const xmlSchemaValType_XML_SCHEMAS_DECIMAL: xmlSchemaValType = 3;
pub const xmlSchemaValType_XML_SCHEMAS_TIME: xmlSchemaValType = 4;
pub const xmlSchemaValType_XML_SCHEMAS_GDAY: xmlSchemaValType = 5;
pub const xmlSchemaValType_XML_SCHEMAS_GMONTH: xmlSchemaValType = 6;
pub const xmlSchemaValType_XML_SCHEMAS_GMONTHDAY: xmlSchemaValType = 7;
pub const xmlSchemaValType_XML_SCHEMAS_GYEAR: xmlSchemaValType = 8;
pub const xmlSchemaValType_XML_SCHEMAS_GYEARMONTH: xmlSchemaValType = 9;
pub const xmlSchemaValType_XML_SCHEMAS_DATE: xmlSchemaValType = 10;
pub const xmlSchemaValType_XML_SCHEMAS_DATETIME: xmlSchemaValType = 11;
pub const xmlSchemaValType_XML_SCHEMAS_DURATION: xmlSchemaValType = 12;
pub const xmlSchemaValType_XML_SCHEMAS_FLOAT: xmlSchemaValType = 13;
pub const xmlSchemaValType_XML_SCHEMAS_DOUBLE: xmlSchemaValType = 14;
pub const xmlSchemaValType_XML_SCHEMAS_BOOLEAN: xmlSchemaValType = 15;
pub const xmlSchemaValType_XML_SCHEMAS_TOKEN: xmlSchemaValType = 16;
pub const xmlSchemaValType_XML_SCHEMAS_LANGUAGE: xmlSchemaValType = 17;
pub const xmlSchemaValType_XML_SCHEMAS_NMTOKEN: xmlSchemaValType = 18;
pub const xmlSchemaValType_XML_SCHEMAS_NMTOKENS: xmlSchemaValType = 19;
pub const xmlSchemaValType_XML_SCHEMAS_NAME: xmlSchemaValType = 20;
pub const xmlSchemaValType_XML_SCHEMAS_QNAME: xmlSchemaValType = 21;
pub const xmlSchemaValType_XML_SCHEMAS_NCNAME: xmlSchemaValType = 22;
pub const xmlSchemaValType_XML_SCHEMAS_ID: xmlSchemaValType = 23;
pub const xmlSchemaValType_XML_SCHEMAS_IDREF: xmlSchemaValType = 24;
pub const xmlSchemaValType_XML_SCHEMAS_IDREFS: xmlSchemaValType = 25;
pub const xmlSchemaValType_XML_SCHEMAS_ENTITY: xmlSchemaValType = 26;
pub const xmlSchemaValType_XML_SCHEMAS_ENTITIES: xmlSchemaValType = 27;
pub const xmlSchemaValType_XML_SCHEMAS_NOTATION: xmlSchemaValType = 28;
pub const xmlSchemaValType_XML_SCHEMAS_ANYURI: xmlSchemaValType = 29;
pub const xmlSchemaValType_XML_SCHEMAS_INTEGER: xmlSchemaValType = 30;
pub const xmlSchemaValType_XML_SCHEMAS_NPINTEGER: xmlSchemaValType = 31;
pub const xmlSchemaValType_XML_SCHEMAS_NINTEGER: xmlSchemaValType = 32;
pub const xmlSchemaValType_XML_SCHEMAS_NNINTEGER: xmlSchemaValType = 33;
pub const xmlSchemaValType_XML_SCHEMAS_PINTEGER: xmlSchemaValType = 34;
pub const xmlSchemaValType_XML_SCHEMAS_INT: xmlSchemaValType = 35;
pub const xmlSchemaValType_XML_SCHEMAS_UINT: xmlSchemaValType = 36;
pub const xmlSchemaValType_XML_SCHEMAS_LONG: xmlSchemaValType = 37;
pub const xmlSchemaValType_XML_SCHEMAS_ULONG: xmlSchemaValType = 38;
pub const xmlSchemaValType_XML_SCHEMAS_SHORT: xmlSchemaValType = 39;
pub const xmlSchemaValType_XML_SCHEMAS_USHORT: xmlSchemaValType = 40;
pub const xmlSchemaValType_XML_SCHEMAS_BYTE: xmlSchemaValType = 41;
pub const xmlSchemaValType_XML_SCHEMAS_UBYTE: xmlSchemaValType = 42;
pub const xmlSchemaValType_XML_SCHEMAS_HEXBINARY: xmlSchemaValType = 43;
pub const xmlSchemaValType_XML_SCHEMAS_BASE64BINARY: xmlSchemaValType = 44;
pub const xmlSchemaValType_XML_SCHEMAS_ANYTYPE: xmlSchemaValType = 45;
pub const xmlSchemaValType_XML_SCHEMAS_ANYSIMPLETYPE: xmlSchemaValType = 46;
pub type xmlSchemaValType = u32;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_BASIC: xmlSchemaTypeType = 1;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_ANY: xmlSchemaTypeType = 2;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_FACET: xmlSchemaTypeType = 3;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_SIMPLE: xmlSchemaTypeType = 4;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_COMPLEX: xmlSchemaTypeType = 5;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_SEQUENCE: xmlSchemaTypeType = 6;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_CHOICE: xmlSchemaTypeType = 7;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_ALL: xmlSchemaTypeType = 8;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_SIMPLE_CONTENT: xmlSchemaTypeType = 9;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_COMPLEX_CONTENT: xmlSchemaTypeType = 10;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_UR: xmlSchemaTypeType = 11;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_RESTRICTION: xmlSchemaTypeType = 12;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_EXTENSION: xmlSchemaTypeType = 13;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_ELEMENT: xmlSchemaTypeType = 14;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_ATTRIBUTE: xmlSchemaTypeType = 15;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_ATTRIBUTEGROUP: xmlSchemaTypeType = 16;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_GROUP: xmlSchemaTypeType = 17;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_NOTATION: xmlSchemaTypeType = 18;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_LIST: xmlSchemaTypeType = 19;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_UNION: xmlSchemaTypeType = 20;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_ANY_ATTRIBUTE: xmlSchemaTypeType = 21;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_IDC_UNIQUE: xmlSchemaTypeType = 22;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_IDC_KEY: xmlSchemaTypeType = 23;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_IDC_KEYREF: xmlSchemaTypeType = 24;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_PARTICLE: xmlSchemaTypeType = 25;
pub const xmlSchemaTypeType_XML_SCHEMA_TYPE_ATTRIBUTE_USE: xmlSchemaTypeType = 26;
pub const xmlSchemaTypeType_XML_SCHEMA_FACET_MININCLUSIVE: xmlSchemaTypeType = 1000;
pub const xmlSchemaTypeType_XML_SCHEMA_FACET_MINEXCLUSIVE: xmlSchemaTypeType = 1001;
pub const xmlSchemaTypeType_XML_SCHEMA_FACET_MAXINCLUSIVE: xmlSchemaTypeType = 1002;
pub const xmlSchemaTypeType_XML_SCHEMA_FACET_MAXEXCLUSIVE: xmlSchemaTypeType = 1003;
pub const xmlSchemaTypeType_XML_SCHEMA_FACET_TOTALDIGITS: xmlSchemaTypeType = 1004;
pub const xmlSchemaTypeType_XML_SCHEMA_FACET_FRACTIONDIGITS: xmlSchemaTypeType = 1005;
pub const xmlSchemaTypeType_XML_SCHEMA_FACET_PATTERN: xmlSchemaTypeType = 1006;
pub const xmlSchemaTypeType_XML_SCHEMA_FACET_ENUMERATION: xmlSchemaTypeType = 1007;
pub const xmlSchemaTypeType_XML_SCHEMA_FACET_WHITESPACE: xmlSchemaTypeType = 1008;
pub const xmlSchemaTypeType_XML_SCHEMA_FACET_LENGTH: xmlSchemaTypeType = 1009;
pub const xmlSchemaTypeType_XML_SCHEMA_FACET_MAXLENGTH: xmlSchemaTypeType = 1010;
pub const xmlSchemaTypeType_XML_SCHEMA_FACET_MINLENGTH: xmlSchemaTypeType = 1011;
pub const xmlSchemaTypeType_XML_SCHEMA_EXTRA_QNAMEREF: xmlSchemaTypeType = 2000;
pub const xmlSchemaTypeType_XML_SCHEMA_EXTRA_ATTR_USE_PROHIB: xmlSchemaTypeType = 2001;
pub type xmlSchemaTypeType = u32;
pub const xmlSchemaContentType_XML_SCHEMA_CONTENT_UNKNOWN: xmlSchemaContentType = 0;
pub const xmlSchemaContentType_XML_SCHEMA_CONTENT_EMPTY: xmlSchemaContentType = 1;
pub const xmlSchemaContentType_XML_SCHEMA_CONTENT_ELEMENTS: xmlSchemaContentType = 2;
pub const xmlSchemaContentType_XML_SCHEMA_CONTENT_MIXED: xmlSchemaContentType = 3;
pub const xmlSchemaContentType_XML_SCHEMA_CONTENT_SIMPLE: xmlSchemaContentType = 4;
pub const xmlSchemaContentType_XML_SCHEMA_CONTENT_MIXED_OR_ELEMENTS: xmlSchemaContentType = 5;
pub const xmlSchemaContentType_XML_SCHEMA_CONTENT_BASIC: xmlSchemaContentType = 6;
pub const xmlSchemaContentType_XML_SCHEMA_CONTENT_ANY: xmlSchemaContentType = 7;
pub type xmlSchemaContentType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchemaVal {
  _unused: [u8; 0],
}
pub type xmlSchemaVal = _xmlSchemaVal;
pub type xmlSchemaValPtr = *mut xmlSchemaVal;
pub type xmlSchemaType = _xmlSchemaType;
pub type xmlSchemaTypePtr = *mut xmlSchemaType;
pub type xmlSchemaFacet = _xmlSchemaFacet;
pub type xmlSchemaFacetPtr = *mut xmlSchemaFacet;
/// Annotation
pub type xmlSchemaAnnot = _xmlSchemaAnnot;
pub type xmlSchemaAnnotPtr = *mut xmlSchemaAnnot;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchemaAnnot {
  pub next: *mut _xmlSchemaAnnot,
  pub content: xmlNodePtr,
}
#[test]
fn bindgen_test_layout__xmlSchemaAnnot() {
  assert_eq!(
    ::std::mem::size_of::<_xmlSchemaAnnot>(),
    16usize,
    concat!("Size of: ", stringify!(_xmlSchemaAnnot))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlSchemaAnnot>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlSchemaAnnot))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAnnot>())).next as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAnnot),
      "::",
      stringify!(next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAnnot>())).content as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAnnot),
      "::",
      stringify!(content)
    )
  );
}
/// xmlSchemaAttribute:
/// An attribute definition.
pub type xmlSchemaAttribute = _xmlSchemaAttribute;
pub type xmlSchemaAttributePtr = *mut xmlSchemaAttribute;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchemaAttribute {
  pub type_: xmlSchemaTypeType,
  pub next: *mut _xmlSchemaAttribute,
  pub name: *const xmlChar,
  pub id: *const xmlChar,
  pub ref_: *const xmlChar,
  pub refNs: *const xmlChar,
  pub typeName: *const xmlChar,
  pub typeNs: *const xmlChar,
  pub annot: xmlSchemaAnnotPtr,
  pub base: xmlSchemaTypePtr,
  pub occurs: ::std::os::raw::c_int,
  pub defValue: *const xmlChar,
  pub subtypes: xmlSchemaTypePtr,
  pub node: xmlNodePtr,
  pub targetNamespace: *const xmlChar,
  pub flags: ::std::os::raw::c_int,
  pub refPrefix: *const xmlChar,
  pub defVal: xmlSchemaValPtr,
  pub refDecl: xmlSchemaAttributePtr,
}
#[test]
fn bindgen_test_layout__xmlSchemaAttribute() {
  assert_eq!(
    ::std::mem::size_of::<_xmlSchemaAttribute>(),
    152usize,
    concat!("Size of: ", stringify!(_xmlSchemaAttribute))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlSchemaAttribute>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlSchemaAttribute))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttribute>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttribute),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttribute>())).next as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttribute),
      "::",
      stringify!(next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttribute>())).name as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttribute),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttribute>())).id as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttribute),
      "::",
      stringify!(id)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttribute>())).ref_ as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttribute),
      "::",
      stringify!(ref_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttribute>())).refNs as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttribute),
      "::",
      stringify!(refNs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttribute>())).typeName as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttribute),
      "::",
      stringify!(typeName)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttribute>())).typeNs as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttribute),
      "::",
      stringify!(typeNs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttribute>())).annot as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttribute),
      "::",
      stringify!(annot)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttribute>())).base as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttribute),
      "::",
      stringify!(base)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttribute>())).occurs as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttribute),
      "::",
      stringify!(occurs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttribute>())).defValue as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttribute),
      "::",
      stringify!(defValue)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttribute>())).subtypes as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttribute),
      "::",
      stringify!(subtypes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttribute>())).node as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttribute),
      "::",
      stringify!(node)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttribute>())).targetNamespace as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttribute),
      "::",
      stringify!(targetNamespace)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttribute>())).flags as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttribute),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttribute>())).refPrefix as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttribute),
      "::",
      stringify!(refPrefix)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttribute>())).defVal as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttribute),
      "::",
      stringify!(defVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttribute>())).refDecl as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttribute),
      "::",
      stringify!(refDecl)
    )
  );
}
/// xmlSchemaAttributeLink:
/// Used to build a list of attribute uses on complexType definitions.
/// WARNING: Deprecated; not used.
pub type xmlSchemaAttributeLink = _xmlSchemaAttributeLink;
pub type xmlSchemaAttributeLinkPtr = *mut xmlSchemaAttributeLink;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchemaAttributeLink {
  pub next: *mut _xmlSchemaAttributeLink,
  pub attr: *mut _xmlSchemaAttribute,
}
#[test]
fn bindgen_test_layout__xmlSchemaAttributeLink() {
  assert_eq!(
    ::std::mem::size_of::<_xmlSchemaAttributeLink>(),
    16usize,
    concat!("Size of: ", stringify!(_xmlSchemaAttributeLink))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlSchemaAttributeLink>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlSchemaAttributeLink))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttributeLink>())).next as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttributeLink),
      "::",
      stringify!(next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttributeLink>())).attr as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttributeLink),
      "::",
      stringify!(attr)
    )
  );
}
/// xmlSchemaCharValueLink:
/// Used to build a list of namespaces on wildcards.
pub type xmlSchemaWildcardNs = _xmlSchemaWildcardNs;
pub type xmlSchemaWildcardNsPtr = *mut xmlSchemaWildcardNs;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchemaWildcardNs {
  pub next: *mut _xmlSchemaWildcardNs,
  pub value: *const xmlChar,
}
#[test]
fn bindgen_test_layout__xmlSchemaWildcardNs() {
  assert_eq!(
    ::std::mem::size_of::<_xmlSchemaWildcardNs>(),
    16usize,
    concat!("Size of: ", stringify!(_xmlSchemaWildcardNs))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlSchemaWildcardNs>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlSchemaWildcardNs))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaWildcardNs>())).next as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaWildcardNs),
      "::",
      stringify!(next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaWildcardNs>())).value as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaWildcardNs),
      "::",
      stringify!(value)
    )
  );
}
/// xmlSchemaWildcard.
/// A wildcard.
pub type xmlSchemaWildcard = _xmlSchemaWildcard;
pub type xmlSchemaWildcardPtr = *mut xmlSchemaWildcard;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchemaWildcard {
  pub type_: xmlSchemaTypeType,
  pub id: *const xmlChar,
  pub annot: xmlSchemaAnnotPtr,
  pub node: xmlNodePtr,
  pub minOccurs: ::std::os::raw::c_int,
  pub maxOccurs: ::std::os::raw::c_int,
  pub processContents: ::std::os::raw::c_int,
  pub any: ::std::os::raw::c_int,
  pub nsSet: xmlSchemaWildcardNsPtr,
  pub negNsSet: xmlSchemaWildcardNsPtr,
  pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__xmlSchemaWildcard() {
  assert_eq!(
    ::std::mem::size_of::<_xmlSchemaWildcard>(),
    72usize,
    concat!("Size of: ", stringify!(_xmlSchemaWildcard))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlSchemaWildcard>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlSchemaWildcard))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaWildcard>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaWildcard),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaWildcard>())).id as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaWildcard),
      "::",
      stringify!(id)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaWildcard>())).annot as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaWildcard),
      "::",
      stringify!(annot)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaWildcard>())).node as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaWildcard),
      "::",
      stringify!(node)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaWildcard>())).minOccurs as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaWildcard),
      "::",
      stringify!(minOccurs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaWildcard>())).maxOccurs as *const _ as usize },
    36usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaWildcard),
      "::",
      stringify!(maxOccurs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaWildcard>())).processContents as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaWildcard),
      "::",
      stringify!(processContents)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaWildcard>())).any as *const _ as usize },
    44usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaWildcard),
      "::",
      stringify!(any)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaWildcard>())).nsSet as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaWildcard),
      "::",
      stringify!(nsSet)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaWildcard>())).negNsSet as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaWildcard),
      "::",
      stringify!(negNsSet)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaWildcard>())).flags as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaWildcard),
      "::",
      stringify!(flags)
    )
  );
}
/// An attribute group definition.
///
/// xmlSchemaAttribute and xmlSchemaAttributeGroup start of structures
/// must be kept similar
pub type xmlSchemaAttributeGroup = _xmlSchemaAttributeGroup;
pub type xmlSchemaAttributeGroupPtr = *mut xmlSchemaAttributeGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchemaAttributeGroup {
  pub type_: xmlSchemaTypeType,
  pub next: *mut _xmlSchemaAttribute,
  pub name: *const xmlChar,
  pub id: *const xmlChar,
  pub ref_: *const xmlChar,
  pub refNs: *const xmlChar,
  pub annot: xmlSchemaAnnotPtr,
  pub attributes: xmlSchemaAttributePtr,
  pub node: xmlNodePtr,
  pub flags: ::std::os::raw::c_int,
  pub attributeWildcard: xmlSchemaWildcardPtr,
  pub refPrefix: *const xmlChar,
  pub refItem: xmlSchemaAttributeGroupPtr,
  pub targetNamespace: *const xmlChar,
  pub attrUses: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlSchemaAttributeGroup() {
  assert_eq!(
    ::std::mem::size_of::<_xmlSchemaAttributeGroup>(),
    120usize,
    concat!("Size of: ", stringify!(_xmlSchemaAttributeGroup))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlSchemaAttributeGroup>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlSchemaAttributeGroup))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttributeGroup>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttributeGroup),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttributeGroup>())).next as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttributeGroup),
      "::",
      stringify!(next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttributeGroup>())).name as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttributeGroup),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttributeGroup>())).id as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttributeGroup),
      "::",
      stringify!(id)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttributeGroup>())).ref_ as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttributeGroup),
      "::",
      stringify!(ref_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttributeGroup>())).refNs as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttributeGroup),
      "::",
      stringify!(refNs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttributeGroup>())).annot as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttributeGroup),
      "::",
      stringify!(annot)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttributeGroup>())).attributes as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttributeGroup),
      "::",
      stringify!(attributes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttributeGroup>())).node as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttributeGroup),
      "::",
      stringify!(node)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttributeGroup>())).flags as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttributeGroup),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlSchemaAttributeGroup>())).attributeWildcard as *const _ as usize
    },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttributeGroup),
      "::",
      stringify!(attributeWildcard)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttributeGroup>())).refPrefix as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttributeGroup),
      "::",
      stringify!(refPrefix)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttributeGroup>())).refItem as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttributeGroup),
      "::",
      stringify!(refItem)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<_xmlSchemaAttributeGroup>())).targetNamespace as *const _ as usize
    },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttributeGroup),
      "::",
      stringify!(targetNamespace)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaAttributeGroup>())).attrUses as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaAttributeGroup),
      "::",
      stringify!(attrUses)
    )
  );
}
/// xmlSchemaTypeLink:
/// Used to build a list of types (e.g. member types of
/// simpleType with variety "union").
pub type xmlSchemaTypeLink = _xmlSchemaTypeLink;
pub type xmlSchemaTypeLinkPtr = *mut xmlSchemaTypeLink;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchemaTypeLink {
  pub next: *mut _xmlSchemaTypeLink,
  pub type_: xmlSchemaTypePtr,
}
#[test]
fn bindgen_test_layout__xmlSchemaTypeLink() {
  assert_eq!(
    ::std::mem::size_of::<_xmlSchemaTypeLink>(),
    16usize,
    concat!("Size of: ", stringify!(_xmlSchemaTypeLink))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlSchemaTypeLink>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlSchemaTypeLink))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaTypeLink>())).next as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaTypeLink),
      "::",
      stringify!(next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaTypeLink>())).type_ as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaTypeLink),
      "::",
      stringify!(type_)
    )
  );
}
/// xmlSchemaFacetLink:
/// Used to build a list of facets.
pub type xmlSchemaFacetLink = _xmlSchemaFacetLink;
pub type xmlSchemaFacetLinkPtr = *mut xmlSchemaFacetLink;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchemaFacetLink {
  pub next: *mut _xmlSchemaFacetLink,
  pub facet: xmlSchemaFacetPtr,
}
#[test]
fn bindgen_test_layout__xmlSchemaFacetLink() {
  assert_eq!(
    ::std::mem::size_of::<_xmlSchemaFacetLink>(),
    16usize,
    concat!("Size of: ", stringify!(_xmlSchemaFacetLink))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlSchemaFacetLink>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlSchemaFacetLink))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaFacetLink>())).next as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaFacetLink),
      "::",
      stringify!(next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaFacetLink>())).facet as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaFacetLink),
      "::",
      stringify!(facet)
    )
  );
}
/// _xmlSchemaType:
///
/// Schemas type definition.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchemaType {
  pub type_: xmlSchemaTypeType,
  pub next: *mut _xmlSchemaType,
  pub name: *const xmlChar,
  pub id: *const xmlChar,
  pub ref_: *const xmlChar,
  pub refNs: *const xmlChar,
  pub annot: xmlSchemaAnnotPtr,
  pub subtypes: xmlSchemaTypePtr,
  pub attributes: xmlSchemaAttributePtr,
  pub node: xmlNodePtr,
  pub minOccurs: ::std::os::raw::c_int,
  pub maxOccurs: ::std::os::raw::c_int,
  pub flags: ::std::os::raw::c_int,
  pub contentType: xmlSchemaContentType,
  pub base: *const xmlChar,
  pub baseNs: *const xmlChar,
  pub baseType: xmlSchemaTypePtr,
  pub facets: xmlSchemaFacetPtr,
  pub redef: *mut _xmlSchemaType,
  pub recurse: ::std::os::raw::c_int,
  pub attributeUses: *mut xmlSchemaAttributeLinkPtr,
  pub attributeWildcard: xmlSchemaWildcardPtr,
  pub builtInType: ::std::os::raw::c_int,
  pub memberTypes: xmlSchemaTypeLinkPtr,
  pub facetSet: xmlSchemaFacetLinkPtr,
  pub refPrefix: *const xmlChar,
  pub contentTypeDef: xmlSchemaTypePtr,
  pub contModel: xmlRegexpPtr,
  pub targetNamespace: *const xmlChar,
  pub attrUses: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlSchemaType() {
  assert_eq!(
    ::std::mem::size_of::<_xmlSchemaType>(),
    224usize,
    concat!("Size of: ", stringify!(_xmlSchemaType))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlSchemaType>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlSchemaType))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).next as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).name as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).id as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(id)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).ref_ as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(ref_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).refNs as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(refNs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).annot as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(annot)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).subtypes as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(subtypes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).attributes as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(attributes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).node as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(node)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).minOccurs as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(minOccurs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).maxOccurs as *const _ as usize },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(maxOccurs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).flags as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).contentType as *const _ as usize },
    92usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(contentType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).base as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(base)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).baseNs as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(baseNs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).baseType as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(baseType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).facets as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(facets)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).redef as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(redef)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).recurse as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(recurse)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).attributeUses as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(attributeUses)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).attributeWildcard as *const _ as usize },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(attributeWildcard)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).builtInType as *const _ as usize },
    160usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(builtInType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).memberTypes as *const _ as usize },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(memberTypes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).facetSet as *const _ as usize },
    176usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(facetSet)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).refPrefix as *const _ as usize },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(refPrefix)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).contentTypeDef as *const _ as usize },
    192usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(contentTypeDef)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).contModel as *const _ as usize },
    200usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(contModel)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).targetNamespace as *const _ as usize },
    208usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(targetNamespace)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaType>())).attrUses as *const _ as usize },
    216usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaType),
      "::",
      stringify!(attrUses)
    )
  );
}
pub type xmlSchemaElement = _xmlSchemaElement;
pub type xmlSchemaElementPtr = *mut xmlSchemaElement;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchemaElement {
  pub type_: xmlSchemaTypeType,
  pub next: *mut _xmlSchemaType,
  pub name: *const xmlChar,
  pub id: *const xmlChar,
  pub ref_: *const xmlChar,
  pub refNs: *const xmlChar,
  pub annot: xmlSchemaAnnotPtr,
  pub subtypes: xmlSchemaTypePtr,
  pub attributes: xmlSchemaAttributePtr,
  pub node: xmlNodePtr,
  pub minOccurs: ::std::os::raw::c_int,
  pub maxOccurs: ::std::os::raw::c_int,
  pub flags: ::std::os::raw::c_int,
  pub targetNamespace: *const xmlChar,
  pub namedType: *const xmlChar,
  pub namedTypeNs: *const xmlChar,
  pub substGroup: *const xmlChar,
  pub substGroupNs: *const xmlChar,
  pub scope: *const xmlChar,
  pub value: *const xmlChar,
  pub refDecl: *mut _xmlSchemaElement,
  pub contModel: xmlRegexpPtr,
  pub contentType: xmlSchemaContentType,
  pub refPrefix: *const xmlChar,
  pub defVal: xmlSchemaValPtr,
  pub idcs: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlSchemaElement() {
  assert_eq!(
    ::std::mem::size_of::<_xmlSchemaElement>(),
    200usize,
    concat!("Size of: ", stringify!(_xmlSchemaElement))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlSchemaElement>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlSchemaElement))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).next as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).name as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).id as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(id)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).ref_ as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(ref_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).refNs as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(refNs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).annot as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(annot)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).subtypes as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(subtypes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).attributes as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(attributes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).node as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(node)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).minOccurs as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(minOccurs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).maxOccurs as *const _ as usize },
    84usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(maxOccurs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).flags as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).targetNamespace as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(targetNamespace)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).namedType as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(namedType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).namedTypeNs as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(namedTypeNs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).substGroup as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(substGroup)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).substGroupNs as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(substGroupNs)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).scope as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(scope)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).value as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(value)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).refDecl as *const _ as usize },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(refDecl)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).contModel as *const _ as usize },
    160usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(contModel)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).contentType as *const _ as usize },
    168usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(contentType)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).refPrefix as *const _ as usize },
    176usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(refPrefix)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).defVal as *const _ as usize },
    184usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(defVal)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaElement>())).idcs as *const _ as usize },
    192usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaElement),
      "::",
      stringify!(idcs)
    )
  );
}
/// A facet definition.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchemaFacet {
  pub type_: xmlSchemaTypeType,
  pub next: *mut _xmlSchemaFacet,
  pub value: *const xmlChar,
  pub id: *const xmlChar,
  pub annot: xmlSchemaAnnotPtr,
  pub node: xmlNodePtr,
  pub fixed: ::std::os::raw::c_int,
  pub whitespace: ::std::os::raw::c_int,
  pub val: xmlSchemaValPtr,
  pub regexp: xmlRegexpPtr,
}
#[test]
fn bindgen_test_layout__xmlSchemaFacet() {
  assert_eq!(
    ::std::mem::size_of::<_xmlSchemaFacet>(),
    72usize,
    concat!("Size of: ", stringify!(_xmlSchemaFacet))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlSchemaFacet>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlSchemaFacet))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaFacet>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaFacet),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaFacet>())).next as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaFacet),
      "::",
      stringify!(next)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaFacet>())).value as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaFacet),
      "::",
      stringify!(value)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaFacet>())).id as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaFacet),
      "::",
      stringify!(id)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaFacet>())).annot as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaFacet),
      "::",
      stringify!(annot)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaFacet>())).node as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaFacet),
      "::",
      stringify!(node)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaFacet>())).fixed as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaFacet),
      "::",
      stringify!(fixed)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaFacet>())).whitespace as *const _ as usize },
    52usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaFacet),
      "::",
      stringify!(whitespace)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaFacet>())).val as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaFacet),
      "::",
      stringify!(val)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaFacet>())).regexp as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaFacet),
      "::",
      stringify!(regexp)
    )
  );
}
/// A notation definition.
pub type xmlSchemaNotation = _xmlSchemaNotation;
pub type xmlSchemaNotationPtr = *mut xmlSchemaNotation;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchemaNotation {
  pub type_: xmlSchemaTypeType,
  pub name: *const xmlChar,
  pub annot: xmlSchemaAnnotPtr,
  pub identifier: *const xmlChar,
  pub targetNamespace: *const xmlChar,
}
#[test]
fn bindgen_test_layout__xmlSchemaNotation() {
  assert_eq!(
    ::std::mem::size_of::<_xmlSchemaNotation>(),
    40usize,
    concat!("Size of: ", stringify!(_xmlSchemaNotation))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlSchemaNotation>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlSchemaNotation))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaNotation>())).type_ as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaNotation),
      "::",
      stringify!(type_)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaNotation>())).name as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaNotation),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaNotation>())).annot as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaNotation),
      "::",
      stringify!(annot)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaNotation>())).identifier as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaNotation),
      "::",
      stringify!(identifier)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchemaNotation>())).targetNamespace as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchemaNotation),
      "::",
      stringify!(targetNamespace)
    )
  );
}
/// _xmlSchema:
///
/// A Schemas definition
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchema {
  pub name: *const xmlChar,
  pub targetNamespace: *const xmlChar,
  pub version: *const xmlChar,
  pub id: *const xmlChar,
  pub doc: xmlDocPtr,
  pub annot: xmlSchemaAnnotPtr,
  pub flags: ::std::os::raw::c_int,
  pub typeDecl: xmlHashTablePtr,
  pub attrDecl: xmlHashTablePtr,
  pub attrgrpDecl: xmlHashTablePtr,
  pub elemDecl: xmlHashTablePtr,
  pub notaDecl: xmlHashTablePtr,
  pub schemasImports: xmlHashTablePtr,
  pub _private: *mut ::std::os::raw::c_void,
  pub groupDecl: xmlHashTablePtr,
  pub dict: xmlDictPtr,
  pub includes: *mut ::std::os::raw::c_void,
  pub preserve: ::std::os::raw::c_int,
  pub counter: ::std::os::raw::c_int,
  pub idcDef: xmlHashTablePtr,
  pub volatiles: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__xmlSchema() {
  assert_eq!(
    ::std::mem::size_of::<_xmlSchema>(),
    160usize,
    concat!("Size of: ", stringify!(_xmlSchema))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlSchema>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlSchema))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchema>())).name as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchema),
      "::",
      stringify!(name)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchema>())).targetNamespace as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchema),
      "::",
      stringify!(targetNamespace)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchema>())).version as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchema),
      "::",
      stringify!(version)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchema>())).id as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchema),
      "::",
      stringify!(id)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchema>())).doc as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchema),
      "::",
      stringify!(doc)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchema>())).annot as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchema),
      "::",
      stringify!(annot)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchema>())).flags as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchema),
      "::",
      stringify!(flags)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchema>())).typeDecl as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchema),
      "::",
      stringify!(typeDecl)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchema>())).attrDecl as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchema),
      "::",
      stringify!(attrDecl)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchema>())).attrgrpDecl as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchema),
      "::",
      stringify!(attrgrpDecl)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchema>())).elemDecl as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchema),
      "::",
      stringify!(elemDecl)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchema>())).notaDecl as *const _ as usize },
    88usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchema),
      "::",
      stringify!(notaDecl)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchema>())).schemasImports as *const _ as usize },
    96usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchema),
      "::",
      stringify!(schemasImports)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchema>()))._private as *const _ as usize },
    104usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchema),
      "::",
      stringify!(_private)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchema>())).groupDecl as *const _ as usize },
    112usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchema),
      "::",
      stringify!(groupDecl)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchema>())).dict as *const _ as usize },
    120usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchema),
      "::",
      stringify!(dict)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchema>())).includes as *const _ as usize },
    128usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchema),
      "::",
      stringify!(includes)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchema>())).preserve as *const _ as usize },
    136usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchema),
      "::",
      stringify!(preserve)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchema>())).counter as *const _ as usize },
    140usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchema),
      "::",
      stringify!(counter)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchema>())).idcDef as *const _ as usize },
    144usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchema),
      "::",
      stringify!(idcDef)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlSchema>())).volatiles as *const _ as usize },
    152usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlSchema),
      "::",
      stringify!(volatiles)
    )
  );
}
extern "C" {
  pub fn xmlSchemaFreeType(type_: xmlSchemaTypePtr);
}
extern "C" {
  pub fn xmlSchemaFreeWildcard(wildcard: xmlSchemaWildcardPtr);
}
pub const xmlSchematronValidOptions_XML_SCHEMATRON_OUT_QUIET: xmlSchematronValidOptions = 1;
pub const xmlSchematronValidOptions_XML_SCHEMATRON_OUT_TEXT: xmlSchematronValidOptions = 2;
pub const xmlSchematronValidOptions_XML_SCHEMATRON_OUT_XML: xmlSchematronValidOptions = 4;
pub const xmlSchematronValidOptions_XML_SCHEMATRON_OUT_ERROR: xmlSchematronValidOptions = 8;
pub const xmlSchematronValidOptions_XML_SCHEMATRON_OUT_FILE: xmlSchematronValidOptions = 256;
pub const xmlSchematronValidOptions_XML_SCHEMATRON_OUT_BUFFER: xmlSchematronValidOptions = 512;
pub const xmlSchematronValidOptions_XML_SCHEMATRON_OUT_IO: xmlSchematronValidOptions = 1024;
pub type xmlSchematronValidOptions = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchematron {
  _unused: [u8; 0],
}
/// The schemas related types are kept internal
pub type xmlSchematron = _xmlSchematron;
pub type xmlSchematronPtr = *mut xmlSchematron;
/// xmlSchematronValidityErrorFunc:
/// @ctx: the validation context
/// @msg: the message
/// @...: extra arguments
///
/// Signature of an error callback from a Schematron validation
pub type xmlSchematronValidityErrorFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
/// xmlSchematronValidityWarningFunc:
/// @ctx: the validation context
/// @msg: the message
/// @...: extra arguments
///
/// Signature of a warning callback from a Schematron validation
pub type xmlSchematronValidityWarningFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchematronParserCtxt {
  _unused: [u8; 0],
}
/// A schemas validation context
pub type xmlSchematronParserCtxt = _xmlSchematronParserCtxt;
pub type xmlSchematronParserCtxtPtr = *mut xmlSchematronParserCtxt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchematronValidCtxt {
  _unused: [u8; 0],
}
pub type xmlSchematronValidCtxt = _xmlSchematronValidCtxt;
pub type xmlSchematronValidCtxtPtr = *mut xmlSchematronValidCtxt;
extern "C" {
  pub fn xmlSchematronNewParserCtxt(
    URL: *const ::std::os::raw::c_char,
  ) -> xmlSchematronParserCtxtPtr;
}
extern "C" {
  pub fn xmlSchematronNewMemParserCtxt(
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
  ) -> xmlSchematronParserCtxtPtr;
}
extern "C" {
  pub fn xmlSchematronNewDocParserCtxt(doc: xmlDocPtr) -> xmlSchematronParserCtxtPtr;
}
extern "C" {
  pub fn xmlSchematronFreeParserCtxt(ctxt: xmlSchematronParserCtxtPtr);
}
extern "C" {
  /// XMLPUBFUN void XMLCALL
  /// xmlSchematronSetParserErrors(xmlSchematronParserCtxtPtr ctxt,
  /// xmlSchematronValidityErrorFunc err,
  /// xmlSchematronValidityWarningFunc warn,
  /// void *ctx);
  /// XMLPUBFUN int XMLCALL
  /// xmlSchematronGetParserErrors(xmlSchematronParserCtxtPtr ctxt,
  /// xmlSchematronValidityErrorFunc * err,
  /// xmlSchematronValidityWarningFunc * warn,
  /// void **ctx);
  /// XMLPUBFUN int XMLCALL
  /// xmlSchematronIsValid	(xmlSchematronValidCtxtPtr ctxt);
  pub fn xmlSchematronParse(ctxt: xmlSchematronParserCtxtPtr) -> xmlSchematronPtr;
}
extern "C" {
  pub fn xmlSchematronFree(schema: xmlSchematronPtr);
}
extern "C" {
  pub fn xmlSchematronSetValidStructuredErrors(
    ctxt: xmlSchematronValidCtxtPtr,
    serror: xmlStructuredErrorFunc,
    ctx: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  /// XMLPUBFUN void XMLCALL
  /// xmlSchematronSetValidErrors	(xmlSchematronValidCtxtPtr ctxt,
  /// xmlSchematronValidityErrorFunc err,
  /// xmlSchematronValidityWarningFunc warn,
  /// void *ctx);
  /// XMLPUBFUN int XMLCALL
  /// xmlSchematronGetValidErrors	(xmlSchematronValidCtxtPtr ctxt,
  /// xmlSchematronValidityErrorFunc *err,
  /// xmlSchematronValidityWarningFunc *warn,
  /// void **ctx);
  /// XMLPUBFUN int XMLCALL
  /// xmlSchematronSetValidOptions(xmlSchematronValidCtxtPtr ctxt,
  /// int options);
  /// XMLPUBFUN int XMLCALL
  /// xmlSchematronValidCtxtGetOptions(xmlSchematronValidCtxtPtr ctxt);
  /// XMLPUBFUN int XMLCALL
  /// xmlSchematronValidateOneElement (xmlSchematronValidCtxtPtr ctxt,
  /// xmlNodePtr elem);
  pub fn xmlSchematronNewValidCtxt(
    schema: xmlSchematronPtr,
    options: ::std::os::raw::c_int,
  ) -> xmlSchematronValidCtxtPtr;
}
extern "C" {
  pub fn xmlSchematronFreeValidCtxt(ctxt: xmlSchematronValidCtxtPtr);
}
extern "C" {
  pub fn xmlSchematronValidateDoc(
    ctxt: xmlSchematronValidCtxtPtr,
    instance: xmlDocPtr,
  ) -> ::std::os::raw::c_int;
}
/// xmlURI:
///
/// A parsed URI reference. This is a struct containing the various fields
/// as described in RFC 2396 but separated for further processing.
///
/// Note: query is a deprecated field which is incorrectly unescaped.
/// query_raw takes precedence over query if the former is set.
/// See: http://mail.gnome.org/archives/xml/2007-April/thread.html#00127
pub type xmlURI = _xmlURI;
pub type xmlURIPtr = *mut xmlURI;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlURI {
  pub scheme: *mut ::std::os::raw::c_char,
  pub opaque: *mut ::std::os::raw::c_char,
  pub authority: *mut ::std::os::raw::c_char,
  pub server: *mut ::std::os::raw::c_char,
  pub user: *mut ::std::os::raw::c_char,
  pub port: ::std::os::raw::c_int,
  pub path: *mut ::std::os::raw::c_char,
  pub query: *mut ::std::os::raw::c_char,
  pub fragment: *mut ::std::os::raw::c_char,
  pub cleanup: ::std::os::raw::c_int,
  pub query_raw: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__xmlURI() {
  assert_eq!(
    ::std::mem::size_of::<_xmlURI>(),
    88usize,
    concat!("Size of: ", stringify!(_xmlURI))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlURI>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlURI))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlURI>())).scheme as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlURI),
      "::",
      stringify!(scheme)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlURI>())).opaque as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlURI),
      "::",
      stringify!(opaque)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlURI>())).authority as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlURI),
      "::",
      stringify!(authority)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlURI>())).server as *const _ as usize },
    24usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlURI),
      "::",
      stringify!(server)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlURI>())).user as *const _ as usize },
    32usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlURI),
      "::",
      stringify!(user)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlURI>())).port as *const _ as usize },
    40usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlURI),
      "::",
      stringify!(port)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlURI>())).path as *const _ as usize },
    48usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlURI),
      "::",
      stringify!(path)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlURI>())).query as *const _ as usize },
    56usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlURI),
      "::",
      stringify!(query)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlURI>())).fragment as *const _ as usize },
    64usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlURI),
      "::",
      stringify!(fragment)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlURI>())).cleanup as *const _ as usize },
    72usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlURI),
      "::",
      stringify!(cleanup)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlURI>())).query_raw as *const _ as usize },
    80usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlURI),
      "::",
      stringify!(query_raw)
    )
  );
}
extern "C" {
  pub fn xmlCreateURI() -> xmlURIPtr;
}
extern "C" {
  pub fn xmlBuildURI(URI: *const xmlChar, base: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlBuildRelativeURI(URI: *const xmlChar, base: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlParseURI(str: *const ::std::os::raw::c_char) -> xmlURIPtr;
}
extern "C" {
  pub fn xmlParseURIRaw(
    str: *const ::std::os::raw::c_char,
    raw: ::std::os::raw::c_int,
  ) -> xmlURIPtr;
}
extern "C" {
  pub fn xmlParseURIReference(
    uri: xmlURIPtr,
    str: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSaveUri(uri: xmlURIPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlPrintURI(stream: *mut FILE, uri: xmlURIPtr);
}
extern "C" {
  pub fn xmlURIEscapeStr(str: *const xmlChar, list: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlURIUnescapeString(
    str: *const ::std::os::raw::c_char,
    len: ::std::os::raw::c_int,
    target: *mut ::std::os::raw::c_char,
  ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
  pub fn xmlNormalizeURIPath(path: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlURIEscape(str: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlFreeURI(uri: xmlURIPtr);
}
extern "C" {
  pub fn xmlCanonicPath(path: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlPathToURI(path: *const xmlChar) -> *mut xmlChar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlXIncludeCtxt {
  _unused: [u8; 0],
}
pub type xmlXIncludeCtxt = _xmlXIncludeCtxt;
pub type xmlXIncludeCtxtPtr = *mut xmlXIncludeCtxt;
extern "C" {
  pub fn xmlXIncludeProcess(doc: xmlDocPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXIncludeProcessFlags(
    doc: xmlDocPtr,
    flags: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXIncludeProcessFlagsData(
    doc: xmlDocPtr,
    flags: ::std::os::raw::c_int,
    data: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXIncludeProcessTreeFlagsData(
    tree: xmlNodePtr,
    flags: ::std::os::raw::c_int,
    data: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXIncludeProcessTree(tree: xmlNodePtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXIncludeProcessTreeFlags(
    tree: xmlNodePtr,
    flags: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXIncludeNewContext(doc: xmlDocPtr) -> xmlXIncludeCtxtPtr;
}
extern "C" {
  pub fn xmlXIncludeSetFlags(
    ctxt: xmlXIncludeCtxtPtr,
    flags: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXIncludeFreeContext(ctxt: xmlXIncludeCtxtPtr);
}
extern "C" {
  pub fn xmlXIncludeProcessNode(
    ctxt: xmlXIncludeCtxtPtr,
    tree: xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlModule {
  _unused: [u8; 0],
}
/// xmlModulePtr:
///
/// A handle to a dynamically loaded module
pub type xmlModule = _xmlModule;
pub type xmlModulePtr = *mut xmlModule;
pub const xmlModuleOption_XML_MODULE_LAZY: xmlModuleOption = 1;
pub const xmlModuleOption_XML_MODULE_LOCAL: xmlModuleOption = 2;
/// xmlModuleOption:
///
/// enumeration of options that can be passed down to xmlModuleOpen()
pub type xmlModuleOption = u32;
extern "C" {
  pub fn xmlModuleOpen(
    filename: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlModulePtr;
}
extern "C" {
  pub fn xmlModuleSymbol(
    module: xmlModulePtr,
    name: *const ::std::os::raw::c_char,
    result: *mut *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlModuleClose(module: xmlModulePtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlModuleFree(module: xmlModulePtr) -> ::std::os::raw::c_int;
}
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_OK: xmlSchemaValidError = 0;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_NOROOT: xmlSchemaValidError = 1;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_UNDECLAREDELEM: xmlSchemaValidError = 2;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_NOTTOPLEVEL: xmlSchemaValidError = 3;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_MISSING: xmlSchemaValidError = 4;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_WRONGELEM: xmlSchemaValidError = 5;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_NOTYPE: xmlSchemaValidError = 6;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_NOROLLBACK: xmlSchemaValidError = 7;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_ISABSTRACT: xmlSchemaValidError = 8;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_NOTEMPTY: xmlSchemaValidError = 9;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_ELEMCONT: xmlSchemaValidError = 10;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_HAVEDEFAULT: xmlSchemaValidError = 11;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_NOTNILLABLE: xmlSchemaValidError = 12;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_EXTRACONTENT: xmlSchemaValidError = 13;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_INVALIDATTR: xmlSchemaValidError = 14;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_INVALIDELEM: xmlSchemaValidError = 15;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_NOTDETERMINIST: xmlSchemaValidError = 16;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_CONSTRUCT: xmlSchemaValidError = 17;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_INTERNAL: xmlSchemaValidError = 18;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_NOTSIMPLE: xmlSchemaValidError = 19;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_ATTRUNKNOWN: xmlSchemaValidError = 20;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_ATTRINVALID: xmlSchemaValidError = 21;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_VALUE: xmlSchemaValidError = 22;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_FACET: xmlSchemaValidError = 23;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_: xmlSchemaValidError = 24;
pub const xmlSchemaValidError_XML_SCHEMAS_ERR_XXX: xmlSchemaValidError = 25;
/// This error codes are obsolete; not used any more.
pub type xmlSchemaValidError = u32;
pub const xmlSchemaValidOption_XML_SCHEMA_VAL_VC_I_CREATE: xmlSchemaValidOption = 1;
/// xmlSchemaValidOption:
///
/// This is the set of XML Schema validation options.
pub type xmlSchemaValidOption = u32;
/// The schemas related types are kept internal
pub type xmlSchema = _xmlSchema;
pub type xmlSchemaPtr = *mut xmlSchema;
/// xmlSchemaValidityErrorFunc:
/// @ctx: the validation context
/// @msg: the message
/// @...: extra arguments
///
/// Signature of an error callback from an XSD validation
pub type xmlSchemaValidityErrorFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
/// xmlSchemaValidityWarningFunc:
/// @ctx: the validation context
/// @msg: the message
/// @...: extra arguments
///
/// Signature of a warning callback from an XSD validation
pub type xmlSchemaValidityWarningFunc = ::std::option::Option<
  unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, msg: *const ::std::os::raw::c_char, ...),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchemaParserCtxt {
  _unused: [u8; 0],
}
/// A schemas validation context
pub type xmlSchemaParserCtxt = _xmlSchemaParserCtxt;
pub type xmlSchemaParserCtxtPtr = *mut xmlSchemaParserCtxt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchemaValidCtxt {
  _unused: [u8; 0],
}
pub type xmlSchemaValidCtxt = _xmlSchemaValidCtxt;
pub type xmlSchemaValidCtxtPtr = *mut xmlSchemaValidCtxt;
/// xmlSchemaValidityLocatorFunc:
/// @ctx: user provided context
/// @file: returned file information
/// @line: returned line information
///
/// A schemas validation locator, a callback called by the validator.
/// This is used when file or node informations are not available
/// to find out what file and line number are affected
///
/// Returns: 0 in case of success and -1 in case of error
pub type xmlSchemaValidityLocatorFunc = ::std::option::Option<
  unsafe extern "C" fn(
    ctx: *mut ::std::os::raw::c_void,
    file: *mut *const ::std::os::raw::c_char,
    line: *mut ::std::os::raw::c_ulong,
  ) -> ::std::os::raw::c_int,
>;
extern "C" {
  pub fn xmlSchemaNewParserCtxt(URL: *const ::std::os::raw::c_char) -> xmlSchemaParserCtxtPtr;
}
extern "C" {
  pub fn xmlSchemaNewMemParserCtxt(
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
  ) -> xmlSchemaParserCtxtPtr;
}
extern "C" {
  pub fn xmlSchemaNewDocParserCtxt(doc: xmlDocPtr) -> xmlSchemaParserCtxtPtr;
}
extern "C" {
  pub fn xmlSchemaFreeParserCtxt(ctxt: xmlSchemaParserCtxtPtr);
}
extern "C" {
  pub fn xmlSchemaSetParserErrors(
    ctxt: xmlSchemaParserCtxtPtr,
    err: xmlSchemaValidityErrorFunc,
    warn: xmlSchemaValidityWarningFunc,
    ctx: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn xmlSchemaSetParserStructuredErrors(
    ctxt: xmlSchemaParserCtxtPtr,
    serror: xmlStructuredErrorFunc,
    ctx: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn xmlSchemaGetParserErrors(
    ctxt: xmlSchemaParserCtxtPtr,
    err: *mut xmlSchemaValidityErrorFunc,
    warn: *mut xmlSchemaValidityWarningFunc,
    ctx: *mut *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaIsValid(ctxt: xmlSchemaValidCtxtPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaParse(ctxt: xmlSchemaParserCtxtPtr) -> xmlSchemaPtr;
}
extern "C" {
  pub fn xmlSchemaFree(schema: xmlSchemaPtr);
}
extern "C" {
  pub fn xmlSchemaDump(output: *mut FILE, schema: xmlSchemaPtr);
}
extern "C" {
  pub fn xmlSchemaSetValidErrors(
    ctxt: xmlSchemaValidCtxtPtr,
    err: xmlSchemaValidityErrorFunc,
    warn: xmlSchemaValidityWarningFunc,
    ctx: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn xmlSchemaSetValidStructuredErrors(
    ctxt: xmlSchemaValidCtxtPtr,
    serror: xmlStructuredErrorFunc,
    ctx: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn xmlSchemaGetValidErrors(
    ctxt: xmlSchemaValidCtxtPtr,
    err: *mut xmlSchemaValidityErrorFunc,
    warn: *mut xmlSchemaValidityWarningFunc,
    ctx: *mut *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaSetValidOptions(
    ctxt: xmlSchemaValidCtxtPtr,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaValidateSetFilename(
    vctxt: xmlSchemaValidCtxtPtr,
    filename: *const ::std::os::raw::c_char,
  );
}
extern "C" {
  pub fn xmlSchemaValidCtxtGetOptions(ctxt: xmlSchemaValidCtxtPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaNewValidCtxt(schema: xmlSchemaPtr) -> xmlSchemaValidCtxtPtr;
}
extern "C" {
  pub fn xmlSchemaFreeValidCtxt(ctxt: xmlSchemaValidCtxtPtr);
}
extern "C" {
  pub fn xmlSchemaValidateDoc(
    ctxt: xmlSchemaValidCtxtPtr,
    instance: xmlDocPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaValidateOneElement(
    ctxt: xmlSchemaValidCtxtPtr,
    elem: xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaValidateStream(
    ctxt: xmlSchemaValidCtxtPtr,
    input: xmlParserInputBufferPtr,
    enc: xmlCharEncoding,
    sax: xmlSAXHandlerPtr,
    user_data: *mut ::std::os::raw::c_void,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaValidateFile(
    ctxt: xmlSchemaValidCtxtPtr,
    filename: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaValidCtxtGetParserCtxt(ctxt: xmlSchemaValidCtxtPtr) -> xmlParserCtxtPtr;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSchemaSAXPlug {
  _unused: [u8; 0],
}
pub type xmlSchemaSAXPlugStruct = _xmlSchemaSAXPlug;
pub type xmlSchemaSAXPlugPtr = *mut xmlSchemaSAXPlugStruct;
extern "C" {
  pub fn xmlSchemaSAXPlug(
    ctxt: xmlSchemaValidCtxtPtr,
    sax: *mut xmlSAXHandlerPtr,
    user_data: *mut *mut ::std::os::raw::c_void,
  ) -> xmlSchemaSAXPlugPtr;
}
extern "C" {
  pub fn xmlSchemaSAXUnplug(plug: xmlSchemaSAXPlugPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaValidateSetLocator(
    vctxt: xmlSchemaValidCtxtPtr,
    f: xmlSchemaValidityLocatorFunc,
    ctxt: *mut ::std::os::raw::c_void,
  );
}
pub const xmlParserSeverities_XML_PARSER_SEVERITY_VALIDITY_WARNING: xmlParserSeverities = 1;
pub const xmlParserSeverities_XML_PARSER_SEVERITY_VALIDITY_ERROR: xmlParserSeverities = 2;
pub const xmlParserSeverities_XML_PARSER_SEVERITY_WARNING: xmlParserSeverities = 3;
pub const xmlParserSeverities_XML_PARSER_SEVERITY_ERROR: xmlParserSeverities = 4;
/// xmlParserSeverities:
///
/// How severe an error callback is when the per-reader error callback API
/// is used.
pub type xmlParserSeverities = u32;
pub const xmlTextReaderMode_XML_TEXTREADER_MODE_INITIAL: xmlTextReaderMode = 0;
pub const xmlTextReaderMode_XML_TEXTREADER_MODE_INTERACTIVE: xmlTextReaderMode = 1;
pub const xmlTextReaderMode_XML_TEXTREADER_MODE_ERROR: xmlTextReaderMode = 2;
pub const xmlTextReaderMode_XML_TEXTREADER_MODE_EOF: xmlTextReaderMode = 3;
pub const xmlTextReaderMode_XML_TEXTREADER_MODE_CLOSED: xmlTextReaderMode = 4;
pub const xmlTextReaderMode_XML_TEXTREADER_MODE_READING: xmlTextReaderMode = 5;
/// xmlTextReaderMode:
///
/// Internal state values for the reader.
pub type xmlTextReaderMode = u32;
pub const xmlParserProperties_XML_PARSER_LOADDTD: xmlParserProperties = 1;
pub const xmlParserProperties_XML_PARSER_DEFAULTATTRS: xmlParserProperties = 2;
pub const xmlParserProperties_XML_PARSER_VALIDATE: xmlParserProperties = 3;
pub const xmlParserProperties_XML_PARSER_SUBST_ENTITIES: xmlParserProperties = 4;
/// xmlParserProperties:
///
/// Some common options to use with xmlTextReaderSetParserProp, but it
/// is better to use xmlParserOption and the xmlReaderNewxxx and
/// xmlReaderForxxx APIs now.
pub type xmlParserProperties = u32;
pub const xmlReaderTypes_XML_READER_TYPE_NONE: xmlReaderTypes = 0;
pub const xmlReaderTypes_XML_READER_TYPE_ELEMENT: xmlReaderTypes = 1;
pub const xmlReaderTypes_XML_READER_TYPE_ATTRIBUTE: xmlReaderTypes = 2;
pub const xmlReaderTypes_XML_READER_TYPE_TEXT: xmlReaderTypes = 3;
pub const xmlReaderTypes_XML_READER_TYPE_CDATA: xmlReaderTypes = 4;
pub const xmlReaderTypes_XML_READER_TYPE_ENTITY_REFERENCE: xmlReaderTypes = 5;
pub const xmlReaderTypes_XML_READER_TYPE_ENTITY: xmlReaderTypes = 6;
pub const xmlReaderTypes_XML_READER_TYPE_PROCESSING_INSTRUCTION: xmlReaderTypes = 7;
pub const xmlReaderTypes_XML_READER_TYPE_COMMENT: xmlReaderTypes = 8;
pub const xmlReaderTypes_XML_READER_TYPE_DOCUMENT: xmlReaderTypes = 9;
pub const xmlReaderTypes_XML_READER_TYPE_DOCUMENT_TYPE: xmlReaderTypes = 10;
pub const xmlReaderTypes_XML_READER_TYPE_DOCUMENT_FRAGMENT: xmlReaderTypes = 11;
pub const xmlReaderTypes_XML_READER_TYPE_NOTATION: xmlReaderTypes = 12;
pub const xmlReaderTypes_XML_READER_TYPE_WHITESPACE: xmlReaderTypes = 13;
pub const xmlReaderTypes_XML_READER_TYPE_SIGNIFICANT_WHITESPACE: xmlReaderTypes = 14;
pub const xmlReaderTypes_XML_READER_TYPE_END_ELEMENT: xmlReaderTypes = 15;
pub const xmlReaderTypes_XML_READER_TYPE_END_ENTITY: xmlReaderTypes = 16;
pub const xmlReaderTypes_XML_READER_TYPE_XML_DECLARATION: xmlReaderTypes = 17;
/// xmlReaderTypes:
///
/// Predefined constants for the different types of nodes.
pub type xmlReaderTypes = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlTextReader {
  _unused: [u8; 0],
}
/// xmlTextReader:
///
/// Structure for an xmlReader context.
pub type xmlTextReader = _xmlTextReader;
/// xmlTextReaderPtr:
///
/// Pointer to an xmlReader context.
pub type xmlTextReaderPtr = *mut xmlTextReader;
extern "C" {
  pub fn xmlNewTextReader(
    input: xmlParserInputBufferPtr,
    URI: *const ::std::os::raw::c_char,
  ) -> xmlTextReaderPtr;
}
extern "C" {
  pub fn xmlNewTextReaderFilename(URI: *const ::std::os::raw::c_char) -> xmlTextReaderPtr;
}
extern "C" {
  pub fn xmlFreeTextReader(reader: xmlTextReaderPtr);
}
extern "C" {
  pub fn xmlTextReaderSetup(
    reader: xmlTextReaderPtr,
    input: xmlParserInputBufferPtr,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderRead(reader: xmlTextReaderPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderReadInnerXml(reader: xmlTextReaderPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlTextReaderReadOuterXml(reader: xmlTextReaderPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlTextReaderReadString(reader: xmlTextReaderPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlTextReaderReadAttributeValue(reader: xmlTextReaderPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderAttributeCount(reader: xmlTextReaderPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderDepth(reader: xmlTextReaderPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderHasAttributes(reader: xmlTextReaderPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderHasValue(reader: xmlTextReaderPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderIsDefault(reader: xmlTextReaderPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderIsEmptyElement(reader: xmlTextReaderPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderNodeType(reader: xmlTextReaderPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderQuoteChar(reader: xmlTextReaderPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderReadState(reader: xmlTextReaderPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderIsNamespaceDecl(reader: xmlTextReaderPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderConstBaseUri(reader: xmlTextReaderPtr) -> *const xmlChar;
}
extern "C" {
  pub fn xmlTextReaderConstLocalName(reader: xmlTextReaderPtr) -> *const xmlChar;
}
extern "C" {
  pub fn xmlTextReaderConstName(reader: xmlTextReaderPtr) -> *const xmlChar;
}
extern "C" {
  pub fn xmlTextReaderConstNamespaceUri(reader: xmlTextReaderPtr) -> *const xmlChar;
}
extern "C" {
  pub fn xmlTextReaderConstPrefix(reader: xmlTextReaderPtr) -> *const xmlChar;
}
extern "C" {
  pub fn xmlTextReaderConstXmlLang(reader: xmlTextReaderPtr) -> *const xmlChar;
}
extern "C" {
  pub fn xmlTextReaderConstString(reader: xmlTextReaderPtr, str: *const xmlChar) -> *const xmlChar;
}
extern "C" {
  pub fn xmlTextReaderConstValue(reader: xmlTextReaderPtr) -> *const xmlChar;
}
extern "C" {
  pub fn xmlTextReaderBaseUri(reader: xmlTextReaderPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlTextReaderLocalName(reader: xmlTextReaderPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlTextReaderName(reader: xmlTextReaderPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlTextReaderNamespaceUri(reader: xmlTextReaderPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlTextReaderPrefix(reader: xmlTextReaderPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlTextReaderXmlLang(reader: xmlTextReaderPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlTextReaderValue(reader: xmlTextReaderPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlTextReaderClose(reader: xmlTextReaderPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderGetAttributeNo(
    reader: xmlTextReaderPtr,
    no: ::std::os::raw::c_int,
  ) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlTextReaderGetAttribute(reader: xmlTextReaderPtr, name: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlTextReaderGetAttributeNs(
    reader: xmlTextReaderPtr,
    localName: *const xmlChar,
    namespaceURI: *const xmlChar,
  ) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlTextReaderGetRemainder(reader: xmlTextReaderPtr) -> xmlParserInputBufferPtr;
}
extern "C" {
  pub fn xmlTextReaderLookupNamespace(
    reader: xmlTextReaderPtr,
    prefix: *const xmlChar,
  ) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlTextReaderMoveToAttributeNo(
    reader: xmlTextReaderPtr,
    no: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderMoveToAttribute(
    reader: xmlTextReaderPtr,
    name: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderMoveToAttributeNs(
    reader: xmlTextReaderPtr,
    localName: *const xmlChar,
    namespaceURI: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderMoveToFirstAttribute(reader: xmlTextReaderPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderMoveToNextAttribute(reader: xmlTextReaderPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderMoveToElement(reader: xmlTextReaderPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderNormalization(reader: xmlTextReaderPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderConstEncoding(reader: xmlTextReaderPtr) -> *const xmlChar;
}
extern "C" {
  pub fn xmlTextReaderSetParserProp(
    reader: xmlTextReaderPtr,
    prop: ::std::os::raw::c_int,
    value: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderGetParserProp(
    reader: xmlTextReaderPtr,
    prop: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderCurrentNode(reader: xmlTextReaderPtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlTextReaderGetParserLineNumber(reader: xmlTextReaderPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderGetParserColumnNumber(reader: xmlTextReaderPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderPreserve(reader: xmlTextReaderPtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlTextReaderPreservePattern(
    reader: xmlTextReaderPtr,
    pattern: *const xmlChar,
    namespaces: *mut *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderCurrentDoc(reader: xmlTextReaderPtr) -> xmlDocPtr;
}
extern "C" {
  pub fn xmlTextReaderExpand(reader: xmlTextReaderPtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlTextReaderNext(reader: xmlTextReaderPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderNextSibling(reader: xmlTextReaderPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderIsValid(reader: xmlTextReaderPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderRelaxNGValidate(
    reader: xmlTextReaderPtr,
    rng: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderRelaxNGValidateCtxt(
    reader: xmlTextReaderPtr,
    ctxt: xmlRelaxNGValidCtxtPtr,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderRelaxNGSetSchema(
    reader: xmlTextReaderPtr,
    schema: xmlRelaxNGPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderSchemaValidate(
    reader: xmlTextReaderPtr,
    xsd: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderSchemaValidateCtxt(
    reader: xmlTextReaderPtr,
    ctxt: xmlSchemaValidCtxtPtr,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderSetSchema(
    reader: xmlTextReaderPtr,
    schema: xmlSchemaPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderConstXmlVersion(reader: xmlTextReaderPtr) -> *const xmlChar;
}
extern "C" {
  pub fn xmlTextReaderStandalone(reader: xmlTextReaderPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderByteConsumed(reader: xmlTextReaderPtr) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn xmlReaderWalker(doc: xmlDocPtr) -> xmlTextReaderPtr;
}
extern "C" {
  pub fn xmlReaderForDoc(
    cur: *const xmlChar,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlTextReaderPtr;
}
extern "C" {
  pub fn xmlReaderForFile(
    filename: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlTextReaderPtr;
}
extern "C" {
  pub fn xmlReaderForMemory(
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlTextReaderPtr;
}
extern "C" {
  pub fn xmlReaderForFd(
    fd: ::std::os::raw::c_int,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlTextReaderPtr;
}
extern "C" {
  pub fn xmlReaderForIO(
    ioread: xmlInputReadCallback,
    ioclose: xmlInputCloseCallback,
    ioctx: *mut ::std::os::raw::c_void,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlTextReaderPtr;
}
extern "C" {
  pub fn xmlReaderNewWalker(reader: xmlTextReaderPtr, doc: xmlDocPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlReaderNewDoc(
    reader: xmlTextReaderPtr,
    cur: *const xmlChar,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlReaderNewFile(
    reader: xmlTextReaderPtr,
    filename: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlReaderNewMemory(
    reader: xmlTextReaderPtr,
    buffer: *const ::std::os::raw::c_char,
    size: ::std::os::raw::c_int,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlReaderNewFd(
    reader: xmlTextReaderPtr,
    fd: ::std::os::raw::c_int,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlReaderNewIO(
    reader: xmlTextReaderPtr,
    ioread: xmlInputReadCallback,
    ioclose: xmlInputCloseCallback,
    ioctx: *mut ::std::os::raw::c_void,
    URL: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
pub type xmlTextReaderLocatorPtr = *mut ::std::os::raw::c_void;
/// xmlTextReaderErrorFunc:
/// @arg: the user argument
/// @msg: the message
/// @severity: the severity of the error
/// @locator: a locator indicating where the error occured
///
/// Signature of an error callback from a reader parser
pub type xmlTextReaderErrorFunc = ::std::option::Option<
  unsafe extern "C" fn(
    arg: *mut ::std::os::raw::c_void,
    msg: *const ::std::os::raw::c_char,
    severity: xmlParserSeverities,
    locator: xmlTextReaderLocatorPtr,
  ),
>;
extern "C" {
  pub fn xmlTextReaderLocatorLineNumber(locator: xmlTextReaderLocatorPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextReaderLocatorBaseURI(locator: xmlTextReaderLocatorPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlTextReaderSetErrorHandler(
    reader: xmlTextReaderPtr,
    f: xmlTextReaderErrorFunc,
    arg: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn xmlTextReaderSetStructuredErrorHandler(
    reader: xmlTextReaderPtr,
    f: xmlStructuredErrorFunc,
    arg: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn xmlTextReaderGetErrorHandler(
    reader: xmlTextReaderPtr,
    f: *mut xmlTextReaderErrorFunc,
    arg: *mut *mut ::std::os::raw::c_void,
  );
}
pub const xmlSaveOption_XML_SAVE_FORMAT: xmlSaveOption = 1;
pub const xmlSaveOption_XML_SAVE_NO_DECL: xmlSaveOption = 2;
pub const xmlSaveOption_XML_SAVE_NO_EMPTY: xmlSaveOption = 4;
pub const xmlSaveOption_XML_SAVE_NO_XHTML: xmlSaveOption = 8;
pub const xmlSaveOption_XML_SAVE_XHTML: xmlSaveOption = 16;
pub const xmlSaveOption_XML_SAVE_AS_XML: xmlSaveOption = 32;
pub const xmlSaveOption_XML_SAVE_AS_HTML: xmlSaveOption = 64;
pub const xmlSaveOption_XML_SAVE_WSNONSIG: xmlSaveOption = 128;
/// xmlSaveOption:
///
/// This is the set of XML save options that can be passed down
/// to the xmlSaveToFd() and similar calls.
pub type xmlSaveOption = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlSaveCtxt {
  _unused: [u8; 0],
}
pub type xmlSaveCtxt = _xmlSaveCtxt;
pub type xmlSaveCtxtPtr = *mut xmlSaveCtxt;
extern "C" {
  pub fn xmlSaveToFd(
    fd: ::std::os::raw::c_int,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlSaveCtxtPtr;
}
extern "C" {
  pub fn xmlSaveToFilename(
    filename: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlSaveCtxtPtr;
}
extern "C" {
  pub fn xmlSaveToBuffer(
    buffer: xmlBufferPtr,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlSaveCtxtPtr;
}
extern "C" {
  pub fn xmlSaveToIO(
    iowrite: xmlOutputWriteCallback,
    ioclose: xmlOutputCloseCallback,
    ioctx: *mut ::std::os::raw::c_void,
    encoding: *const ::std::os::raw::c_char,
    options: ::std::os::raw::c_int,
  ) -> xmlSaveCtxtPtr;
}
extern "C" {
  pub fn xmlSaveDoc(ctxt: xmlSaveCtxtPtr, doc: xmlDocPtr) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn xmlSaveTree(ctxt: xmlSaveCtxtPtr, node: xmlNodePtr) -> ::std::os::raw::c_long;
}
extern "C" {
  pub fn xmlSaveFlush(ctxt: xmlSaveCtxtPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSaveClose(ctxt: xmlSaveCtxtPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSaveSetEscape(
    ctxt: xmlSaveCtxtPtr,
    escape: xmlCharEncodingOutputFunc,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSaveSetAttrEscape(
    ctxt: xmlSaveCtxtPtr,
    escape: xmlCharEncodingOutputFunc,
  ) -> ::std::os::raw::c_int;
}
pub const xmlSchemaWhitespaceValueType_XML_SCHEMA_WHITESPACE_UNKNOWN: xmlSchemaWhitespaceValueType =
  0;
pub const xmlSchemaWhitespaceValueType_XML_SCHEMA_WHITESPACE_PRESERVE:
  xmlSchemaWhitespaceValueType = 1;
pub const xmlSchemaWhitespaceValueType_XML_SCHEMA_WHITESPACE_REPLACE: xmlSchemaWhitespaceValueType =
  2;
pub const xmlSchemaWhitespaceValueType_XML_SCHEMA_WHITESPACE_COLLAPSE:
  xmlSchemaWhitespaceValueType = 3;
pub type xmlSchemaWhitespaceValueType = u32;
extern "C" {
  pub fn xmlSchemaInitTypes();
}
extern "C" {
  pub fn xmlSchemaCleanupTypes();
}
extern "C" {
  pub fn xmlSchemaGetPredefinedType(name: *const xmlChar, ns: *const xmlChar) -> xmlSchemaTypePtr;
}
extern "C" {
  pub fn xmlSchemaValidatePredefinedType(
    type_: xmlSchemaTypePtr,
    value: *const xmlChar,
    val: *mut xmlSchemaValPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaValPredefTypeNode(
    type_: xmlSchemaTypePtr,
    value: *const xmlChar,
    val: *mut xmlSchemaValPtr,
    node: xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaValidateFacet(
    base: xmlSchemaTypePtr,
    facet: xmlSchemaFacetPtr,
    value: *const xmlChar,
    val: xmlSchemaValPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaValidateFacetWhtsp(
    facet: xmlSchemaFacetPtr,
    fws: xmlSchemaWhitespaceValueType,
    valType: xmlSchemaValType,
    value: *const xmlChar,
    val: xmlSchemaValPtr,
    ws: xmlSchemaWhitespaceValueType,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaFreeValue(val: xmlSchemaValPtr);
}
extern "C" {
  pub fn xmlSchemaNewFacet() -> xmlSchemaFacetPtr;
}
extern "C" {
  pub fn xmlSchemaCheckFacet(
    facet: xmlSchemaFacetPtr,
    typeDecl: xmlSchemaTypePtr,
    ctxt: xmlSchemaParserCtxtPtr,
    name: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaFreeFacet(facet: xmlSchemaFacetPtr);
}
extern "C" {
  pub fn xmlSchemaCompareValues(x: xmlSchemaValPtr, y: xmlSchemaValPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaGetBuiltInListSimpleTypeItemType(type_: xmlSchemaTypePtr) -> xmlSchemaTypePtr;
}
extern "C" {
  pub fn xmlSchemaValidateListSimpleTypeFacet(
    facet: xmlSchemaFacetPtr,
    value: *const xmlChar,
    actualLen: ::std::os::raw::c_ulong,
    expectedLen: *mut ::std::os::raw::c_ulong,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaGetBuiltInType(type_: xmlSchemaValType) -> xmlSchemaTypePtr;
}
extern "C" {
  pub fn xmlSchemaIsBuiltInTypeFacet(
    type_: xmlSchemaTypePtr,
    facetType: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaCollapseString(value: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlSchemaWhiteSpaceReplace(value: *const xmlChar) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlSchemaGetFacetValueAsULong(facet: xmlSchemaFacetPtr) -> ::std::os::raw::c_ulong;
}
extern "C" {
  pub fn xmlSchemaValidateLengthFacet(
    type_: xmlSchemaTypePtr,
    facet: xmlSchemaFacetPtr,
    value: *const xmlChar,
    val: xmlSchemaValPtr,
    length: *mut ::std::os::raw::c_ulong,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaValidateLengthFacetWhtsp(
    facet: xmlSchemaFacetPtr,
    valType: xmlSchemaValType,
    value: *const xmlChar,
    val: xmlSchemaValPtr,
    length: *mut ::std::os::raw::c_ulong,
    ws: xmlSchemaWhitespaceValueType,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaValPredefTypeNodeNoNorm(
    type_: xmlSchemaTypePtr,
    value: *const xmlChar,
    val: *mut xmlSchemaValPtr,
    node: xmlNodePtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaGetCanonValue(
    val: xmlSchemaValPtr,
    retValue: *mut *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaGetCanonValueWhtsp(
    val: xmlSchemaValPtr,
    retValue: *mut *const xmlChar,
    ws: xmlSchemaWhitespaceValueType,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaValueAppend(prev: xmlSchemaValPtr, cur: xmlSchemaValPtr)
    -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaValueGetNext(cur: xmlSchemaValPtr) -> xmlSchemaValPtr;
}
extern "C" {
  pub fn xmlSchemaValueGetAsString(val: xmlSchemaValPtr) -> *const xmlChar;
}
extern "C" {
  pub fn xmlSchemaValueGetAsBoolean(val: xmlSchemaValPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaNewStringValue(type_: xmlSchemaValType, value: *const xmlChar)
    -> xmlSchemaValPtr;
}
extern "C" {
  pub fn xmlSchemaNewNOTATIONValue(name: *const xmlChar, ns: *const xmlChar) -> xmlSchemaValPtr;
}
extern "C" {
  pub fn xmlSchemaNewQNameValue(
    namespaceName: *const xmlChar,
    localName: *const xmlChar,
  ) -> xmlSchemaValPtr;
}
extern "C" {
  pub fn xmlSchemaCompareValuesWhtsp(
    x: xmlSchemaValPtr,
    xws: xmlSchemaWhitespaceValueType,
    y: xmlSchemaValPtr,
    yws: xmlSchemaWhitespaceValueType,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlSchemaCopyValue(val: xmlSchemaValPtr) -> xmlSchemaValPtr;
}
extern "C" {
  pub fn xmlSchemaGetValType(val: xmlSchemaValPtr) -> xmlSchemaValType;
}
extern "C" {
  pub fn xmlUCSIsAegeanNumbers(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsAlphabeticPresentationForms(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsArabic(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsArabicPresentationFormsA(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsArabicPresentationFormsB(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsArmenian(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsArrows(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsBasicLatin(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsBengali(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsBlockElements(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsBopomofo(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsBopomofoExtended(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsBoxDrawing(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsBraillePatterns(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsBuhid(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsByzantineMusicalSymbols(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCJKCompatibility(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCJKCompatibilityForms(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCJKCompatibilityIdeographs(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCJKCompatibilityIdeographsSupplement(
    code: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCJKRadicalsSupplement(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCJKSymbolsandPunctuation(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCJKUnifiedIdeographs(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCJKUnifiedIdeographsExtensionA(
    code: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCJKUnifiedIdeographsExtensionB(
    code: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCherokee(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCombiningDiacriticalMarks(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCombiningDiacriticalMarksforSymbols(
    code: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCombiningHalfMarks(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCombiningMarksforSymbols(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsControlPictures(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCurrencySymbols(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCypriotSyllabary(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCyrillic(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCyrillicSupplement(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsDeseret(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsDevanagari(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsDingbats(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsEnclosedAlphanumerics(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsEnclosedCJKLettersandMonths(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsEthiopic(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsGeneralPunctuation(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsGeometricShapes(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsGeorgian(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsGothic(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsGreek(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsGreekExtended(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsGreekandCoptic(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsGujarati(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsGurmukhi(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsHalfwidthandFullwidthForms(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsHangulCompatibilityJamo(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsHangulJamo(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsHangulSyllables(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsHanunoo(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsHebrew(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsHighPrivateUseSurrogates(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsHighSurrogates(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsHiragana(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsIPAExtensions(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsIdeographicDescriptionCharacters(
    code: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsKanbun(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsKangxiRadicals(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsKannada(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsKatakana(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsKatakanaPhoneticExtensions(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsKhmer(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsKhmerSymbols(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsLao(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsLatin1Supplement(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsLatinExtendedA(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsLatinExtendedB(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsLatinExtendedAdditional(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsLetterlikeSymbols(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsLimbu(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsLinearBIdeograms(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsLinearBSyllabary(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsLowSurrogates(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsMalayalam(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsMathematicalAlphanumericSymbols(
    code: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsMathematicalOperators(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsMiscellaneousMathematicalSymbolsA(
    code: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsMiscellaneousMathematicalSymbolsB(
    code: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsMiscellaneousSymbols(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsMiscellaneousSymbolsandArrows(
    code: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsMiscellaneousTechnical(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsMongolian(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsMusicalSymbols(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsMyanmar(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsNumberForms(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsOgham(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsOldItalic(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsOpticalCharacterRecognition(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsOriya(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsOsmanya(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsPhoneticExtensions(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsPrivateUse(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsPrivateUseArea(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsRunic(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsShavian(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsSinhala(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsSmallFormVariants(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsSpacingModifierLetters(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsSpecials(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsSuperscriptsandSubscripts(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsSupplementalArrowsA(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsSupplementalArrowsB(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsSupplementalMathematicalOperators(
    code: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsSupplementaryPrivateUseAreaA(code: ::std::os::raw::c_int)
    -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsSupplementaryPrivateUseAreaB(code: ::std::os::raw::c_int)
    -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsSyriac(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsTagalog(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsTagbanwa(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsTags(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsTaiLe(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsTaiXuanJingSymbols(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsTamil(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsTelugu(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsThaana(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsThai(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsTibetan(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsUgaritic(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsUnifiedCanadianAboriginalSyllabics(
    code: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsVariationSelectors(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsVariationSelectorsSupplement(code: ::std::os::raw::c_int)
    -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsYiRadicals(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsYiSyllables(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsYijingHexagramSymbols(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsBlock(
    code: ::std::os::raw::c_int,
    block: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatC(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatCc(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatCf(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatCo(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatCs(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatL(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatLl(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatLm(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatLo(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatLt(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatLu(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatM(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatMc(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatMe(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatMn(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatN(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatNd(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatNl(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatNo(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatP(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatPc(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatPd(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatPe(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatPf(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatPi(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatPo(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatPs(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatS(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatSc(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatSk(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatSm(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatSo(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatZ(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatZl(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatZp(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCatZs(code: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlUCSIsCat(
    code: ::std::os::raw::c_int,
    cat: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlTextWriter {
  _unused: [u8; 0],
}
pub type xmlTextWriter = _xmlTextWriter;
pub type xmlTextWriterPtr = *mut xmlTextWriter;
extern "C" {
  pub fn xmlNewTextWriter(out: xmlOutputBufferPtr) -> xmlTextWriterPtr;
}
extern "C" {
  pub fn xmlNewTextWriterFilename(
    uri: *const ::std::os::raw::c_char,
    compression: ::std::os::raw::c_int,
  ) -> xmlTextWriterPtr;
}
extern "C" {
  pub fn xmlNewTextWriterMemory(
    buf: xmlBufferPtr,
    compression: ::std::os::raw::c_int,
  ) -> xmlTextWriterPtr;
}
extern "C" {
  pub fn xmlNewTextWriterPushParser(
    ctxt: xmlParserCtxtPtr,
    compression: ::std::os::raw::c_int,
  ) -> xmlTextWriterPtr;
}
extern "C" {
  pub fn xmlNewTextWriterDoc(
    doc: *mut xmlDocPtr,
    compression: ::std::os::raw::c_int,
  ) -> xmlTextWriterPtr;
}
extern "C" {
  pub fn xmlNewTextWriterTree(
    doc: xmlDocPtr,
    node: xmlNodePtr,
    compression: ::std::os::raw::c_int,
  ) -> xmlTextWriterPtr;
}
extern "C" {
  pub fn xmlFreeTextWriter(writer: xmlTextWriterPtr);
}
extern "C" {
  pub fn xmlTextWriterStartDocument(
    writer: xmlTextWriterPtr,
    version: *const ::std::os::raw::c_char,
    encoding: *const ::std::os::raw::c_char,
    standalone: *const ::std::os::raw::c_char,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterEndDocument(writer: xmlTextWriterPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterStartComment(writer: xmlTextWriterPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterEndComment(writer: xmlTextWriterPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteFormatComment(
    writer: xmlTextWriterPtr,
    format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteVFormatComment(
    writer: xmlTextWriterPtr,
    format: *const ::std::os::raw::c_char,
    argptr: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteComment(
    writer: xmlTextWriterPtr,
    content: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterStartElement(
    writer: xmlTextWriterPtr,
    name: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterStartElementNS(
    writer: xmlTextWriterPtr,
    prefix: *const xmlChar,
    name: *const xmlChar,
    namespaceURI: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterEndElement(writer: xmlTextWriterPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterFullEndElement(writer: xmlTextWriterPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteFormatElement(
    writer: xmlTextWriterPtr,
    name: *const xmlChar,
    format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteVFormatElement(
    writer: xmlTextWriterPtr,
    name: *const xmlChar,
    format: *const ::std::os::raw::c_char,
    argptr: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteElement(
    writer: xmlTextWriterPtr,
    name: *const xmlChar,
    content: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteFormatElementNS(
    writer: xmlTextWriterPtr,
    prefix: *const xmlChar,
    name: *const xmlChar,
    namespaceURI: *const xmlChar,
    format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteVFormatElementNS(
    writer: xmlTextWriterPtr,
    prefix: *const xmlChar,
    name: *const xmlChar,
    namespaceURI: *const xmlChar,
    format: *const ::std::os::raw::c_char,
    argptr: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteElementNS(
    writer: xmlTextWriterPtr,
    prefix: *const xmlChar,
    name: *const xmlChar,
    namespaceURI: *const xmlChar,
    content: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteFormatRaw(
    writer: xmlTextWriterPtr,
    format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteVFormatRaw(
    writer: xmlTextWriterPtr,
    format: *const ::std::os::raw::c_char,
    argptr: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteRawLen(
    writer: xmlTextWriterPtr,
    content: *const xmlChar,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteRaw(
    writer: xmlTextWriterPtr,
    content: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteFormatString(
    writer: xmlTextWriterPtr,
    format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteVFormatString(
    writer: xmlTextWriterPtr,
    format: *const ::std::os::raw::c_char,
    argptr: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteString(
    writer: xmlTextWriterPtr,
    content: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteBase64(
    writer: xmlTextWriterPtr,
    data: *const ::std::os::raw::c_char,
    start: ::std::os::raw::c_int,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteBinHex(
    writer: xmlTextWriterPtr,
    data: *const ::std::os::raw::c_char,
    start: ::std::os::raw::c_int,
    len: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterStartAttribute(
    writer: xmlTextWriterPtr,
    name: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterStartAttributeNS(
    writer: xmlTextWriterPtr,
    prefix: *const xmlChar,
    name: *const xmlChar,
    namespaceURI: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterEndAttribute(writer: xmlTextWriterPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteFormatAttribute(
    writer: xmlTextWriterPtr,
    name: *const xmlChar,
    format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteVFormatAttribute(
    writer: xmlTextWriterPtr,
    name: *const xmlChar,
    format: *const ::std::os::raw::c_char,
    argptr: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteAttribute(
    writer: xmlTextWriterPtr,
    name: *const xmlChar,
    content: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteFormatAttributeNS(
    writer: xmlTextWriterPtr,
    prefix: *const xmlChar,
    name: *const xmlChar,
    namespaceURI: *const xmlChar,
    format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteVFormatAttributeNS(
    writer: xmlTextWriterPtr,
    prefix: *const xmlChar,
    name: *const xmlChar,
    namespaceURI: *const xmlChar,
    format: *const ::std::os::raw::c_char,
    argptr: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteAttributeNS(
    writer: xmlTextWriterPtr,
    prefix: *const xmlChar,
    name: *const xmlChar,
    namespaceURI: *const xmlChar,
    content: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterStartPI(
    writer: xmlTextWriterPtr,
    target: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterEndPI(writer: xmlTextWriterPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteFormatPI(
    writer: xmlTextWriterPtr,
    target: *const xmlChar,
    format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteVFormatPI(
    writer: xmlTextWriterPtr,
    target: *const xmlChar,
    format: *const ::std::os::raw::c_char,
    argptr: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWritePI(
    writer: xmlTextWriterPtr,
    target: *const xmlChar,
    content: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterStartCDATA(writer: xmlTextWriterPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterEndCDATA(writer: xmlTextWriterPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteFormatCDATA(
    writer: xmlTextWriterPtr,
    format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteVFormatCDATA(
    writer: xmlTextWriterPtr,
    format: *const ::std::os::raw::c_char,
    argptr: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteCDATA(
    writer: xmlTextWriterPtr,
    content: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterStartDTD(
    writer: xmlTextWriterPtr,
    name: *const xmlChar,
    pubid: *const xmlChar,
    sysid: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterEndDTD(writer: xmlTextWriterPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteFormatDTD(
    writer: xmlTextWriterPtr,
    name: *const xmlChar,
    pubid: *const xmlChar,
    sysid: *const xmlChar,
    format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteVFormatDTD(
    writer: xmlTextWriterPtr,
    name: *const xmlChar,
    pubid: *const xmlChar,
    sysid: *const xmlChar,
    format: *const ::std::os::raw::c_char,
    argptr: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteDTD(
    writer: xmlTextWriterPtr,
    name: *const xmlChar,
    pubid: *const xmlChar,
    sysid: *const xmlChar,
    subset: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterStartDTDElement(
    writer: xmlTextWriterPtr,
    name: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterEndDTDElement(writer: xmlTextWriterPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteFormatDTDElement(
    writer: xmlTextWriterPtr,
    name: *const xmlChar,
    format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteVFormatDTDElement(
    writer: xmlTextWriterPtr,
    name: *const xmlChar,
    format: *const ::std::os::raw::c_char,
    argptr: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteDTDElement(
    writer: xmlTextWriterPtr,
    name: *const xmlChar,
    content: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterStartDTDAttlist(
    writer: xmlTextWriterPtr,
    name: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterEndDTDAttlist(writer: xmlTextWriterPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteFormatDTDAttlist(
    writer: xmlTextWriterPtr,
    name: *const xmlChar,
    format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteVFormatDTDAttlist(
    writer: xmlTextWriterPtr,
    name: *const xmlChar,
    format: *const ::std::os::raw::c_char,
    argptr: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteDTDAttlist(
    writer: xmlTextWriterPtr,
    name: *const xmlChar,
    content: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterStartDTDEntity(
    writer: xmlTextWriterPtr,
    pe: ::std::os::raw::c_int,
    name: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterEndDTDEntity(writer: xmlTextWriterPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteFormatDTDInternalEntity(
    writer: xmlTextWriterPtr,
    pe: ::std::os::raw::c_int,
    name: *const xmlChar,
    format: *const ::std::os::raw::c_char,
    ...
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteVFormatDTDInternalEntity(
    writer: xmlTextWriterPtr,
    pe: ::std::os::raw::c_int,
    name: *const xmlChar,
    format: *const ::std::os::raw::c_char,
    argptr: *mut __va_list_tag,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteDTDInternalEntity(
    writer: xmlTextWriterPtr,
    pe: ::std::os::raw::c_int,
    name: *const xmlChar,
    content: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteDTDExternalEntity(
    writer: xmlTextWriterPtr,
    pe: ::std::os::raw::c_int,
    name: *const xmlChar,
    pubid: *const xmlChar,
    sysid: *const xmlChar,
    ndataid: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteDTDExternalEntityContents(
    writer: xmlTextWriterPtr,
    pubid: *const xmlChar,
    sysid: *const xmlChar,
    ndataid: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteDTDEntity(
    writer: xmlTextWriterPtr,
    pe: ::std::os::raw::c_int,
    name: *const xmlChar,
    pubid: *const xmlChar,
    sysid: *const xmlChar,
    ndataid: *const xmlChar,
    content: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterWriteDTDNotation(
    writer: xmlTextWriterPtr,
    name: *const xmlChar,
    pubid: *const xmlChar,
    sysid: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterSetIndent(
    writer: xmlTextWriterPtr,
    indent: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterSetIndentString(
    writer: xmlTextWriterPtr,
    str: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterSetQuoteChar(
    writer: xmlTextWriterPtr,
    quotechar: xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlTextWriterFlush(writer: xmlTextWriterPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathPopBoolean(ctxt: xmlXPathParserContextPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathPopNumber(ctxt: xmlXPathParserContextPtr) -> f64;
}
extern "C" {
  pub fn xmlXPathPopString(ctxt: xmlXPathParserContextPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlXPathPopNodeSet(ctxt: xmlXPathParserContextPtr) -> xmlNodeSetPtr;
}
extern "C" {
  pub fn xmlXPathPopExternal(ctxt: xmlXPathParserContextPtr) -> *mut ::std::os::raw::c_void;
}
extern "C" {
  pub fn xmlXPathRegisterVariableLookup(
    ctxt: xmlXPathContextPtr,
    f: xmlXPathVariableLookupFunc,
    data: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn xmlXPathRegisterFuncLookup(
    ctxt: xmlXPathContextPtr,
    f: xmlXPathFuncLookupFunc,
    funcCtxt: *mut ::std::os::raw::c_void,
  );
}
extern "C" {
  pub fn xmlXPatherror(
    ctxt: xmlXPathParserContextPtr,
    file: *const ::std::os::raw::c_char,
    line: ::std::os::raw::c_int,
    no: ::std::os::raw::c_int,
  );
}
extern "C" {
  pub fn xmlXPathErr(ctxt: xmlXPathParserContextPtr, error: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathDebugDumpObject(
    output: *mut FILE,
    cur: xmlXPathObjectPtr,
    depth: ::std::os::raw::c_int,
  );
}
extern "C" {
  pub fn xmlXPathDebugDumpCompExpr(
    output: *mut FILE,
    comp: xmlXPathCompExprPtr,
    depth: ::std::os::raw::c_int,
  );
}
extern "C" {
  /// NodeSet handling.
  pub fn xmlXPathNodeSetContains(cur: xmlNodeSetPtr, val: xmlNodePtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathDifference(nodes1: xmlNodeSetPtr, nodes2: xmlNodeSetPtr) -> xmlNodeSetPtr;
}
extern "C" {
  pub fn xmlXPathIntersection(nodes1: xmlNodeSetPtr, nodes2: xmlNodeSetPtr) -> xmlNodeSetPtr;
}
extern "C" {
  pub fn xmlXPathDistinctSorted(nodes: xmlNodeSetPtr) -> xmlNodeSetPtr;
}
extern "C" {
  pub fn xmlXPathDistinct(nodes: xmlNodeSetPtr) -> xmlNodeSetPtr;
}
extern "C" {
  pub fn xmlXPathHasSameNodes(
    nodes1: xmlNodeSetPtr,
    nodes2: xmlNodeSetPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathNodeLeadingSorted(nodes: xmlNodeSetPtr, node: xmlNodePtr) -> xmlNodeSetPtr;
}
extern "C" {
  pub fn xmlXPathLeadingSorted(nodes1: xmlNodeSetPtr, nodes2: xmlNodeSetPtr) -> xmlNodeSetPtr;
}
extern "C" {
  pub fn xmlXPathNodeLeading(nodes: xmlNodeSetPtr, node: xmlNodePtr) -> xmlNodeSetPtr;
}
extern "C" {
  pub fn xmlXPathLeading(nodes1: xmlNodeSetPtr, nodes2: xmlNodeSetPtr) -> xmlNodeSetPtr;
}
extern "C" {
  pub fn xmlXPathNodeTrailingSorted(nodes: xmlNodeSetPtr, node: xmlNodePtr) -> xmlNodeSetPtr;
}
extern "C" {
  pub fn xmlXPathTrailingSorted(nodes1: xmlNodeSetPtr, nodes2: xmlNodeSetPtr) -> xmlNodeSetPtr;
}
extern "C" {
  pub fn xmlXPathNodeTrailing(nodes: xmlNodeSetPtr, node: xmlNodePtr) -> xmlNodeSetPtr;
}
extern "C" {
  pub fn xmlXPathTrailing(nodes1: xmlNodeSetPtr, nodes2: xmlNodeSetPtr) -> xmlNodeSetPtr;
}
extern "C" {
  /// Extending a context.
  pub fn xmlXPathRegisterNs(
    ctxt: xmlXPathContextPtr,
    prefix: *const xmlChar,
    ns_uri: *const xmlChar,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathNsLookup(ctxt: xmlXPathContextPtr, prefix: *const xmlChar) -> *const xmlChar;
}
extern "C" {
  pub fn xmlXPathRegisteredNsCleanup(ctxt: xmlXPathContextPtr);
}
extern "C" {
  pub fn xmlXPathRegisterFunc(
    ctxt: xmlXPathContextPtr,
    name: *const xmlChar,
    f: xmlXPathFunction,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathRegisterFuncNS(
    ctxt: xmlXPathContextPtr,
    name: *const xmlChar,
    ns_uri: *const xmlChar,
    f: xmlXPathFunction,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathRegisterVariable(
    ctxt: xmlXPathContextPtr,
    name: *const xmlChar,
    value: xmlXPathObjectPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathRegisterVariableNS(
    ctxt: xmlXPathContextPtr,
    name: *const xmlChar,
    ns_uri: *const xmlChar,
    value: xmlXPathObjectPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathFunctionLookup(ctxt: xmlXPathContextPtr, name: *const xmlChar)
    -> xmlXPathFunction;
}
extern "C" {
  pub fn xmlXPathFunctionLookupNS(
    ctxt: xmlXPathContextPtr,
    name: *const xmlChar,
    ns_uri: *const xmlChar,
  ) -> xmlXPathFunction;
}
extern "C" {
  pub fn xmlXPathRegisteredFuncsCleanup(ctxt: xmlXPathContextPtr);
}
extern "C" {
  pub fn xmlXPathVariableLookup(
    ctxt: xmlXPathContextPtr,
    name: *const xmlChar,
  ) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPathVariableLookupNS(
    ctxt: xmlXPathContextPtr,
    name: *const xmlChar,
    ns_uri: *const xmlChar,
  ) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPathRegisteredVariablesCleanup(ctxt: xmlXPathContextPtr);
}
extern "C" {
  /// Utilities to extend XPath.
  pub fn xmlXPathNewParserContext(
    str: *const xmlChar,
    ctxt: xmlXPathContextPtr,
  ) -> xmlXPathParserContextPtr;
}
extern "C" {
  pub fn xmlXPathFreeParserContext(ctxt: xmlXPathParserContextPtr);
}
extern "C" {
  pub fn valuePop(ctxt: xmlXPathParserContextPtr) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn valuePush(
    ctxt: xmlXPathParserContextPtr,
    value: xmlXPathObjectPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathNewString(val: *const xmlChar) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPathNewCString(val: *const ::std::os::raw::c_char) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPathWrapString(val: *mut xmlChar) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPathWrapCString(val: *mut ::std::os::raw::c_char) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPathNewFloat(val: f64) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPathNewBoolean(val: ::std::os::raw::c_int) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPathNewNodeSet(val: xmlNodePtr) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPathNewValueTree(val: xmlNodePtr) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPathNodeSetAdd(cur: xmlNodeSetPtr, val: xmlNodePtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathNodeSetAddUnique(cur: xmlNodeSetPtr, val: xmlNodePtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathNodeSetAddNs(
    cur: xmlNodeSetPtr,
    node: xmlNodePtr,
    ns: xmlNsPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathNodeSetSort(set: xmlNodeSetPtr);
}
extern "C" {
  pub fn xmlXPathRoot(ctxt: xmlXPathParserContextPtr);
}
extern "C" {
  pub fn xmlXPathEvalExpr(ctxt: xmlXPathParserContextPtr);
}
extern "C" {
  pub fn xmlXPathParseName(ctxt: xmlXPathParserContextPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlXPathParseNCName(ctxt: xmlXPathParserContextPtr) -> *mut xmlChar;
}
extern "C" {
  pub fn xmlXPathStringEvalNumber(str: *const xmlChar) -> f64;
}
extern "C" {
  pub fn xmlXPathEvaluatePredicateResult(
    ctxt: xmlXPathParserContextPtr,
    res: xmlXPathObjectPtr,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathRegisterAllFunctions(ctxt: xmlXPathContextPtr);
}
extern "C" {
  pub fn xmlXPathNodeSetMerge(val1: xmlNodeSetPtr, val2: xmlNodeSetPtr) -> xmlNodeSetPtr;
}
extern "C" {
  pub fn xmlXPathNodeSetDel(cur: xmlNodeSetPtr, val: xmlNodePtr);
}
extern "C" {
  pub fn xmlXPathNodeSetRemove(cur: xmlNodeSetPtr, val: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathNewNodeSetList(val: xmlNodeSetPtr) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPathWrapNodeSet(val: xmlNodeSetPtr) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPathWrapExternal(val: *mut ::std::os::raw::c_void) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPathEqualValues(ctxt: xmlXPathParserContextPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathNotEqualValues(ctxt: xmlXPathParserContextPtr) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathCompareValues(
    ctxt: xmlXPathParserContextPtr,
    inf: ::std::os::raw::c_int,
    strict: ::std::os::raw::c_int,
  ) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathValueFlipSign(ctxt: xmlXPathParserContextPtr);
}
extern "C" {
  pub fn xmlXPathAddValues(ctxt: xmlXPathParserContextPtr);
}
extern "C" {
  pub fn xmlXPathSubValues(ctxt: xmlXPathParserContextPtr);
}
extern "C" {
  pub fn xmlXPathMultValues(ctxt: xmlXPathParserContextPtr);
}
extern "C" {
  pub fn xmlXPathDivValues(ctxt: xmlXPathParserContextPtr);
}
extern "C" {
  pub fn xmlXPathModValues(ctxt: xmlXPathParserContextPtr);
}
extern "C" {
  pub fn xmlXPathIsNodeType(name: *const xmlChar) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn xmlXPathNextSelf(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlXPathNextChild(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlXPathNextDescendant(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlXPathNextDescendantOrSelf(
    ctxt: xmlXPathParserContextPtr,
    cur: xmlNodePtr,
  ) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlXPathNextParent(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlXPathNextAncestorOrSelf(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlXPathNextFollowingSibling(
    ctxt: xmlXPathParserContextPtr,
    cur: xmlNodePtr,
  ) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlXPathNextFollowing(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlXPathNextNamespace(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlXPathNextAttribute(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlXPathNextPreceding(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlXPathNextAncestor(ctxt: xmlXPathParserContextPtr, cur: xmlNodePtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlXPathNextPrecedingSibling(
    ctxt: xmlXPathParserContextPtr,
    cur: xmlNodePtr,
  ) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlXPathLastFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathPositionFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathCountFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathIdFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathLocalNameFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathNamespaceURIFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathStringFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathStringLengthFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathConcatFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathContainsFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathStartsWithFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathSubstringFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathSubstringBeforeFunction(
    ctxt: xmlXPathParserContextPtr,
    nargs: ::std::os::raw::c_int,
  );
}
extern "C" {
  pub fn xmlXPathSubstringAfterFunction(
    ctxt: xmlXPathParserContextPtr,
    nargs: ::std::os::raw::c_int,
  );
}
extern "C" {
  pub fn xmlXPathNormalizeFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathTranslateFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathNotFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathTrueFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathFalseFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathLangFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathNumberFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathSumFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathFloorFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathCeilingFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathRoundFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPathBooleanFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  /// Really internal functions
  pub fn xmlXPathNodeSetFreeNs(ns: xmlNsPtr);
}
pub type xmlLocationSet = _xmlLocationSet;
pub type xmlLocationSetPtr = *mut xmlLocationSet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmlLocationSet {
  pub locNr: ::std::os::raw::c_int,
  pub locMax: ::std::os::raw::c_int,
  pub locTab: *mut xmlXPathObjectPtr,
}
#[test]
fn bindgen_test_layout__xmlLocationSet() {
  assert_eq!(
    ::std::mem::size_of::<_xmlLocationSet>(),
    16usize,
    concat!("Size of: ", stringify!(_xmlLocationSet))
  );
  assert_eq!(
    ::std::mem::align_of::<_xmlLocationSet>(),
    8usize,
    concat!("Alignment of ", stringify!(_xmlLocationSet))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlLocationSet>())).locNr as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlLocationSet),
      "::",
      stringify!(locNr)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlLocationSet>())).locMax as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlLocationSet),
      "::",
      stringify!(locMax)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_xmlLocationSet>())).locTab as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_xmlLocationSet),
      "::",
      stringify!(locTab)
    )
  );
}
extern "C" {
  pub fn xmlXPtrLocationSetCreate(val: xmlXPathObjectPtr) -> xmlLocationSetPtr;
}
extern "C" {
  pub fn xmlXPtrFreeLocationSet(obj: xmlLocationSetPtr);
}
extern "C" {
  pub fn xmlXPtrLocationSetMerge(
    val1: xmlLocationSetPtr,
    val2: xmlLocationSetPtr,
  ) -> xmlLocationSetPtr;
}
extern "C" {
  pub fn xmlXPtrNewRange(
    start: xmlNodePtr,
    startindex: ::std::os::raw::c_int,
    end: xmlNodePtr,
    endindex: ::std::os::raw::c_int,
  ) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPtrNewRangePoints(
    start: xmlXPathObjectPtr,
    end: xmlXPathObjectPtr,
  ) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPtrNewRangeNodePoint(start: xmlNodePtr, end: xmlXPathObjectPtr) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPtrNewRangePointNode(start: xmlXPathObjectPtr, end: xmlNodePtr) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPtrNewRangeNodes(start: xmlNodePtr, end: xmlNodePtr) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPtrNewLocationSetNodes(start: xmlNodePtr, end: xmlNodePtr) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPtrNewLocationSetNodeSet(set: xmlNodeSetPtr) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPtrNewRangeNodeObject(start: xmlNodePtr, end: xmlXPathObjectPtr) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPtrNewCollapsedRange(start: xmlNodePtr) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPtrLocationSetAdd(cur: xmlLocationSetPtr, val: xmlXPathObjectPtr);
}
extern "C" {
  pub fn xmlXPtrWrapLocationSet(val: xmlLocationSetPtr) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPtrLocationSetDel(cur: xmlLocationSetPtr, val: xmlXPathObjectPtr);
}
extern "C" {
  pub fn xmlXPtrLocationSetRemove(cur: xmlLocationSetPtr, val: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPtrNewContext(
    doc: xmlDocPtr,
    here: xmlNodePtr,
    origin: xmlNodePtr,
  ) -> xmlXPathContextPtr;
}
extern "C" {
  pub fn xmlXPtrEval(str: *const xmlChar, ctx: xmlXPathContextPtr) -> xmlXPathObjectPtr;
}
extern "C" {
  pub fn xmlXPtrRangeToFunction(ctxt: xmlXPathParserContextPtr, nargs: ::std::os::raw::c_int);
}
extern "C" {
  pub fn xmlXPtrBuildNodeList(obj: xmlXPathObjectPtr) -> xmlNodePtr;
}
extern "C" {
  pub fn xmlXPtrEvalRangePredicate(ctxt: xmlXPathParserContextPtr);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
  pub gp_offset: ::std::os::raw::c_uint,
  pub fp_offset: ::std::os::raw::c_uint,
  pub overflow_arg_area: *mut ::std::os::raw::c_void,
  pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
  assert_eq!(
    ::std::mem::size_of::<__va_list_tag>(),
    24usize,
    concat!("Size of: ", stringify!(__va_list_tag))
  );
  assert_eq!(
    ::std::mem::align_of::<__va_list_tag>(),
    8usize,
    concat!("Alignment of ", stringify!(__va_list_tag))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(__va_list_tag),
      "::",
      stringify!(gp_offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
    4usize,
    concat!(
      "Offset of field: ",
      stringify!(__va_list_tag),
      "::",
      stringify!(fp_offset)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(__va_list_tag),
      "::",
      stringify!(overflow_arg_area)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(__va_list_tag),
      "::",
      stringify!(reg_save_area)
    )
  );
}
