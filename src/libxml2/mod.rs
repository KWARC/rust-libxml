#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
//include!("bindings.rs");

/* automatically generated by rust-bindgen */

pub const __GNUC_VA_LIST : :: std :: os :: raw :: c_uint = 1 ; pub const LIBXML_DOTTED_VERSION : & 'static [ u8 ; 6usize ] = b"2.9.4\0" ; pub const LIBXML_VERSION : :: std :: os :: raw :: c_uint = 20904 ; pub const LIBXML_VERSION_STRING : & 'static [ u8 ; 6usize ] = b"20904\0" ; pub const LIBXML_VERSION_EXTRA : & 'static [ u8 ; 1usize ] = b"\0" ; pub const LIBXML_MODULE_EXTENSION : & 'static [ u8 ; 4usize ] = b".so\0" ; pub const __DARWIN_ONLY_64_BIT_INO_T : :: std :: os :: raw :: c_uint = 0 ; pub const __DARWIN_ONLY_VERS_1050 : :: std :: os :: raw :: c_uint = 0 ; pub const __DARWIN_ONLY_UNIX_CONFORMANCE : :: std :: os :: raw :: c_uint = 1 ; pub const __DARWIN_UNIX03 : :: std :: os :: raw :: c_uint = 1 ; pub const __DARWIN_64_BIT_INO_T : :: std :: os :: raw :: c_uint = 0 ; pub const __DARWIN_VERS_1050 : :: std :: os :: raw :: c_uint = 0 ; pub const __DARWIN_NON_CANCELABLE : :: std :: os :: raw :: c_uint = 0 ; pub const __DARWIN_SUF_EXTSN : & 'static [ u8 ; 14usize ] = b"$DARWIN_EXTSN\0" ; pub const __DARWIN_C_ANSI : :: std :: os :: raw :: c_uint = 4096 ; pub const __DARWIN_C_FULL : :: std :: os :: raw :: c_uint = 900000 ; pub const __DARWIN_C_LEVEL : :: std :: os :: raw :: c_uint = 900000 ; pub const __STDC_WANT_LIB_EXT1__ : :: std :: os :: raw :: c_uint = 1 ; pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE : :: std :: os :: raw :: c_uint = 1 ; pub const _DARWIN_FEATURE_UNIX_CONFORMANCE : :: std :: os :: raw :: c_uint = 3 ; pub const __MAC_10_0 : :: std :: os :: raw :: c_uint = 1000 ; pub const __MAC_10_1 : :: std :: os :: raw :: c_uint = 1010 ; pub const __MAC_10_2 : :: std :: os :: raw :: c_uint = 1020 ; pub const __MAC_10_3 : :: std :: os :: raw :: c_uint = 1030 ; pub const __MAC_10_4 : :: std :: os :: raw :: c_uint = 1040 ; pub const __MAC_10_5 : :: std :: os :: raw :: c_uint = 1050 ; pub const __MAC_10_6 : :: std :: os :: raw :: c_uint = 1060 ; pub const __MAC_10_7 : :: std :: os :: raw :: c_uint = 1070 ; pub const __MAC_10_8 : :: std :: os :: raw :: c_uint = 1080 ; pub const __MAC_10_9 : :: std :: os :: raw :: c_uint = 1090 ; pub const __MAC_10_10 : :: std :: os :: raw :: c_uint = 101000 ; pub const __MAC_10_10_2 : :: std :: os :: raw :: c_uint = 101002 ; pub const __MAC_10_10_3 : :: std :: os :: raw :: c_uint = 101003 ; pub const __MAC_10_11 : :: std :: os :: raw :: c_uint = 101100 ; pub const __MAC_10_11_2 : :: std :: os :: raw :: c_uint = 101102 ; pub const __MAC_10_11_3 : :: std :: os :: raw :: c_uint = 101103 ; pub const __MAC_10_11_4 : :: std :: os :: raw :: c_uint = 101104 ; pub const __MAC_10_12 : :: std :: os :: raw :: c_uint = 101200 ; pub const __MAC_10_12_1 : :: std :: os :: raw :: c_uint = 101201 ; pub const __MAC_10_12_2 : :: std :: os :: raw :: c_uint = 101202 ; pub const __MAC_10_12_4 : :: std :: os :: raw :: c_uint = 101204 ; pub const __MAC_10_13 : :: std :: os :: raw :: c_uint = 101300 ; pub const __IPHONE_2_0 : :: std :: os :: raw :: c_uint = 20000 ; pub const __IPHONE_2_1 : :: std :: os :: raw :: c_uint = 20100 ; pub const __IPHONE_2_2 : :: std :: os :: raw :: c_uint = 20200 ; pub const __IPHONE_3_0 : :: std :: os :: raw :: c_uint = 30000 ; pub const __IPHONE_3_1 : :: std :: os :: raw :: c_uint = 30100 ; pub const __IPHONE_3_2 : :: std :: os :: raw :: c_uint = 30200 ; pub const __IPHONE_4_0 : :: std :: os :: raw :: c_uint = 40000 ; pub const __IPHONE_4_1 : :: std :: os :: raw :: c_uint = 40100 ; pub const __IPHONE_4_2 : :: std :: os :: raw :: c_uint = 40200 ; pub const __IPHONE_4_3 : :: std :: os :: raw :: c_uint = 40300 ; pub const __IPHONE_5_0 : :: std :: os :: raw :: c_uint = 50000 ; pub const __IPHONE_5_1 : :: std :: os :: raw :: c_uint = 50100 ; pub const __IPHONE_6_0 : :: std :: os :: raw :: c_uint = 60000 ; pub const __IPHONE_6_1 : :: std :: os :: raw :: c_uint = 60100 ; pub const __IPHONE_7_0 : :: std :: os :: raw :: c_uint = 70000 ; pub const __IPHONE_7_1 : :: std :: os :: raw :: c_uint = 70100 ; pub const __IPHONE_8_0 : :: std :: os :: raw :: c_uint = 80000 ; pub const __IPHONE_8_1 : :: std :: os :: raw :: c_uint = 80100 ; pub const __IPHONE_8_2 : :: std :: os :: raw :: c_uint = 80200 ; pub const __IPHONE_8_3 : :: std :: os :: raw :: c_uint = 80300 ; pub const __IPHONE_8_4 : :: std :: os :: raw :: c_uint = 80400 ; pub const __IPHONE_9_0 : :: std :: os :: raw :: c_uint = 90000 ; pub const __IPHONE_9_1 : :: std :: os :: raw :: c_uint = 90100 ; pub const __IPHONE_9_2 : :: std :: os :: raw :: c_uint = 90200 ; pub const __IPHONE_9_3 : :: std :: os :: raw :: c_uint = 90300 ; pub const __IPHONE_10_0 : :: std :: os :: raw :: c_uint = 100000 ; pub const __IPHONE_10_1 : :: std :: os :: raw :: c_uint = 100100 ; pub const __IPHONE_10_2 : :: std :: os :: raw :: c_uint = 100200 ; pub const __IPHONE_10_3 : :: std :: os :: raw :: c_uint = 100300 ; pub const __IPHONE_11_0 : :: std :: os :: raw :: c_uint = 110000 ; pub const __TVOS_9_0 : :: std :: os :: raw :: c_uint = 90000 ; pub const __TVOS_9_1 : :: std :: os :: raw :: c_uint = 90100 ; pub const __TVOS_9_2 : :: std :: os :: raw :: c_uint = 90200 ; pub const __TVOS_10_0 : :: std :: os :: raw :: c_uint = 100000 ; pub const __TVOS_10_0_1 : :: std :: os :: raw :: c_uint = 100001 ; pub const __TVOS_10_1 : :: std :: os :: raw :: c_uint = 100100 ; pub const __TVOS_10_2 : :: std :: os :: raw :: c_uint = 100200 ; pub const __TVOS_11_0 : :: std :: os :: raw :: c_uint = 110000 ; pub const __WATCHOS_1_0 : :: std :: os :: raw :: c_uint = 10000 ; pub const __WATCHOS_2_0 : :: std :: os :: raw :: c_uint = 20000 ; pub const __WATCHOS_2_1 : :: std :: os :: raw :: c_uint = 20100 ; pub const __WATCHOS_2_2 : :: std :: os :: raw :: c_uint = 20200 ; pub const __WATCHOS_3_0 : :: std :: os :: raw :: c_uint = 30000 ; pub const __WATCHOS_3_1 : :: std :: os :: raw :: c_uint = 30100 ; pub const __WATCHOS_3_1_1 : :: std :: os :: raw :: c_uint = 30101 ; pub const __WATCHOS_3_2 : :: std :: os :: raw :: c_uint = 30200 ; pub const __WATCHOS_4_0 : :: std :: os :: raw :: c_uint = 40000 ; pub const __MAC_OS_X_VERSION_MAX_ALLOWED : :: std :: os :: raw :: c_uint = 101300 ; pub const __PTHREAD_SIZE__ : :: std :: os :: raw :: c_uint = 8176 ; pub const __PTHREAD_ATTR_SIZE__ : :: std :: os :: raw :: c_uint = 56 ; pub const __PTHREAD_MUTEXATTR_SIZE__ : :: std :: os :: raw :: c_uint = 8 ; pub const __PTHREAD_MUTEX_SIZE__ : :: std :: os :: raw :: c_uint = 56 ; pub const __PTHREAD_CONDATTR_SIZE__ : :: std :: os :: raw :: c_uint = 8 ; pub const __PTHREAD_COND_SIZE__ : :: std :: os :: raw :: c_uint = 40 ; pub const __PTHREAD_ONCE_SIZE__ : :: std :: os :: raw :: c_uint = 8 ; pub const __PTHREAD_RWLOCK_SIZE__ : :: std :: os :: raw :: c_uint = 192 ; pub const __PTHREAD_RWLOCKATTR_SIZE__ : :: std :: os :: raw :: c_uint = 16 ; pub const __DARWIN_WCHAR_MIN : :: std :: os :: raw :: c_int = -2147483648 ; pub const _FORTIFY_SOURCE : :: std :: os :: raw :: c_uint = 0 ; pub const RENAME_SECLUDE : :: std :: os :: raw :: c_uint = 1 ; pub const RENAME_SWAP : :: std :: os :: raw :: c_uint = 2 ; pub const RENAME_EXCL : :: std :: os :: raw :: c_uint = 4 ; pub const __SLBF : :: std :: os :: raw :: c_uint = 1 ; pub const __SNBF : :: std :: os :: raw :: c_uint = 2 ; pub const __SRD : :: std :: os :: raw :: c_uint = 4 ; pub const __SWR : :: std :: os :: raw :: c_uint = 8 ; pub const __SRW : :: std :: os :: raw :: c_uint = 16 ; pub const __SEOF : :: std :: os :: raw :: c_uint = 32 ; pub const __SERR : :: std :: os :: raw :: c_uint = 64 ; pub const __SMBF : :: std :: os :: raw :: c_uint = 128 ; pub const __SAPP : :: std :: os :: raw :: c_uint = 256 ; pub const __SSTR : :: std :: os :: raw :: c_uint = 512 ; pub const __SOPT : :: std :: os :: raw :: c_uint = 1024 ; pub const __SNPT : :: std :: os :: raw :: c_uint = 2048 ; pub const __SOFF : :: std :: os :: raw :: c_uint = 4096 ; pub const __SMOD : :: std :: os :: raw :: c_uint = 8192 ; pub const __SALC : :: std :: os :: raw :: c_uint = 16384 ; pub const __SIGN : :: std :: os :: raw :: c_uint = 32768 ; pub const _IOFBF : :: std :: os :: raw :: c_uint = 0 ; pub const _IOLBF : :: std :: os :: raw :: c_uint = 1 ; pub const _IONBF : :: std :: os :: raw :: c_uint = 2 ; pub const BUFSIZ : :: std :: os :: raw :: c_uint = 1024 ; pub const EOF : :: std :: os :: raw :: c_int = -1 ; pub const FOPEN_MAX : :: std :: os :: raw :: c_uint = 20 ; pub const FILENAME_MAX : :: std :: os :: raw :: c_uint = 1024 ; pub const P_tmpdir : & 'static [ u8 ; 10usize ] = b"/var/tmp/\0" ; pub const L_tmpnam : :: std :: os :: raw :: c_uint = 1024 ; pub const TMP_MAX : :: std :: os :: raw :: c_uint = 308915776 ; pub const SEEK_SET : :: std :: os :: raw :: c_uint = 0 ; pub const SEEK_CUR : :: std :: os :: raw :: c_uint = 1 ; pub const SEEK_END : :: std :: os :: raw :: c_uint = 2 ; pub const L_ctermid : :: std :: os :: raw :: c_uint = 1024 ; pub const __CTERMID_DEFINED : :: std :: os :: raw :: c_uint = 1 ; pub const __DARWIN_CLK_TCK : :: std :: os :: raw :: c_uint = 100 ; pub const CHAR_BIT : :: std :: os :: raw :: c_uint = 8 ; pub const MB_LEN_MAX : :: std :: os :: raw :: c_uint = 6 ; pub const CLK_TCK : :: std :: os :: raw :: c_uint = 100 ; pub const SCHAR_MAX : :: std :: os :: raw :: c_uint = 127 ; pub const SCHAR_MIN : :: std :: os :: raw :: c_int = -128 ; pub const UCHAR_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const CHAR_MAX : :: std :: os :: raw :: c_uint = 127 ; pub const CHAR_MIN : :: std :: os :: raw :: c_int = -128 ; pub const USHRT_MAX : :: std :: os :: raw :: c_uint = 65535 ; pub const SHRT_MAX : :: std :: os :: raw :: c_uint = 32767 ; pub const SHRT_MIN : :: std :: os :: raw :: c_int = -32768 ; pub const UINT_MAX : :: std :: os :: raw :: c_uint = 4294967295 ; pub const INT_MAX : :: std :: os :: raw :: c_uint = 2147483647 ; pub const INT_MIN : :: std :: os :: raw :: c_int = -2147483648 ; pub const ULONG_MAX : :: std :: os :: raw :: c_int = -1 ; pub const LONG_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const LONG_MIN : :: std :: os :: raw :: c_longlong = -9223372036854775808 ; pub const ULLONG_MAX : :: std :: os :: raw :: c_int = -1 ; pub const LLONG_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const LLONG_MIN : :: std :: os :: raw :: c_longlong = -9223372036854775808 ; pub const LONG_BIT : :: std :: os :: raw :: c_uint = 64 ; pub const SSIZE_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const WORD_BIT : :: std :: os :: raw :: c_uint = 32 ; pub const SIZE_T_MAX : :: std :: os :: raw :: c_int = -1 ; pub const UQUAD_MAX : :: std :: os :: raw :: c_int = -1 ; pub const QUAD_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const QUAD_MIN : :: std :: os :: raw :: c_longlong = -9223372036854775808 ; pub const ARG_MAX : :: std :: os :: raw :: c_uint = 262144 ; pub const CHILD_MAX : :: std :: os :: raw :: c_uint = 266 ; pub const GID_MAX : :: std :: os :: raw :: c_uint = 2147483647 ; pub const LINK_MAX : :: std :: os :: raw :: c_uint = 32767 ; pub const MAX_CANON : :: std :: os :: raw :: c_uint = 1024 ; pub const MAX_INPUT : :: std :: os :: raw :: c_uint = 1024 ; pub const NAME_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const NGROUPS_MAX : :: std :: os :: raw :: c_uint = 16 ; pub const UID_MAX : :: std :: os :: raw :: c_uint = 2147483647 ; pub const OPEN_MAX : :: std :: os :: raw :: c_uint = 10240 ; pub const PATH_MAX : :: std :: os :: raw :: c_uint = 1024 ; pub const PIPE_BUF : :: std :: os :: raw :: c_uint = 512 ; pub const BC_BASE_MAX : :: std :: os :: raw :: c_uint = 99 ; pub const BC_DIM_MAX : :: std :: os :: raw :: c_uint = 2048 ; pub const BC_SCALE_MAX : :: std :: os :: raw :: c_uint = 99 ; pub const BC_STRING_MAX : :: std :: os :: raw :: c_uint = 1000 ; pub const CHARCLASS_NAME_MAX : :: std :: os :: raw :: c_uint = 14 ; pub const COLL_WEIGHTS_MAX : :: std :: os :: raw :: c_uint = 2 ; pub const EQUIV_CLASS_MAX : :: std :: os :: raw :: c_uint = 2 ; pub const EXPR_NEST_MAX : :: std :: os :: raw :: c_uint = 32 ; pub const LINE_MAX : :: std :: os :: raw :: c_uint = 2048 ; pub const RE_DUP_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const NZERO : :: std :: os :: raw :: c_uint = 20 ; pub const _POSIX_ARG_MAX : :: std :: os :: raw :: c_uint = 4096 ; pub const _POSIX_CHILD_MAX : :: std :: os :: raw :: c_uint = 25 ; pub const _POSIX_LINK_MAX : :: std :: os :: raw :: c_uint = 8 ; pub const _POSIX_MAX_CANON : :: std :: os :: raw :: c_uint = 255 ; pub const _POSIX_MAX_INPUT : :: std :: os :: raw :: c_uint = 255 ; pub const _POSIX_NAME_MAX : :: std :: os :: raw :: c_uint = 14 ; pub const _POSIX_NGROUPS_MAX : :: std :: os :: raw :: c_uint = 8 ; pub const _POSIX_OPEN_MAX : :: std :: os :: raw :: c_uint = 20 ; pub const _POSIX_PATH_MAX : :: std :: os :: raw :: c_uint = 256 ; pub const _POSIX_PIPE_BUF : :: std :: os :: raw :: c_uint = 512 ; pub const _POSIX_SSIZE_MAX : :: std :: os :: raw :: c_uint = 32767 ; pub const _POSIX_STREAM_MAX : :: std :: os :: raw :: c_uint = 8 ; pub const _POSIX_TZNAME_MAX : :: std :: os :: raw :: c_uint = 6 ; pub const _POSIX2_BC_BASE_MAX : :: std :: os :: raw :: c_uint = 99 ; pub const _POSIX2_BC_DIM_MAX : :: std :: os :: raw :: c_uint = 2048 ; pub const _POSIX2_BC_SCALE_MAX : :: std :: os :: raw :: c_uint = 99 ; pub const _POSIX2_BC_STRING_MAX : :: std :: os :: raw :: c_uint = 1000 ; pub const _POSIX2_EQUIV_CLASS_MAX : :: std :: os :: raw :: c_uint = 2 ; pub const _POSIX2_EXPR_NEST_MAX : :: std :: os :: raw :: c_uint = 32 ; pub const _POSIX2_LINE_MAX : :: std :: os :: raw :: c_uint = 2048 ; pub const _POSIX2_RE_DUP_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const _POSIX_AIO_LISTIO_MAX : :: std :: os :: raw :: c_uint = 2 ; pub const _POSIX_AIO_MAX : :: std :: os :: raw :: c_uint = 1 ; pub const _POSIX_DELAYTIMER_MAX : :: std :: os :: raw :: c_uint = 32 ; pub const _POSIX_MQ_OPEN_MAX : :: std :: os :: raw :: c_uint = 8 ; pub const _POSIX_MQ_PRIO_MAX : :: std :: os :: raw :: c_uint = 32 ; pub const _POSIX_RTSIG_MAX : :: std :: os :: raw :: c_uint = 8 ; pub const _POSIX_SEM_NSEMS_MAX : :: std :: os :: raw :: c_uint = 256 ; pub const _POSIX_SEM_VALUE_MAX : :: std :: os :: raw :: c_uint = 32767 ; pub const _POSIX_SIGQUEUE_MAX : :: std :: os :: raw :: c_uint = 32 ; pub const _POSIX_TIMER_MAX : :: std :: os :: raw :: c_uint = 32 ; pub const _POSIX_CLOCKRES_MIN : :: std :: os :: raw :: c_uint = 20000000 ; pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS : :: std :: os :: raw :: c_uint = 4 ; pub const _POSIX_THREAD_KEYS_MAX : :: std :: os :: raw :: c_uint = 128 ; pub const _POSIX_THREAD_THREADS_MAX : :: std :: os :: raw :: c_uint = 64 ; pub const PTHREAD_DESTRUCTOR_ITERATIONS : :: std :: os :: raw :: c_uint = 4 ; pub const PTHREAD_KEYS_MAX : :: std :: os :: raw :: c_uint = 512 ; pub const PTHREAD_STACK_MIN : :: std :: os :: raw :: c_uint = 8192 ; pub const _POSIX_HOST_NAME_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const _POSIX_LOGIN_NAME_MAX : :: std :: os :: raw :: c_uint = 9 ; pub const _POSIX_SS_REPL_MAX : :: std :: os :: raw :: c_uint = 4 ; pub const _POSIX_SYMLINK_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const _POSIX_SYMLOOP_MAX : :: std :: os :: raw :: c_uint = 8 ; pub const _POSIX_TRACE_EVENT_NAME_MAX : :: std :: os :: raw :: c_uint = 30 ; pub const _POSIX_TRACE_NAME_MAX : :: std :: os :: raw :: c_uint = 8 ; pub const _POSIX_TRACE_SYS_MAX : :: std :: os :: raw :: c_uint = 8 ; pub const _POSIX_TRACE_USER_EVENT_MAX : :: std :: os :: raw :: c_uint = 32 ; pub const _POSIX_TTY_NAME_MAX : :: std :: os :: raw :: c_uint = 9 ; pub const _POSIX2_CHARCLASS_NAME_MAX : :: std :: os :: raw :: c_uint = 14 ; pub const _POSIX2_COLL_WEIGHTS_MAX : :: std :: os :: raw :: c_uint = 2 ; pub const _POSIX_RE_DUP_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const OFF_MIN : :: std :: os :: raw :: c_longlong = -9223372036854775808 ; pub const OFF_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const PASS_MAX : :: std :: os :: raw :: c_uint = 128 ; pub const NL_ARGMAX : :: std :: os :: raw :: c_uint = 9 ; pub const NL_LANGMAX : :: std :: os :: raw :: c_uint = 14 ; pub const NL_MSGMAX : :: std :: os :: raw :: c_uint = 32767 ; pub const NL_NMAX : :: std :: os :: raw :: c_uint = 1 ; pub const NL_SETMAX : :: std :: os :: raw :: c_uint = 255 ; pub const NL_TEXTMAX : :: std :: os :: raw :: c_uint = 2048 ; pub const _XOPEN_IOV_MAX : :: std :: os :: raw :: c_uint = 16 ; pub const IOV_MAX : :: std :: os :: raw :: c_uint = 1024 ; pub const _XOPEN_NAME_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const _XOPEN_PATH_MAX : :: std :: os :: raw :: c_uint = 1024 ; pub const BASE_BUFFER_SIZE : :: std :: os :: raw :: c_uint = 4096 ; pub const XML_DEFAULT_VERSION : & 'static [ u8 ; 4usize ] = b"1.0\0" ; pub const XML_DETECT_IDS : :: std :: os :: raw :: c_uint = 2 ; pub const XML_COMPLETE_ATTRS : :: std :: os :: raw :: c_uint = 4 ; pub const XML_SKIP_IDS : :: std :: os :: raw :: c_uint = 8 ; pub const XML_SAX2_MAGIC : :: std :: os :: raw :: c_uint = 3740122799 ; pub const __DARWIN_NSIG : :: std :: os :: raw :: c_uint = 32 ; pub const NSIG : :: std :: os :: raw :: c_uint = 32 ; pub const _I386_SIGNAL_H_ : :: std :: os :: raw :: c_uint = 1 ; pub const SIGHUP : :: std :: os :: raw :: c_uint = 1 ; pub const SIGINT : :: std :: os :: raw :: c_uint = 2 ; pub const SIGQUIT : :: std :: os :: raw :: c_uint = 3 ; pub const SIGILL : :: std :: os :: raw :: c_uint = 4 ; pub const SIGTRAP : :: std :: os :: raw :: c_uint = 5 ; pub const SIGABRT : :: std :: os :: raw :: c_uint = 6 ; pub const SIGIOT : :: std :: os :: raw :: c_uint = 6 ; pub const SIGEMT : :: std :: os :: raw :: c_uint = 7 ; pub const SIGFPE : :: std :: os :: raw :: c_uint = 8 ; pub const SIGKILL : :: std :: os :: raw :: c_uint = 9 ; pub const SIGBUS : :: std :: os :: raw :: c_uint = 10 ; pub const SIGSEGV : :: std :: os :: raw :: c_uint = 11 ; pub const SIGSYS : :: std :: os :: raw :: c_uint = 12 ; pub const SIGPIPE : :: std :: os :: raw :: c_uint = 13 ; pub const SIGALRM : :: std :: os :: raw :: c_uint = 14 ; pub const SIGTERM : :: std :: os :: raw :: c_uint = 15 ; pub const SIGURG : :: std :: os :: raw :: c_uint = 16 ; pub const SIGSTOP : :: std :: os :: raw :: c_uint = 17 ; pub const SIGTSTP : :: std :: os :: raw :: c_uint = 18 ; pub const SIGCONT : :: std :: os :: raw :: c_uint = 19 ; pub const SIGCHLD : :: std :: os :: raw :: c_uint = 20 ; pub const SIGTTIN : :: std :: os :: raw :: c_uint = 21 ; pub const SIGTTOU : :: std :: os :: raw :: c_uint = 22 ; pub const SIGIO : :: std :: os :: raw :: c_uint = 23 ; pub const SIGXCPU : :: std :: os :: raw :: c_uint = 24 ; pub const SIGXFSZ : :: std :: os :: raw :: c_uint = 25 ; pub const SIGVTALRM : :: std :: os :: raw :: c_uint = 26 ; pub const SIGPROF : :: std :: os :: raw :: c_uint = 27 ; pub const SIGWINCH : :: std :: os :: raw :: c_uint = 28 ; pub const SIGINFO : :: std :: os :: raw :: c_uint = 29 ; pub const SIGUSR1 : :: std :: os :: raw :: c_uint = 30 ; pub const SIGUSR2 : :: std :: os :: raw :: c_uint = 31 ; pub const FP_PREC_24B : :: std :: os :: raw :: c_uint = 0 ; pub const FP_PREC_53B : :: std :: os :: raw :: c_uint = 2 ; pub const FP_PREC_64B : :: std :: os :: raw :: c_uint = 3 ; pub const FP_RND_NEAR : :: std :: os :: raw :: c_uint = 0 ; pub const FP_RND_DOWN : :: std :: os :: raw :: c_uint = 1 ; pub const FP_RND_UP : :: std :: os :: raw :: c_uint = 2 ; pub const FP_CHOP : :: std :: os :: raw :: c_uint = 3 ; pub const FP_STATE_BYTES : :: std :: os :: raw :: c_uint = 512 ; pub const SIGEV_NONE : :: std :: os :: raw :: c_uint = 0 ; pub const SIGEV_SIGNAL : :: std :: os :: raw :: c_uint = 1 ; pub const SIGEV_THREAD : :: std :: os :: raw :: c_uint = 3 ; pub const ILL_NOOP : :: std :: os :: raw :: c_uint = 0 ; pub const ILL_ILLOPC : :: std :: os :: raw :: c_uint = 1 ; pub const ILL_ILLTRP : :: std :: os :: raw :: c_uint = 2 ; pub const ILL_PRVOPC : :: std :: os :: raw :: c_uint = 3 ; pub const ILL_ILLOPN : :: std :: os :: raw :: c_uint = 4 ; pub const ILL_ILLADR : :: std :: os :: raw :: c_uint = 5 ; pub const ILL_PRVREG : :: std :: os :: raw :: c_uint = 6 ; pub const ILL_COPROC : :: std :: os :: raw :: c_uint = 7 ; pub const ILL_BADSTK : :: std :: os :: raw :: c_uint = 8 ; pub const FPE_NOOP : :: std :: os :: raw :: c_uint = 0 ; pub const FPE_FLTDIV : :: std :: os :: raw :: c_uint = 1 ; pub const FPE_FLTOVF : :: std :: os :: raw :: c_uint = 2 ; pub const FPE_FLTUND : :: std :: os :: raw :: c_uint = 3 ; pub const FPE_FLTRES : :: std :: os :: raw :: c_uint = 4 ; pub const FPE_FLTINV : :: std :: os :: raw :: c_uint = 5 ; pub const FPE_FLTSUB : :: std :: os :: raw :: c_uint = 6 ; pub const FPE_INTDIV : :: std :: os :: raw :: c_uint = 7 ; pub const FPE_INTOVF : :: std :: os :: raw :: c_uint = 8 ; pub const SEGV_NOOP : :: std :: os :: raw :: c_uint = 0 ; pub const SEGV_MAPERR : :: std :: os :: raw :: c_uint = 1 ; pub const SEGV_ACCERR : :: std :: os :: raw :: c_uint = 2 ; pub const BUS_NOOP : :: std :: os :: raw :: c_uint = 0 ; pub const BUS_ADRALN : :: std :: os :: raw :: c_uint = 1 ; pub const BUS_ADRERR : :: std :: os :: raw :: c_uint = 2 ; pub const BUS_OBJERR : :: std :: os :: raw :: c_uint = 3 ; pub const TRAP_BRKPT : :: std :: os :: raw :: c_uint = 1 ; pub const TRAP_TRACE : :: std :: os :: raw :: c_uint = 2 ; pub const CLD_NOOP : :: std :: os :: raw :: c_uint = 0 ; pub const CLD_EXITED : :: std :: os :: raw :: c_uint = 1 ; pub const CLD_KILLED : :: std :: os :: raw :: c_uint = 2 ; pub const CLD_DUMPED : :: std :: os :: raw :: c_uint = 3 ; pub const CLD_TRAPPED : :: std :: os :: raw :: c_uint = 4 ; pub const CLD_STOPPED : :: std :: os :: raw :: c_uint = 5 ; pub const CLD_CONTINUED : :: std :: os :: raw :: c_uint = 6 ; pub const POLL_IN : :: std :: os :: raw :: c_uint = 1 ; pub const POLL_OUT : :: std :: os :: raw :: c_uint = 2 ; pub const POLL_MSG : :: std :: os :: raw :: c_uint = 3 ; pub const POLL_ERR : :: std :: os :: raw :: c_uint = 4 ; pub const POLL_PRI : :: std :: os :: raw :: c_uint = 5 ; pub const POLL_HUP : :: std :: os :: raw :: c_uint = 6 ; pub const SA_ONSTACK : :: std :: os :: raw :: c_uint = 1 ; pub const SA_RESTART : :: std :: os :: raw :: c_uint = 2 ; pub const SA_RESETHAND : :: std :: os :: raw :: c_uint = 4 ; pub const SA_NOCLDSTOP : :: std :: os :: raw :: c_uint = 8 ; pub const SA_NODEFER : :: std :: os :: raw :: c_uint = 16 ; pub const SA_NOCLDWAIT : :: std :: os :: raw :: c_uint = 32 ; pub const SA_SIGINFO : :: std :: os :: raw :: c_uint = 64 ; pub const SA_USERTRAMP : :: std :: os :: raw :: c_uint = 256 ; pub const SA_64REGSET : :: std :: os :: raw :: c_uint = 512 ; pub const SA_USERSPACE_MASK : :: std :: os :: raw :: c_uint = 127 ; pub const SIG_BLOCK : :: std :: os :: raw :: c_uint = 1 ; pub const SIG_UNBLOCK : :: std :: os :: raw :: c_uint = 2 ; pub const SIG_SETMASK : :: std :: os :: raw :: c_uint = 3 ; pub const SI_USER : :: std :: os :: raw :: c_uint = 65537 ; pub const SI_QUEUE : :: std :: os :: raw :: c_uint = 65538 ; pub const SI_TIMER : :: std :: os :: raw :: c_uint = 65539 ; pub const SI_ASYNCIO : :: std :: os :: raw :: c_uint = 65540 ; pub const SI_MESGQ : :: std :: os :: raw :: c_uint = 65541 ; pub const SS_ONSTACK : :: std :: os :: raw :: c_uint = 1 ; pub const SS_DISABLE : :: std :: os :: raw :: c_uint = 4 ; pub const MINSIGSTKSZ : :: std :: os :: raw :: c_uint = 32768 ; pub const SIGSTKSZ : :: std :: os :: raw :: c_uint = 131072 ; pub const SV_ONSTACK : :: std :: os :: raw :: c_uint = 1 ; pub const SV_INTERRUPT : :: std :: os :: raw :: c_uint = 2 ; pub const SV_RESETHAND : :: std :: os :: raw :: c_uint = 4 ; pub const SV_NODEFER : :: std :: os :: raw :: c_uint = 16 ; pub const SV_NOCLDSTOP : :: std :: os :: raw :: c_uint = 8 ; pub const SV_SIGINFO : :: std :: os :: raw :: c_uint = 64 ; pub const __WORDSIZE : :: std :: os :: raw :: c_uint = 64 ; pub const INT8_MAX : :: std :: os :: raw :: c_uint = 127 ; pub const INT16_MAX : :: std :: os :: raw :: c_uint = 32767 ; pub const INT32_MAX : :: std :: os :: raw :: c_uint = 2147483647 ; pub const INT64_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const INT8_MIN : :: std :: os :: raw :: c_int = -128 ; pub const INT16_MIN : :: std :: os :: raw :: c_int = -32768 ; pub const INT32_MIN : :: std :: os :: raw :: c_int = -2147483648 ; pub const INT64_MIN : :: std :: os :: raw :: c_longlong = -9223372036854775808 ; pub const UINT8_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const UINT16_MAX : :: std :: os :: raw :: c_uint = 65535 ; pub const UINT32_MAX : :: std :: os :: raw :: c_uint = 4294967295 ; pub const UINT64_MAX : :: std :: os :: raw :: c_int = -1 ; pub const INT_LEAST8_MIN : :: std :: os :: raw :: c_int = -128 ; pub const INT_LEAST16_MIN : :: std :: os :: raw :: c_int = -32768 ; pub const INT_LEAST32_MIN : :: std :: os :: raw :: c_int = -2147483648 ; pub const INT_LEAST64_MIN : :: std :: os :: raw :: c_longlong = -9223372036854775808 ; pub const INT_LEAST8_MAX : :: std :: os :: raw :: c_uint = 127 ; pub const INT_LEAST16_MAX : :: std :: os :: raw :: c_uint = 32767 ; pub const INT_LEAST32_MAX : :: std :: os :: raw :: c_uint = 2147483647 ; pub const INT_LEAST64_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const UINT_LEAST8_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const UINT_LEAST16_MAX : :: std :: os :: raw :: c_uint = 65535 ; pub const UINT_LEAST32_MAX : :: std :: os :: raw :: c_uint = 4294967295 ; pub const UINT_LEAST64_MAX : :: std :: os :: raw :: c_int = -1 ; pub const INT_FAST8_MIN : :: std :: os :: raw :: c_int = -128 ; pub const INT_FAST16_MIN : :: std :: os :: raw :: c_int = -32768 ; pub const INT_FAST32_MIN : :: std :: os :: raw :: c_int = -2147483648 ; pub const INT_FAST64_MIN : :: std :: os :: raw :: c_longlong = -9223372036854775808 ; pub const INT_FAST8_MAX : :: std :: os :: raw :: c_uint = 127 ; pub const INT_FAST16_MAX : :: std :: os :: raw :: c_uint = 32767 ; pub const INT_FAST32_MAX : :: std :: os :: raw :: c_uint = 2147483647 ; pub const INT_FAST64_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const UINT_FAST8_MAX : :: std :: os :: raw :: c_uint = 255 ; pub const UINT_FAST16_MAX : :: std :: os :: raw :: c_uint = 65535 ; pub const UINT_FAST32_MAX : :: std :: os :: raw :: c_uint = 4294967295 ; pub const UINT_FAST64_MAX : :: std :: os :: raw :: c_int = -1 ; pub const INTPTR_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const INTPTR_MIN : :: std :: os :: raw :: c_longlong = -9223372036854775808 ; pub const UINTPTR_MAX : :: std :: os :: raw :: c_int = -1 ; pub const INTMAX_MIN : :: std :: os :: raw :: c_longlong = -9223372036854775808 ; pub const INTMAX_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const UINTMAX_MAX : :: std :: os :: raw :: c_int = -1 ; pub const PTRDIFF_MIN : :: std :: os :: raw :: c_longlong = -9223372036854775808 ; pub const PTRDIFF_MAX : :: std :: os :: raw :: c_ulonglong = 9223372036854775807 ; pub const SIZE_MAX : :: std :: os :: raw :: c_int = -1 ; pub const RSIZE_MAX : :: std :: os :: raw :: c_int = -1 ; pub const WINT_MIN : :: std :: os :: raw :: c_int = -2147483648 ; pub const WINT_MAX : :: std :: os :: raw :: c_uint = 2147483647 ; pub const SIG_ATOMIC_MIN : :: std :: os :: raw :: c_int = -2147483648 ; pub const SIG_ATOMIC_MAX : :: std :: os :: raw :: c_uint = 2147483647 ; pub const PRIO_PROCESS : :: std :: os :: raw :: c_uint = 0 ; pub const PRIO_PGRP : :: std :: os :: raw :: c_uint = 1 ; pub const PRIO_USER : :: std :: os :: raw :: c_uint = 2 ; pub const PRIO_DARWIN_THREAD : :: std :: os :: raw :: c_uint = 3 ; pub const PRIO_DARWIN_PROCESS : :: std :: os :: raw :: c_uint = 4 ; pub const PRIO_MIN : :: std :: os :: raw :: c_int = -20 ; pub const PRIO_MAX : :: std :: os :: raw :: c_uint = 20 ; pub const PRIO_DARWIN_BG : :: std :: os :: raw :: c_uint = 4096 ; pub const PRIO_DARWIN_NONUI : :: std :: os :: raw :: c_uint = 4097 ; pub const RUSAGE_SELF : :: std :: os :: raw :: c_uint = 0 ; pub const RUSAGE_CHILDREN : :: std :: os :: raw :: c_int = -1 ; pub const RUSAGE_INFO_V0 : :: std :: os :: raw :: c_uint = 0 ; pub const RUSAGE_INFO_V1 : :: std :: os :: raw :: c_uint = 1 ; pub const RUSAGE_INFO_V2 : :: std :: os :: raw :: c_uint = 2 ; pub const RUSAGE_INFO_V3 : :: std :: os :: raw :: c_uint = 3 ; pub const RUSAGE_INFO_V4 : :: std :: os :: raw :: c_uint = 4 ; pub const RUSAGE_INFO_CURRENT : :: std :: os :: raw :: c_uint = 4 ; pub const RLIMIT_CPU : :: std :: os :: raw :: c_uint = 0 ; pub const RLIMIT_FSIZE : :: std :: os :: raw :: c_uint = 1 ; pub const RLIMIT_DATA : :: std :: os :: raw :: c_uint = 2 ; pub const RLIMIT_STACK : :: std :: os :: raw :: c_uint = 3 ; pub const RLIMIT_CORE : :: std :: os :: raw :: c_uint = 4 ; pub const RLIMIT_AS : :: std :: os :: raw :: c_uint = 5 ; pub const RLIMIT_RSS : :: std :: os :: raw :: c_uint = 5 ; pub const RLIMIT_MEMLOCK : :: std :: os :: raw :: c_uint = 6 ; pub const RLIMIT_NPROC : :: std :: os :: raw :: c_uint = 7 ; pub const RLIMIT_NOFILE : :: std :: os :: raw :: c_uint = 8 ; pub const RLIM_NLIMITS : :: std :: os :: raw :: c_uint = 9 ; pub const _RLIMIT_POSIX_FLAG : :: std :: os :: raw :: c_uint = 4096 ; pub const RLIMIT_WAKEUPS_MONITOR : :: std :: os :: raw :: c_uint = 1 ; pub const RLIMIT_CPU_USAGE_MONITOR : :: std :: os :: raw :: c_uint = 2 ; pub const RLIMIT_THREAD_CPULIMITS : :: std :: os :: raw :: c_uint = 3 ; pub const WAKEMON_ENABLE : :: std :: os :: raw :: c_uint = 1 ; pub const WAKEMON_DISABLE : :: std :: os :: raw :: c_uint = 2 ; pub const WAKEMON_GET_PARAMS : :: std :: os :: raw :: c_uint = 4 ; pub const WAKEMON_SET_DEFAULTS : :: std :: os :: raw :: c_uint = 8 ; pub const WAKEMON_MAKE_FATAL : :: std :: os :: raw :: c_uint = 16 ; pub const CPUMON_MAKE_FATAL : :: std :: os :: raw :: c_uint = 4096 ; pub const IOPOL_TYPE_DISK : :: std :: os :: raw :: c_uint = 0 ; pub const IOPOL_SCOPE_PROCESS : :: std :: os :: raw :: c_uint = 0 ; pub const IOPOL_SCOPE_THREAD : :: std :: os :: raw :: c_uint = 1 ; pub const IOPOL_SCOPE_DARWIN_BG : :: std :: os :: raw :: c_uint = 2 ; pub const IOPOL_DEFAULT : :: std :: os :: raw :: c_uint = 0 ; pub const IOPOL_IMPORTANT : :: std :: os :: raw :: c_uint = 1 ; pub const IOPOL_PASSIVE : :: std :: os :: raw :: c_uint = 2 ; pub const IOPOL_THROTTLE : :: std :: os :: raw :: c_uint = 3 ; pub const IOPOL_UTILITY : :: std :: os :: raw :: c_uint = 4 ; pub const IOPOL_STANDARD : :: std :: os :: raw :: c_uint = 5 ; pub const IOPOL_APPLICATION : :: std :: os :: raw :: c_uint = 5 ; pub const IOPOL_NORMAL : :: std :: os :: raw :: c_uint = 1 ; pub const WNOHANG : :: std :: os :: raw :: c_uint = 1 ; pub const WUNTRACED : :: std :: os :: raw :: c_uint = 2 ; pub const WCOREFLAG : :: std :: os :: raw :: c_uint = 128 ; pub const _WSTOPPED : :: std :: os :: raw :: c_uint = 127 ; pub const WEXITED : :: std :: os :: raw :: c_uint = 4 ; pub const WSTOPPED : :: std :: os :: raw :: c_uint = 8 ; pub const WCONTINUED : :: std :: os :: raw :: c_uint = 16 ; pub const WNOWAIT : :: std :: os :: raw :: c_uint = 32 ; pub const WAIT_ANY : :: std :: os :: raw :: c_int = -1 ; pub const WAIT_MYPGRP : :: std :: os :: raw :: c_uint = 0 ; pub const _QUAD_HIGHWORD : :: std :: os :: raw :: c_uint = 1 ; pub const _QUAD_LOWWORD : :: std :: os :: raw :: c_uint = 0 ; pub const __DARWIN_LITTLE_ENDIAN : :: std :: os :: raw :: c_uint = 1234 ; pub const __DARWIN_BIG_ENDIAN : :: std :: os :: raw :: c_uint = 4321 ; pub const __DARWIN_PDP_ENDIAN : :: std :: os :: raw :: c_uint = 3412 ; pub const __DARWIN_BYTE_ORDER : :: std :: os :: raw :: c_uint = 1234 ; pub const LITTLE_ENDIAN : :: std :: os :: raw :: c_uint = 1234 ; pub const BIG_ENDIAN : :: std :: os :: raw :: c_uint = 4321 ; pub const PDP_ENDIAN : :: std :: os :: raw :: c_uint = 3412 ; pub const BYTE_ORDER : :: std :: os :: raw :: c_uint = 1234 ; pub const EXIT_FAILURE : :: std :: os :: raw :: c_uint = 1 ; pub const EXIT_SUCCESS : :: std :: os :: raw :: c_uint = 0 ; pub const RAND_MAX : :: std :: os :: raw :: c_uint = 2147483647 ; pub type va_list = __builtin_va_list ; pub type __gnuc_va_list = __builtin_va_list ; extern "C" {
    # [ link_name = "\u{1}_xmlCheckVersion" ]
    pub fn xmlCheckVersion ( version : :: std :: os :: raw :: c_int , ) ;
} pub type __int8_t = :: std :: os :: raw :: c_schar ; pub type __uint8_t = :: std :: os :: raw :: c_uchar ; pub type __int16_t = :: std :: os :: raw :: c_short ; pub type __uint16_t = :: std :: os :: raw :: c_ushort ; pub type __int32_t = :: std :: os :: raw :: c_int ; pub type __uint32_t = :: std :: os :: raw :: c_uint ; pub type __int64_t = :: std :: os :: raw :: c_longlong ; pub type __uint64_t = :: std :: os :: raw :: c_ulonglong ; pub type __darwin_intptr_t = :: std :: os :: raw :: c_long ; pub type __darwin_natural_t = :: std :: os :: raw :: c_uint ; pub type __darwin_ct_rune_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __mbstate_t { pub __mbstate8 : [ :: std :: os :: raw :: c_char ; 128usize ] , pub _mbstateL : :: std :: os :: raw :: c_longlong , _bindgen_union_align : [ u64 ; 16usize ] , } # [ test ] fn bindgen_test_layout___mbstate_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __mbstate_t > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( __mbstate_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __mbstate_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __mbstate_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" , stringify ! ( __mbstate8 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" , stringify ! ( _mbstateL ) ) ) ; } pub type __darwin_mbstate_t = __mbstate_t ; pub type __darwin_ptrdiff_t = :: std :: os :: raw :: c_long ; pub type __darwin_size_t = :: std :: os :: raw :: c_ulong ; pub type __darwin_va_list = __builtin_va_list ; pub type __darwin_wchar_t = :: std :: os :: raw :: c_int ; pub type __darwin_rune_t = __darwin_wchar_t ; pub type __darwin_wint_t = :: std :: os :: raw :: c_int ; pub type __darwin_clock_t = :: std :: os :: raw :: c_ulong ; pub type __darwin_socklen_t = __uint32_t ; pub type __darwin_ssize_t = :: std :: os :: raw :: c_long ; pub type __darwin_time_t = :: std :: os :: raw :: c_long ; pub type __darwin_blkcnt_t = __int64_t ; pub type __darwin_blksize_t = __int32_t ; pub type __darwin_dev_t = __int32_t ; pub type __darwin_fsblkcnt_t = :: std :: os :: raw :: c_uint ; pub type __darwin_fsfilcnt_t = :: std :: os :: raw :: c_uint ; pub type __darwin_gid_t = __uint32_t ; pub type __darwin_id_t = __uint32_t ; pub type __darwin_ino64_t = __uint64_t ; pub type __darwin_ino_t = __uint32_t ; pub type __darwin_mach_port_name_t = __darwin_natural_t ; pub type __darwin_mach_port_t = __darwin_mach_port_name_t ; pub type __darwin_mode_t = __uint16_t ; pub type __darwin_off_t = __int64_t ; pub type __darwin_pid_t = __int32_t ; pub type __darwin_sigset_t = __uint32_t ; pub type __darwin_suseconds_t = __int32_t ; pub type __darwin_uid_t = __uint32_t ; pub type __darwin_useconds_t = __uint32_t ; pub type __darwin_uuid_t = [ :: std :: os :: raw :: c_uchar ; 16usize ] ; pub type __darwin_uuid_string_t = [ :: std :: os :: raw :: c_char ; 37usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __darwin_pthread_handler_rec { pub __routine : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) > , pub __arg : * mut :: std :: os :: raw :: c_void , pub __next : * mut __darwin_pthread_handler_rec , } # [ test ] fn bindgen_test_layout___darwin_pthread_handler_rec ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_pthread_handler_rec > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( __darwin_pthread_handler_rec ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_pthread_handler_rec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __darwin_pthread_handler_rec ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __routine as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_pthread_handler_rec ) , "::" , stringify ! ( __routine ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __arg as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_pthread_handler_rec ) , "::" , stringify ! ( __arg ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __next as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_pthread_handler_rec ) , "::" , stringify ! ( __next ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _opaque_pthread_attr_t { pub __sig : :: std :: os :: raw :: c_long , pub __opaque : [ :: std :: os :: raw :: c_char ; 56usize ] , } # [ test ] fn bindgen_test_layout__opaque_pthread_attr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _opaque_pthread_attr_t > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( _opaque_pthread_attr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _opaque_pthread_attr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _opaque_pthread_attr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __sig as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t ) , "::" , stringify ! ( __sig ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __opaque as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t ) , "::" , stringify ! ( __opaque ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _opaque_pthread_cond_t { pub __sig : :: std :: os :: raw :: c_long , pub __opaque : [ :: std :: os :: raw :: c_char ; 40usize ] , } # [ test ] fn bindgen_test_layout__opaque_pthread_cond_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _opaque_pthread_cond_t > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( _opaque_pthread_cond_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _opaque_pthread_cond_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _opaque_pthread_cond_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __sig as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t ) , "::" , stringify ! ( __sig ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __opaque as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t ) , "::" , stringify ! ( __opaque ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _opaque_pthread_condattr_t { pub __sig : :: std :: os :: raw :: c_long , pub __opaque : [ :: std :: os :: raw :: c_char ; 8usize ] , } # [ test ] fn bindgen_test_layout__opaque_pthread_condattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _opaque_pthread_condattr_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _opaque_pthread_condattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _opaque_pthread_condattr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _opaque_pthread_condattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __sig as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _opaque_pthread_condattr_t ) , "::" , stringify ! ( __sig ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __opaque as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _opaque_pthread_condattr_t ) , "::" , stringify ! ( __opaque ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _opaque_pthread_mutex_t { pub __sig : :: std :: os :: raw :: c_long , pub __opaque : [ :: std :: os :: raw :: c_char ; 56usize ] , } # [ test ] fn bindgen_test_layout__opaque_pthread_mutex_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _opaque_pthread_mutex_t > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( _opaque_pthread_mutex_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _opaque_pthread_mutex_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _opaque_pthread_mutex_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __sig as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t ) , "::" , stringify ! ( __sig ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __opaque as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t ) , "::" , stringify ! ( __opaque ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _opaque_pthread_mutexattr_t { pub __sig : :: std :: os :: raw :: c_long , pub __opaque : [ :: std :: os :: raw :: c_char ; 8usize ] , } # [ test ] fn bindgen_test_layout__opaque_pthread_mutexattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _opaque_pthread_mutexattr_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _opaque_pthread_mutexattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _opaque_pthread_mutexattr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _opaque_pthread_mutexattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) . __sig as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __sig ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) . __opaque as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __opaque ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _opaque_pthread_once_t { pub __sig : :: std :: os :: raw :: c_long , pub __opaque : [ :: std :: os :: raw :: c_char ; 8usize ] , } # [ test ] fn bindgen_test_layout__opaque_pthread_once_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _opaque_pthread_once_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _opaque_pthread_once_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _opaque_pthread_once_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _opaque_pthread_once_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __sig as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _opaque_pthread_once_t ) , "::" , stringify ! ( __sig ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __opaque as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _opaque_pthread_once_t ) , "::" , stringify ! ( __opaque ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _opaque_pthread_rwlock_t { pub __sig : :: std :: os :: raw :: c_long , pub __opaque : [ :: std :: os :: raw :: c_char ; 192usize ] , } # [ test ] fn bindgen_test_layout__opaque_pthread_rwlock_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _opaque_pthread_rwlock_t > ( ) , 200usize , concat ! ( "Size of: " , stringify ! ( _opaque_pthread_rwlock_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _opaque_pthread_rwlock_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _opaque_pthread_rwlock_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __sig as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __sig ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __opaque as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __opaque ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _opaque_pthread_rwlockattr_t { pub __sig : :: std :: os :: raw :: c_long , pub __opaque : [ :: std :: os :: raw :: c_char ; 16usize ] , } # [ test ] fn bindgen_test_layout__opaque_pthread_rwlockattr_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _opaque_pthread_rwlockattr_t > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( _opaque_pthread_rwlockattr_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _opaque_pthread_rwlockattr_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _opaque_pthread_rwlockattr_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) . __sig as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __sig ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) . __opaque as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __opaque ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _opaque_pthread_t { pub __sig : :: std :: os :: raw :: c_long , pub __cleanup_stack : * mut __darwin_pthread_handler_rec , pub __opaque : [ :: std :: os :: raw :: c_char ; 8176usize ] , } # [ test ] fn bindgen_test_layout__opaque_pthread_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _opaque_pthread_t > ( ) , 8192usize , concat ! ( "Size of: " , stringify ! ( _opaque_pthread_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _opaque_pthread_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _opaque_pthread_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _opaque_pthread_t ) ) . __sig as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _opaque_pthread_t ) , "::" , stringify ! ( __sig ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _opaque_pthread_t ) ) . __cleanup_stack as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _opaque_pthread_t ) , "::" , stringify ! ( __cleanup_stack ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _opaque_pthread_t ) ) . __opaque as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _opaque_pthread_t ) , "::" , stringify ! ( __opaque ) ) ) ; } pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t ; pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t ; pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t ; pub type __darwin_pthread_key_t = :: std :: os :: raw :: c_ulong ; pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t ; pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t ; pub type __darwin_pthread_once_t = _opaque_pthread_once_t ; pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t ; pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t ; pub type __darwin_pthread_t = * mut _opaque_pthread_t ; pub type __darwin_nl_item = :: std :: os :: raw :: c_int ; pub type __darwin_wctrans_t = :: std :: os :: raw :: c_int ; pub type __darwin_wctype_t = __uint32_t ; pub type u_int8_t = :: std :: os :: raw :: c_uchar ; pub type u_int16_t = :: std :: os :: raw :: c_ushort ; pub type u_int32_t = :: std :: os :: raw :: c_uint ; pub type u_int64_t = :: std :: os :: raw :: c_ulonglong ; pub type register_t = i64 ; pub type user_addr_t = u_int64_t ; pub type user_size_t = u_int64_t ; pub type user_ssize_t = i64 ; pub type user_long_t = i64 ; pub type user_ulong_t = u_int64_t ; pub type user_time_t = i64 ; pub type user_off_t = i64 ; pub type syscall_arg_t = u_int64_t ; extern "C" {
    # [ link_name = "\u{1}_renameat" ]
    pub fn renameat ( arg1 : :: std :: os :: raw :: c_int , arg2 : * const :: std :: os :: raw :: c_char , arg3 : :: std :: os :: raw :: c_int , arg4 : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_renamex_np" ]
    pub fn renamex_np ( arg1 : * const :: std :: os :: raw :: c_char , arg2 : * const :: std :: os :: raw :: c_char , arg3 : :: std :: os :: raw :: c_uint , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_renameatx_np" ]
    pub fn renameatx_np ( arg1 : :: std :: os :: raw :: c_int , arg2 : * const :: std :: os :: raw :: c_char , arg3 : :: std :: os :: raw :: c_int , arg4 : * const :: std :: os :: raw :: c_char , arg5 : :: std :: os :: raw :: c_uint , ) -> :: std :: os :: raw :: c_int ;
} pub type fpos_t = __darwin_off_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __sbuf { pub _base : * mut :: std :: os :: raw :: c_uchar , pub _size : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout___sbuf ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __sbuf > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( __sbuf ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __sbuf > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __sbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sbuf ) ) . _base as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __sbuf ) , "::" , stringify ! ( _base ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sbuf ) ) . _size as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __sbuf ) , "::" , stringify ! ( _size ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __sFILEX { _unused : [ u8 ; 0 ] } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __sFILE { pub _p : * mut :: std :: os :: raw :: c_uchar , pub _r : :: std :: os :: raw :: c_int , pub _w : :: std :: os :: raw :: c_int , pub _flags : :: std :: os :: raw :: c_short , pub _file : :: std :: os :: raw :: c_short , pub _bf : __sbuf , pub _lbfsize : :: std :: os :: raw :: c_int , pub _cookie : * mut :: std :: os :: raw :: c_void , pub _close : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > , pub _read : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void , arg2 : * mut :: std :: os :: raw :: c_char , arg3 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , pub _seek : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void , arg2 : fpos_t , arg3 : :: std :: os :: raw :: c_int ) -> fpos_t > , pub _write : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_char , arg3 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , pub _ub : __sbuf , pub _extra : * mut __sFILEX , pub _ur : :: std :: os :: raw :: c_int , pub _ubuf : [ :: std :: os :: raw :: c_uchar ; 3usize ] , pub _nbuf : [ :: std :: os :: raw :: c_uchar ; 1usize ] , pub _lb : __sbuf , pub _blksize : :: std :: os :: raw :: c_int , pub _offset : fpos_t , } # [ test ] fn bindgen_test_layout___sFILE ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __sFILE > ( ) , 152usize , concat ! ( "Size of: " , stringify ! ( __sFILE ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __sFILE > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __sFILE ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sFILE ) ) . _p as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _p ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sFILE ) ) . _r as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _r ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sFILE ) ) . _w as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _w ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sFILE ) ) . _flags as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sFILE ) ) . _file as * const _ as usize } , 18usize , concat ! ( "Alignment of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _file ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sFILE ) ) . _bf as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _bf ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sFILE ) ) . _lbfsize as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _lbfsize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sFILE ) ) . _cookie as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _cookie ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sFILE ) ) . _close as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _close ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sFILE ) ) . _read as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _read ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sFILE ) ) . _seek as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _seek ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sFILE ) ) . _write as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _write ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sFILE ) ) . _ub as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _ub ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sFILE ) ) . _extra as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _extra ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sFILE ) ) . _ur as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _ur ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sFILE ) ) . _ubuf as * const _ as usize } , 116usize , concat ! ( "Alignment of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _ubuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sFILE ) ) . _nbuf as * const _ as usize } , 119usize , concat ! ( "Alignment of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _nbuf ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sFILE ) ) . _lb as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _lb ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sFILE ) ) . _blksize as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _blksize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sFILE ) ) . _offset as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( __sFILE ) , "::" , stringify ! ( _offset ) ) ) ; } pub type FILE = __sFILE ; extern "C" {
    # [ link_name = "\u{1}___stdinp" ]
    pub static mut  __stdinp  :  * mut FILE ;
} extern "C" {
    # [ link_name = "\u{1}___stdoutp" ]
    pub static mut  __stdoutp  :  * mut FILE ;
} extern "C" {
    # [ link_name = "\u{1}___stderrp" ]
    pub static mut  __stderrp  :  * mut FILE ;
} extern "C" {
    # [ link_name = "\u{1}_clearerr" ]
    pub fn clearerr ( arg1 : * mut FILE , ) ;
} extern "C" {
    # [ link_name = "\u{1}_fclose" ]
    pub fn fclose ( arg1 : * mut FILE , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_feof" ]
    pub fn feof ( arg1 : * mut FILE , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_ferror" ]
    pub fn ferror ( arg1 : * mut FILE , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_fflush" ]
    pub fn fflush ( arg1 : * mut FILE , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_fgetc" ]
    pub fn fgetc ( arg1 : * mut FILE , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_fgetpos" ]
    pub fn fgetpos ( arg1 : * mut FILE , arg2 : * mut fpos_t , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_fgets" ]
    pub fn fgets ( arg1 : * mut :: std :: os :: raw :: c_char , arg2 : :: std :: os :: raw :: c_int , arg3 : * mut FILE , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_fopen" ]
    pub fn fopen ( __filename : * const :: std :: os :: raw :: c_char , __mode : * const :: std :: os :: raw :: c_char , ) -> * mut FILE ;
} extern "C" {
    # [ link_name = "\u{1}_fprintf" ]
    pub fn fprintf ( arg1 : * mut FILE , arg2 : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_fputc" ]
    pub fn fputc ( arg1 : :: std :: os :: raw :: c_int , arg2 : * mut FILE , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_fputs" ]
    pub fn fputs ( arg1 : * const :: std :: os :: raw :: c_char , arg2 : * mut FILE , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_fread" ]
    pub fn fread ( __ptr : * mut :: std :: os :: raw :: c_void , __size : usize , __nitems : usize , __stream : * mut FILE , ) -> usize ;
} extern "C" {
    # [ link_name = "\u{1}_freopen" ]
    pub fn freopen ( arg1 : * const :: std :: os :: raw :: c_char , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * mut FILE , ) -> * mut FILE ;
} extern "C" {
    # [ link_name = "\u{1}_fscanf" ]
    pub fn fscanf ( arg1 : * mut FILE , arg2 : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_fseek" ]
    pub fn fseek ( arg1 : * mut FILE , arg2 : :: std :: os :: raw :: c_long , arg3 : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_fsetpos" ]
    pub fn fsetpos ( arg1 : * mut FILE , arg2 : * const fpos_t , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_ftell" ]
    pub fn ftell ( arg1 : * mut FILE , ) -> :: std :: os :: raw :: c_long ;
} extern "C" {
    # [ link_name = "\u{1}_fwrite" ]
    pub fn fwrite ( __ptr : * const :: std :: os :: raw :: c_void , __size : usize , __nitems : usize , __stream : * mut FILE , ) -> usize ;
} extern "C" {
    # [ link_name = "\u{1}_getc" ]
    pub fn getc ( arg1 : * mut FILE , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_getchar" ]
    pub fn getchar ( ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_gets" ]
    pub fn gets ( arg1 : * mut :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_perror" ]
    pub fn perror ( arg1 : * const :: std :: os :: raw :: c_char , ) ;
} extern "C" {
    # [ link_name = "\u{1}_printf" ]
    pub fn printf ( arg1 : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_putc" ]
    pub fn putc ( arg1 : :: std :: os :: raw :: c_int , arg2 : * mut FILE , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_putchar" ]
    pub fn putchar ( arg1 : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_puts" ]
    pub fn puts ( arg1 : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_remove" ]
    pub fn remove ( arg1 : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_rename" ]
    pub fn rename ( __old : * const :: std :: os :: raw :: c_char , __new : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_rewind" ]
    pub fn rewind ( arg1 : * mut FILE , ) ;
} extern "C" {
    # [ link_name = "\u{1}_scanf" ]
    pub fn scanf ( arg1 : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_setbuf" ]
    pub fn setbuf ( arg1 : * mut FILE , arg2 : * mut :: std :: os :: raw :: c_char , ) ;
} extern "C" {
    # [ link_name = "\u{1}_setvbuf" ]
    pub fn setvbuf ( arg1 : * mut FILE , arg2 : * mut :: std :: os :: raw :: c_char , arg3 : :: std :: os :: raw :: c_int , arg4 : usize , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_sprintf" ]
    pub fn sprintf ( arg1 : * mut :: std :: os :: raw :: c_char , arg2 : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_sscanf" ]
    pub fn sscanf ( arg1 : * const :: std :: os :: raw :: c_char , arg2 : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_tmpfile" ]
    pub fn tmpfile ( ) -> * mut FILE ;
} extern "C" {
    # [ link_name = "\u{1}_tmpnam" ]
    pub fn tmpnam ( arg1 : * mut :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_ungetc" ]
    pub fn ungetc ( arg1 : :: std :: os :: raw :: c_int , arg2 : * mut FILE , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_vfprintf" ]
    pub fn vfprintf ( arg1 : * mut FILE , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * mut __va_list_tag , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_vprintf" ]
    pub fn vprintf ( arg1 : * const :: std :: os :: raw :: c_char , arg2 : * mut __va_list_tag , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_vsprintf" ]
    pub fn vsprintf ( arg1 : * mut :: std :: os :: raw :: c_char , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * mut __va_list_tag , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_ctermid" ]
    pub fn ctermid ( arg1 : * mut :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_fdopen" ]
    pub fn fdopen ( arg1 : :: std :: os :: raw :: c_int , arg2 : * const :: std :: os :: raw :: c_char , ) -> * mut FILE ;
} extern "C" {
    # [ link_name = "\u{1}_fileno" ]
    pub fn fileno ( arg1 : * mut FILE , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_pclose" ]
    pub fn pclose ( arg1 : * mut FILE , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_popen" ]
    pub fn popen ( arg1 : * const :: std :: os :: raw :: c_char , arg2 : * const :: std :: os :: raw :: c_char , ) -> * mut FILE ;
} extern "C" {
    # [ link_name = "\u{1}___srget" ]
    pub fn __srget ( arg1 : * mut FILE , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}___svfscanf" ]
    pub fn __svfscanf ( arg1 : * mut FILE , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * mut __va_list_tag , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}___swbuf" ]
    pub fn __swbuf ( arg1 : :: std :: os :: raw :: c_int , arg2 : * mut FILE , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_flockfile" ]
    pub fn flockfile ( arg1 : * mut FILE , ) ;
} extern "C" {
    # [ link_name = "\u{1}_ftrylockfile" ]
    pub fn ftrylockfile ( arg1 : * mut FILE , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_funlockfile" ]
    pub fn funlockfile ( arg1 : * mut FILE , ) ;
} extern "C" {
    # [ link_name = "\u{1}_getc_unlocked" ]
    pub fn getc_unlocked ( arg1 : * mut FILE , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_getchar_unlocked" ]
    pub fn getchar_unlocked ( ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_putc_unlocked" ]
    pub fn putc_unlocked ( arg1 : :: std :: os :: raw :: c_int , arg2 : * mut FILE , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_putchar_unlocked" ]
    pub fn putchar_unlocked ( arg1 : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_getw" ]
    pub fn getw ( arg1 : * mut FILE , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_putw" ]
    pub fn putw ( arg1 : :: std :: os :: raw :: c_int , arg2 : * mut FILE , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_tempnam" ]
    pub fn tempnam ( __dir : * const :: std :: os :: raw :: c_char , __prefix : * const :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ;
} pub type off_t = __darwin_off_t ; extern "C" {
    # [ link_name = "\u{1}_fseeko" ]
    pub fn fseeko ( __stream : * mut FILE , __offset : off_t , __whence : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_ftello" ]
    pub fn ftello ( __stream : * mut FILE , ) -> off_t ;
} extern "C" {
    # [ link_name = "\u{1}_snprintf" ]
    pub fn snprintf ( __str : * mut :: std :: os :: raw :: c_char , __size : usize , __format : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_vfscanf" ]
    pub fn vfscanf ( __stream : * mut FILE , __format : * const :: std :: os :: raw :: c_char , arg1 : * mut __va_list_tag , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_vscanf" ]
    pub fn vscanf ( __format : * const :: std :: os :: raw :: c_char , arg1 : * mut __va_list_tag , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_vsnprintf" ]
    pub fn vsnprintf ( __str : * mut :: std :: os :: raw :: c_char , __size : usize , __format : * const :: std :: os :: raw :: c_char , arg1 : * mut __va_list_tag , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_vsscanf" ]
    pub fn vsscanf ( __str : * const :: std :: os :: raw :: c_char , __format : * const :: std :: os :: raw :: c_char , arg1 : * mut __va_list_tag , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_dprintf" ]
    pub fn dprintf ( arg1 : :: std :: os :: raw :: c_int , arg2 : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_vdprintf" ]
    pub fn vdprintf ( arg1 : :: std :: os :: raw :: c_int , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * mut __va_list_tag , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_getdelim" ]
    pub fn getdelim ( __linep : * mut * mut :: std :: os :: raw :: c_char , __linecapp : * mut usize , __delimiter : :: std :: os :: raw :: c_int , __stream : * mut FILE , ) -> isize ;
} extern "C" {
    # [ link_name = "\u{1}_getline" ]
    pub fn getline ( __linep : * mut * mut :: std :: os :: raw :: c_char , __linecapp : * mut usize , __stream : * mut FILE , ) -> isize ;
} extern "C" {
    # [ link_name = "\u{1}_fmemopen" ]
    pub fn fmemopen ( __buf : * mut :: std :: os :: raw :: c_void , __size : usize , __mode : * const :: std :: os :: raw :: c_char , ) -> * mut FILE ;
} extern "C" {
    # [ link_name = "\u{1}_open_memstream" ]
    pub fn open_memstream ( __bufp : * mut * mut :: std :: os :: raw :: c_char , __sizep : * mut usize , ) -> * mut FILE ;
} extern "C" {
    # [ link_name = "\u{1}_sys_nerr" ]
    pub static mut  sys_nerr  :  :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_sys_errlist" ]
    pub static mut  sys_errlist  :  [ * const :: std :: os :: raw :: c_char ; 0usize ] ;
} extern "C" {
    # [ link_name = "\u{1}_asprintf" ]
    pub fn asprintf ( arg1 : * mut * mut :: std :: os :: raw :: c_char , arg2 : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_ctermid_r" ]
    pub fn ctermid_r ( arg1 : * mut :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_fgetln" ]
    pub fn fgetln ( arg1 : * mut FILE , arg2 : * mut usize , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_fmtcheck" ]
    pub fn fmtcheck ( arg1 : * const :: std :: os :: raw :: c_char , arg2 : * const :: std :: os :: raw :: c_char , ) -> * const :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_fpurge" ]
    pub fn fpurge ( arg1 : * mut FILE , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_setbuffer" ]
    pub fn setbuffer ( arg1 : * mut FILE , arg2 : * mut :: std :: os :: raw :: c_char , arg3 : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
    # [ link_name = "\u{1}_setlinebuf" ]
    pub fn setlinebuf ( arg1 : * mut FILE , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_vasprintf" ]
    pub fn vasprintf ( arg1 : * mut * mut :: std :: os :: raw :: c_char , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * mut __va_list_tag , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_zopen" ]
    pub fn zopen ( arg1 : * const :: std :: os :: raw :: c_char , arg2 : * const :: std :: os :: raw :: c_char , arg3 : :: std :: os :: raw :: c_int , ) -> * mut FILE ;
} extern "C" {
    # [ link_name = "\u{1}_funopen" ]
    pub fn funopen ( arg1 : * const :: std :: os :: raw :: c_void , arg2 : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void , arg2 : * mut :: std :: os :: raw :: c_char , arg3 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , arg3 : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_char , arg3 : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > , arg4 : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void , arg2 : fpos_t , arg3 : :: std :: os :: raw :: c_int ) -> fpos_t > , arg5 : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > , ) -> * mut FILE ;
}
/// xmlChar:
///
/// This is a basic byte in an UTF-8 encoded string.
/// It's unsigned allowing to pinpoint case where char * are assigned
/// to xmlChar * (possibly making serialization back impossible).
pub type xmlChar = :: std :: os :: raw :: c_uchar ; extern "C" {
    # [ link_name = "\u{1}_xmlStrdup" ]
    pub fn xmlStrdup ( cur : * const xmlChar , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlStrndup" ]
    pub fn xmlStrndup ( cur : * const xmlChar , len : :: std :: os :: raw :: c_int , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCharStrndup" ]
    pub fn xmlCharStrndup ( cur : * const :: std :: os :: raw :: c_char , len : :: std :: os :: raw :: c_int , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCharStrdup" ]
    pub fn xmlCharStrdup ( cur : * const :: std :: os :: raw :: c_char , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlStrsub" ]
    pub fn xmlStrsub ( str : * const xmlChar , start : :: std :: os :: raw :: c_int , len : :: std :: os :: raw :: c_int , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlStrchr" ]
    pub fn xmlStrchr ( str : * const xmlChar , val : xmlChar , ) -> * const xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlStrstr" ]
    pub fn xmlStrstr ( str : * const xmlChar , val : * const xmlChar , ) -> * const xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlStrcasestr" ]
    pub fn xmlStrcasestr ( str : * const xmlChar , val : * const xmlChar , ) -> * const xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlStrcmp" ]
    pub fn xmlStrcmp ( str1 : * const xmlChar , str2 : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlStrncmp" ]
    pub fn xmlStrncmp ( str1 : * const xmlChar , str2 : * const xmlChar , len : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlStrcasecmp" ]
    pub fn xmlStrcasecmp ( str1 : * const xmlChar , str2 : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlStrncasecmp" ]
    pub fn xmlStrncasecmp ( str1 : * const xmlChar , str2 : * const xmlChar , len : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlStrEqual" ]
    pub fn xmlStrEqual ( str1 : * const xmlChar , str2 : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlStrQEqual" ]
    pub fn xmlStrQEqual ( pref : * const xmlChar , name : * const xmlChar , str : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlStrlen" ]
    pub fn xmlStrlen ( str : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlStrcat" ]
    pub fn xmlStrcat ( cur : * mut xmlChar , add : * const xmlChar , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlStrncat" ]
    pub fn xmlStrncat ( cur : * mut xmlChar , add : * const xmlChar , len : :: std :: os :: raw :: c_int , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlStrncatNew" ]
    pub fn xmlStrncatNew ( str1 : * const xmlChar , str2 : * const xmlChar , len : :: std :: os :: raw :: c_int , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlStrPrintf" ]
    pub fn xmlStrPrintf ( buf : * mut xmlChar , len : :: std :: os :: raw :: c_int , msg : * const :: std :: os :: raw :: c_char , ... ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlStrVPrintf" ]
    pub fn xmlStrVPrintf ( buf : * mut xmlChar , len : :: std :: os :: raw :: c_int , msg : * const :: std :: os :: raw :: c_char , ap : * mut __va_list_tag , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetUTF8Char" ]
    pub fn xmlGetUTF8Char ( utf : * const :: std :: os :: raw :: c_uchar , len : * mut :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCheckUTF8" ]
    pub fn xmlCheckUTF8 ( utf : * const :: std :: os :: raw :: c_uchar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlUTF8Strsize" ]
    pub fn xmlUTF8Strsize ( utf : * const xmlChar , len : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlUTF8Strndup" ]
    pub fn xmlUTF8Strndup ( utf : * const xmlChar , len : :: std :: os :: raw :: c_int , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlUTF8Strpos" ]
    pub fn xmlUTF8Strpos ( utf : * const xmlChar , pos : :: std :: os :: raw :: c_int , ) -> * const xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlUTF8Strloc" ]
    pub fn xmlUTF8Strloc ( utf : * const xmlChar , utfchar : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlUTF8Strsub" ]
    pub fn xmlUTF8Strsub ( utf : * const xmlChar , start : :: std :: os :: raw :: c_int , len : :: std :: os :: raw :: c_int , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlUTF8Strlen" ]
    pub fn xmlUTF8Strlen ( utf : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlUTF8Size" ]
    pub fn xmlUTF8Size ( utf : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlUTF8Charcmp" ]
    pub fn xmlUTF8Charcmp ( utf1 : * const xmlChar , utf2 : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} pub type xmlParserInputBuffer = _xmlParserInputBuffer ; pub type xmlParserInputBufferPtr = * mut xmlParserInputBuffer ; pub type xmlOutputBuffer = _xmlOutputBuffer ; pub type xmlOutputBufferPtr = * mut xmlOutputBuffer ; pub type xmlParserInput = _xmlParserInput ; pub type xmlParserInputPtr = * mut xmlParserInput ; pub type xmlParserCtxt = _xmlParserCtxt ; pub type xmlParserCtxtPtr = * mut xmlParserCtxt ; pub type xmlSAXLocator = _xmlSAXLocator ; pub type xmlSAXLocatorPtr = * mut xmlSAXLocator ; pub type xmlSAXHandler = _xmlSAXHandler ; pub type xmlSAXHandlerPtr = * mut xmlSAXHandler ; pub type xmlEntity = _xmlEntity ; pub type xmlEntityPtr = * mut xmlEntity ; pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_DOUBLEIT : xmlBufferAllocationScheme = 0 ; pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_EXACT : xmlBufferAllocationScheme = 1 ; pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_IMMUTABLE : xmlBufferAllocationScheme = 2 ; pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_IO : xmlBufferAllocationScheme = 3 ; pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_HYBRID : xmlBufferAllocationScheme = 4 ; pub const xmlBufferAllocationScheme_XML_BUFFER_ALLOC_BOUNDED : xmlBufferAllocationScheme = 5 ; pub type xmlBufferAllocationScheme = :: std :: os :: raw :: c_uint ;
/// xmlBuffer:
///
/// A buffer structure, this old construct is limited to 2GB and
/// is being deprecated, use API with xmlBuf instead
pub type xmlBuffer = _xmlBuffer ; pub type xmlBufferPtr = * mut xmlBuffer ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlBuffer { pub content : * mut xmlChar , pub use_ : :: std :: os :: raw :: c_uint , pub size : :: std :: os :: raw :: c_uint , pub alloc : xmlBufferAllocationScheme , pub contentIO : * mut xmlChar , } # [ test ] fn bindgen_test_layout__xmlBuffer ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlBuffer > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( _xmlBuffer ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlBuffer > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlBuffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlBuffer ) ) . content as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlBuffer ) , "::" , stringify ! ( content ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlBuffer ) ) . use_ as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlBuffer ) , "::" , stringify ! ( use_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlBuffer ) ) . size as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlBuffer ) , "::" , stringify ! ( size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlBuffer ) ) . alloc as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlBuffer ) , "::" , stringify ! ( alloc ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlBuffer ) ) . contentIO as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlBuffer ) , "::" , stringify ! ( contentIO ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlBuf { _unused : [ u8 ; 0 ] }
/// xmlBuf:
///
/// A buffer structure, new one, the actual structure internals are not public
pub type xmlBuf = _xmlBuf ;
/// xmlBufPtr:
///
/// A pointer to a buffer structure, the actual structure internals are not
/// public
pub type xmlBufPtr = * mut xmlBuf ; extern "C" {
    # [ link_name = "\u{1}_xmlBufContent" ]
    pub fn xmlBufContent ( buf : * const xmlBuf , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufEnd" ]
    pub fn xmlBufEnd ( buf : xmlBufPtr , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufUse" ]
    pub fn xmlBufUse ( buf : xmlBufPtr , ) -> usize ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufShrink" ]
    pub fn xmlBufShrink ( buf : xmlBufPtr , len : usize , ) -> usize ;
} pub const xmlElementType_XML_ELEMENT_NODE : xmlElementType = 1 ; pub const xmlElementType_XML_ATTRIBUTE_NODE : xmlElementType = 2 ; pub const xmlElementType_XML_TEXT_NODE : xmlElementType = 3 ; pub const xmlElementType_XML_CDATA_SECTION_NODE : xmlElementType = 4 ; pub const xmlElementType_XML_ENTITY_REF_NODE : xmlElementType = 5 ; pub const xmlElementType_XML_ENTITY_NODE : xmlElementType = 6 ; pub const xmlElementType_XML_PI_NODE : xmlElementType = 7 ; pub const xmlElementType_XML_COMMENT_NODE : xmlElementType = 8 ; pub const xmlElementType_XML_DOCUMENT_NODE : xmlElementType = 9 ; pub const xmlElementType_XML_DOCUMENT_TYPE_NODE : xmlElementType = 10 ; pub const xmlElementType_XML_DOCUMENT_FRAG_NODE : xmlElementType = 11 ; pub const xmlElementType_XML_NOTATION_NODE : xmlElementType = 12 ; pub const xmlElementType_XML_HTML_DOCUMENT_NODE : xmlElementType = 13 ; pub const xmlElementType_XML_DTD_NODE : xmlElementType = 14 ; pub const xmlElementType_XML_ELEMENT_DECL : xmlElementType = 15 ; pub const xmlElementType_XML_ATTRIBUTE_DECL : xmlElementType = 16 ; pub const xmlElementType_XML_ENTITY_DECL : xmlElementType = 17 ; pub const xmlElementType_XML_NAMESPACE_DECL : xmlElementType = 18 ; pub const xmlElementType_XML_XINCLUDE_START : xmlElementType = 19 ; pub const xmlElementType_XML_XINCLUDE_END : xmlElementType = 20 ; pub const xmlElementType_XML_DOCB_DOCUMENT_NODE : xmlElementType = 21 ; pub type xmlElementType = :: std :: os :: raw :: c_uint ;
/// xmlNotation:
///
/// A DTD Notation definition.
pub type xmlNotation = _xmlNotation ; pub type xmlNotationPtr = * mut xmlNotation ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlNotation { pub name : * const xmlChar , pub PublicID : * const xmlChar , pub SystemID : * const xmlChar , } # [ test ] fn bindgen_test_layout__xmlNotation ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlNotation > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( _xmlNotation ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlNotation > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlNotation ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNotation ) ) . name as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNotation ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNotation ) ) . PublicID as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNotation ) , "::" , stringify ! ( PublicID ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNotation ) ) . SystemID as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNotation ) , "::" , stringify ! ( SystemID ) ) ) ; } pub const xmlAttributeType_XML_ATTRIBUTE_CDATA : xmlAttributeType = 1 ; pub const xmlAttributeType_XML_ATTRIBUTE_ID : xmlAttributeType = 2 ; pub const xmlAttributeType_XML_ATTRIBUTE_IDREF : xmlAttributeType = 3 ; pub const xmlAttributeType_XML_ATTRIBUTE_IDREFS : xmlAttributeType = 4 ; pub const xmlAttributeType_XML_ATTRIBUTE_ENTITY : xmlAttributeType = 5 ; pub const xmlAttributeType_XML_ATTRIBUTE_ENTITIES : xmlAttributeType = 6 ; pub const xmlAttributeType_XML_ATTRIBUTE_NMTOKEN : xmlAttributeType = 7 ; pub const xmlAttributeType_XML_ATTRIBUTE_NMTOKENS : xmlAttributeType = 8 ; pub const xmlAttributeType_XML_ATTRIBUTE_ENUMERATION : xmlAttributeType = 9 ; pub const xmlAttributeType_XML_ATTRIBUTE_NOTATION : xmlAttributeType = 10 ; pub type xmlAttributeType = :: std :: os :: raw :: c_uint ; pub const xmlAttributeDefault_XML_ATTRIBUTE_NONE : xmlAttributeDefault = 1 ; pub const xmlAttributeDefault_XML_ATTRIBUTE_REQUIRED : xmlAttributeDefault = 2 ; pub const xmlAttributeDefault_XML_ATTRIBUTE_IMPLIED : xmlAttributeDefault = 3 ; pub const xmlAttributeDefault_XML_ATTRIBUTE_FIXED : xmlAttributeDefault = 4 ; pub type xmlAttributeDefault = :: std :: os :: raw :: c_uint ;
/// xmlEnumeration:
///
/// List structure used when there is an enumeration in DTDs.
pub type xmlEnumeration = _xmlEnumeration ; pub type xmlEnumerationPtr = * mut xmlEnumeration ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlEnumeration { pub next : * mut _xmlEnumeration , pub name : * const xmlChar , } # [ test ] fn bindgen_test_layout__xmlEnumeration ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlEnumeration > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _xmlEnumeration ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlEnumeration > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlEnumeration ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlEnumeration ) ) . next as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlEnumeration ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlEnumeration ) ) . name as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlEnumeration ) , "::" , stringify ! ( name ) ) ) ; }
/// xmlAttribute:
///
/// An Attribute declaration in a DTD.
pub type xmlAttribute = _xmlAttribute ; pub type xmlAttributePtr = * mut xmlAttribute ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlAttribute { pub _private : * mut :: std :: os :: raw :: c_void , pub type_ : xmlElementType , pub name : * const xmlChar , pub children : * mut _xmlNode , pub last : * mut _xmlNode , pub parent : * mut _xmlDtd , pub next : * mut _xmlNode , pub prev : * mut _xmlNode , pub doc : * mut _xmlDoc , pub nexth : * mut _xmlAttribute , pub atype : xmlAttributeType , pub def : xmlAttributeDefault , pub defaultValue : * const xmlChar , pub tree : xmlEnumerationPtr , pub prefix : * const xmlChar , pub elem : * const xmlChar , } # [ test ] fn bindgen_test_layout__xmlAttribute ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlAttribute > ( ) , 120usize , concat ! ( "Size of: " , stringify ! ( _xmlAttribute ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlAttribute > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlAttribute ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttribute ) ) . _private as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttribute ) , "::" , stringify ! ( _private ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttribute ) ) . type_ as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttribute ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttribute ) ) . name as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttribute ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttribute ) ) . children as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttribute ) , "::" , stringify ! ( children ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttribute ) ) . last as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttribute ) , "::" , stringify ! ( last ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttribute ) ) . parent as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttribute ) , "::" , stringify ! ( parent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttribute ) ) . next as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttribute ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttribute ) ) . prev as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttribute ) , "::" , stringify ! ( prev ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttribute ) ) . doc as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttribute ) , "::" , stringify ! ( doc ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttribute ) ) . nexth as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttribute ) , "::" , stringify ! ( nexth ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttribute ) ) . atype as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttribute ) , "::" , stringify ! ( atype ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttribute ) ) . def as * const _ as usize } , 84usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttribute ) , "::" , stringify ! ( def ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttribute ) ) . defaultValue as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttribute ) , "::" , stringify ! ( defaultValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttribute ) ) . tree as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttribute ) , "::" , stringify ! ( tree ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttribute ) ) . prefix as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttribute ) , "::" , stringify ! ( prefix ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttribute ) ) . elem as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttribute ) , "::" , stringify ! ( elem ) ) ) ; } pub const xmlElementContentType_XML_ELEMENT_CONTENT_PCDATA : xmlElementContentType = 1 ; pub const xmlElementContentType_XML_ELEMENT_CONTENT_ELEMENT : xmlElementContentType = 2 ; pub const xmlElementContentType_XML_ELEMENT_CONTENT_SEQ : xmlElementContentType = 3 ; pub const xmlElementContentType_XML_ELEMENT_CONTENT_OR : xmlElementContentType = 4 ; pub type xmlElementContentType = :: std :: os :: raw :: c_uint ; pub const xmlElementContentOccur_XML_ELEMENT_CONTENT_ONCE : xmlElementContentOccur = 1 ; pub const xmlElementContentOccur_XML_ELEMENT_CONTENT_OPT : xmlElementContentOccur = 2 ; pub const xmlElementContentOccur_XML_ELEMENT_CONTENT_MULT : xmlElementContentOccur = 3 ; pub const xmlElementContentOccur_XML_ELEMENT_CONTENT_PLUS : xmlElementContentOccur = 4 ; pub type xmlElementContentOccur = :: std :: os :: raw :: c_uint ;
/// xmlElementContent:
///
/// An XML Element content as stored after parsing an element definition
/// in a DTD.
pub type xmlElementContent = _xmlElementContent ; pub type xmlElementContentPtr = * mut xmlElementContent ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlElementContent { pub type_ : xmlElementContentType , pub ocur : xmlElementContentOccur , pub name : * const xmlChar , pub c1 : * mut _xmlElementContent , pub c2 : * mut _xmlElementContent , pub parent : * mut _xmlElementContent , pub prefix : * const xmlChar , } # [ test ] fn bindgen_test_layout__xmlElementContent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlElementContent > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( _xmlElementContent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlElementContent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlElementContent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlElementContent ) ) . type_ as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlElementContent ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlElementContent ) ) . ocur as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlElementContent ) , "::" , stringify ! ( ocur ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlElementContent ) ) . name as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlElementContent ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlElementContent ) ) . c1 as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlElementContent ) , "::" , stringify ! ( c1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlElementContent ) ) . c2 as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlElementContent ) , "::" , stringify ! ( c2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlElementContent ) ) . parent as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlElementContent ) , "::" , stringify ! ( parent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlElementContent ) ) . prefix as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlElementContent ) , "::" , stringify ! ( prefix ) ) ) ; } pub const xmlElementTypeVal_XML_ELEMENT_TYPE_UNDEFINED : xmlElementTypeVal = 0 ; pub const xmlElementTypeVal_XML_ELEMENT_TYPE_EMPTY : xmlElementTypeVal = 1 ; pub const xmlElementTypeVal_XML_ELEMENT_TYPE_ANY : xmlElementTypeVal = 2 ; pub const xmlElementTypeVal_XML_ELEMENT_TYPE_MIXED : xmlElementTypeVal = 3 ; pub const xmlElementTypeVal_XML_ELEMENT_TYPE_ELEMENT : xmlElementTypeVal = 4 ; pub type xmlElementTypeVal = :: std :: os :: raw :: c_uint ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlRegexp { _unused : [ u8 ; 0 ] }
/// xmlRegexpPtr:
///
/// A libxml regular expression, they can actually be far more complex
/// thank the POSIX regex expressions.
pub type xmlRegexp = _xmlRegexp ; pub type xmlRegexpPtr = * mut xmlRegexp ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlRegExecCtxt { _unused : [ u8 ; 0 ] }
/// xmlRegExecCtxtPtr:
///
/// A libxml progressive regular expression evaluation context
pub type xmlRegExecCtxt = _xmlRegExecCtxt ; pub type xmlRegExecCtxtPtr = * mut xmlRegExecCtxt ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlDict { _unused : [ u8 ; 0 ] } pub type xmlDict = _xmlDict ; pub type xmlDictPtr = * mut xmlDict ; extern "C" {
    # [ link_name = "\u{1}_xmlInitializeDict" ]
    pub fn xmlInitializeDict ( ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDictCreate" ]
    pub fn xmlDictCreate ( ) -> xmlDictPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDictSetLimit" ]
    pub fn xmlDictSetLimit ( dict : xmlDictPtr , limit : usize , ) -> usize ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDictGetUsage" ]
    pub fn xmlDictGetUsage ( dict : xmlDictPtr , ) -> usize ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDictCreateSub" ]
    pub fn xmlDictCreateSub ( sub : xmlDictPtr , ) -> xmlDictPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDictReference" ]
    pub fn xmlDictReference ( dict : xmlDictPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDictFree" ]
    pub fn xmlDictFree ( dict : xmlDictPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDictLookup" ]
    pub fn xmlDictLookup ( dict : xmlDictPtr , name : * const xmlChar , len : :: std :: os :: raw :: c_int , ) -> * const xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDictExists" ]
    pub fn xmlDictExists ( dict : xmlDictPtr , name : * const xmlChar , len : :: std :: os :: raw :: c_int , ) -> * const xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDictQLookup" ]
    pub fn xmlDictQLookup ( dict : xmlDictPtr , prefix : * const xmlChar , name : * const xmlChar , ) -> * const xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDictOwns" ]
    pub fn xmlDictOwns ( dict : xmlDictPtr , str : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDictSize" ]
    pub fn xmlDictSize ( dict : xmlDictPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDictCleanup" ]
    pub fn xmlDictCleanup ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRegexpCompile" ]
    pub fn xmlRegexpCompile ( regexp : * const xmlChar , ) -> xmlRegexpPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRegFreeRegexp" ]
    pub fn xmlRegFreeRegexp ( regexp : xmlRegexpPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRegexpExec" ]
    pub fn xmlRegexpExec ( comp : xmlRegexpPtr , value : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRegexpPrint" ]
    pub fn xmlRegexpPrint ( output : * mut FILE , regexp : xmlRegexpPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRegexpIsDeterminist" ]
    pub fn xmlRegexpIsDeterminist ( comp : xmlRegexpPtr , ) -> :: std :: os :: raw :: c_int ;
}
/// xmlRegExecCallbacks:
/// @exec: the regular expression context
/// @token: the current token string
/// @transdata: transition data
/// @inputdata: input data
///
/// Callback function when doing a transition in the automata
pub type xmlRegExecCallbacks = :: std :: option :: Option < unsafe extern "C" fn ( exec : xmlRegExecCtxtPtr , token : * const xmlChar , transdata : * mut :: std :: os :: raw :: c_void , inputdata : * mut :: std :: os :: raw :: c_void ) > ; extern "C" {
    # [ link_name = "\u{1}_xmlRegNewExecCtxt" ]
    pub fn xmlRegNewExecCtxt ( comp : xmlRegexpPtr , callback : xmlRegExecCallbacks , data : * mut :: std :: os :: raw :: c_void , ) -> xmlRegExecCtxtPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRegFreeExecCtxt" ]
    pub fn xmlRegFreeExecCtxt ( exec : xmlRegExecCtxtPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRegExecPushString" ]
    pub fn xmlRegExecPushString ( exec : xmlRegExecCtxtPtr , value : * const xmlChar , data : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRegExecPushString2" ]
    pub fn xmlRegExecPushString2 ( exec : xmlRegExecCtxtPtr , value : * const xmlChar , value2 : * const xmlChar , data : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRegExecNextValues" ]
    pub fn xmlRegExecNextValues ( exec : xmlRegExecCtxtPtr , nbval : * mut :: std :: os :: raw :: c_int , nbneg : * mut :: std :: os :: raw :: c_int , values : * mut * mut xmlChar , terminal : * mut :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRegExecErrInfo" ]
    pub fn xmlRegExecErrInfo ( exec : xmlRegExecCtxtPtr , string : * mut * const xmlChar , nbval : * mut :: std :: os :: raw :: c_int , nbneg : * mut :: std :: os :: raw :: c_int , values : * mut * mut xmlChar , terminal : * mut :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlExpCtxt { _unused : [ u8 ; 0 ] } pub type xmlExpCtxt = _xmlExpCtxt ; pub type xmlExpCtxtPtr = * mut xmlExpCtxt ; extern "C" {
    # [ link_name = "\u{1}_xmlExpFreeCtxt" ]
    pub fn xmlExpFreeCtxt ( ctxt : xmlExpCtxtPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlExpNewCtxt" ]
    pub fn xmlExpNewCtxt ( maxNodes : :: std :: os :: raw :: c_int , dict : xmlDictPtr , ) -> xmlExpCtxtPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlExpCtxtNbNodes" ]
    pub fn xmlExpCtxtNbNodes ( ctxt : xmlExpCtxtPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlExpCtxtNbCons" ]
    pub fn xmlExpCtxtNbCons ( ctxt : xmlExpCtxtPtr , ) -> :: std :: os :: raw :: c_int ;
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlExpNode { _unused : [ u8 ; 0 ] } pub type xmlExpNode = _xmlExpNode ; pub type xmlExpNodePtr = * mut xmlExpNode ; pub const xmlExpNodeType_XML_EXP_EMPTY : xmlExpNodeType = 0 ; pub const xmlExpNodeType_XML_EXP_FORBID : xmlExpNodeType = 1 ; pub const xmlExpNodeType_XML_EXP_ATOM : xmlExpNodeType = 2 ; pub const xmlExpNodeType_XML_EXP_SEQ : xmlExpNodeType = 3 ; pub const xmlExpNodeType_XML_EXP_OR : xmlExpNodeType = 4 ; pub const xmlExpNodeType_XML_EXP_COUNT : xmlExpNodeType = 5 ; pub type xmlExpNodeType = :: std :: os :: raw :: c_uint ; extern "C" {
    # [ link_name = "\u{1}_forbiddenExp" ]
    pub static mut  forbiddenExp  :  xmlExpNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_emptyExp" ]
    pub static mut  emptyExp  :  xmlExpNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlExpFree" ]
    pub fn xmlExpFree ( ctxt : xmlExpCtxtPtr , expr : xmlExpNodePtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlExpRef" ]
    pub fn xmlExpRef ( expr : xmlExpNodePtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlExpParse" ]
    pub fn xmlExpParse ( ctxt : xmlExpCtxtPtr , expr : * const :: std :: os :: raw :: c_char , ) -> xmlExpNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlExpNewAtom" ]
    pub fn xmlExpNewAtom ( ctxt : xmlExpCtxtPtr , name : * const xmlChar , len : :: std :: os :: raw :: c_int , ) -> xmlExpNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlExpNewOr" ]
    pub fn xmlExpNewOr ( ctxt : xmlExpCtxtPtr , left : xmlExpNodePtr , right : xmlExpNodePtr , ) -> xmlExpNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlExpNewSeq" ]
    pub fn xmlExpNewSeq ( ctxt : xmlExpCtxtPtr , left : xmlExpNodePtr , right : xmlExpNodePtr , ) -> xmlExpNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlExpNewRange" ]
    pub fn xmlExpNewRange ( ctxt : xmlExpCtxtPtr , subset : xmlExpNodePtr , min : :: std :: os :: raw :: c_int , max : :: std :: os :: raw :: c_int , ) -> xmlExpNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlExpIsNillable" ]
    pub fn xmlExpIsNillable ( expr : xmlExpNodePtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlExpMaxToken" ]
    pub fn xmlExpMaxToken ( expr : xmlExpNodePtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlExpGetLanguage" ]
    pub fn xmlExpGetLanguage ( ctxt : xmlExpCtxtPtr , expr : xmlExpNodePtr , langList : * mut * const xmlChar , len : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlExpGetStart" ]
    pub fn xmlExpGetStart ( ctxt : xmlExpCtxtPtr , expr : xmlExpNodePtr , tokList : * mut * const xmlChar , len : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlExpStringDerive" ]
    pub fn xmlExpStringDerive ( ctxt : xmlExpCtxtPtr , expr : xmlExpNodePtr , str : * const xmlChar , len : :: std :: os :: raw :: c_int , ) -> xmlExpNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlExpExpDerive" ]
    pub fn xmlExpExpDerive ( ctxt : xmlExpCtxtPtr , expr : xmlExpNodePtr , sub : xmlExpNodePtr , ) -> xmlExpNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlExpSubsume" ]
    pub fn xmlExpSubsume ( ctxt : xmlExpCtxtPtr , expr : xmlExpNodePtr , sub : xmlExpNodePtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlExpDump" ]
    pub fn xmlExpDump ( buf : xmlBufferPtr , expr : xmlExpNodePtr , ) ;
}
/// xmlElement:
///
/// An XML Element declaration from a DTD.
pub type xmlElement = _xmlElement ; pub type xmlElementPtr = * mut xmlElement ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlElement { pub _private : * mut :: std :: os :: raw :: c_void , pub type_ : xmlElementType , pub name : * const xmlChar , pub children : * mut _xmlNode , pub last : * mut _xmlNode , pub parent : * mut _xmlDtd , pub next : * mut _xmlNode , pub prev : * mut _xmlNode , pub doc : * mut _xmlDoc , pub etype : xmlElementTypeVal , pub content : xmlElementContentPtr , pub attributes : xmlAttributePtr , pub prefix : * const xmlChar , pub contModel : xmlRegexpPtr , } # [ test ] fn bindgen_test_layout__xmlElement ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlElement > ( ) , 112usize , concat ! ( "Size of: " , stringify ! ( _xmlElement ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlElement > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlElement ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlElement ) ) . _private as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlElement ) , "::" , stringify ! ( _private ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlElement ) ) . type_ as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlElement ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlElement ) ) . name as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlElement ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlElement ) ) . children as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlElement ) , "::" , stringify ! ( children ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlElement ) ) . last as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlElement ) , "::" , stringify ! ( last ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlElement ) ) . parent as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlElement ) , "::" , stringify ! ( parent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlElement ) ) . next as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlElement ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlElement ) ) . prev as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlElement ) , "::" , stringify ! ( prev ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlElement ) ) . doc as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlElement ) , "::" , stringify ! ( doc ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlElement ) ) . etype as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlElement ) , "::" , stringify ! ( etype ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlElement ) ) . content as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlElement ) , "::" , stringify ! ( content ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlElement ) ) . attributes as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlElement ) , "::" , stringify ! ( attributes ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlElement ) ) . prefix as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlElement ) , "::" , stringify ! ( prefix ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlElement ) ) . contModel as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlElement ) , "::" , stringify ! ( contModel ) ) ) ; } pub use self :: xmlElementType as xmlNsType ;
/// xmlNs:
///
/// An XML namespace.
/// Note that prefix == NULL is valid, it defines the default namespace
/// within the subtree (until overridden).
///
/// xmlNsType is unified with xmlElementType.
pub type xmlNs = _xmlNs ; pub type xmlNsPtr = * mut xmlNs ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlNs { pub next : * mut _xmlNs , pub type_ : xmlNsType , pub href : * const xmlChar , pub prefix : * const xmlChar , pub _private : * mut :: std :: os :: raw :: c_void , pub context : * mut _xmlDoc , } # [ test ] fn bindgen_test_layout__xmlNs ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlNs > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( _xmlNs ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlNs > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlNs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNs ) ) . next as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNs ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNs ) ) . type_ as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNs ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNs ) ) . href as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNs ) , "::" , stringify ! ( href ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNs ) ) . prefix as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNs ) , "::" , stringify ! ( prefix ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNs ) ) . _private as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNs ) , "::" , stringify ! ( _private ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNs ) ) . context as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNs ) , "::" , stringify ! ( context ) ) ) ; }
/// xmlDtd:
///
/// An XML DTD, as defined by <!DOCTYPE ... There is actually one for
/// the internal subset and for the external subset.
pub type xmlDtd = _xmlDtd ; pub type xmlDtdPtr = * mut xmlDtd ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlDtd { pub _private : * mut :: std :: os :: raw :: c_void , pub type_ : xmlElementType , pub name : * const xmlChar , pub children : * mut _xmlNode , pub last : * mut _xmlNode , pub parent : * mut _xmlDoc , pub next : * mut _xmlNode , pub prev : * mut _xmlNode , pub doc : * mut _xmlDoc , pub notations : * mut :: std :: os :: raw :: c_void , pub elements : * mut :: std :: os :: raw :: c_void , pub attributes : * mut :: std :: os :: raw :: c_void , pub entities : * mut :: std :: os :: raw :: c_void , pub ExternalID : * const xmlChar , pub SystemID : * const xmlChar , pub pentities : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout__xmlDtd ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlDtd > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( _xmlDtd ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlDtd > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlDtd ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDtd ) ) . _private as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( _private ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDtd ) ) . type_ as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDtd ) ) . name as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDtd ) ) . children as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( children ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDtd ) ) . last as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( last ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDtd ) ) . parent as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( parent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDtd ) ) . next as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDtd ) ) . prev as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( prev ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDtd ) ) . doc as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( doc ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDtd ) ) . notations as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( notations ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDtd ) ) . elements as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( elements ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDtd ) ) . attributes as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( attributes ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDtd ) ) . entities as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( entities ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDtd ) ) . ExternalID as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( ExternalID ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDtd ) ) . SystemID as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( SystemID ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDtd ) ) . pentities as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDtd ) , "::" , stringify ! ( pentities ) ) ) ; }
/// xmlAttr:
///
/// An attribute on an XML node.
pub type xmlAttr = _xmlAttr ; pub type xmlAttrPtr = * mut xmlAttr ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlAttr { pub _private : * mut :: std :: os :: raw :: c_void , pub type_ : xmlElementType , pub name : * const xmlChar , pub children : * mut _xmlNode , pub last : * mut _xmlNode , pub parent : * mut _xmlNode , pub next : * mut _xmlAttr , pub prev : * mut _xmlAttr , pub doc : * mut _xmlDoc , pub ns : * mut xmlNs , pub atype : xmlAttributeType , pub psvi : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout__xmlAttr ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlAttr > ( ) , 96usize , concat ! ( "Size of: " , stringify ! ( _xmlAttr ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlAttr > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlAttr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttr ) ) . _private as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( _private ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttr ) ) . type_ as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttr ) ) . name as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttr ) ) . children as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( children ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttr ) ) . last as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( last ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttr ) ) . parent as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( parent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttr ) ) . next as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttr ) ) . prev as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( prev ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttr ) ) . doc as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( doc ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttr ) ) . ns as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( ns ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttr ) ) . atype as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( atype ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlAttr ) ) . psvi as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlAttr ) , "::" , stringify ! ( psvi ) ) ) ; }
/// xmlID:
///
/// An XML ID instance.
pub type xmlID = _xmlID ; pub type xmlIDPtr = * mut xmlID ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlID { pub next : * mut _xmlID , pub value : * const xmlChar , pub attr : xmlAttrPtr , pub name : * const xmlChar , pub lineno : :: std :: os :: raw :: c_int , pub doc : * mut _xmlDoc , } # [ test ] fn bindgen_test_layout__xmlID ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlID > ( ) , 48usize , concat ! ( "Size of: " , stringify ! ( _xmlID ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlID > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlID ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlID ) ) . next as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlID ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlID ) ) . value as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlID ) , "::" , stringify ! ( value ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlID ) ) . attr as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlID ) , "::" , stringify ! ( attr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlID ) ) . name as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlID ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlID ) ) . lineno as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlID ) , "::" , stringify ! ( lineno ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlID ) ) . doc as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlID ) , "::" , stringify ! ( doc ) ) ) ; }
/// xmlRef:
///
/// An XML IDREF instance.
pub type xmlRef = _xmlRef ; pub type xmlRefPtr = * mut xmlRef ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlRef { pub next : * mut _xmlRef , pub value : * const xmlChar , pub attr : xmlAttrPtr , pub name : * const xmlChar , pub lineno : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout__xmlRef ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlRef > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( _xmlRef ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlRef > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlRef ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlRef ) ) . next as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlRef ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlRef ) ) . value as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlRef ) , "::" , stringify ! ( value ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlRef ) ) . attr as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlRef ) , "::" , stringify ! ( attr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlRef ) ) . name as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlRef ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlRef ) ) . lineno as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlRef ) , "::" , stringify ! ( lineno ) ) ) ; }
/// xmlNode:
///
/// A node in an XML tree.
pub type xmlNode = _xmlNode ; pub type xmlNodePtr = * mut xmlNode ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlNode { pub _private : * mut :: std :: os :: raw :: c_void , pub type_ : xmlElementType , pub name : * const xmlChar , pub children : * mut _xmlNode , pub last : * mut _xmlNode , pub parent : * mut _xmlNode , pub next : * mut _xmlNode , pub prev : * mut _xmlNode , pub doc : * mut _xmlDoc , pub ns : * mut xmlNs , pub content : * mut xmlChar , pub properties : * mut _xmlAttr , pub nsDef : * mut xmlNs , pub psvi : * mut :: std :: os :: raw :: c_void , pub line : :: std :: os :: raw :: c_ushort , pub extra : :: std :: os :: raw :: c_ushort , } # [ test ] fn bindgen_test_layout__xmlNode ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlNode > ( ) , 120usize , concat ! ( "Size of: " , stringify ! ( _xmlNode ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlNode > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlNode ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNode ) ) . _private as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( _private ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNode ) ) . type_ as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNode ) ) . name as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNode ) ) . children as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( children ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNode ) ) . last as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( last ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNode ) ) . parent as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( parent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNode ) ) . next as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNode ) ) . prev as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( prev ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNode ) ) . doc as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( doc ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNode ) ) . ns as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( ns ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNode ) ) . content as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( content ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNode ) ) . properties as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( properties ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNode ) ) . nsDef as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( nsDef ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNode ) ) . psvi as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( psvi ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNode ) ) . line as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( line ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlNode ) ) . extra as * const _ as usize } , 114usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlNode ) , "::" , stringify ! ( extra ) ) ) ; } pub const xmlDocProperties_XML_DOC_WELLFORMED : xmlDocProperties = 1 ; pub const xmlDocProperties_XML_DOC_NSVALID : xmlDocProperties = 2 ; pub const xmlDocProperties_XML_DOC_OLD10 : xmlDocProperties = 4 ; pub const xmlDocProperties_XML_DOC_DTDVALID : xmlDocProperties = 8 ; pub const xmlDocProperties_XML_DOC_XINCLUDE : xmlDocProperties = 16 ; pub const xmlDocProperties_XML_DOC_USERBUILT : xmlDocProperties = 32 ; pub const xmlDocProperties_XML_DOC_INTERNAL : xmlDocProperties = 64 ; pub const xmlDocProperties_XML_DOC_HTML : xmlDocProperties = 128 ; pub type xmlDocProperties = :: std :: os :: raw :: c_uint ;
/// xmlDoc:
///
/// An XML document.
pub type xmlDoc = _xmlDoc ; pub type xmlDocPtr = * mut xmlDoc ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlDoc { pub _private : * mut :: std :: os :: raw :: c_void , pub type_ : xmlElementType , pub name : * mut :: std :: os :: raw :: c_char , pub children : * mut _xmlNode , pub last : * mut _xmlNode , pub parent : * mut _xmlNode , pub next : * mut _xmlNode , pub prev : * mut _xmlNode , pub doc : * mut _xmlDoc , pub compression : :: std :: os :: raw :: c_int , pub standalone : :: std :: os :: raw :: c_int , pub intSubset : * mut _xmlDtd , pub extSubset : * mut _xmlDtd , pub oldNs : * mut _xmlNs , pub version : * const xmlChar , pub encoding : * const xmlChar , pub ids : * mut :: std :: os :: raw :: c_void , pub refs : * mut :: std :: os :: raw :: c_void , pub URL : * const xmlChar , pub charset : :: std :: os :: raw :: c_int , pub dict : * mut _xmlDict , pub psvi : * mut :: std :: os :: raw :: c_void , pub parseFlags : :: std :: os :: raw :: c_int , pub properties : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout__xmlDoc ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlDoc > ( ) , 176usize , concat ! ( "Size of: " , stringify ! ( _xmlDoc ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlDoc > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlDoc ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . _private as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( _private ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . type_ as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . name as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . children as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( children ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . last as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( last ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . parent as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( parent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . next as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . prev as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( prev ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . doc as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( doc ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . compression as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( compression ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . standalone as * const _ as usize } , 76usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( standalone ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . intSubset as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( intSubset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . extSubset as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( extSubset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . oldNs as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( oldNs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . version as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( version ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . encoding as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( encoding ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . ids as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( ids ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . refs as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( refs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . URL as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( URL ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . charset as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( charset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . dict as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( dict ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . psvi as * const _ as usize } , 160usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( psvi ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . parseFlags as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( parseFlags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDoc ) ) . properties as * const _ as usize } , 172usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDoc ) , "::" , stringify ! ( properties ) ) ) ; } pub type xmlDOMWrapCtxt = _xmlDOMWrapCtxt ; pub type xmlDOMWrapCtxtPtr = * mut xmlDOMWrapCtxt ;
/// xmlDOMWrapAcquireNsFunction:
/// @ctxt:  a DOM wrapper context
/// @node:  the context node (element or attribute)
/// @nsName:  the requested namespace name
/// @nsPrefix:  the requested namespace prefix
///
/// A function called to acquire namespaces (xmlNs) from the wrapper.
///
/// Returns an xmlNsPtr or NULL in case of an error.
pub type xmlDOMWrapAcquireNsFunction = :: std :: option :: Option < unsafe extern "C" fn ( ctxt : xmlDOMWrapCtxtPtr , node : xmlNodePtr , nsName : * const xmlChar , nsPrefix : * const xmlChar ) -> xmlNsPtr > ;
/// xmlDOMWrapCtxt:
///
/// Context for DOM wrapper-operations.
# [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlDOMWrapCtxt { pub _private : * mut :: std :: os :: raw :: c_void , pub type_ : :: std :: os :: raw :: c_int , pub namespaceMap : * mut :: std :: os :: raw :: c_void , pub getNsForNodeFunc : xmlDOMWrapAcquireNsFunction , } # [ test ] fn bindgen_test_layout__xmlDOMWrapCtxt ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlDOMWrapCtxt > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( _xmlDOMWrapCtxt ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlDOMWrapCtxt > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlDOMWrapCtxt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDOMWrapCtxt ) ) . _private as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDOMWrapCtxt ) , "::" , stringify ! ( _private ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDOMWrapCtxt ) ) . type_ as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDOMWrapCtxt ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDOMWrapCtxt ) ) . namespaceMap as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDOMWrapCtxt ) , "::" , stringify ! ( namespaceMap ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlDOMWrapCtxt ) ) . getNsForNodeFunc as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlDOMWrapCtxt ) , "::" , stringify ! ( getNsForNodeFunc ) ) ) ; } extern "C" {
    # [ link_name = "\u{1}_xmlValidateNCName" ]
    pub fn xmlValidateNCName ( value : * const xmlChar , space : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidateQName" ]
    pub fn xmlValidateQName ( value : * const xmlChar , space : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidateName" ]
    pub fn xmlValidateName ( value : * const xmlChar , space : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidateNMToken" ]
    pub fn xmlValidateNMToken ( value : * const xmlChar , space : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBuildQName" ]
    pub fn xmlBuildQName ( ncname : * const xmlChar , prefix : * const xmlChar , memory : * mut xmlChar , len : :: std :: os :: raw :: c_int , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSplitQName2" ]
    pub fn xmlSplitQName2 ( name : * const xmlChar , prefix : * mut * mut xmlChar , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSplitQName3" ]
    pub fn xmlSplitQName3 ( name : * const xmlChar , len : * mut :: std :: os :: raw :: c_int , ) -> * const xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSetBufferAllocationScheme" ]
    pub fn xmlSetBufferAllocationScheme ( scheme : xmlBufferAllocationScheme , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetBufferAllocationScheme" ]
    pub fn xmlGetBufferAllocationScheme ( ) -> xmlBufferAllocationScheme ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufferCreate" ]
    pub fn xmlBufferCreate ( ) -> xmlBufferPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufferCreateSize" ]
    pub fn xmlBufferCreateSize ( size : usize , ) -> xmlBufferPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufferCreateStatic" ]
    pub fn xmlBufferCreateStatic ( mem : * mut :: std :: os :: raw :: c_void , size : usize , ) -> xmlBufferPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufferResize" ]
    pub fn xmlBufferResize ( buf : xmlBufferPtr , size : :: std :: os :: raw :: c_uint , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufferFree" ]
    pub fn xmlBufferFree ( buf : xmlBufferPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufferDump" ]
    pub fn xmlBufferDump ( file : * mut FILE , buf : xmlBufferPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufferAdd" ]
    pub fn xmlBufferAdd ( buf : xmlBufferPtr , str : * const xmlChar , len : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufferAddHead" ]
    pub fn xmlBufferAddHead ( buf : xmlBufferPtr , str : * const xmlChar , len : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufferCat" ]
    pub fn xmlBufferCat ( buf : xmlBufferPtr , str : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufferCCat" ]
    pub fn xmlBufferCCat ( buf : xmlBufferPtr , str : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufferShrink" ]
    pub fn xmlBufferShrink ( buf : xmlBufferPtr , len : :: std :: os :: raw :: c_uint , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufferGrow" ]
    pub fn xmlBufferGrow ( buf : xmlBufferPtr , len : :: std :: os :: raw :: c_uint , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufferEmpty" ]
    pub fn xmlBufferEmpty ( buf : xmlBufferPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufferContent" ]
    pub fn xmlBufferContent ( buf : * const xmlBuffer , ) -> * const xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufferDetach" ]
    pub fn xmlBufferDetach ( buf : xmlBufferPtr , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufferSetAllocationScheme" ]
    pub fn xmlBufferSetAllocationScheme ( buf : xmlBufferPtr , scheme : xmlBufferAllocationScheme , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufferLength" ]
    pub fn xmlBufferLength ( buf : * const xmlBuffer , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCreateIntSubset" ]
    pub fn xmlCreateIntSubset ( doc : xmlDocPtr , name : * const xmlChar , ExternalID : * const xmlChar , SystemID : * const xmlChar , ) -> xmlDtdPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewDtd" ]
    pub fn xmlNewDtd ( doc : xmlDocPtr , name : * const xmlChar , ExternalID : * const xmlChar , SystemID : * const xmlChar , ) -> xmlDtdPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetIntSubset" ]
    pub fn xmlGetIntSubset ( doc : * const xmlDoc , ) -> xmlDtdPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFreeDtd" ]
    pub fn xmlFreeDtd ( cur : xmlDtdPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewGlobalNs" ]
    pub fn xmlNewGlobalNs ( doc : xmlDocPtr , href : * const xmlChar , prefix : * const xmlChar , ) -> xmlNsPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewNs" ]
    pub fn xmlNewNs ( node : xmlNodePtr , href : * const xmlChar , prefix : * const xmlChar , ) -> xmlNsPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFreeNs" ]
    pub fn xmlFreeNs ( cur : xmlNsPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFreeNsList" ]
    pub fn xmlFreeNsList ( cur : xmlNsPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewDoc" ]
    pub fn xmlNewDoc ( version : * const xmlChar , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFreeDoc" ]
    pub fn xmlFreeDoc ( cur : xmlDocPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewDocProp" ]
    pub fn xmlNewDocProp ( doc : xmlDocPtr , name : * const xmlChar , value : * const xmlChar , ) -> xmlAttrPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewProp" ]
    pub fn xmlNewProp ( node : xmlNodePtr , name : * const xmlChar , value : * const xmlChar , ) -> xmlAttrPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewNsProp" ]
    pub fn xmlNewNsProp ( node : xmlNodePtr , ns : xmlNsPtr , name : * const xmlChar , value : * const xmlChar , ) -> xmlAttrPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewNsPropEatName" ]
    pub fn xmlNewNsPropEatName ( node : xmlNodePtr , ns : xmlNsPtr , name : * mut xmlChar , value : * const xmlChar , ) -> xmlAttrPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFreePropList" ]
    pub fn xmlFreePropList ( cur : xmlAttrPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFreeProp" ]
    pub fn xmlFreeProp ( cur : xmlAttrPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCopyProp" ]
    pub fn xmlCopyProp ( target : xmlNodePtr , cur : xmlAttrPtr , ) -> xmlAttrPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCopyPropList" ]
    pub fn xmlCopyPropList ( target : xmlNodePtr , cur : xmlAttrPtr , ) -> xmlAttrPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCopyDtd" ]
    pub fn xmlCopyDtd ( dtd : xmlDtdPtr , ) -> xmlDtdPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCopyDoc" ]
    pub fn xmlCopyDoc ( doc : xmlDocPtr , recursive : :: std :: os :: raw :: c_int , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewDocNode" ]
    pub fn xmlNewDocNode ( doc : xmlDocPtr , ns : xmlNsPtr , name : * const xmlChar , content : * const xmlChar , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewDocNodeEatName" ]
    pub fn xmlNewDocNodeEatName ( doc : xmlDocPtr , ns : xmlNsPtr , name : * mut xmlChar , content : * const xmlChar , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewNode" ]
    pub fn xmlNewNode ( ns : xmlNsPtr , name : * const xmlChar , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewNodeEatName" ]
    pub fn xmlNewNodeEatName ( ns : xmlNsPtr , name : * mut xmlChar , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewChild" ]
    pub fn xmlNewChild ( parent : xmlNodePtr , ns : xmlNsPtr , name : * const xmlChar , content : * const xmlChar , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewDocText" ]
    pub fn xmlNewDocText ( doc : * const xmlDoc , content : * const xmlChar , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewText" ]
    pub fn xmlNewText ( content : * const xmlChar , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewDocPI" ]
    pub fn xmlNewDocPI ( doc : xmlDocPtr , name : * const xmlChar , content : * const xmlChar , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewPI" ]
    pub fn xmlNewPI ( name : * const xmlChar , content : * const xmlChar , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewDocTextLen" ]
    pub fn xmlNewDocTextLen ( doc : xmlDocPtr , content : * const xmlChar , len : :: std :: os :: raw :: c_int , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewTextLen" ]
    pub fn xmlNewTextLen ( content : * const xmlChar , len : :: std :: os :: raw :: c_int , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewDocComment" ]
    pub fn xmlNewDocComment ( doc : xmlDocPtr , content : * const xmlChar , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewComment" ]
    pub fn xmlNewComment ( content : * const xmlChar , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewCDataBlock" ]
    pub fn xmlNewCDataBlock ( doc : xmlDocPtr , content : * const xmlChar , len : :: std :: os :: raw :: c_int , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewCharRef" ]
    pub fn xmlNewCharRef ( doc : xmlDocPtr , name : * const xmlChar , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewReference" ]
    pub fn xmlNewReference ( doc : * const xmlDoc , name : * const xmlChar , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCopyNode" ]
    pub fn xmlCopyNode ( node : xmlNodePtr , recursive : :: std :: os :: raw :: c_int , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDocCopyNode" ]
    pub fn xmlDocCopyNode ( node : xmlNodePtr , doc : xmlDocPtr , recursive : :: std :: os :: raw :: c_int , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDocCopyNodeList" ]
    pub fn xmlDocCopyNodeList ( doc : xmlDocPtr , node : xmlNodePtr , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCopyNodeList" ]
    pub fn xmlCopyNodeList ( node : xmlNodePtr , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewTextChild" ]
    pub fn xmlNewTextChild ( parent : xmlNodePtr , ns : xmlNsPtr , name : * const xmlChar , content : * const xmlChar , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewDocRawNode" ]
    pub fn xmlNewDocRawNode ( doc : xmlDocPtr , ns : xmlNsPtr , name : * const xmlChar , content : * const xmlChar , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewDocFragment" ]
    pub fn xmlNewDocFragment ( doc : xmlDocPtr , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetLineNo" ]
    pub fn xmlGetLineNo ( node : * const xmlNode , ) -> :: std :: os :: raw :: c_long ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetNodePath" ]
    pub fn xmlGetNodePath ( node : * const xmlNode , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDocGetRootElement" ]
    pub fn xmlDocGetRootElement ( doc : * const xmlDoc , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetLastChild" ]
    pub fn xmlGetLastChild ( parent : * const xmlNode , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNodeIsText" ]
    pub fn xmlNodeIsText ( node : * const xmlNode , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlIsBlankNode" ]
    pub fn xmlIsBlankNode ( node : * const xmlNode , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDocSetRootElement" ]
    pub fn xmlDocSetRootElement ( doc : xmlDocPtr , root : xmlNodePtr , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNodeSetName" ]
    pub fn xmlNodeSetName ( cur : xmlNodePtr , name : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAddChild" ]
    pub fn xmlAddChild ( parent : xmlNodePtr , cur : xmlNodePtr , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAddChildList" ]
    pub fn xmlAddChildList ( parent : xmlNodePtr , cur : xmlNodePtr , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlReplaceNode" ]
    pub fn xmlReplaceNode ( old : xmlNodePtr , cur : xmlNodePtr , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAddPrevSibling" ]
    pub fn xmlAddPrevSibling ( cur : xmlNodePtr , elem : xmlNodePtr , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAddSibling" ]
    pub fn xmlAddSibling ( cur : xmlNodePtr , elem : xmlNodePtr , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAddNextSibling" ]
    pub fn xmlAddNextSibling ( cur : xmlNodePtr , elem : xmlNodePtr , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlUnlinkNode" ]
    pub fn xmlUnlinkNode ( cur : xmlNodePtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlTextMerge" ]
    pub fn xmlTextMerge ( first : xmlNodePtr , second : xmlNodePtr , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlTextConcat" ]
    pub fn xmlTextConcat ( node : xmlNodePtr , content : * const xmlChar , len : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFreeNodeList" ]
    pub fn xmlFreeNodeList ( cur : xmlNodePtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFreeNode" ]
    pub fn xmlFreeNode ( cur : xmlNodePtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSetTreeDoc" ]
    pub fn xmlSetTreeDoc ( tree : xmlNodePtr , doc : xmlDocPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSetListDoc" ]
    pub fn xmlSetListDoc ( list : xmlNodePtr , doc : xmlDocPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSearchNs" ]
    pub fn xmlSearchNs ( doc : xmlDocPtr , node : xmlNodePtr , nameSpace : * const xmlChar , ) -> xmlNsPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSearchNsByHref" ]
    pub fn xmlSearchNsByHref ( doc : xmlDocPtr , node : xmlNodePtr , href : * const xmlChar , ) -> xmlNsPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetNsList" ]
    pub fn xmlGetNsList ( doc : * const xmlDoc , node : * const xmlNode , ) -> * mut xmlNsPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSetNs" ]
    pub fn xmlSetNs ( node : xmlNodePtr , ns : xmlNsPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCopyNamespace" ]
    pub fn xmlCopyNamespace ( cur : xmlNsPtr , ) -> xmlNsPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCopyNamespaceList" ]
    pub fn xmlCopyNamespaceList ( cur : xmlNsPtr , ) -> xmlNsPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSetProp" ]
    pub fn xmlSetProp ( node : xmlNodePtr , name : * const xmlChar , value : * const xmlChar , ) -> xmlAttrPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSetNsProp" ]
    pub fn xmlSetNsProp ( node : xmlNodePtr , ns : xmlNsPtr , name : * const xmlChar , value : * const xmlChar , ) -> xmlAttrPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetNoNsProp" ]
    pub fn xmlGetNoNsProp ( node : * const xmlNode , name : * const xmlChar , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetProp" ]
    pub fn xmlGetProp ( node : * const xmlNode , name : * const xmlChar , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHasProp" ]
    pub fn xmlHasProp ( node : * const xmlNode , name : * const xmlChar , ) -> xmlAttrPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHasNsProp" ]
    pub fn xmlHasNsProp ( node : * const xmlNode , name : * const xmlChar , nameSpace : * const xmlChar , ) -> xmlAttrPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetNsProp" ]
    pub fn xmlGetNsProp ( node : * const xmlNode , name : * const xmlChar , nameSpace : * const xmlChar , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlStringGetNodeList" ]
    pub fn xmlStringGetNodeList ( doc : * const xmlDoc , value : * const xmlChar , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlStringLenGetNodeList" ]
    pub fn xmlStringLenGetNodeList ( doc : * const xmlDoc , value : * const xmlChar , len : :: std :: os :: raw :: c_int , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNodeListGetString" ]
    pub fn xmlNodeListGetString ( doc : xmlDocPtr , list : * const xmlNode , inLine : :: std :: os :: raw :: c_int , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNodeListGetRawString" ]
    pub fn xmlNodeListGetRawString ( doc : * const xmlDoc , list : * const xmlNode , inLine : :: std :: os :: raw :: c_int , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNodeSetContent" ]
    pub fn xmlNodeSetContent ( cur : xmlNodePtr , content : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNodeSetContentLen" ]
    pub fn xmlNodeSetContentLen ( cur : xmlNodePtr , content : * const xmlChar , len : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNodeAddContent" ]
    pub fn xmlNodeAddContent ( cur : xmlNodePtr , content : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNodeAddContentLen" ]
    pub fn xmlNodeAddContentLen ( cur : xmlNodePtr , content : * const xmlChar , len : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNodeGetContent" ]
    pub fn xmlNodeGetContent ( cur : * const xmlNode , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNodeBufGetContent" ]
    pub fn xmlNodeBufGetContent ( buffer : xmlBufferPtr , cur : * const xmlNode , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufGetNodeContent" ]
    pub fn xmlBufGetNodeContent ( buf : xmlBufPtr , cur : * const xmlNode , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNodeGetLang" ]
    pub fn xmlNodeGetLang ( cur : * const xmlNode , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNodeGetSpacePreserve" ]
    pub fn xmlNodeGetSpacePreserve ( cur : * const xmlNode , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNodeSetLang" ]
    pub fn xmlNodeSetLang ( cur : xmlNodePtr , lang : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNodeSetSpacePreserve" ]
    pub fn xmlNodeSetSpacePreserve ( cur : xmlNodePtr , val : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNodeGetBase" ]
    pub fn xmlNodeGetBase ( doc : * const xmlDoc , cur : * const xmlNode , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNodeSetBase" ]
    pub fn xmlNodeSetBase ( cur : xmlNodePtr , uri : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRemoveProp" ]
    pub fn xmlRemoveProp ( cur : xmlAttrPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlUnsetNsProp" ]
    pub fn xmlUnsetNsProp ( node : xmlNodePtr , ns : xmlNsPtr , name : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlUnsetProp" ]
    pub fn xmlUnsetProp ( node : xmlNodePtr , name : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufferWriteCHAR" ]
    pub fn xmlBufferWriteCHAR ( buf : xmlBufferPtr , string : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufferWriteChar" ]
    pub fn xmlBufferWriteChar ( buf : xmlBufferPtr , string : * const :: std :: os :: raw :: c_char , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufferWriteQuotedString" ]
    pub fn xmlBufferWriteQuotedString ( buf : xmlBufferPtr , string : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAttrSerializeTxtContent" ]
    pub fn xmlAttrSerializeTxtContent ( buf : xmlBufferPtr , doc : xmlDocPtr , attr : xmlAttrPtr , string : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlReconciliateNs" ]
    pub fn xmlReconciliateNs ( doc : xmlDocPtr , tree : xmlNodePtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDocDumpFormatMemory" ]
    pub fn xmlDocDumpFormatMemory ( cur : xmlDocPtr , mem : * mut * mut xmlChar , size : * mut :: std :: os :: raw :: c_int , format : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDocDumpMemory" ]
    pub fn xmlDocDumpMemory ( cur : xmlDocPtr , mem : * mut * mut xmlChar , size : * mut :: std :: os :: raw :: c_int , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDocDumpMemoryEnc" ]
    pub fn xmlDocDumpMemoryEnc ( out_doc : xmlDocPtr , doc_txt_ptr : * mut * mut xmlChar , doc_txt_len : * mut :: std :: os :: raw :: c_int , txt_encoding : * const :: std :: os :: raw :: c_char , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDocDumpFormatMemoryEnc" ]
    pub fn xmlDocDumpFormatMemoryEnc ( out_doc : xmlDocPtr , doc_txt_ptr : * mut * mut xmlChar , doc_txt_len : * mut :: std :: os :: raw :: c_int , txt_encoding : * const :: std :: os :: raw :: c_char , format : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDocFormatDump" ]
    pub fn xmlDocFormatDump ( f : * mut FILE , cur : xmlDocPtr , format : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDocDump" ]
    pub fn xmlDocDump ( f : * mut FILE , cur : xmlDocPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlElemDump" ]
    pub fn xmlElemDump ( f : * mut FILE , doc : xmlDocPtr , cur : xmlNodePtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSaveFile" ]
    pub fn xmlSaveFile ( filename : * const :: std :: os :: raw :: c_char , cur : xmlDocPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSaveFormatFile" ]
    pub fn xmlSaveFormatFile ( filename : * const :: std :: os :: raw :: c_char , cur : xmlDocPtr , format : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufNodeDump" ]
    pub fn xmlBufNodeDump ( buf : xmlBufPtr , doc : xmlDocPtr , cur : xmlNodePtr , level : :: std :: os :: raw :: c_int , format : :: std :: os :: raw :: c_int , ) -> usize ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNodeDump" ]
    pub fn xmlNodeDump ( buf : xmlBufferPtr , doc : xmlDocPtr , cur : xmlNodePtr , level : :: std :: os :: raw :: c_int , format : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSaveFileTo" ]
    pub fn xmlSaveFileTo ( buf : xmlOutputBufferPtr , cur : xmlDocPtr , encoding : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSaveFormatFileTo" ]
    pub fn xmlSaveFormatFileTo ( buf : xmlOutputBufferPtr , cur : xmlDocPtr , encoding : * const :: std :: os :: raw :: c_char , format : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNodeDumpOutput" ]
    pub fn xmlNodeDumpOutput ( buf : xmlOutputBufferPtr , doc : xmlDocPtr , cur : xmlNodePtr , level : :: std :: os :: raw :: c_int , format : :: std :: os :: raw :: c_int , encoding : * const :: std :: os :: raw :: c_char , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSaveFormatFileEnc" ]
    pub fn xmlSaveFormatFileEnc ( filename : * const :: std :: os :: raw :: c_char , cur : xmlDocPtr , encoding : * const :: std :: os :: raw :: c_char , format : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSaveFileEnc" ]
    pub fn xmlSaveFileEnc ( filename : * const :: std :: os :: raw :: c_char , cur : xmlDocPtr , encoding : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlIsXHTML" ]
    pub fn xmlIsXHTML ( systemID : * const xmlChar , publicID : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetDocCompressMode" ]
    pub fn xmlGetDocCompressMode ( doc : * const xmlDoc , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSetDocCompressMode" ]
    pub fn xmlSetDocCompressMode ( doc : xmlDocPtr , mode : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetCompressMode" ]
    pub fn xmlGetCompressMode ( ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSetCompressMode" ]
    pub fn xmlSetCompressMode ( mode : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDOMWrapNewCtxt" ]
    pub fn xmlDOMWrapNewCtxt ( ) -> xmlDOMWrapCtxtPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDOMWrapFreeCtxt" ]
    pub fn xmlDOMWrapFreeCtxt ( ctxt : xmlDOMWrapCtxtPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDOMWrapReconcileNamespaces" ]
    pub fn xmlDOMWrapReconcileNamespaces ( ctxt : xmlDOMWrapCtxtPtr , elem : xmlNodePtr , options : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDOMWrapAdoptNode" ]
    pub fn xmlDOMWrapAdoptNode ( ctxt : xmlDOMWrapCtxtPtr , sourceDoc : xmlDocPtr , node : xmlNodePtr , destDoc : xmlDocPtr , destParent : xmlNodePtr , options : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDOMWrapRemoveNode" ]
    pub fn xmlDOMWrapRemoveNode ( ctxt : xmlDOMWrapCtxtPtr , doc : xmlDocPtr , node : xmlNodePtr , options : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDOMWrapCloneNode" ]
    pub fn xmlDOMWrapCloneNode ( ctxt : xmlDOMWrapCtxtPtr , sourceDoc : xmlDocPtr , node : xmlNodePtr , clonedNode : * mut xmlNodePtr , destDoc : xmlDocPtr , destParent : xmlNodePtr , deep : :: std :: os :: raw :: c_int , options : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlChildElementCount" ]
    pub fn xmlChildElementCount ( parent : xmlNodePtr , ) -> :: std :: os :: raw :: c_ulong ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNextElementSibling" ]
    pub fn xmlNextElementSibling ( node : xmlNodePtr , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFirstElementChild" ]
    pub fn xmlFirstElementChild ( parent : xmlNodePtr , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlLastElementChild" ]
    pub fn xmlLastElementChild ( parent : xmlNodePtr , ) -> xmlNodePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlPreviousElementSibling" ]
    pub fn xmlPreviousElementSibling ( node : xmlNodePtr , ) -> xmlNodePtr ;
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlHashTable { _unused : [ u8 ; 0 ] } pub type xmlHashTable = _xmlHashTable ; pub type xmlHashTablePtr = * mut xmlHashTable ;
/// xmlHashDeallocator:
/// @payload:  the data in the hash
/// @name:  the name associated
///
/// Callback to free data from a hash.
pub type xmlHashDeallocator = :: std :: option :: Option < unsafe extern "C" fn ( payload : * mut :: std :: os :: raw :: c_void , name : * mut xmlChar ) > ;
/// xmlHashCopier:
/// @payload:  the data in the hash
/// @name:  the name associated
///
/// Callback to copy data from a hash.
///
/// Returns a copy of the data or NULL in case of error.
pub type xmlHashCopier = :: std :: option :: Option < unsafe extern "C" fn ( payload : * mut :: std :: os :: raw :: c_void , name : * mut xmlChar ) -> * mut :: std :: os :: raw :: c_void > ;
/// xmlHashScanner:
/// @payload:  the data in the hash
/// @data:  extra scannner data
/// @name:  the name associated
///
/// Callback when scanning data in a hash with the simple scanner.
pub type xmlHashScanner = :: std :: option :: Option < unsafe extern "C" fn ( payload : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , name : * mut xmlChar ) > ;
/// xmlHashScannerFull:
/// @payload:  the data in the hash
/// @data:  extra scannner data
/// @name:  the name associated
/// @name2:  the second name associated
/// @name3:  the third name associated
///
/// Callback when scanning data in a hash with the full scanner.
pub type xmlHashScannerFull = :: std :: option :: Option < unsafe extern "C" fn ( payload : * mut :: std :: os :: raw :: c_void , data : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , name2 : * const xmlChar , name3 : * const xmlChar ) > ; extern "C" {
    # [ link_name = "\u{1}_xmlHashCreate" ]
    pub fn xmlHashCreate ( size : :: std :: os :: raw :: c_int , ) -> xmlHashTablePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHashCreateDict" ]
    pub fn xmlHashCreateDict ( size : :: std :: os :: raw :: c_int , dict : xmlDictPtr , ) -> xmlHashTablePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHashFree" ]
    pub fn xmlHashFree ( table : xmlHashTablePtr , f : xmlHashDeallocator , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHashAddEntry" ]
    pub fn xmlHashAddEntry ( table : xmlHashTablePtr , name : * const xmlChar , userdata : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHashUpdateEntry" ]
    pub fn xmlHashUpdateEntry ( table : xmlHashTablePtr , name : * const xmlChar , userdata : * mut :: std :: os :: raw :: c_void , f : xmlHashDeallocator , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHashAddEntry2" ]
    pub fn xmlHashAddEntry2 ( table : xmlHashTablePtr , name : * const xmlChar , name2 : * const xmlChar , userdata : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHashUpdateEntry2" ]
    pub fn xmlHashUpdateEntry2 ( table : xmlHashTablePtr , name : * const xmlChar , name2 : * const xmlChar , userdata : * mut :: std :: os :: raw :: c_void , f : xmlHashDeallocator , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHashAddEntry3" ]
    pub fn xmlHashAddEntry3 ( table : xmlHashTablePtr , name : * const xmlChar , name2 : * const xmlChar , name3 : * const xmlChar , userdata : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHashUpdateEntry3" ]
    pub fn xmlHashUpdateEntry3 ( table : xmlHashTablePtr , name : * const xmlChar , name2 : * const xmlChar , name3 : * const xmlChar , userdata : * mut :: std :: os :: raw :: c_void , f : xmlHashDeallocator , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHashRemoveEntry" ]
    pub fn xmlHashRemoveEntry ( table : xmlHashTablePtr , name : * const xmlChar , f : xmlHashDeallocator , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHashRemoveEntry2" ]
    pub fn xmlHashRemoveEntry2 ( table : xmlHashTablePtr , name : * const xmlChar , name2 : * const xmlChar , f : xmlHashDeallocator , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHashRemoveEntry3" ]
    pub fn xmlHashRemoveEntry3 ( table : xmlHashTablePtr , name : * const xmlChar , name2 : * const xmlChar , name3 : * const xmlChar , f : xmlHashDeallocator , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHashLookup" ]
    pub fn xmlHashLookup ( table : xmlHashTablePtr , name : * const xmlChar , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHashLookup2" ]
    pub fn xmlHashLookup2 ( table : xmlHashTablePtr , name : * const xmlChar , name2 : * const xmlChar , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHashLookup3" ]
    pub fn xmlHashLookup3 ( table : xmlHashTablePtr , name : * const xmlChar , name2 : * const xmlChar , name3 : * const xmlChar , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHashQLookup" ]
    pub fn xmlHashQLookup ( table : xmlHashTablePtr , name : * const xmlChar , prefix : * const xmlChar , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHashQLookup2" ]
    pub fn xmlHashQLookup2 ( table : xmlHashTablePtr , name : * const xmlChar , prefix : * const xmlChar , name2 : * const xmlChar , prefix2 : * const xmlChar , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHashQLookup3" ]
    pub fn xmlHashQLookup3 ( table : xmlHashTablePtr , name : * const xmlChar , prefix : * const xmlChar , name2 : * const xmlChar , prefix2 : * const xmlChar , name3 : * const xmlChar , prefix3 : * const xmlChar , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHashCopy" ]
    pub fn xmlHashCopy ( table : xmlHashTablePtr , f : xmlHashCopier , ) -> xmlHashTablePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHashSize" ]
    pub fn xmlHashSize ( table : xmlHashTablePtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHashScan" ]
    pub fn xmlHashScan ( table : xmlHashTablePtr , f : xmlHashScanner , data : * mut :: std :: os :: raw :: c_void , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHashScan3" ]
    pub fn xmlHashScan3 ( table : xmlHashTablePtr , name : * const xmlChar , name2 : * const xmlChar , name3 : * const xmlChar , f : xmlHashScanner , data : * mut :: std :: os :: raw :: c_void , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHashScanFull" ]
    pub fn xmlHashScanFull ( table : xmlHashTablePtr , f : xmlHashScannerFull , data : * mut :: std :: os :: raw :: c_void , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlHashScanFull3" ]
    pub fn xmlHashScanFull3 ( table : xmlHashTablePtr , name : * const xmlChar , name2 : * const xmlChar , name3 : * const xmlChar , f : xmlHashScannerFull , data : * mut :: std :: os :: raw :: c_void , ) ;
} pub const xmlErrorLevel_XML_ERR_NONE : xmlErrorLevel = 0 ; pub const xmlErrorLevel_XML_ERR_WARNING : xmlErrorLevel = 1 ; pub const xmlErrorLevel_XML_ERR_ERROR : xmlErrorLevel = 2 ; pub const xmlErrorLevel_XML_ERR_FATAL : xmlErrorLevel = 3 ; pub type xmlErrorLevel = :: std :: os :: raw :: c_uint ; pub const xmlErrorDomain_XML_FROM_NONE : xmlErrorDomain = 0 ; pub const xmlErrorDomain_XML_FROM_PARSER : xmlErrorDomain = 1 ; pub const xmlErrorDomain_XML_FROM_TREE : xmlErrorDomain = 2 ; pub const xmlErrorDomain_XML_FROM_NAMESPACE : xmlErrorDomain = 3 ; pub const xmlErrorDomain_XML_FROM_DTD : xmlErrorDomain = 4 ; pub const xmlErrorDomain_XML_FROM_HTML : xmlErrorDomain = 5 ; pub const xmlErrorDomain_XML_FROM_MEMORY : xmlErrorDomain = 6 ; pub const xmlErrorDomain_XML_FROM_OUTPUT : xmlErrorDomain = 7 ; pub const xmlErrorDomain_XML_FROM_IO : xmlErrorDomain = 8 ; pub const xmlErrorDomain_XML_FROM_FTP : xmlErrorDomain = 9 ; pub const xmlErrorDomain_XML_FROM_HTTP : xmlErrorDomain = 10 ; pub const xmlErrorDomain_XML_FROM_XINCLUDE : xmlErrorDomain = 11 ; pub const xmlErrorDomain_XML_FROM_XPATH : xmlErrorDomain = 12 ; pub const xmlErrorDomain_XML_FROM_XPOINTER : xmlErrorDomain = 13 ; pub const xmlErrorDomain_XML_FROM_REGEXP : xmlErrorDomain = 14 ; pub const xmlErrorDomain_XML_FROM_DATATYPE : xmlErrorDomain = 15 ; pub const xmlErrorDomain_XML_FROM_SCHEMASP : xmlErrorDomain = 16 ; pub const xmlErrorDomain_XML_FROM_SCHEMASV : xmlErrorDomain = 17 ; pub const xmlErrorDomain_XML_FROM_RELAXNGP : xmlErrorDomain = 18 ; pub const xmlErrorDomain_XML_FROM_RELAXNGV : xmlErrorDomain = 19 ; pub const xmlErrorDomain_XML_FROM_CATALOG : xmlErrorDomain = 20 ; pub const xmlErrorDomain_XML_FROM_C14N : xmlErrorDomain = 21 ; pub const xmlErrorDomain_XML_FROM_XSLT : xmlErrorDomain = 22 ; pub const xmlErrorDomain_XML_FROM_VALID : xmlErrorDomain = 23 ; pub const xmlErrorDomain_XML_FROM_CHECK : xmlErrorDomain = 24 ; pub const xmlErrorDomain_XML_FROM_WRITER : xmlErrorDomain = 25 ; pub const xmlErrorDomain_XML_FROM_MODULE : xmlErrorDomain = 26 ; pub const xmlErrorDomain_XML_FROM_I18N : xmlErrorDomain = 27 ; pub const xmlErrorDomain_XML_FROM_SCHEMATRONV : xmlErrorDomain = 28 ; pub const xmlErrorDomain_XML_FROM_BUFFER : xmlErrorDomain = 29 ; pub const xmlErrorDomain_XML_FROM_URI : xmlErrorDomain = 30 ; pub type xmlErrorDomain = :: std :: os :: raw :: c_uint ;
/// xmlError:
///
/// An XML Error instance.
pub type xmlError = _xmlError ; pub type xmlErrorPtr = * mut xmlError ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlError { pub domain : :: std :: os :: raw :: c_int , pub code : :: std :: os :: raw :: c_int , pub message : * mut :: std :: os :: raw :: c_char , pub level : xmlErrorLevel , pub file : * mut :: std :: os :: raw :: c_char , pub line : :: std :: os :: raw :: c_int , pub str1 : * mut :: std :: os :: raw :: c_char , pub str2 : * mut :: std :: os :: raw :: c_char , pub str3 : * mut :: std :: os :: raw :: c_char , pub int1 : :: std :: os :: raw :: c_int , pub int2 : :: std :: os :: raw :: c_int , pub ctxt : * mut :: std :: os :: raw :: c_void , pub node : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout__xmlError ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlError > ( ) , 88usize , concat ! ( "Size of: " , stringify ! ( _xmlError ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlError > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlError ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlError ) ) . domain as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( domain ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlError ) ) . code as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( code ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlError ) ) . message as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( message ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlError ) ) . level as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( level ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlError ) ) . file as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( file ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlError ) ) . line as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( line ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlError ) ) . str1 as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( str1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlError ) ) . str2 as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( str2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlError ) ) . str3 as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( str3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlError ) ) . int1 as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( int1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlError ) ) . int2 as * const _ as usize } , 68usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( int2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlError ) ) . ctxt as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( ctxt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlError ) ) . node as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlError ) , "::" , stringify ! ( node ) ) ) ; } pub const xmlParserErrors_XML_ERR_OK : xmlParserErrors = 0 ; pub const xmlParserErrors_XML_ERR_INTERNAL_ERROR : xmlParserErrors = 1 ; pub const xmlParserErrors_XML_ERR_NO_MEMORY : xmlParserErrors = 2 ; pub const xmlParserErrors_XML_ERR_DOCUMENT_START : xmlParserErrors = 3 ; pub const xmlParserErrors_XML_ERR_DOCUMENT_EMPTY : xmlParserErrors = 4 ; pub const xmlParserErrors_XML_ERR_DOCUMENT_END : xmlParserErrors = 5 ; pub const xmlParserErrors_XML_ERR_INVALID_HEX_CHARREF : xmlParserErrors = 6 ; pub const xmlParserErrors_XML_ERR_INVALID_DEC_CHARREF : xmlParserErrors = 7 ; pub const xmlParserErrors_XML_ERR_INVALID_CHARREF : xmlParserErrors = 8 ; pub const xmlParserErrors_XML_ERR_INVALID_CHAR : xmlParserErrors = 9 ; pub const xmlParserErrors_XML_ERR_CHARREF_AT_EOF : xmlParserErrors = 10 ; pub const xmlParserErrors_XML_ERR_CHARREF_IN_PROLOG : xmlParserErrors = 11 ; pub const xmlParserErrors_XML_ERR_CHARREF_IN_EPILOG : xmlParserErrors = 12 ; pub const xmlParserErrors_XML_ERR_CHARREF_IN_DTD : xmlParserErrors = 13 ; pub const xmlParserErrors_XML_ERR_ENTITYREF_AT_EOF : xmlParserErrors = 14 ; pub const xmlParserErrors_XML_ERR_ENTITYREF_IN_PROLOG : xmlParserErrors = 15 ; pub const xmlParserErrors_XML_ERR_ENTITYREF_IN_EPILOG : xmlParserErrors = 16 ; pub const xmlParserErrors_XML_ERR_ENTITYREF_IN_DTD : xmlParserErrors = 17 ; pub const xmlParserErrors_XML_ERR_PEREF_AT_EOF : xmlParserErrors = 18 ; pub const xmlParserErrors_XML_ERR_PEREF_IN_PROLOG : xmlParserErrors = 19 ; pub const xmlParserErrors_XML_ERR_PEREF_IN_EPILOG : xmlParserErrors = 20 ; pub const xmlParserErrors_XML_ERR_PEREF_IN_INT_SUBSET : xmlParserErrors = 21 ; pub const xmlParserErrors_XML_ERR_ENTITYREF_NO_NAME : xmlParserErrors = 22 ; pub const xmlParserErrors_XML_ERR_ENTITYREF_SEMICOL_MISSING : xmlParserErrors = 23 ; pub const xmlParserErrors_XML_ERR_PEREF_NO_NAME : xmlParserErrors = 24 ; pub const xmlParserErrors_XML_ERR_PEREF_SEMICOL_MISSING : xmlParserErrors = 25 ; pub const xmlParserErrors_XML_ERR_UNDECLARED_ENTITY : xmlParserErrors = 26 ; pub const xmlParserErrors_XML_WAR_UNDECLARED_ENTITY : xmlParserErrors = 27 ; pub const xmlParserErrors_XML_ERR_UNPARSED_ENTITY : xmlParserErrors = 28 ; pub const xmlParserErrors_XML_ERR_ENTITY_IS_EXTERNAL : xmlParserErrors = 29 ; pub const xmlParserErrors_XML_ERR_ENTITY_IS_PARAMETER : xmlParserErrors = 30 ; pub const xmlParserErrors_XML_ERR_UNKNOWN_ENCODING : xmlParserErrors = 31 ; pub const xmlParserErrors_XML_ERR_UNSUPPORTED_ENCODING : xmlParserErrors = 32 ; pub const xmlParserErrors_XML_ERR_STRING_NOT_STARTED : xmlParserErrors = 33 ; pub const xmlParserErrors_XML_ERR_STRING_NOT_CLOSED : xmlParserErrors = 34 ; pub const xmlParserErrors_XML_ERR_NS_DECL_ERROR : xmlParserErrors = 35 ; pub const xmlParserErrors_XML_ERR_ENTITY_NOT_STARTED : xmlParserErrors = 36 ; pub const xmlParserErrors_XML_ERR_ENTITY_NOT_FINISHED : xmlParserErrors = 37 ; pub const xmlParserErrors_XML_ERR_LT_IN_ATTRIBUTE : xmlParserErrors = 38 ; pub const xmlParserErrors_XML_ERR_ATTRIBUTE_NOT_STARTED : xmlParserErrors = 39 ; pub const xmlParserErrors_XML_ERR_ATTRIBUTE_NOT_FINISHED : xmlParserErrors = 40 ; pub const xmlParserErrors_XML_ERR_ATTRIBUTE_WITHOUT_VALUE : xmlParserErrors = 41 ; pub const xmlParserErrors_XML_ERR_ATTRIBUTE_REDEFINED : xmlParserErrors = 42 ; pub const xmlParserErrors_XML_ERR_LITERAL_NOT_STARTED : xmlParserErrors = 43 ; pub const xmlParserErrors_XML_ERR_LITERAL_NOT_FINISHED : xmlParserErrors = 44 ; pub const xmlParserErrors_XML_ERR_COMMENT_NOT_FINISHED : xmlParserErrors = 45 ; pub const xmlParserErrors_XML_ERR_PI_NOT_STARTED : xmlParserErrors = 46 ; pub const xmlParserErrors_XML_ERR_PI_NOT_FINISHED : xmlParserErrors = 47 ; pub const xmlParserErrors_XML_ERR_NOTATION_NOT_STARTED : xmlParserErrors = 48 ; pub const xmlParserErrors_XML_ERR_NOTATION_NOT_FINISHED : xmlParserErrors = 49 ; pub const xmlParserErrors_XML_ERR_ATTLIST_NOT_STARTED : xmlParserErrors = 50 ; pub const xmlParserErrors_XML_ERR_ATTLIST_NOT_FINISHED : xmlParserErrors = 51 ; pub const xmlParserErrors_XML_ERR_MIXED_NOT_STARTED : xmlParserErrors = 52 ; pub const xmlParserErrors_XML_ERR_MIXED_NOT_FINISHED : xmlParserErrors = 53 ; pub const xmlParserErrors_XML_ERR_ELEMCONTENT_NOT_STARTED : xmlParserErrors = 54 ; pub const xmlParserErrors_XML_ERR_ELEMCONTENT_NOT_FINISHED : xmlParserErrors = 55 ; pub const xmlParserErrors_XML_ERR_XMLDECL_NOT_STARTED : xmlParserErrors = 56 ; pub const xmlParserErrors_XML_ERR_XMLDECL_NOT_FINISHED : xmlParserErrors = 57 ; pub const xmlParserErrors_XML_ERR_CONDSEC_NOT_STARTED : xmlParserErrors = 58 ; pub const xmlParserErrors_XML_ERR_CONDSEC_NOT_FINISHED : xmlParserErrors = 59 ; pub const xmlParserErrors_XML_ERR_EXT_SUBSET_NOT_FINISHED : xmlParserErrors = 60 ; pub const xmlParserErrors_XML_ERR_DOCTYPE_NOT_FINISHED : xmlParserErrors = 61 ; pub const xmlParserErrors_XML_ERR_MISPLACED_CDATA_END : xmlParserErrors = 62 ; pub const xmlParserErrors_XML_ERR_CDATA_NOT_FINISHED : xmlParserErrors = 63 ; pub const xmlParserErrors_XML_ERR_RESERVED_XML_NAME : xmlParserErrors = 64 ; pub const xmlParserErrors_XML_ERR_SPACE_REQUIRED : xmlParserErrors = 65 ; pub const xmlParserErrors_XML_ERR_SEPARATOR_REQUIRED : xmlParserErrors = 66 ; pub const xmlParserErrors_XML_ERR_NMTOKEN_REQUIRED : xmlParserErrors = 67 ; pub const xmlParserErrors_XML_ERR_NAME_REQUIRED : xmlParserErrors = 68 ; pub const xmlParserErrors_XML_ERR_PCDATA_REQUIRED : xmlParserErrors = 69 ; pub const xmlParserErrors_XML_ERR_URI_REQUIRED : xmlParserErrors = 70 ; pub const xmlParserErrors_XML_ERR_PUBID_REQUIRED : xmlParserErrors = 71 ; pub const xmlParserErrors_XML_ERR_LT_REQUIRED : xmlParserErrors = 72 ; pub const xmlParserErrors_XML_ERR_GT_REQUIRED : xmlParserErrors = 73 ; pub const xmlParserErrors_XML_ERR_LTSLASH_REQUIRED : xmlParserErrors = 74 ; pub const xmlParserErrors_XML_ERR_EQUAL_REQUIRED : xmlParserErrors = 75 ; pub const xmlParserErrors_XML_ERR_TAG_NAME_MISMATCH : xmlParserErrors = 76 ; pub const xmlParserErrors_XML_ERR_TAG_NOT_FINISHED : xmlParserErrors = 77 ; pub const xmlParserErrors_XML_ERR_STANDALONE_VALUE : xmlParserErrors = 78 ; pub const xmlParserErrors_XML_ERR_ENCODING_NAME : xmlParserErrors = 79 ; pub const xmlParserErrors_XML_ERR_HYPHEN_IN_COMMENT : xmlParserErrors = 80 ; pub const xmlParserErrors_XML_ERR_INVALID_ENCODING : xmlParserErrors = 81 ; pub const xmlParserErrors_XML_ERR_EXT_ENTITY_STANDALONE : xmlParserErrors = 82 ; pub const xmlParserErrors_XML_ERR_CONDSEC_INVALID : xmlParserErrors = 83 ; pub const xmlParserErrors_XML_ERR_VALUE_REQUIRED : xmlParserErrors = 84 ; pub const xmlParserErrors_XML_ERR_NOT_WELL_BALANCED : xmlParserErrors = 85 ; pub const xmlParserErrors_XML_ERR_EXTRA_CONTENT : xmlParserErrors = 86 ; pub const xmlParserErrors_XML_ERR_ENTITY_CHAR_ERROR : xmlParserErrors = 87 ; pub const xmlParserErrors_XML_ERR_ENTITY_PE_INTERNAL : xmlParserErrors = 88 ; pub const xmlParserErrors_XML_ERR_ENTITY_LOOP : xmlParserErrors = 89 ; pub const xmlParserErrors_XML_ERR_ENTITY_BOUNDARY : xmlParserErrors = 90 ; pub const xmlParserErrors_XML_ERR_INVALID_URI : xmlParserErrors = 91 ; pub const xmlParserErrors_XML_ERR_URI_FRAGMENT : xmlParserErrors = 92 ; pub const xmlParserErrors_XML_WAR_CATALOG_PI : xmlParserErrors = 93 ; pub const xmlParserErrors_XML_ERR_NO_DTD : xmlParserErrors = 94 ; pub const xmlParserErrors_XML_ERR_CONDSEC_INVALID_KEYWORD : xmlParserErrors = 95 ; pub const xmlParserErrors_XML_ERR_VERSION_MISSING : xmlParserErrors = 96 ; pub const xmlParserErrors_XML_WAR_UNKNOWN_VERSION : xmlParserErrors = 97 ; pub const xmlParserErrors_XML_WAR_LANG_VALUE : xmlParserErrors = 98 ; pub const xmlParserErrors_XML_WAR_NS_URI : xmlParserErrors = 99 ; pub const xmlParserErrors_XML_WAR_NS_URI_RELATIVE : xmlParserErrors = 100 ; pub const xmlParserErrors_XML_ERR_MISSING_ENCODING : xmlParserErrors = 101 ; pub const xmlParserErrors_XML_WAR_SPACE_VALUE : xmlParserErrors = 102 ; pub const xmlParserErrors_XML_ERR_NOT_STANDALONE : xmlParserErrors = 103 ; pub const xmlParserErrors_XML_ERR_ENTITY_PROCESSING : xmlParserErrors = 104 ; pub const xmlParserErrors_XML_ERR_NOTATION_PROCESSING : xmlParserErrors = 105 ; pub const xmlParserErrors_XML_WAR_NS_COLUMN : xmlParserErrors = 106 ; pub const xmlParserErrors_XML_WAR_ENTITY_REDEFINED : xmlParserErrors = 107 ; pub const xmlParserErrors_XML_ERR_UNKNOWN_VERSION : xmlParserErrors = 108 ; pub const xmlParserErrors_XML_ERR_VERSION_MISMATCH : xmlParserErrors = 109 ; pub const xmlParserErrors_XML_ERR_NAME_TOO_LONG : xmlParserErrors = 110 ; pub const xmlParserErrors_XML_ERR_USER_STOP : xmlParserErrors = 111 ; pub const xmlParserErrors_XML_NS_ERR_XML_NAMESPACE : xmlParserErrors = 200 ; pub const xmlParserErrors_XML_NS_ERR_UNDEFINED_NAMESPACE : xmlParserErrors = 201 ; pub const xmlParserErrors_XML_NS_ERR_QNAME : xmlParserErrors = 202 ; pub const xmlParserErrors_XML_NS_ERR_ATTRIBUTE_REDEFINED : xmlParserErrors = 203 ; pub const xmlParserErrors_XML_NS_ERR_EMPTY : xmlParserErrors = 204 ; pub const xmlParserErrors_XML_NS_ERR_COLON : xmlParserErrors = 205 ; pub const xmlParserErrors_XML_DTD_ATTRIBUTE_DEFAULT : xmlParserErrors = 500 ; pub const xmlParserErrors_XML_DTD_ATTRIBUTE_REDEFINED : xmlParserErrors = 501 ; pub const xmlParserErrors_XML_DTD_ATTRIBUTE_VALUE : xmlParserErrors = 502 ; pub const xmlParserErrors_XML_DTD_CONTENT_ERROR : xmlParserErrors = 503 ; pub const xmlParserErrors_XML_DTD_CONTENT_MODEL : xmlParserErrors = 504 ; pub const xmlParserErrors_XML_DTD_CONTENT_NOT_DETERMINIST : xmlParserErrors = 505 ; pub const xmlParserErrors_XML_DTD_DIFFERENT_PREFIX : xmlParserErrors = 506 ; pub const xmlParserErrors_XML_DTD_ELEM_DEFAULT_NAMESPACE : xmlParserErrors = 507 ; pub const xmlParserErrors_XML_DTD_ELEM_NAMESPACE : xmlParserErrors = 508 ; pub const xmlParserErrors_XML_DTD_ELEM_REDEFINED : xmlParserErrors = 509 ; pub const xmlParserErrors_XML_DTD_EMPTY_NOTATION : xmlParserErrors = 510 ; pub const xmlParserErrors_XML_DTD_ENTITY_TYPE : xmlParserErrors = 511 ; pub const xmlParserErrors_XML_DTD_ID_FIXED : xmlParserErrors = 512 ; pub const xmlParserErrors_XML_DTD_ID_REDEFINED : xmlParserErrors = 513 ; pub const xmlParserErrors_XML_DTD_ID_SUBSET : xmlParserErrors = 514 ; pub const xmlParserErrors_XML_DTD_INVALID_CHILD : xmlParserErrors = 515 ; pub const xmlParserErrors_XML_DTD_INVALID_DEFAULT : xmlParserErrors = 516 ; pub const xmlParserErrors_XML_DTD_LOAD_ERROR : xmlParserErrors = 517 ; pub const xmlParserErrors_XML_DTD_MISSING_ATTRIBUTE : xmlParserErrors = 518 ; pub const xmlParserErrors_XML_DTD_MIXED_CORRUPT : xmlParserErrors = 519 ; pub const xmlParserErrors_XML_DTD_MULTIPLE_ID : xmlParserErrors = 520 ; pub const xmlParserErrors_XML_DTD_NO_DOC : xmlParserErrors = 521 ; pub const xmlParserErrors_XML_DTD_NO_DTD : xmlParserErrors = 522 ; pub const xmlParserErrors_XML_DTD_NO_ELEM_NAME : xmlParserErrors = 523 ; pub const xmlParserErrors_XML_DTD_NO_PREFIX : xmlParserErrors = 524 ; pub const xmlParserErrors_XML_DTD_NO_ROOT : xmlParserErrors = 525 ; pub const xmlParserErrors_XML_DTD_NOTATION_REDEFINED : xmlParserErrors = 526 ; pub const xmlParserErrors_XML_DTD_NOTATION_VALUE : xmlParserErrors = 527 ; pub const xmlParserErrors_XML_DTD_NOT_EMPTY : xmlParserErrors = 528 ; pub const xmlParserErrors_XML_DTD_NOT_PCDATA : xmlParserErrors = 529 ; pub const xmlParserErrors_XML_DTD_NOT_STANDALONE : xmlParserErrors = 530 ; pub const xmlParserErrors_XML_DTD_ROOT_NAME : xmlParserErrors = 531 ; pub const xmlParserErrors_XML_DTD_STANDALONE_WHITE_SPACE : xmlParserErrors = 532 ; pub const xmlParserErrors_XML_DTD_UNKNOWN_ATTRIBUTE : xmlParserErrors = 533 ; pub const xmlParserErrors_XML_DTD_UNKNOWN_ELEM : xmlParserErrors = 534 ; pub const xmlParserErrors_XML_DTD_UNKNOWN_ENTITY : xmlParserErrors = 535 ; pub const xmlParserErrors_XML_DTD_UNKNOWN_ID : xmlParserErrors = 536 ; pub const xmlParserErrors_XML_DTD_UNKNOWN_NOTATION : xmlParserErrors = 537 ; pub const xmlParserErrors_XML_DTD_STANDALONE_DEFAULTED : xmlParserErrors = 538 ; pub const xmlParserErrors_XML_DTD_XMLID_VALUE : xmlParserErrors = 539 ; pub const xmlParserErrors_XML_DTD_XMLID_TYPE : xmlParserErrors = 540 ; pub const xmlParserErrors_XML_DTD_DUP_TOKEN : xmlParserErrors = 541 ; pub const xmlParserErrors_XML_HTML_STRUCURE_ERROR : xmlParserErrors = 800 ; pub const xmlParserErrors_XML_HTML_UNKNOWN_TAG : xmlParserErrors = 801 ; pub const xmlParserErrors_XML_RNGP_ANYNAME_ATTR_ANCESTOR : xmlParserErrors = 1000 ; pub const xmlParserErrors_XML_RNGP_ATTR_CONFLICT : xmlParserErrors = 1001 ; pub const xmlParserErrors_XML_RNGP_ATTRIBUTE_CHILDREN : xmlParserErrors = 1002 ; pub const xmlParserErrors_XML_RNGP_ATTRIBUTE_CONTENT : xmlParserErrors = 1003 ; pub const xmlParserErrors_XML_RNGP_ATTRIBUTE_EMPTY : xmlParserErrors = 1004 ; pub const xmlParserErrors_XML_RNGP_ATTRIBUTE_NOOP : xmlParserErrors = 1005 ; pub const xmlParserErrors_XML_RNGP_CHOICE_CONTENT : xmlParserErrors = 1006 ; pub const xmlParserErrors_XML_RNGP_CHOICE_EMPTY : xmlParserErrors = 1007 ; pub const xmlParserErrors_XML_RNGP_CREATE_FAILURE : xmlParserErrors = 1008 ; pub const xmlParserErrors_XML_RNGP_DATA_CONTENT : xmlParserErrors = 1009 ; pub const xmlParserErrors_XML_RNGP_DEF_CHOICE_AND_INTERLEAVE : xmlParserErrors = 1010 ; pub const xmlParserErrors_XML_RNGP_DEFINE_CREATE_FAILED : xmlParserErrors = 1011 ; pub const xmlParserErrors_XML_RNGP_DEFINE_EMPTY : xmlParserErrors = 1012 ; pub const xmlParserErrors_XML_RNGP_DEFINE_MISSING : xmlParserErrors = 1013 ; pub const xmlParserErrors_XML_RNGP_DEFINE_NAME_MISSING : xmlParserErrors = 1014 ; pub const xmlParserErrors_XML_RNGP_ELEM_CONTENT_EMPTY : xmlParserErrors = 1015 ; pub const xmlParserErrors_XML_RNGP_ELEM_CONTENT_ERROR : xmlParserErrors = 1016 ; pub const xmlParserErrors_XML_RNGP_ELEMENT_EMPTY : xmlParserErrors = 1017 ; pub const xmlParserErrors_XML_RNGP_ELEMENT_CONTENT : xmlParserErrors = 1018 ; pub const xmlParserErrors_XML_RNGP_ELEMENT_NAME : xmlParserErrors = 1019 ; pub const xmlParserErrors_XML_RNGP_ELEMENT_NO_CONTENT : xmlParserErrors = 1020 ; pub const xmlParserErrors_XML_RNGP_ELEM_TEXT_CONFLICT : xmlParserErrors = 1021 ; pub const xmlParserErrors_XML_RNGP_EMPTY : xmlParserErrors = 1022 ; pub const xmlParserErrors_XML_RNGP_EMPTY_CONSTRUCT : xmlParserErrors = 1023 ; pub const xmlParserErrors_XML_RNGP_EMPTY_CONTENT : xmlParserErrors = 1024 ; pub const xmlParserErrors_XML_RNGP_EMPTY_NOT_EMPTY : xmlParserErrors = 1025 ; pub const xmlParserErrors_XML_RNGP_ERROR_TYPE_LIB : xmlParserErrors = 1026 ; pub const xmlParserErrors_XML_RNGP_EXCEPT_EMPTY : xmlParserErrors = 1027 ; pub const xmlParserErrors_XML_RNGP_EXCEPT_MISSING : xmlParserErrors = 1028 ; pub const xmlParserErrors_XML_RNGP_EXCEPT_MULTIPLE : xmlParserErrors = 1029 ; pub const xmlParserErrors_XML_RNGP_EXCEPT_NO_CONTENT : xmlParserErrors = 1030 ; pub const xmlParserErrors_XML_RNGP_EXTERNALREF_EMTPY : xmlParserErrors = 1031 ; pub const xmlParserErrors_XML_RNGP_EXTERNAL_REF_FAILURE : xmlParserErrors = 1032 ; pub const xmlParserErrors_XML_RNGP_EXTERNALREF_RECURSE : xmlParserErrors = 1033 ; pub const xmlParserErrors_XML_RNGP_FORBIDDEN_ATTRIBUTE : xmlParserErrors = 1034 ; pub const xmlParserErrors_XML_RNGP_FOREIGN_ELEMENT : xmlParserErrors = 1035 ; pub const xmlParserErrors_XML_RNGP_GRAMMAR_CONTENT : xmlParserErrors = 1036 ; pub const xmlParserErrors_XML_RNGP_GRAMMAR_EMPTY : xmlParserErrors = 1037 ; pub const xmlParserErrors_XML_RNGP_GRAMMAR_MISSING : xmlParserErrors = 1038 ; pub const xmlParserErrors_XML_RNGP_GRAMMAR_NO_START : xmlParserErrors = 1039 ; pub const xmlParserErrors_XML_RNGP_GROUP_ATTR_CONFLICT : xmlParserErrors = 1040 ; pub const xmlParserErrors_XML_RNGP_HREF_ERROR : xmlParserErrors = 1041 ; pub const xmlParserErrors_XML_RNGP_INCLUDE_EMPTY : xmlParserErrors = 1042 ; pub const xmlParserErrors_XML_RNGP_INCLUDE_FAILURE : xmlParserErrors = 1043 ; pub const xmlParserErrors_XML_RNGP_INCLUDE_RECURSE : xmlParserErrors = 1044 ; pub const xmlParserErrors_XML_RNGP_INTERLEAVE_ADD : xmlParserErrors = 1045 ; pub const xmlParserErrors_XML_RNGP_INTERLEAVE_CREATE_FAILED : xmlParserErrors = 1046 ; pub const xmlParserErrors_XML_RNGP_INTERLEAVE_EMPTY : xmlParserErrors = 1047 ; pub const xmlParserErrors_XML_RNGP_INTERLEAVE_NO_CONTENT : xmlParserErrors = 1048 ; pub const xmlParserErrors_XML_RNGP_INVALID_DEFINE_NAME : xmlParserErrors = 1049 ; pub const xmlParserErrors_XML_RNGP_INVALID_URI : xmlParserErrors = 1050 ; pub const xmlParserErrors_XML_RNGP_INVALID_VALUE : xmlParserErrors = 1051 ; pub const xmlParserErrors_XML_RNGP_MISSING_HREF : xmlParserErrors = 1052 ; pub const xmlParserErrors_XML_RNGP_NAME_MISSING : xmlParserErrors = 1053 ; pub const xmlParserErrors_XML_RNGP_NEED_COMBINE : xmlParserErrors = 1054 ; pub const xmlParserErrors_XML_RNGP_NOTALLOWED_NOT_EMPTY : xmlParserErrors = 1055 ; pub const xmlParserErrors_XML_RNGP_NSNAME_ATTR_ANCESTOR : xmlParserErrors = 1056 ; pub const xmlParserErrors_XML_RNGP_NSNAME_NO_NS : xmlParserErrors = 1057 ; pub const xmlParserErrors_XML_RNGP_PARAM_FORBIDDEN : xmlParserErrors = 1058 ; pub const xmlParserErrors_XML_RNGP_PARAM_NAME_MISSING : xmlParserErrors = 1059 ; pub const xmlParserErrors_XML_RNGP_PARENTREF_CREATE_FAILED : xmlParserErrors = 1060 ; pub const xmlParserErrors_XML_RNGP_PARENTREF_NAME_INVALID : xmlParserErrors = 1061 ; pub const xmlParserErrors_XML_RNGP_PARENTREF_NO_NAME : xmlParserErrors = 1062 ; pub const xmlParserErrors_XML_RNGP_PARENTREF_NO_PARENT : xmlParserErrors = 1063 ; pub const xmlParserErrors_XML_RNGP_PARENTREF_NOT_EMPTY : xmlParserErrors = 1064 ; pub const xmlParserErrors_XML_RNGP_PARSE_ERROR : xmlParserErrors = 1065 ; pub const xmlParserErrors_XML_RNGP_PAT_ANYNAME_EXCEPT_ANYNAME : xmlParserErrors = 1066 ; pub const xmlParserErrors_XML_RNGP_PAT_ATTR_ATTR : xmlParserErrors = 1067 ; pub const xmlParserErrors_XML_RNGP_PAT_ATTR_ELEM : xmlParserErrors = 1068 ; pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_ATTR : xmlParserErrors = 1069 ; pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_ELEM : xmlParserErrors = 1070 ; pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_EMPTY : xmlParserErrors = 1071 ; pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_GROUP : xmlParserErrors = 1072 ; pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_INTERLEAVE : xmlParserErrors = 1073 ; pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_LIST : xmlParserErrors = 1074 ; pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_ONEMORE : xmlParserErrors = 1075 ; pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_REF : xmlParserErrors = 1076 ; pub const xmlParserErrors_XML_RNGP_PAT_DATA_EXCEPT_TEXT : xmlParserErrors = 1077 ; pub const xmlParserErrors_XML_RNGP_PAT_LIST_ATTR : xmlParserErrors = 1078 ; pub const xmlParserErrors_XML_RNGP_PAT_LIST_ELEM : xmlParserErrors = 1079 ; pub const xmlParserErrors_XML_RNGP_PAT_LIST_INTERLEAVE : xmlParserErrors = 1080 ; pub const xmlParserErrors_XML_RNGP_PAT_LIST_LIST : xmlParserErrors = 1081 ; pub const xmlParserErrors_XML_RNGP_PAT_LIST_REF : xmlParserErrors = 1082 ; pub const xmlParserErrors_XML_RNGP_PAT_LIST_TEXT : xmlParserErrors = 1083 ; pub const xmlParserErrors_XML_RNGP_PAT_NSNAME_EXCEPT_ANYNAME : xmlParserErrors = 1084 ; pub const xmlParserErrors_XML_RNGP_PAT_NSNAME_EXCEPT_NSNAME : xmlParserErrors = 1085 ; pub const xmlParserErrors_XML_RNGP_PAT_ONEMORE_GROUP_ATTR : xmlParserErrors = 1086 ; pub const xmlParserErrors_XML_RNGP_PAT_ONEMORE_INTERLEAVE_ATTR : xmlParserErrors = 1087 ; pub const xmlParserErrors_XML_RNGP_PAT_START_ATTR : xmlParserErrors = 1088 ; pub const xmlParserErrors_XML_RNGP_PAT_START_DATA : xmlParserErrors = 1089 ; pub const xmlParserErrors_XML_RNGP_PAT_START_EMPTY : xmlParserErrors = 1090 ; pub const xmlParserErrors_XML_RNGP_PAT_START_GROUP : xmlParserErrors = 1091 ; pub const xmlParserErrors_XML_RNGP_PAT_START_INTERLEAVE : xmlParserErrors = 1092 ; pub const xmlParserErrors_XML_RNGP_PAT_START_LIST : xmlParserErrors = 1093 ; pub const xmlParserErrors_XML_RNGP_PAT_START_ONEMORE : xmlParserErrors = 1094 ; pub const xmlParserErrors_XML_RNGP_PAT_START_TEXT : xmlParserErrors = 1095 ; pub const xmlParserErrors_XML_RNGP_PAT_START_VALUE : xmlParserErrors = 1096 ; pub const xmlParserErrors_XML_RNGP_PREFIX_UNDEFINED : xmlParserErrors = 1097 ; pub const xmlParserErrors_XML_RNGP_REF_CREATE_FAILED : xmlParserErrors = 1098 ; pub const xmlParserErrors_XML_RNGP_REF_CYCLE : xmlParserErrors = 1099 ; pub const xmlParserErrors_XML_RNGP_REF_NAME_INVALID : xmlParserErrors = 1100 ; pub const xmlParserErrors_XML_RNGP_REF_NO_DEF : xmlParserErrors = 1101 ; pub const xmlParserErrors_XML_RNGP_REF_NO_NAME : xmlParserErrors = 1102 ; pub const xmlParserErrors_XML_RNGP_REF_NOT_EMPTY : xmlParserErrors = 1103 ; pub const xmlParserErrors_XML_RNGP_START_CHOICE_AND_INTERLEAVE : xmlParserErrors = 1104 ; pub const xmlParserErrors_XML_RNGP_START_CONTENT : xmlParserErrors = 1105 ; pub const xmlParserErrors_XML_RNGP_START_EMPTY : xmlParserErrors = 1106 ; pub const xmlParserErrors_XML_RNGP_START_MISSING : xmlParserErrors = 1107 ; pub const xmlParserErrors_XML_RNGP_TEXT_EXPECTED : xmlParserErrors = 1108 ; pub const xmlParserErrors_XML_RNGP_TEXT_HAS_CHILD : xmlParserErrors = 1109 ; pub const xmlParserErrors_XML_RNGP_TYPE_MISSING : xmlParserErrors = 1110 ; pub const xmlParserErrors_XML_RNGP_TYPE_NOT_FOUND : xmlParserErrors = 1111 ; pub const xmlParserErrors_XML_RNGP_TYPE_VALUE : xmlParserErrors = 1112 ; pub const xmlParserErrors_XML_RNGP_UNKNOWN_ATTRIBUTE : xmlParserErrors = 1113 ; pub const xmlParserErrors_XML_RNGP_UNKNOWN_COMBINE : xmlParserErrors = 1114 ; pub const xmlParserErrors_XML_RNGP_UNKNOWN_CONSTRUCT : xmlParserErrors = 1115 ; pub const xmlParserErrors_XML_RNGP_UNKNOWN_TYPE_LIB : xmlParserErrors = 1116 ; pub const xmlParserErrors_XML_RNGP_URI_FRAGMENT : xmlParserErrors = 1117 ; pub const xmlParserErrors_XML_RNGP_URI_NOT_ABSOLUTE : xmlParserErrors = 1118 ; pub const xmlParserErrors_XML_RNGP_VALUE_EMPTY : xmlParserErrors = 1119 ; pub const xmlParserErrors_XML_RNGP_VALUE_NO_CONTENT : xmlParserErrors = 1120 ; pub const xmlParserErrors_XML_RNGP_XMLNS_NAME : xmlParserErrors = 1121 ; pub const xmlParserErrors_XML_RNGP_XML_NS : xmlParserErrors = 1122 ; pub const xmlParserErrors_XML_XPATH_EXPRESSION_OK : xmlParserErrors = 1200 ; pub const xmlParserErrors_XML_XPATH_NUMBER_ERROR : xmlParserErrors = 1201 ; pub const xmlParserErrors_XML_XPATH_UNFINISHED_LITERAL_ERROR : xmlParserErrors = 1202 ; pub const xmlParserErrors_XML_XPATH_START_LITERAL_ERROR : xmlParserErrors = 1203 ; pub const xmlParserErrors_XML_XPATH_VARIABLE_REF_ERROR : xmlParserErrors = 1204 ; pub const xmlParserErrors_XML_XPATH_UNDEF_VARIABLE_ERROR : xmlParserErrors = 1205 ; pub const xmlParserErrors_XML_XPATH_INVALID_PREDICATE_ERROR : xmlParserErrors = 1206 ; pub const xmlParserErrors_XML_XPATH_EXPR_ERROR : xmlParserErrors = 1207 ; pub const xmlParserErrors_XML_XPATH_UNCLOSED_ERROR : xmlParserErrors = 1208 ; pub const xmlParserErrors_XML_XPATH_UNKNOWN_FUNC_ERROR : xmlParserErrors = 1209 ; pub const xmlParserErrors_XML_XPATH_INVALID_OPERAND : xmlParserErrors = 1210 ; pub const xmlParserErrors_XML_XPATH_INVALID_TYPE : xmlParserErrors = 1211 ; pub const xmlParserErrors_XML_XPATH_INVALID_ARITY : xmlParserErrors = 1212 ; pub const xmlParserErrors_XML_XPATH_INVALID_CTXT_SIZE : xmlParserErrors = 1213 ; pub const xmlParserErrors_XML_XPATH_INVALID_CTXT_POSITION : xmlParserErrors = 1214 ; pub const xmlParserErrors_XML_XPATH_MEMORY_ERROR : xmlParserErrors = 1215 ; pub const xmlParserErrors_XML_XPTR_SYNTAX_ERROR : xmlParserErrors = 1216 ; pub const xmlParserErrors_XML_XPTR_RESOURCE_ERROR : xmlParserErrors = 1217 ; pub const xmlParserErrors_XML_XPTR_SUB_RESOURCE_ERROR : xmlParserErrors = 1218 ; pub const xmlParserErrors_XML_XPATH_UNDEF_PREFIX_ERROR : xmlParserErrors = 1219 ; pub const xmlParserErrors_XML_XPATH_ENCODING_ERROR : xmlParserErrors = 1220 ; pub const xmlParserErrors_XML_XPATH_INVALID_CHAR_ERROR : xmlParserErrors = 1221 ; pub const xmlParserErrors_XML_TREE_INVALID_HEX : xmlParserErrors = 1300 ; pub const xmlParserErrors_XML_TREE_INVALID_DEC : xmlParserErrors = 1301 ; pub const xmlParserErrors_XML_TREE_UNTERMINATED_ENTITY : xmlParserErrors = 1302 ; pub const xmlParserErrors_XML_TREE_NOT_UTF8 : xmlParserErrors = 1303 ; pub const xmlParserErrors_XML_SAVE_NOT_UTF8 : xmlParserErrors = 1400 ; pub const xmlParserErrors_XML_SAVE_CHAR_INVALID : xmlParserErrors = 1401 ; pub const xmlParserErrors_XML_SAVE_NO_DOCTYPE : xmlParserErrors = 1402 ; pub const xmlParserErrors_XML_SAVE_UNKNOWN_ENCODING : xmlParserErrors = 1403 ; pub const xmlParserErrors_XML_REGEXP_COMPILE_ERROR : xmlParserErrors = 1450 ; pub const xmlParserErrors_XML_IO_UNKNOWN : xmlParserErrors = 1500 ; pub const xmlParserErrors_XML_IO_EACCES : xmlParserErrors = 1501 ; pub const xmlParserErrors_XML_IO_EAGAIN : xmlParserErrors = 1502 ; pub const xmlParserErrors_XML_IO_EBADF : xmlParserErrors = 1503 ; pub const xmlParserErrors_XML_IO_EBADMSG : xmlParserErrors = 1504 ; pub const xmlParserErrors_XML_IO_EBUSY : xmlParserErrors = 1505 ; pub const xmlParserErrors_XML_IO_ECANCELED : xmlParserErrors = 1506 ; pub const xmlParserErrors_XML_IO_ECHILD : xmlParserErrors = 1507 ; pub const xmlParserErrors_XML_IO_EDEADLK : xmlParserErrors = 1508 ; pub const xmlParserErrors_XML_IO_EDOM : xmlParserErrors = 1509 ; pub const xmlParserErrors_XML_IO_EEXIST : xmlParserErrors = 1510 ; pub const xmlParserErrors_XML_IO_EFAULT : xmlParserErrors = 1511 ; pub const xmlParserErrors_XML_IO_EFBIG : xmlParserErrors = 1512 ; pub const xmlParserErrors_XML_IO_EINPROGRESS : xmlParserErrors = 1513 ; pub const xmlParserErrors_XML_IO_EINTR : xmlParserErrors = 1514 ; pub const xmlParserErrors_XML_IO_EINVAL : xmlParserErrors = 1515 ; pub const xmlParserErrors_XML_IO_EIO : xmlParserErrors = 1516 ; pub const xmlParserErrors_XML_IO_EISDIR : xmlParserErrors = 1517 ; pub const xmlParserErrors_XML_IO_EMFILE : xmlParserErrors = 1518 ; pub const xmlParserErrors_XML_IO_EMLINK : xmlParserErrors = 1519 ; pub const xmlParserErrors_XML_IO_EMSGSIZE : xmlParserErrors = 1520 ; pub const xmlParserErrors_XML_IO_ENAMETOOLONG : xmlParserErrors = 1521 ; pub const xmlParserErrors_XML_IO_ENFILE : xmlParserErrors = 1522 ; pub const xmlParserErrors_XML_IO_ENODEV : xmlParserErrors = 1523 ; pub const xmlParserErrors_XML_IO_ENOENT : xmlParserErrors = 1524 ; pub const xmlParserErrors_XML_IO_ENOEXEC : xmlParserErrors = 1525 ; pub const xmlParserErrors_XML_IO_ENOLCK : xmlParserErrors = 1526 ; pub const xmlParserErrors_XML_IO_ENOMEM : xmlParserErrors = 1527 ; pub const xmlParserErrors_XML_IO_ENOSPC : xmlParserErrors = 1528 ; pub const xmlParserErrors_XML_IO_ENOSYS : xmlParserErrors = 1529 ; pub const xmlParserErrors_XML_IO_ENOTDIR : xmlParserErrors = 1530 ; pub const xmlParserErrors_XML_IO_ENOTEMPTY : xmlParserErrors = 1531 ; pub const xmlParserErrors_XML_IO_ENOTSUP : xmlParserErrors = 1532 ; pub const xmlParserErrors_XML_IO_ENOTTY : xmlParserErrors = 1533 ; pub const xmlParserErrors_XML_IO_ENXIO : xmlParserErrors = 1534 ; pub const xmlParserErrors_XML_IO_EPERM : xmlParserErrors = 1535 ; pub const xmlParserErrors_XML_IO_EPIPE : xmlParserErrors = 1536 ; pub const xmlParserErrors_XML_IO_ERANGE : xmlParserErrors = 1537 ; pub const xmlParserErrors_XML_IO_EROFS : xmlParserErrors = 1538 ; pub const xmlParserErrors_XML_IO_ESPIPE : xmlParserErrors = 1539 ; pub const xmlParserErrors_XML_IO_ESRCH : xmlParserErrors = 1540 ; pub const xmlParserErrors_XML_IO_ETIMEDOUT : xmlParserErrors = 1541 ; pub const xmlParserErrors_XML_IO_EXDEV : xmlParserErrors = 1542 ; pub const xmlParserErrors_XML_IO_NETWORK_ATTEMPT : xmlParserErrors = 1543 ; pub const xmlParserErrors_XML_IO_ENCODER : xmlParserErrors = 1544 ; pub const xmlParserErrors_XML_IO_FLUSH : xmlParserErrors = 1545 ; pub const xmlParserErrors_XML_IO_WRITE : xmlParserErrors = 1546 ; pub const xmlParserErrors_XML_IO_NO_INPUT : xmlParserErrors = 1547 ; pub const xmlParserErrors_XML_IO_BUFFER_FULL : xmlParserErrors = 1548 ; pub const xmlParserErrors_XML_IO_LOAD_ERROR : xmlParserErrors = 1549 ; pub const xmlParserErrors_XML_IO_ENOTSOCK : xmlParserErrors = 1550 ; pub const xmlParserErrors_XML_IO_EISCONN : xmlParserErrors = 1551 ; pub const xmlParserErrors_XML_IO_ECONNREFUSED : xmlParserErrors = 1552 ; pub const xmlParserErrors_XML_IO_ENETUNREACH : xmlParserErrors = 1553 ; pub const xmlParserErrors_XML_IO_EADDRINUSE : xmlParserErrors = 1554 ; pub const xmlParserErrors_XML_IO_EALREADY : xmlParserErrors = 1555 ; pub const xmlParserErrors_XML_IO_EAFNOSUPPORT : xmlParserErrors = 1556 ; pub const xmlParserErrors_XML_XINCLUDE_RECURSION : xmlParserErrors = 1600 ; pub const xmlParserErrors_XML_XINCLUDE_PARSE_VALUE : xmlParserErrors = 1601 ; pub const xmlParserErrors_XML_XINCLUDE_ENTITY_DEF_MISMATCH : xmlParserErrors = 1602 ; pub const xmlParserErrors_XML_XINCLUDE_NO_HREF : xmlParserErrors = 1603 ; pub const xmlParserErrors_XML_XINCLUDE_NO_FALLBACK : xmlParserErrors = 1604 ; pub const xmlParserErrors_XML_XINCLUDE_HREF_URI : xmlParserErrors = 1605 ; pub const xmlParserErrors_XML_XINCLUDE_TEXT_FRAGMENT : xmlParserErrors = 1606 ; pub const xmlParserErrors_XML_XINCLUDE_TEXT_DOCUMENT : xmlParserErrors = 1607 ; pub const xmlParserErrors_XML_XINCLUDE_INVALID_CHAR : xmlParserErrors = 1608 ; pub const xmlParserErrors_XML_XINCLUDE_BUILD_FAILED : xmlParserErrors = 1609 ; pub const xmlParserErrors_XML_XINCLUDE_UNKNOWN_ENCODING : xmlParserErrors = 1610 ; pub const xmlParserErrors_XML_XINCLUDE_MULTIPLE_ROOT : xmlParserErrors = 1611 ; pub const xmlParserErrors_XML_XINCLUDE_XPTR_FAILED : xmlParserErrors = 1612 ; pub const xmlParserErrors_XML_XINCLUDE_XPTR_RESULT : xmlParserErrors = 1613 ; pub const xmlParserErrors_XML_XINCLUDE_INCLUDE_IN_INCLUDE : xmlParserErrors = 1614 ; pub const xmlParserErrors_XML_XINCLUDE_FALLBACKS_IN_INCLUDE : xmlParserErrors = 1615 ; pub const xmlParserErrors_XML_XINCLUDE_FALLBACK_NOT_IN_INCLUDE : xmlParserErrors = 1616 ; pub const xmlParserErrors_XML_XINCLUDE_DEPRECATED_NS : xmlParserErrors = 1617 ; pub const xmlParserErrors_XML_XINCLUDE_FRAGMENT_ID : xmlParserErrors = 1618 ; pub const xmlParserErrors_XML_CATALOG_MISSING_ATTR : xmlParserErrors = 1650 ; pub const xmlParserErrors_XML_CATALOG_ENTRY_BROKEN : xmlParserErrors = 1651 ; pub const xmlParserErrors_XML_CATALOG_PREFER_VALUE : xmlParserErrors = 1652 ; pub const xmlParserErrors_XML_CATALOG_NOT_CATALOG : xmlParserErrors = 1653 ; pub const xmlParserErrors_XML_CATALOG_RECURSION : xmlParserErrors = 1654 ; pub const xmlParserErrors_XML_SCHEMAP_PREFIX_UNDEFINED : xmlParserErrors = 1700 ; pub const xmlParserErrors_XML_SCHEMAP_ATTRFORMDEFAULT_VALUE : xmlParserErrors = 1701 ; pub const xmlParserErrors_XML_SCHEMAP_ATTRGRP_NONAME_NOREF : xmlParserErrors = 1702 ; pub const xmlParserErrors_XML_SCHEMAP_ATTR_NONAME_NOREF : xmlParserErrors = 1703 ; pub const xmlParserErrors_XML_SCHEMAP_COMPLEXTYPE_NONAME_NOREF : xmlParserErrors = 1704 ; pub const xmlParserErrors_XML_SCHEMAP_ELEMFORMDEFAULT_VALUE : xmlParserErrors = 1705 ; pub const xmlParserErrors_XML_SCHEMAP_ELEM_NONAME_NOREF : xmlParserErrors = 1706 ; pub const xmlParserErrors_XML_SCHEMAP_EXTENSION_NO_BASE : xmlParserErrors = 1707 ; pub const xmlParserErrors_XML_SCHEMAP_FACET_NO_VALUE : xmlParserErrors = 1708 ; pub const xmlParserErrors_XML_SCHEMAP_FAILED_BUILD_IMPORT : xmlParserErrors = 1709 ; pub const xmlParserErrors_XML_SCHEMAP_GROUP_NONAME_NOREF : xmlParserErrors = 1710 ; pub const xmlParserErrors_XML_SCHEMAP_IMPORT_NAMESPACE_NOT_URI : xmlParserErrors = 1711 ; pub const xmlParserErrors_XML_SCHEMAP_IMPORT_REDEFINE_NSNAME : xmlParserErrors = 1712 ; pub const xmlParserErrors_XML_SCHEMAP_IMPORT_SCHEMA_NOT_URI : xmlParserErrors = 1713 ; pub const xmlParserErrors_XML_SCHEMAP_INVALID_BOOLEAN : xmlParserErrors = 1714 ; pub const xmlParserErrors_XML_SCHEMAP_INVALID_ENUM : xmlParserErrors = 1715 ; pub const xmlParserErrors_XML_SCHEMAP_INVALID_FACET : xmlParserErrors = 1716 ; pub const xmlParserErrors_XML_SCHEMAP_INVALID_FACET_VALUE : xmlParserErrors = 1717 ; pub const xmlParserErrors_XML_SCHEMAP_INVALID_MAXOCCURS : xmlParserErrors = 1718 ; pub const xmlParserErrors_XML_SCHEMAP_INVALID_MINOCCURS : xmlParserErrors = 1719 ; pub const xmlParserErrors_XML_SCHEMAP_INVALID_REF_AND_SUBTYPE : xmlParserErrors = 1720 ; pub const xmlParserErrors_XML_SCHEMAP_INVALID_WHITE_SPACE : xmlParserErrors = 1721 ; pub const xmlParserErrors_XML_SCHEMAP_NOATTR_NOREF : xmlParserErrors = 1722 ; pub const xmlParserErrors_XML_SCHEMAP_NOTATION_NO_NAME : xmlParserErrors = 1723 ; pub const xmlParserErrors_XML_SCHEMAP_NOTYPE_NOREF : xmlParserErrors = 1724 ; pub const xmlParserErrors_XML_SCHEMAP_REF_AND_SUBTYPE : xmlParserErrors = 1725 ; pub const xmlParserErrors_XML_SCHEMAP_RESTRICTION_NONAME_NOREF : xmlParserErrors = 1726 ; pub const xmlParserErrors_XML_SCHEMAP_SIMPLETYPE_NONAME : xmlParserErrors = 1727 ; pub const xmlParserErrors_XML_SCHEMAP_TYPE_AND_SUBTYPE : xmlParserErrors = 1728 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ALL_CHILD : xmlParserErrors = 1729 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ANYATTRIBUTE_CHILD : xmlParserErrors = 1730 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ATTR_CHILD : xmlParserErrors = 1731 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ATTRGRP_CHILD : xmlParserErrors = 1732 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ATTRIBUTE_GROUP : xmlParserErrors = 1733 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_BASE_TYPE : xmlParserErrors = 1734 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_CHOICE_CHILD : xmlParserErrors = 1735 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_COMPLEXCONTENT_CHILD : xmlParserErrors = 1736 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_COMPLEXTYPE_CHILD : xmlParserErrors = 1737 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_ELEM_CHILD : xmlParserErrors = 1738 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_EXTENSION_CHILD : xmlParserErrors = 1739 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_FACET_CHILD : xmlParserErrors = 1740 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_FACET_TYPE : xmlParserErrors = 1741 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_GROUP_CHILD : xmlParserErrors = 1742 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_IMPORT_CHILD : xmlParserErrors = 1743 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_LIST_CHILD : xmlParserErrors = 1744 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_NOTATION_CHILD : xmlParserErrors = 1745 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_PROCESSCONTENT_CHILD : xmlParserErrors = 1746 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_REF : xmlParserErrors = 1747 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_RESTRICTION_CHILD : xmlParserErrors = 1748 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_SCHEMAS_CHILD : xmlParserErrors = 1749 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_SEQUENCE_CHILD : xmlParserErrors = 1750 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_SIMPLECONTENT_CHILD : xmlParserErrors = 1751 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_SIMPLETYPE_CHILD : xmlParserErrors = 1752 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_TYPE : xmlParserErrors = 1753 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_UNION_CHILD : xmlParserErrors = 1754 ; pub const xmlParserErrors_XML_SCHEMAP_ELEM_DEFAULT_FIXED : xmlParserErrors = 1755 ; pub const xmlParserErrors_XML_SCHEMAP_REGEXP_INVALID : xmlParserErrors = 1756 ; pub const xmlParserErrors_XML_SCHEMAP_FAILED_LOAD : xmlParserErrors = 1757 ; pub const xmlParserErrors_XML_SCHEMAP_NOTHING_TO_PARSE : xmlParserErrors = 1758 ; pub const xmlParserErrors_XML_SCHEMAP_NOROOT : xmlParserErrors = 1759 ; pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_GROUP : xmlParserErrors = 1760 ; pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_TYPE : xmlParserErrors = 1761 ; pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_ELEMENT : xmlParserErrors = 1762 ; pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_ATTRGROUP : xmlParserErrors = 1763 ; pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_ATTR : xmlParserErrors = 1764 ; pub const xmlParserErrors_XML_SCHEMAP_REDEFINED_NOTATION : xmlParserErrors = 1765 ; pub const xmlParserErrors_XML_SCHEMAP_FAILED_PARSE : xmlParserErrors = 1766 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_PREFIX : xmlParserErrors = 1767 ; pub const xmlParserErrors_XML_SCHEMAP_DEF_AND_PREFIX : xmlParserErrors = 1768 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_INCLUDE_CHILD : xmlParserErrors = 1769 ; pub const xmlParserErrors_XML_SCHEMAP_INCLUDE_SCHEMA_NOT_URI : xmlParserErrors = 1770 ; pub const xmlParserErrors_XML_SCHEMAP_INCLUDE_SCHEMA_NO_URI : xmlParserErrors = 1771 ; pub const xmlParserErrors_XML_SCHEMAP_NOT_SCHEMA : xmlParserErrors = 1772 ; pub const xmlParserErrors_XML_SCHEMAP_UNKNOWN_MEMBER_TYPE : xmlParserErrors = 1773 ; pub const xmlParserErrors_XML_SCHEMAP_INVALID_ATTR_USE : xmlParserErrors = 1774 ; pub const xmlParserErrors_XML_SCHEMAP_RECURSIVE : xmlParserErrors = 1775 ; pub const xmlParserErrors_XML_SCHEMAP_SUPERNUMEROUS_LIST_ITEM_TYPE : xmlParserErrors = 1776 ; pub const xmlParserErrors_XML_SCHEMAP_INVALID_ATTR_COMBINATION : xmlParserErrors = 1777 ; pub const xmlParserErrors_XML_SCHEMAP_INVALID_ATTR_INLINE_COMBINATION : xmlParserErrors = 1778 ; pub const xmlParserErrors_XML_SCHEMAP_MISSING_SIMPLETYPE_CHILD : xmlParserErrors = 1779 ; pub const xmlParserErrors_XML_SCHEMAP_INVALID_ATTR_NAME : xmlParserErrors = 1780 ; pub const xmlParserErrors_XML_SCHEMAP_REF_AND_CONTENT : xmlParserErrors = 1781 ; pub const xmlParserErrors_XML_SCHEMAP_CT_PROPS_CORRECT_1 : xmlParserErrors = 1782 ; pub const xmlParserErrors_XML_SCHEMAP_CT_PROPS_CORRECT_2 : xmlParserErrors = 1783 ; pub const xmlParserErrors_XML_SCHEMAP_CT_PROPS_CORRECT_3 : xmlParserErrors = 1784 ; pub const xmlParserErrors_XML_SCHEMAP_CT_PROPS_CORRECT_4 : xmlParserErrors = 1785 ; pub const xmlParserErrors_XML_SCHEMAP_CT_PROPS_CORRECT_5 : xmlParserErrors = 1786 ; pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1 : xmlParserErrors = 1787 ; pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1 : xmlParserErrors = 1788 ; pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2 : xmlParserErrors = 1789 ; pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2 : xmlParserErrors = 1790 ; pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3 : xmlParserErrors = 1791 ; pub const xmlParserErrors_XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER : xmlParserErrors = 1792 ; pub const xmlParserErrors_XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE : xmlParserErrors = 1793 ; pub const xmlParserErrors_XML_SCHEMAP_UNION_NOT_EXPRESSIBLE : xmlParserErrors = 1794 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_3_1 : xmlParserErrors = 1795 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_3_2 : xmlParserErrors = 1796 ; pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1 : xmlParserErrors = 1797 ; pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2 : xmlParserErrors = 1798 ; pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3 : xmlParserErrors = 1799 ; pub const xmlParserErrors_XML_SCHEMAP_COS_CT_EXTENDS_1_3 : xmlParserErrors = 1800 ; pub const xmlParserErrors_XML_SCHEMAV_NOROOT : xmlParserErrors = 1801 ; pub const xmlParserErrors_XML_SCHEMAV_UNDECLAREDELEM : xmlParserErrors = 1802 ; pub const xmlParserErrors_XML_SCHEMAV_NOTTOPLEVEL : xmlParserErrors = 1803 ; pub const xmlParserErrors_XML_SCHEMAV_MISSING : xmlParserErrors = 1804 ; pub const xmlParserErrors_XML_SCHEMAV_WRONGELEM : xmlParserErrors = 1805 ; pub const xmlParserErrors_XML_SCHEMAV_NOTYPE : xmlParserErrors = 1806 ; pub const xmlParserErrors_XML_SCHEMAV_NOROLLBACK : xmlParserErrors = 1807 ; pub const xmlParserErrors_XML_SCHEMAV_ISABSTRACT : xmlParserErrors = 1808 ; pub const xmlParserErrors_XML_SCHEMAV_NOTEMPTY : xmlParserErrors = 1809 ; pub const xmlParserErrors_XML_SCHEMAV_ELEMCONT : xmlParserErrors = 1810 ; pub const xmlParserErrors_XML_SCHEMAV_HAVEDEFAULT : xmlParserErrors = 1811 ; pub const xmlParserErrors_XML_SCHEMAV_NOTNILLABLE : xmlParserErrors = 1812 ; pub const xmlParserErrors_XML_SCHEMAV_EXTRACONTENT : xmlParserErrors = 1813 ; pub const xmlParserErrors_XML_SCHEMAV_INVALIDATTR : xmlParserErrors = 1814 ; pub const xmlParserErrors_XML_SCHEMAV_INVALIDELEM : xmlParserErrors = 1815 ; pub const xmlParserErrors_XML_SCHEMAV_NOTDETERMINIST : xmlParserErrors = 1816 ; pub const xmlParserErrors_XML_SCHEMAV_CONSTRUCT : xmlParserErrors = 1817 ; pub const xmlParserErrors_XML_SCHEMAV_INTERNAL : xmlParserErrors = 1818 ; pub const xmlParserErrors_XML_SCHEMAV_NOTSIMPLE : xmlParserErrors = 1819 ; pub const xmlParserErrors_XML_SCHEMAV_ATTRUNKNOWN : xmlParserErrors = 1820 ; pub const xmlParserErrors_XML_SCHEMAV_ATTRINVALID : xmlParserErrors = 1821 ; pub const xmlParserErrors_XML_SCHEMAV_VALUE : xmlParserErrors = 1822 ; pub const xmlParserErrors_XML_SCHEMAV_FACET : xmlParserErrors = 1823 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1 : xmlParserErrors = 1824 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2 : xmlParserErrors = 1825 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3 : xmlParserErrors = 1826 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_TYPE_3_1_1 : xmlParserErrors = 1827 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_TYPE_3_1_2 : xmlParserErrors = 1828 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_FACET_VALID : xmlParserErrors = 1829 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_LENGTH_VALID : xmlParserErrors = 1830 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_MINLENGTH_VALID : xmlParserErrors = 1831 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_MAXLENGTH_VALID : xmlParserErrors = 1832 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_MININCLUSIVE_VALID : xmlParserErrors = 1833 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_MAXINCLUSIVE_VALID : xmlParserErrors = 1834 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_MINEXCLUSIVE_VALID : xmlParserErrors = 1835 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_MAXEXCLUSIVE_VALID : xmlParserErrors = 1836 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_TOTALDIGITS_VALID : xmlParserErrors = 1837 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_FRACTIONDIGITS_VALID : xmlParserErrors = 1838 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_PATTERN_VALID : xmlParserErrors = 1839 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_ENUMERATION_VALID : xmlParserErrors = 1840 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1 : xmlParserErrors = 1841 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2 : xmlParserErrors = 1842 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3 : xmlParserErrors = 1843 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_2_4 : xmlParserErrors = 1844 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_1 : xmlParserErrors = 1845 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_2 : xmlParserErrors = 1846 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_3_1 : xmlParserErrors = 1847 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_3_2_1 : xmlParserErrors = 1848 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_3_2_2 : xmlParserErrors = 1849 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_4_1 : xmlParserErrors = 1850 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_4_2 : xmlParserErrors = 1851 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_4_3 : xmlParserErrors = 1852 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_1_1 : xmlParserErrors = 1853 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_1_2 : xmlParserErrors = 1854 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_2_1 : xmlParserErrors = 1855 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_2_2_1 : xmlParserErrors = 1856 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_2_2_2_1 : xmlParserErrors = 1857 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_5_2_2_2_2 : xmlParserErrors = 1858 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_6 : xmlParserErrors = 1859 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_ELT_7 : xmlParserErrors = 1860 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_ATTRIBUTE_1 : xmlParserErrors = 1861 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_ATTRIBUTE_2 : xmlParserErrors = 1862 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_ATTRIBUTE_3 : xmlParserErrors = 1863 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_ATTRIBUTE_4 : xmlParserErrors = 1864 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_3_1 : xmlParserErrors = 1865 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1 : xmlParserErrors = 1866 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2 : xmlParserErrors = 1867 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_4 : xmlParserErrors = 1868 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_5_1 : xmlParserErrors = 1869 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_5_2 : xmlParserErrors = 1870 ; pub const xmlParserErrors_XML_SCHEMAV_ELEMENT_CONTENT : xmlParserErrors = 1871 ; pub const xmlParserErrors_XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING : xmlParserErrors = 1872 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_COMPLEX_TYPE_1 : xmlParserErrors = 1873 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_AU : xmlParserErrors = 1874 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_TYPE_1 : xmlParserErrors = 1875 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_TYPE_2 : xmlParserErrors = 1876 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_IDC : xmlParserErrors = 1877 ; pub const xmlParserErrors_XML_SCHEMAV_CVC_WILDCARD : xmlParserErrors = 1878 ; pub const xmlParserErrors_XML_SCHEMAV_MISC : xmlParserErrors = 1879 ; pub const xmlParserErrors_XML_XPTR_UNKNOWN_SCHEME : xmlParserErrors = 1900 ; pub const xmlParserErrors_XML_XPTR_CHILDSEQ_START : xmlParserErrors = 1901 ; pub const xmlParserErrors_XML_XPTR_EVAL_FAILED : xmlParserErrors = 1902 ; pub const xmlParserErrors_XML_XPTR_EXTRA_OBJECTS : xmlParserErrors = 1903 ; pub const xmlParserErrors_XML_C14N_CREATE_CTXT : xmlParserErrors = 1950 ; pub const xmlParserErrors_XML_C14N_REQUIRES_UTF8 : xmlParserErrors = 1951 ; pub const xmlParserErrors_XML_C14N_CREATE_STACK : xmlParserErrors = 1952 ; pub const xmlParserErrors_XML_C14N_INVALID_NODE : xmlParserErrors = 1953 ; pub const xmlParserErrors_XML_C14N_UNKNOW_NODE : xmlParserErrors = 1954 ; pub const xmlParserErrors_XML_C14N_RELATIVE_NAMESPACE : xmlParserErrors = 1955 ; pub const xmlParserErrors_XML_FTP_PASV_ANSWER : xmlParserErrors = 2000 ; pub const xmlParserErrors_XML_FTP_EPSV_ANSWER : xmlParserErrors = 2001 ; pub const xmlParserErrors_XML_FTP_ACCNT : xmlParserErrors = 2002 ; pub const xmlParserErrors_XML_FTP_URL_SYNTAX : xmlParserErrors = 2003 ; pub const xmlParserErrors_XML_HTTP_URL_SYNTAX : xmlParserErrors = 2020 ; pub const xmlParserErrors_XML_HTTP_USE_IP : xmlParserErrors = 2021 ; pub const xmlParserErrors_XML_HTTP_UNKNOWN_HOST : xmlParserErrors = 2022 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_SIMPLE_TYPE_1 : xmlParserErrors = 3000 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_SIMPLE_TYPE_2 : xmlParserErrors = 3001 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_SIMPLE_TYPE_3 : xmlParserErrors = 3002 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_SIMPLE_TYPE_4 : xmlParserErrors = 3003 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_RESOLVE : xmlParserErrors = 3004 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE : xmlParserErrors = 3005 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_LIST_ITEMTYPE_OR_SIMPLETYPE : xmlParserErrors = 3006 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES : xmlParserErrors = 3007 ; pub const xmlParserErrors_XML_SCHEMAP_ST_PROPS_CORRECT_1 : xmlParserErrors = 3008 ; pub const xmlParserErrors_XML_SCHEMAP_ST_PROPS_CORRECT_2 : xmlParserErrors = 3009 ; pub const xmlParserErrors_XML_SCHEMAP_ST_PROPS_CORRECT_3 : xmlParserErrors = 3010 ; pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_1_1 : xmlParserErrors = 3011 ; pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_1_2 : xmlParserErrors = 3012 ; pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1 : xmlParserErrors = 3013 ; pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_1_3_2 : xmlParserErrors = 3014 ; pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_1 : xmlParserErrors = 3015 ; pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1 : xmlParserErrors = 3016 ; pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2 : xmlParserErrors = 3017 ; pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1 : xmlParserErrors = 3018 ; pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2 : xmlParserErrors = 3019 ; pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3 : xmlParserErrors = 3020 ; pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4 : xmlParserErrors = 3021 ; pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_5 : xmlParserErrors = 3022 ; pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_1 : xmlParserErrors = 3023 ; pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1 : xmlParserErrors = 3024 ; pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2 : xmlParserErrors = 3025 ; pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2 : xmlParserErrors = 3026 ; pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1 : xmlParserErrors = 3027 ; pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3 : xmlParserErrors = 3028 ; pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4 : xmlParserErrors = 3029 ; pub const xmlParserErrors_XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_5 : xmlParserErrors = 3030 ; pub const xmlParserErrors_XML_SCHEMAP_COS_ST_DERIVED_OK_2_1 : xmlParserErrors = 3031 ; pub const xmlParserErrors_XML_SCHEMAP_COS_ST_DERIVED_OK_2_2 : xmlParserErrors = 3032 ; pub const xmlParserErrors_XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED : xmlParserErrors = 3033 ; pub const xmlParserErrors_XML_SCHEMAP_S4S_ELEM_MISSING : xmlParserErrors = 3034 ; pub const xmlParserErrors_XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED : xmlParserErrors = 3035 ; pub const xmlParserErrors_XML_SCHEMAP_S4S_ATTR_MISSING : xmlParserErrors = 3036 ; pub const xmlParserErrors_XML_SCHEMAP_S4S_ATTR_INVALID_VALUE : xmlParserErrors = 3037 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_ELEMENT_1 : xmlParserErrors = 3038 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_ELEMENT_2_1 : xmlParserErrors = 3039 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_ELEMENT_2_2 : xmlParserErrors = 3040 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_ELEMENT_3 : xmlParserErrors = 3041 ; pub const xmlParserErrors_XML_SCHEMAP_P_PROPS_CORRECT_1 : xmlParserErrors = 3042 ; pub const xmlParserErrors_XML_SCHEMAP_P_PROPS_CORRECT_2_1 : xmlParserErrors = 3043 ; pub const xmlParserErrors_XML_SCHEMAP_P_PROPS_CORRECT_2_2 : xmlParserErrors = 3044 ; pub const xmlParserErrors_XML_SCHEMAP_E_PROPS_CORRECT_2 : xmlParserErrors = 3045 ; pub const xmlParserErrors_XML_SCHEMAP_E_PROPS_CORRECT_3 : xmlParserErrors = 3046 ; pub const xmlParserErrors_XML_SCHEMAP_E_PROPS_CORRECT_4 : xmlParserErrors = 3047 ; pub const xmlParserErrors_XML_SCHEMAP_E_PROPS_CORRECT_5 : xmlParserErrors = 3048 ; pub const xmlParserErrors_XML_SCHEMAP_E_PROPS_CORRECT_6 : xmlParserErrors = 3049 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_INCLUDE : xmlParserErrors = 3050 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_1 : xmlParserErrors = 3051 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_2 : xmlParserErrors = 3052 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_3_1 : xmlParserErrors = 3053 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_3_2 : xmlParserErrors = 3054 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_4 : xmlParserErrors = 3055 ; pub const xmlParserErrors_XML_SCHEMAP_NO_XMLNS : xmlParserErrors = 3056 ; pub const xmlParserErrors_XML_SCHEMAP_NO_XSI : xmlParserErrors = 3057 ; pub const xmlParserErrors_XML_SCHEMAP_COS_VALID_DEFAULT_1 : xmlParserErrors = 3058 ; pub const xmlParserErrors_XML_SCHEMAP_COS_VALID_DEFAULT_2_1 : xmlParserErrors = 3059 ; pub const xmlParserErrors_XML_SCHEMAP_COS_VALID_DEFAULT_2_2_1 : xmlParserErrors = 3060 ; pub const xmlParserErrors_XML_SCHEMAP_COS_VALID_DEFAULT_2_2_2 : xmlParserErrors = 3061 ; pub const xmlParserErrors_XML_SCHEMAP_CVC_SIMPLE_TYPE : xmlParserErrors = 3062 ; pub const xmlParserErrors_XML_SCHEMAP_COS_CT_EXTENDS_1_1 : xmlParserErrors = 3063 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_1_1 : xmlParserErrors = 3064 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_1_2 : xmlParserErrors = 3065 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_2 : xmlParserErrors = 3066 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_2_1 : xmlParserErrors = 3067 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT_2_2 : xmlParserErrors = 3068 ; pub const xmlParserErrors_XML_SCHEMAP_INTERNAL : xmlParserErrors = 3069 ; pub const xmlParserErrors_XML_SCHEMAP_NOT_DETERMINISTIC : xmlParserErrors = 3070 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_1 : xmlParserErrors = 3071 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_2 : xmlParserErrors = 3072 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3 : xmlParserErrors = 3073 ; pub const xmlParserErrors_XML_SCHEMAP_MG_PROPS_CORRECT_1 : xmlParserErrors = 3074 ; pub const xmlParserErrors_XML_SCHEMAP_MG_PROPS_CORRECT_2 : xmlParserErrors = 3075 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_CT_1 : xmlParserErrors = 3076 ; pub const xmlParserErrors_XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3 : xmlParserErrors = 3077 ; pub const xmlParserErrors_XML_SCHEMAP_AU_PROPS_CORRECT_2 : xmlParserErrors = 3078 ; pub const xmlParserErrors_XML_SCHEMAP_A_PROPS_CORRECT_2 : xmlParserErrors = 3079 ; pub const xmlParserErrors_XML_SCHEMAP_C_PROPS_CORRECT : xmlParserErrors = 3080 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_REDEFINE : xmlParserErrors = 3081 ; pub const xmlParserErrors_XML_SCHEMAP_SRC_IMPORT : xmlParserErrors = 3082 ; pub const xmlParserErrors_XML_SCHEMAP_WARN_SKIP_SCHEMA : xmlParserErrors = 3083 ; pub const xmlParserErrors_XML_SCHEMAP_WARN_UNLOCATED_SCHEMA : xmlParserErrors = 3084 ; pub const xmlParserErrors_XML_SCHEMAP_WARN_ATTR_REDECL_PROH : xmlParserErrors = 3085 ; pub const xmlParserErrors_XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH : xmlParserErrors = 3086 ; pub const xmlParserErrors_XML_SCHEMAP_AG_PROPS_CORRECT : xmlParserErrors = 3087 ; pub const xmlParserErrors_XML_SCHEMAP_COS_CT_EXTENDS_1_2 : xmlParserErrors = 3088 ; pub const xmlParserErrors_XML_SCHEMAP_AU_PROPS_CORRECT : xmlParserErrors = 3089 ; pub const xmlParserErrors_XML_SCHEMAP_A_PROPS_CORRECT_3 : xmlParserErrors = 3090 ; pub const xmlParserErrors_XML_SCHEMAP_COS_ALL_LIMITED : xmlParserErrors = 3091 ; pub const xmlParserErrors_XML_SCHEMATRONV_ASSERT : xmlParserErrors = 4000 ; pub const xmlParserErrors_XML_SCHEMATRONV_REPORT : xmlParserErrors = 4001 ; pub const xmlParserErrors_XML_MODULE_OPEN : xmlParserErrors = 4900 ; pub const xmlParserErrors_XML_MODULE_CLOSE : xmlParserErrors = 4901 ; pub const xmlParserErrors_XML_CHECK_FOUND_ELEMENT : xmlParserErrors = 5000 ; pub const xmlParserErrors_XML_CHECK_FOUND_ATTRIBUTE : xmlParserErrors = 5001 ; pub const xmlParserErrors_XML_CHECK_FOUND_TEXT : xmlParserErrors = 5002 ; pub const xmlParserErrors_XML_CHECK_FOUND_CDATA : xmlParserErrors = 5003 ; pub const xmlParserErrors_XML_CHECK_FOUND_ENTITYREF : xmlParserErrors = 5004 ; pub const xmlParserErrors_XML_CHECK_FOUND_ENTITY : xmlParserErrors = 5005 ; pub const xmlParserErrors_XML_CHECK_FOUND_PI : xmlParserErrors = 5006 ; pub const xmlParserErrors_XML_CHECK_FOUND_COMMENT : xmlParserErrors = 5007 ; pub const xmlParserErrors_XML_CHECK_FOUND_DOCTYPE : xmlParserErrors = 5008 ; pub const xmlParserErrors_XML_CHECK_FOUND_FRAGMENT : xmlParserErrors = 5009 ; pub const xmlParserErrors_XML_CHECK_FOUND_NOTATION : xmlParserErrors = 5010 ; pub const xmlParserErrors_XML_CHECK_UNKNOWN_NODE : xmlParserErrors = 5011 ; pub const xmlParserErrors_XML_CHECK_ENTITY_TYPE : xmlParserErrors = 5012 ; pub const xmlParserErrors_XML_CHECK_NO_PARENT : xmlParserErrors = 5013 ; pub const xmlParserErrors_XML_CHECK_NO_DOC : xmlParserErrors = 5014 ; pub const xmlParserErrors_XML_CHECK_NO_NAME : xmlParserErrors = 5015 ; pub const xmlParserErrors_XML_CHECK_NO_ELEM : xmlParserErrors = 5016 ; pub const xmlParserErrors_XML_CHECK_WRONG_DOC : xmlParserErrors = 5017 ; pub const xmlParserErrors_XML_CHECK_NO_PREV : xmlParserErrors = 5018 ; pub const xmlParserErrors_XML_CHECK_WRONG_PREV : xmlParserErrors = 5019 ; pub const xmlParserErrors_XML_CHECK_NO_NEXT : xmlParserErrors = 5020 ; pub const xmlParserErrors_XML_CHECK_WRONG_NEXT : xmlParserErrors = 5021 ; pub const xmlParserErrors_XML_CHECK_NOT_DTD : xmlParserErrors = 5022 ; pub const xmlParserErrors_XML_CHECK_NOT_ATTR : xmlParserErrors = 5023 ; pub const xmlParserErrors_XML_CHECK_NOT_ATTR_DECL : xmlParserErrors = 5024 ; pub const xmlParserErrors_XML_CHECK_NOT_ELEM_DECL : xmlParserErrors = 5025 ; pub const xmlParserErrors_XML_CHECK_NOT_ENTITY_DECL : xmlParserErrors = 5026 ; pub const xmlParserErrors_XML_CHECK_NOT_NS_DECL : xmlParserErrors = 5027 ; pub const xmlParserErrors_XML_CHECK_NO_HREF : xmlParserErrors = 5028 ; pub const xmlParserErrors_XML_CHECK_WRONG_PARENT : xmlParserErrors = 5029 ; pub const xmlParserErrors_XML_CHECK_NS_SCOPE : xmlParserErrors = 5030 ; pub const xmlParserErrors_XML_CHECK_NS_ANCESTOR : xmlParserErrors = 5031 ; pub const xmlParserErrors_XML_CHECK_NOT_UTF8 : xmlParserErrors = 5032 ; pub const xmlParserErrors_XML_CHECK_NO_DICT : xmlParserErrors = 5033 ; pub const xmlParserErrors_XML_CHECK_NOT_NCNAME : xmlParserErrors = 5034 ; pub const xmlParserErrors_XML_CHECK_OUTSIDE_DICT : xmlParserErrors = 5035 ; pub const xmlParserErrors_XML_CHECK_WRONG_NAME : xmlParserErrors = 5036 ; pub const xmlParserErrors_XML_CHECK_NAME_NOT_NULL : xmlParserErrors = 5037 ; pub const xmlParserErrors_XML_I18N_NO_NAME : xmlParserErrors = 6000 ; pub const xmlParserErrors_XML_I18N_NO_HANDLER : xmlParserErrors = 6001 ; pub const xmlParserErrors_XML_I18N_EXCESS_HANDLER : xmlParserErrors = 6002 ; pub const xmlParserErrors_XML_I18N_CONV_FAILED : xmlParserErrors = 6003 ; pub const xmlParserErrors_XML_I18N_NO_OUTPUT : xmlParserErrors = 6004 ; pub const xmlParserErrors_XML_BUF_OVERFLOW : xmlParserErrors = 7000 ; pub type xmlParserErrors = :: std :: os :: raw :: c_uint ;
/// xmlGenericErrorFunc:
/// @ctx:  a parsing context
/// @msg:  the message
/// @...:  the extra arguments of the varags to format the message
///
/// Signature of the function to use when there is an error and
/// no parsing or validity context available .
pub type xmlGenericErrorFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , msg : * const :: std :: os :: raw :: c_char ) > ;
/// xmlStructuredErrorFunc:
/// @userData:  user provided data for the error callback
/// @error:  the error being raised.
///
/// Signature of the function to use when there is an error and
/// the module handles the new error reporting mechanism.
pub type xmlStructuredErrorFunc = :: std :: option :: Option < unsafe extern "C" fn ( userData : * mut :: std :: os :: raw :: c_void , error : xmlErrorPtr ) > ; extern "C" {
    # [ link_name = "\u{1}_xmlSetGenericErrorFunc" ]
    pub fn xmlSetGenericErrorFunc ( ctx : * mut :: std :: os :: raw :: c_void , handler : xmlGenericErrorFunc , ) ;
} extern "C" {
    # [ link_name = "\u{1}_initGenericErrorDefaultFunc" ]
    pub fn initGenericErrorDefaultFunc ( handler : * mut xmlGenericErrorFunc , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSetStructuredErrorFunc" ]
    pub fn xmlSetStructuredErrorFunc ( ctx : * mut :: std :: os :: raw :: c_void , handler : xmlStructuredErrorFunc , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserError" ]
    pub fn xmlParserError ( ctx : * mut :: std :: os :: raw :: c_void , msg : * const :: std :: os :: raw :: c_char , ... ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserWarning" ]
    pub fn xmlParserWarning ( ctx : * mut :: std :: os :: raw :: c_void , msg : * const :: std :: os :: raw :: c_char , ... ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserValidityError" ]
    pub fn xmlParserValidityError ( ctx : * mut :: std :: os :: raw :: c_void , msg : * const :: std :: os :: raw :: c_char , ... ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserValidityWarning" ]
    pub fn xmlParserValidityWarning ( ctx : * mut :: std :: os :: raw :: c_void , msg : * const :: std :: os :: raw :: c_char , ... ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserPrintFileInfo" ]
    pub fn xmlParserPrintFileInfo ( input : xmlParserInputPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserPrintFileContext" ]
    pub fn xmlParserPrintFileContext ( input : xmlParserInputPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetLastError" ]
    pub fn xmlGetLastError ( ) -> xmlErrorPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlResetLastError" ]
    pub fn xmlResetLastError ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCtxtGetLastError" ]
    pub fn xmlCtxtGetLastError ( ctx : * mut :: std :: os :: raw :: c_void , ) -> xmlErrorPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCtxtResetLastError" ]
    pub fn xmlCtxtResetLastError ( ctx : * mut :: std :: os :: raw :: c_void , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlResetError" ]
    pub fn xmlResetError ( err : xmlErrorPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCopyError" ]
    pub fn xmlCopyError ( from : xmlErrorPtr , to : xmlErrorPtr , ) -> :: std :: os :: raw :: c_int ;
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlLink { _unused : [ u8 ; 0 ] } pub type xmlLink = _xmlLink ; pub type xmlLinkPtr = * mut xmlLink ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlList { _unused : [ u8 ; 0 ] } pub type xmlList = _xmlList ; pub type xmlListPtr = * mut xmlList ;
/// xmlListDeallocator:
/// @lk:  the data to deallocate
///
/// Callback function used to free data from a list.
pub type xmlListDeallocator = :: std :: option :: Option < unsafe extern "C" fn ( lk : xmlLinkPtr ) > ;
/// xmlListDataCompare:
/// @data0: the first data
/// @data1: the second data
///
/// Callback function used to compare 2 data.
///
/// Returns 0 is equality, -1 or 1 otherwise depending on the ordering.
pub type xmlListDataCompare = :: std :: option :: Option < unsafe extern "C" fn ( data0 : * const :: std :: os :: raw :: c_void , data1 : * const :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ;
/// xmlListWalker:
/// @data: the data found in the list
/// @user: extra user provided data to the walker
///
/// Callback function used when walking a list with xmlListWalk().
///
/// Returns 0 to stop walking the list, 1 otherwise.
pub type xmlListWalker = :: std :: option :: Option < unsafe extern "C" fn ( data : * const :: std :: os :: raw :: c_void , user : * const :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; extern "C" {
    # [ link_name = "\u{1}_xmlListCreate" ]
    pub fn xmlListCreate ( deallocator : xmlListDeallocator , compare : xmlListDataCompare , ) -> xmlListPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListDelete" ]
    pub fn xmlListDelete ( l : xmlListPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListSearch" ]
    pub fn xmlListSearch ( l : xmlListPtr , data : * mut :: std :: os :: raw :: c_void , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListReverseSearch" ]
    pub fn xmlListReverseSearch ( l : xmlListPtr , data : * mut :: std :: os :: raw :: c_void , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListInsert" ]
    pub fn xmlListInsert ( l : xmlListPtr , data : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListAppend" ]
    pub fn xmlListAppend ( l : xmlListPtr , data : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListRemoveFirst" ]
    pub fn xmlListRemoveFirst ( l : xmlListPtr , data : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListRemoveLast" ]
    pub fn xmlListRemoveLast ( l : xmlListPtr , data : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListRemoveAll" ]
    pub fn xmlListRemoveAll ( l : xmlListPtr , data : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListClear" ]
    pub fn xmlListClear ( l : xmlListPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListEmpty" ]
    pub fn xmlListEmpty ( l : xmlListPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListFront" ]
    pub fn xmlListFront ( l : xmlListPtr , ) -> xmlLinkPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListEnd" ]
    pub fn xmlListEnd ( l : xmlListPtr , ) -> xmlLinkPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListSize" ]
    pub fn xmlListSize ( l : xmlListPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListPopFront" ]
    pub fn xmlListPopFront ( l : xmlListPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListPopBack" ]
    pub fn xmlListPopBack ( l : xmlListPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListPushFront" ]
    pub fn xmlListPushFront ( l : xmlListPtr , data : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListPushBack" ]
    pub fn xmlListPushBack ( l : xmlListPtr , data : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListReverse" ]
    pub fn xmlListReverse ( l : xmlListPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListSort" ]
    pub fn xmlListSort ( l : xmlListPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListWalk" ]
    pub fn xmlListWalk ( l : xmlListPtr , walker : xmlListWalker , user : * const :: std :: os :: raw :: c_void , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListReverseWalk" ]
    pub fn xmlListReverseWalk ( l : xmlListPtr , walker : xmlListWalker , user : * const :: std :: os :: raw :: c_void , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListMerge" ]
    pub fn xmlListMerge ( l1 : xmlListPtr , l2 : xmlListPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListDup" ]
    pub fn xmlListDup ( old : xmlListPtr , ) -> xmlListPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlListCopy" ]
    pub fn xmlListCopy ( cur : xmlListPtr , old : xmlListPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlLinkGetData" ]
    pub fn xmlLinkGetData ( lk : xmlLinkPtr , ) -> * mut :: std :: os :: raw :: c_void ;
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlAutomata { _unused : [ u8 ; 0 ] }
/// xmlAutomataPtr:
///
/// A libxml automata description, It can be compiled into a regexp
pub type xmlAutomata = _xmlAutomata ; pub type xmlAutomataPtr = * mut xmlAutomata ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlAutomataState { _unused : [ u8 ; 0 ] }
/// xmlAutomataStatePtr:
///
/// A state int the automata description,
pub type xmlAutomataState = _xmlAutomataState ; pub type xmlAutomataStatePtr = * mut xmlAutomataState ; extern "C" {
    # [ link_name = "\u{1}_xmlNewAutomata" ]
    pub fn xmlNewAutomata ( ) -> xmlAutomataPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFreeAutomata" ]
    pub fn xmlFreeAutomata ( am : xmlAutomataPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAutomataGetInitState" ]
    pub fn xmlAutomataGetInitState ( am : xmlAutomataPtr , ) -> xmlAutomataStatePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAutomataSetFinalState" ]
    pub fn xmlAutomataSetFinalState ( am : xmlAutomataPtr , state : xmlAutomataStatePtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAutomataNewState" ]
    pub fn xmlAutomataNewState ( am : xmlAutomataPtr , ) -> xmlAutomataStatePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAutomataNewTransition" ]
    pub fn xmlAutomataNewTransition ( am : xmlAutomataPtr , from : xmlAutomataStatePtr , to : xmlAutomataStatePtr , token : * const xmlChar , data : * mut :: std :: os :: raw :: c_void , ) -> xmlAutomataStatePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAutomataNewTransition2" ]
    pub fn xmlAutomataNewTransition2 ( am : xmlAutomataPtr , from : xmlAutomataStatePtr , to : xmlAutomataStatePtr , token : * const xmlChar , token2 : * const xmlChar , data : * mut :: std :: os :: raw :: c_void , ) -> xmlAutomataStatePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAutomataNewNegTrans" ]
    pub fn xmlAutomataNewNegTrans ( am : xmlAutomataPtr , from : xmlAutomataStatePtr , to : xmlAutomataStatePtr , token : * const xmlChar , token2 : * const xmlChar , data : * mut :: std :: os :: raw :: c_void , ) -> xmlAutomataStatePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAutomataNewCountTrans" ]
    pub fn xmlAutomataNewCountTrans ( am : xmlAutomataPtr , from : xmlAutomataStatePtr , to : xmlAutomataStatePtr , token : * const xmlChar , min : :: std :: os :: raw :: c_int , max : :: std :: os :: raw :: c_int , data : * mut :: std :: os :: raw :: c_void , ) -> xmlAutomataStatePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAutomataNewCountTrans2" ]
    pub fn xmlAutomataNewCountTrans2 ( am : xmlAutomataPtr , from : xmlAutomataStatePtr , to : xmlAutomataStatePtr , token : * const xmlChar , token2 : * const xmlChar , min : :: std :: os :: raw :: c_int , max : :: std :: os :: raw :: c_int , data : * mut :: std :: os :: raw :: c_void , ) -> xmlAutomataStatePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAutomataNewOnceTrans" ]
    pub fn xmlAutomataNewOnceTrans ( am : xmlAutomataPtr , from : xmlAutomataStatePtr , to : xmlAutomataStatePtr , token : * const xmlChar , min : :: std :: os :: raw :: c_int , max : :: std :: os :: raw :: c_int , data : * mut :: std :: os :: raw :: c_void , ) -> xmlAutomataStatePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAutomataNewOnceTrans2" ]
    pub fn xmlAutomataNewOnceTrans2 ( am : xmlAutomataPtr , from : xmlAutomataStatePtr , to : xmlAutomataStatePtr , token : * const xmlChar , token2 : * const xmlChar , min : :: std :: os :: raw :: c_int , max : :: std :: os :: raw :: c_int , data : * mut :: std :: os :: raw :: c_void , ) -> xmlAutomataStatePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAutomataNewAllTrans" ]
    pub fn xmlAutomataNewAllTrans ( am : xmlAutomataPtr , from : xmlAutomataStatePtr , to : xmlAutomataStatePtr , lax : :: std :: os :: raw :: c_int , ) -> xmlAutomataStatePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAutomataNewEpsilon" ]
    pub fn xmlAutomataNewEpsilon ( am : xmlAutomataPtr , from : xmlAutomataStatePtr , to : xmlAutomataStatePtr , ) -> xmlAutomataStatePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAutomataNewCountedTrans" ]
    pub fn xmlAutomataNewCountedTrans ( am : xmlAutomataPtr , from : xmlAutomataStatePtr , to : xmlAutomataStatePtr , counter : :: std :: os :: raw :: c_int , ) -> xmlAutomataStatePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAutomataNewCounterTrans" ]
    pub fn xmlAutomataNewCounterTrans ( am : xmlAutomataPtr , from : xmlAutomataStatePtr , to : xmlAutomataStatePtr , counter : :: std :: os :: raw :: c_int , ) -> xmlAutomataStatePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAutomataNewCounter" ]
    pub fn xmlAutomataNewCounter ( am : xmlAutomataPtr , min : :: std :: os :: raw :: c_int , max : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAutomataCompile" ]
    pub fn xmlAutomataCompile ( am : xmlAutomataPtr , ) -> xmlRegexpPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAutomataIsDeterminist" ]
    pub fn xmlAutomataIsDeterminist ( am : xmlAutomataPtr , ) -> :: std :: os :: raw :: c_int ;
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlValidState { _unused : [ u8 ; 0 ] } pub type xmlValidState = _xmlValidState ; pub type xmlValidStatePtr = * mut xmlValidState ;
/// xmlValidityErrorFunc:
/// @ctx:  usually an xmlValidCtxtPtr to a validity error context,
/// but comes from ctxt->userData (which normally contains such
/// a pointer); ctxt->userData can be changed by the user.
/// @msg:  the string to format *printf like vararg
/// @...:  remaining arguments to the format
///
/// Callback called when a validity error is found. This is a message
/// oriented function similar to an *printf function.
pub type xmlValidityErrorFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , msg : * const :: std :: os :: raw :: c_char ) > ;
/// xmlValidityWarningFunc:
/// @ctx:  usually an xmlValidCtxtPtr to a validity error context,
/// but comes from ctxt->userData (which normally contains such
/// a pointer); ctxt->userData can be changed by the user.
/// @msg:  the string to format *printf like vararg
/// @...:  remaining arguments to the format
///
/// Callback called when a validity warning is found. This is a message
/// oriented function similar to an *printf function.
pub type xmlValidityWarningFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , msg : * const :: std :: os :: raw :: c_char ) > ; pub type xmlValidCtxt = _xmlValidCtxt ; pub type xmlValidCtxtPtr = * mut xmlValidCtxt ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlValidCtxt { pub userData : * mut :: std :: os :: raw :: c_void , pub error : xmlValidityErrorFunc , pub warning : xmlValidityWarningFunc , pub node : xmlNodePtr , pub nodeNr : :: std :: os :: raw :: c_int , pub nodeMax : :: std :: os :: raw :: c_int , pub nodeTab : * mut xmlNodePtr , pub finishDtd : :: std :: os :: raw :: c_uint , pub doc : xmlDocPtr , pub valid : :: std :: os :: raw :: c_int , pub vstate : * mut xmlValidState , pub vstateNr : :: std :: os :: raw :: c_int , pub vstateMax : :: std :: os :: raw :: c_int , pub vstateTab : * mut xmlValidState , pub am : xmlAutomataPtr , pub state : xmlAutomataStatePtr , } # [ test ] fn bindgen_test_layout__xmlValidCtxt ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlValidCtxt > ( ) , 112usize , concat ! ( "Size of: " , stringify ! ( _xmlValidCtxt ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlValidCtxt > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlValidCtxt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlValidCtxt ) ) . userData as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlValidCtxt ) , "::" , stringify ! ( userData ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlValidCtxt ) ) . error as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlValidCtxt ) , "::" , stringify ! ( error ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlValidCtxt ) ) . warning as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlValidCtxt ) , "::" , stringify ! ( warning ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlValidCtxt ) ) . node as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlValidCtxt ) , "::" , stringify ! ( node ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlValidCtxt ) ) . nodeNr as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlValidCtxt ) , "::" , stringify ! ( nodeNr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlValidCtxt ) ) . nodeMax as * const _ as usize } , 36usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlValidCtxt ) , "::" , stringify ! ( nodeMax ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlValidCtxt ) ) . nodeTab as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlValidCtxt ) , "::" , stringify ! ( nodeTab ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlValidCtxt ) ) . finishDtd as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlValidCtxt ) , "::" , stringify ! ( finishDtd ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlValidCtxt ) ) . doc as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlValidCtxt ) , "::" , stringify ! ( doc ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlValidCtxt ) ) . valid as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlValidCtxt ) , "::" , stringify ! ( valid ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlValidCtxt ) ) . vstate as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlValidCtxt ) , "::" , stringify ! ( vstate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlValidCtxt ) ) . vstateNr as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlValidCtxt ) , "::" , stringify ! ( vstateNr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlValidCtxt ) ) . vstateMax as * const _ as usize } , 84usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlValidCtxt ) , "::" , stringify ! ( vstateMax ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlValidCtxt ) ) . vstateTab as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlValidCtxt ) , "::" , stringify ! ( vstateTab ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlValidCtxt ) ) . am as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlValidCtxt ) , "::" , stringify ! ( am ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlValidCtxt ) ) . state as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlValidCtxt ) , "::" , stringify ! ( state ) ) ) ; } pub type xmlNotationTable = _xmlHashTable ; pub type xmlNotationTablePtr = * mut xmlNotationTable ; pub type xmlElementTable = _xmlHashTable ; pub type xmlElementTablePtr = * mut xmlElementTable ; pub type xmlAttributeTable = _xmlHashTable ; pub type xmlAttributeTablePtr = * mut xmlAttributeTable ; pub type xmlIDTable = _xmlHashTable ; pub type xmlIDTablePtr = * mut xmlIDTable ; pub type xmlRefTable = _xmlHashTable ; pub type xmlRefTablePtr = * mut xmlRefTable ; extern "C" {
    # [ link_name = "\u{1}_xmlAddNotationDecl" ]
    pub fn xmlAddNotationDecl ( ctxt : xmlValidCtxtPtr , dtd : xmlDtdPtr , name : * const xmlChar , PublicID : * const xmlChar , SystemID : * const xmlChar , ) -> xmlNotationPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCopyNotationTable" ]
    pub fn xmlCopyNotationTable ( table : xmlNotationTablePtr , ) -> xmlNotationTablePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFreeNotationTable" ]
    pub fn xmlFreeNotationTable ( table : xmlNotationTablePtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDumpNotationDecl" ]
    pub fn xmlDumpNotationDecl ( buf : xmlBufferPtr , nota : xmlNotationPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDumpNotationTable" ]
    pub fn xmlDumpNotationTable ( buf : xmlBufferPtr , table : xmlNotationTablePtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewElementContent" ]
    pub fn xmlNewElementContent ( name : * const xmlChar , type_ : xmlElementContentType , ) -> xmlElementContentPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCopyElementContent" ]
    pub fn xmlCopyElementContent ( content : xmlElementContentPtr , ) -> xmlElementContentPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFreeElementContent" ]
    pub fn xmlFreeElementContent ( cur : xmlElementContentPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewDocElementContent" ]
    pub fn xmlNewDocElementContent ( doc : xmlDocPtr , name : * const xmlChar , type_ : xmlElementContentType , ) -> xmlElementContentPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCopyDocElementContent" ]
    pub fn xmlCopyDocElementContent ( doc : xmlDocPtr , content : xmlElementContentPtr , ) -> xmlElementContentPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFreeDocElementContent" ]
    pub fn xmlFreeDocElementContent ( doc : xmlDocPtr , cur : xmlElementContentPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSnprintfElementContent" ]
    pub fn xmlSnprintfElementContent ( buf : * mut :: std :: os :: raw :: c_char , size : :: std :: os :: raw :: c_int , content : xmlElementContentPtr , englob : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSprintfElementContent" ]
    pub fn xmlSprintfElementContent ( buf : * mut :: std :: os :: raw :: c_char , content : xmlElementContentPtr , englob : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAddElementDecl" ]
    pub fn xmlAddElementDecl ( ctxt : xmlValidCtxtPtr , dtd : xmlDtdPtr , name : * const xmlChar , type_ : xmlElementTypeVal , content : xmlElementContentPtr , ) -> xmlElementPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCopyElementTable" ]
    pub fn xmlCopyElementTable ( table : xmlElementTablePtr , ) -> xmlElementTablePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFreeElementTable" ]
    pub fn xmlFreeElementTable ( table : xmlElementTablePtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDumpElementTable" ]
    pub fn xmlDumpElementTable ( buf : xmlBufferPtr , table : xmlElementTablePtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDumpElementDecl" ]
    pub fn xmlDumpElementDecl ( buf : xmlBufferPtr , elem : xmlElementPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCreateEnumeration" ]
    pub fn xmlCreateEnumeration ( name : * const xmlChar , ) -> xmlEnumerationPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFreeEnumeration" ]
    pub fn xmlFreeEnumeration ( cur : xmlEnumerationPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCopyEnumeration" ]
    pub fn xmlCopyEnumeration ( cur : xmlEnumerationPtr , ) -> xmlEnumerationPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAddAttributeDecl" ]
    pub fn xmlAddAttributeDecl ( ctxt : xmlValidCtxtPtr , dtd : xmlDtdPtr , elem : * const xmlChar , name : * const xmlChar , ns : * const xmlChar , type_ : xmlAttributeType , def : xmlAttributeDefault , defaultValue : * const xmlChar , tree : xmlEnumerationPtr , ) -> xmlAttributePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCopyAttributeTable" ]
    pub fn xmlCopyAttributeTable ( table : xmlAttributeTablePtr , ) -> xmlAttributeTablePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFreeAttributeTable" ]
    pub fn xmlFreeAttributeTable ( table : xmlAttributeTablePtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDumpAttributeTable" ]
    pub fn xmlDumpAttributeTable ( buf : xmlBufferPtr , table : xmlAttributeTablePtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDumpAttributeDecl" ]
    pub fn xmlDumpAttributeDecl ( buf : xmlBufferPtr , attr : xmlAttributePtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAddID" ]
    pub fn xmlAddID ( ctxt : xmlValidCtxtPtr , doc : xmlDocPtr , value : * const xmlChar , attr : xmlAttrPtr , ) -> xmlIDPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFreeIDTable" ]
    pub fn xmlFreeIDTable ( table : xmlIDTablePtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetID" ]
    pub fn xmlGetID ( doc : xmlDocPtr , ID : * const xmlChar , ) -> xmlAttrPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlIsID" ]
    pub fn xmlIsID ( doc : xmlDocPtr , elem : xmlNodePtr , attr : xmlAttrPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRemoveID" ]
    pub fn xmlRemoveID ( doc : xmlDocPtr , attr : xmlAttrPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAddRef" ]
    pub fn xmlAddRef ( ctxt : xmlValidCtxtPtr , doc : xmlDocPtr , value : * const xmlChar , attr : xmlAttrPtr , ) -> xmlRefPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFreeRefTable" ]
    pub fn xmlFreeRefTable ( table : xmlRefTablePtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlIsRef" ]
    pub fn xmlIsRef ( doc : xmlDocPtr , elem : xmlNodePtr , attr : xmlAttrPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRemoveRef" ]
    pub fn xmlRemoveRef ( doc : xmlDocPtr , attr : xmlAttrPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetRefs" ]
    pub fn xmlGetRefs ( doc : xmlDocPtr , ID : * const xmlChar , ) -> xmlListPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewValidCtxt" ]
    pub fn xmlNewValidCtxt ( ) -> xmlValidCtxtPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFreeValidCtxt" ]
    pub fn xmlFreeValidCtxt ( arg1 : xmlValidCtxtPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidateRoot" ]
    pub fn xmlValidateRoot ( ctxt : xmlValidCtxtPtr , doc : xmlDocPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidateElementDecl" ]
    pub fn xmlValidateElementDecl ( ctxt : xmlValidCtxtPtr , doc : xmlDocPtr , elem : xmlElementPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidNormalizeAttributeValue" ]
    pub fn xmlValidNormalizeAttributeValue ( doc : xmlDocPtr , elem : xmlNodePtr , name : * const xmlChar , value : * const xmlChar , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidCtxtNormalizeAttributeValue" ]
    pub fn xmlValidCtxtNormalizeAttributeValue ( ctxt : xmlValidCtxtPtr , doc : xmlDocPtr , elem : xmlNodePtr , name : * const xmlChar , value : * const xmlChar , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidateAttributeDecl" ]
    pub fn xmlValidateAttributeDecl ( ctxt : xmlValidCtxtPtr , doc : xmlDocPtr , attr : xmlAttributePtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidateAttributeValue" ]
    pub fn xmlValidateAttributeValue ( type_ : xmlAttributeType , value : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidateNotationDecl" ]
    pub fn xmlValidateNotationDecl ( ctxt : xmlValidCtxtPtr , doc : xmlDocPtr , nota : xmlNotationPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidateDtd" ]
    pub fn xmlValidateDtd ( ctxt : xmlValidCtxtPtr , doc : xmlDocPtr , dtd : xmlDtdPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidateDtdFinal" ]
    pub fn xmlValidateDtdFinal ( ctxt : xmlValidCtxtPtr , doc : xmlDocPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidateDocument" ]
    pub fn xmlValidateDocument ( ctxt : xmlValidCtxtPtr , doc : xmlDocPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidateElement" ]
    pub fn xmlValidateElement ( ctxt : xmlValidCtxtPtr , doc : xmlDocPtr , elem : xmlNodePtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidateOneElement" ]
    pub fn xmlValidateOneElement ( ctxt : xmlValidCtxtPtr , doc : xmlDocPtr , elem : xmlNodePtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidateOneAttribute" ]
    pub fn xmlValidateOneAttribute ( ctxt : xmlValidCtxtPtr , doc : xmlDocPtr , elem : xmlNodePtr , attr : xmlAttrPtr , value : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidateOneNamespace" ]
    pub fn xmlValidateOneNamespace ( ctxt : xmlValidCtxtPtr , doc : xmlDocPtr , elem : xmlNodePtr , prefix : * const xmlChar , ns : xmlNsPtr , value : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidateDocumentFinal" ]
    pub fn xmlValidateDocumentFinal ( ctxt : xmlValidCtxtPtr , doc : xmlDocPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidateNotationUse" ]
    pub fn xmlValidateNotationUse ( ctxt : xmlValidCtxtPtr , doc : xmlDocPtr , notationName : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlIsMixedElement" ]
    pub fn xmlIsMixedElement ( doc : xmlDocPtr , name : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetDtdAttrDesc" ]
    pub fn xmlGetDtdAttrDesc ( dtd : xmlDtdPtr , elem : * const xmlChar , name : * const xmlChar , ) -> xmlAttributePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetDtdQAttrDesc" ]
    pub fn xmlGetDtdQAttrDesc ( dtd : xmlDtdPtr , elem : * const xmlChar , name : * const xmlChar , prefix : * const xmlChar , ) -> xmlAttributePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetDtdNotationDesc" ]
    pub fn xmlGetDtdNotationDesc ( dtd : xmlDtdPtr , name : * const xmlChar , ) -> xmlNotationPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetDtdQElementDesc" ]
    pub fn xmlGetDtdQElementDesc ( dtd : xmlDtdPtr , name : * const xmlChar , prefix : * const xmlChar , ) -> xmlElementPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetDtdElementDesc" ]
    pub fn xmlGetDtdElementDesc ( dtd : xmlDtdPtr , name : * const xmlChar , ) -> xmlElementPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidGetPotentialChildren" ]
    pub fn xmlValidGetPotentialChildren ( ctree : * mut xmlElementContent , names : * mut * const xmlChar , len : * mut :: std :: os :: raw :: c_int , max : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidGetValidElements" ]
    pub fn xmlValidGetValidElements ( prev : * mut xmlNode , next : * mut xmlNode , names : * mut * const xmlChar , max : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidateNameValue" ]
    pub fn xmlValidateNameValue ( value : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidateNamesValue" ]
    pub fn xmlValidateNamesValue ( value : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidateNmtokenValue" ]
    pub fn xmlValidateNmtokenValue ( value : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidateNmtokensValue" ]
    pub fn xmlValidateNmtokensValue ( value : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidBuildContentModel" ]
    pub fn xmlValidBuildContentModel ( ctxt : xmlValidCtxtPtr , elem : xmlElementPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidatePushElement" ]
    pub fn xmlValidatePushElement ( ctxt : xmlValidCtxtPtr , doc : xmlDocPtr , elem : xmlNodePtr , qname : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidatePushCData" ]
    pub fn xmlValidatePushCData ( ctxt : xmlValidCtxtPtr , data : * const xmlChar , len : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlValidatePopElement" ]
    pub fn xmlValidatePopElement ( ctxt : xmlValidCtxtPtr , doc : xmlDocPtr , elem : xmlNodePtr , qname : * const xmlChar , ) -> :: std :: os :: raw :: c_int ;
} pub const xmlEntityType_XML_INTERNAL_GENERAL_ENTITY : xmlEntityType = 1 ; pub const xmlEntityType_XML_EXTERNAL_GENERAL_PARSED_ENTITY : xmlEntityType = 2 ; pub const xmlEntityType_XML_EXTERNAL_GENERAL_UNPARSED_ENTITY : xmlEntityType = 3 ; pub const xmlEntityType_XML_INTERNAL_PARAMETER_ENTITY : xmlEntityType = 4 ; pub const xmlEntityType_XML_EXTERNAL_PARAMETER_ENTITY : xmlEntityType = 5 ; pub const xmlEntityType_XML_INTERNAL_PREDEFINED_ENTITY : xmlEntityType = 6 ; pub type xmlEntityType = :: std :: os :: raw :: c_uint ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlEntity { pub _private : * mut :: std :: os :: raw :: c_void , pub type_ : xmlElementType , pub name : * const xmlChar , pub children : * mut _xmlNode , pub last : * mut _xmlNode , pub parent : * mut _xmlDtd , pub next : * mut _xmlNode , pub prev : * mut _xmlNode , pub doc : * mut _xmlDoc , pub orig : * mut xmlChar , pub content : * mut xmlChar , pub length : :: std :: os :: raw :: c_int , pub etype : xmlEntityType , pub ExternalID : * const xmlChar , pub SystemID : * const xmlChar , pub nexte : * mut _xmlEntity , pub URI : * const xmlChar , pub owner : :: std :: os :: raw :: c_int , pub checked : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout__xmlEntity ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlEntity > ( ) , 136usize , concat ! ( "Size of: " , stringify ! ( _xmlEntity ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlEntity > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlEntity ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlEntity ) ) . _private as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlEntity ) , "::" , stringify ! ( _private ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlEntity ) ) . type_ as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlEntity ) , "::" , stringify ! ( type_ ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlEntity ) ) . name as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlEntity ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlEntity ) ) . children as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlEntity ) , "::" , stringify ! ( children ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlEntity ) ) . last as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlEntity ) , "::" , stringify ! ( last ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlEntity ) ) . parent as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlEntity ) , "::" , stringify ! ( parent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlEntity ) ) . next as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlEntity ) , "::" , stringify ! ( next ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlEntity ) ) . prev as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlEntity ) , "::" , stringify ! ( prev ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlEntity ) ) . doc as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlEntity ) , "::" , stringify ! ( doc ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlEntity ) ) . orig as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlEntity ) , "::" , stringify ! ( orig ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlEntity ) ) . content as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlEntity ) , "::" , stringify ! ( content ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlEntity ) ) . length as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlEntity ) , "::" , stringify ! ( length ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlEntity ) ) . etype as * const _ as usize } , 92usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlEntity ) , "::" , stringify ! ( etype ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlEntity ) ) . ExternalID as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlEntity ) , "::" , stringify ! ( ExternalID ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlEntity ) ) . SystemID as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlEntity ) , "::" , stringify ! ( SystemID ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlEntity ) ) . nexte as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlEntity ) , "::" , stringify ! ( nexte ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlEntity ) ) . URI as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlEntity ) , "::" , stringify ! ( URI ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlEntity ) ) . owner as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlEntity ) , "::" , stringify ! ( owner ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlEntity ) ) . checked as * const _ as usize } , 132usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlEntity ) , "::" , stringify ! ( checked ) ) ) ; } pub type xmlEntitiesTable = _xmlHashTable ; pub type xmlEntitiesTablePtr = * mut xmlEntitiesTable ; extern "C" {
    # [ link_name = "\u{1}_xmlInitializePredefinedEntities" ]
    pub fn xmlInitializePredefinedEntities ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewEntity" ]
    pub fn xmlNewEntity ( doc : xmlDocPtr , name : * const xmlChar , type_ : :: std :: os :: raw :: c_int , ExternalID : * const xmlChar , SystemID : * const xmlChar , content : * const xmlChar , ) -> xmlEntityPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAddDocEntity" ]
    pub fn xmlAddDocEntity ( doc : xmlDocPtr , name : * const xmlChar , type_ : :: std :: os :: raw :: c_int , ExternalID : * const xmlChar , SystemID : * const xmlChar , content : * const xmlChar , ) -> xmlEntityPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAddDtdEntity" ]
    pub fn xmlAddDtdEntity ( doc : xmlDocPtr , name : * const xmlChar , type_ : :: std :: os :: raw :: c_int , ExternalID : * const xmlChar , SystemID : * const xmlChar , content : * const xmlChar , ) -> xmlEntityPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetPredefinedEntity" ]
    pub fn xmlGetPredefinedEntity ( name : * const xmlChar , ) -> xmlEntityPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetDocEntity" ]
    pub fn xmlGetDocEntity ( doc : * const xmlDoc , name : * const xmlChar , ) -> xmlEntityPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetDtdEntity" ]
    pub fn xmlGetDtdEntity ( doc : xmlDocPtr , name : * const xmlChar , ) -> xmlEntityPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetParameterEntity" ]
    pub fn xmlGetParameterEntity ( doc : xmlDocPtr , name : * const xmlChar , ) -> xmlEntityPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlEncodeEntities" ]
    pub fn xmlEncodeEntities ( doc : xmlDocPtr , input : * const xmlChar , ) -> * const xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlEncodeEntitiesReentrant" ]
    pub fn xmlEncodeEntitiesReentrant ( doc : xmlDocPtr , input : * const xmlChar , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlEncodeSpecialChars" ]
    pub fn xmlEncodeSpecialChars ( doc : * const xmlDoc , input : * const xmlChar , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCreateEntitiesTable" ]
    pub fn xmlCreateEntitiesTable ( ) -> xmlEntitiesTablePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCopyEntitiesTable" ]
    pub fn xmlCopyEntitiesTable ( table : xmlEntitiesTablePtr , ) -> xmlEntitiesTablePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFreeEntitiesTable" ]
    pub fn xmlFreeEntitiesTable ( table : xmlEntitiesTablePtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDumpEntitiesTable" ]
    pub fn xmlDumpEntitiesTable ( buf : xmlBufferPtr , table : xmlEntitiesTablePtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDumpEntityDecl" ]
    pub fn xmlDumpEntityDecl ( buf : xmlBufferPtr , ent : xmlEntityPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCleanupPredefinedEntities" ]
    pub fn xmlCleanupPredefinedEntities ( ) ;
}
/// xmlParserInputDeallocate:
/// @str:  the string to deallocate
///
/// Callback for freeing some parser input allocations.
pub type xmlParserInputDeallocate = :: std :: option :: Option < unsafe extern "C" fn ( str : * mut xmlChar ) > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlParserInput { pub buf : xmlParserInputBufferPtr , pub filename : * const :: std :: os :: raw :: c_char , pub directory : * const :: std :: os :: raw :: c_char , pub base : * const xmlChar , pub cur : * const xmlChar , pub end : * const xmlChar , pub length : :: std :: os :: raw :: c_int , pub line : :: std :: os :: raw :: c_int , pub col : :: std :: os :: raw :: c_int , pub consumed : :: std :: os :: raw :: c_ulong , pub free : xmlParserInputDeallocate , pub encoding : * const xmlChar , pub version : * const xmlChar , pub standalone : :: std :: os :: raw :: c_int , pub id : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout__xmlParserInput ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlParserInput > ( ) , 104usize , concat ! ( "Size of: " , stringify ! ( _xmlParserInput ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlParserInput > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlParserInput ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInput ) ) . buf as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInput ) , "::" , stringify ! ( buf ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInput ) ) . filename as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInput ) , "::" , stringify ! ( filename ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInput ) ) . directory as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInput ) , "::" , stringify ! ( directory ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInput ) ) . base as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInput ) , "::" , stringify ! ( base ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInput ) ) . cur as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInput ) , "::" , stringify ! ( cur ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInput ) ) . end as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInput ) , "::" , stringify ! ( end ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInput ) ) . length as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInput ) , "::" , stringify ! ( length ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInput ) ) . line as * const _ as usize } , 52usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInput ) , "::" , stringify ! ( line ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInput ) ) . col as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInput ) , "::" , stringify ! ( col ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInput ) ) . consumed as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInput ) , "::" , stringify ! ( consumed ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInput ) ) . free as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInput ) , "::" , stringify ! ( free ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInput ) ) . encoding as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInput ) , "::" , stringify ! ( encoding ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInput ) ) . version as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInput ) , "::" , stringify ! ( version ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInput ) ) . standalone as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInput ) , "::" , stringify ! ( standalone ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInput ) ) . id as * const _ as usize } , 100usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInput ) , "::" , stringify ! ( id ) ) ) ; }
/// xmlParserNodeInfo:
///
/// The parser can be asked to collect Node informations, i.e. at what
/// place in the file they were detected.
/// NOTE: This is off by default and not very well tested.
pub type xmlParserNodeInfo = _xmlParserNodeInfo ; pub type xmlParserNodeInfoPtr = * mut xmlParserNodeInfo ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlParserNodeInfo { pub node : * const _xmlNode , pub begin_pos : :: std :: os :: raw :: c_ulong , pub begin_line : :: std :: os :: raw :: c_ulong , pub end_pos : :: std :: os :: raw :: c_ulong , pub end_line : :: std :: os :: raw :: c_ulong , } # [ test ] fn bindgen_test_layout__xmlParserNodeInfo ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlParserNodeInfo > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( _xmlParserNodeInfo ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlParserNodeInfo > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlParserNodeInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserNodeInfo ) ) . node as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserNodeInfo ) , "::" , stringify ! ( node ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserNodeInfo ) ) . begin_pos as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserNodeInfo ) , "::" , stringify ! ( begin_pos ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserNodeInfo ) ) . begin_line as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserNodeInfo ) , "::" , stringify ! ( begin_line ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserNodeInfo ) ) . end_pos as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserNodeInfo ) , "::" , stringify ! ( end_pos ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserNodeInfo ) ) . end_line as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserNodeInfo ) , "::" , stringify ! ( end_line ) ) ) ; } pub type xmlParserNodeInfoSeq = _xmlParserNodeInfoSeq ; pub type xmlParserNodeInfoSeqPtr = * mut xmlParserNodeInfoSeq ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlParserNodeInfoSeq { pub maximum : :: std :: os :: raw :: c_ulong , pub length : :: std :: os :: raw :: c_ulong , pub buffer : * mut xmlParserNodeInfo , } # [ test ] fn bindgen_test_layout__xmlParserNodeInfoSeq ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlParserNodeInfoSeq > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( _xmlParserNodeInfoSeq ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlParserNodeInfoSeq > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlParserNodeInfoSeq ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserNodeInfoSeq ) ) . maximum as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserNodeInfoSeq ) , "::" , stringify ! ( maximum ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserNodeInfoSeq ) ) . length as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserNodeInfoSeq ) , "::" , stringify ! ( length ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserNodeInfoSeq ) ) . buffer as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserNodeInfoSeq ) , "::" , stringify ! ( buffer ) ) ) ; } pub const xmlParserInputState_XML_PARSER_EOF : xmlParserInputState = -1 ; pub const xmlParserInputState_XML_PARSER_START : xmlParserInputState = 0 ; pub const xmlParserInputState_XML_PARSER_MISC : xmlParserInputState = 1 ; pub const xmlParserInputState_XML_PARSER_PI : xmlParserInputState = 2 ; pub const xmlParserInputState_XML_PARSER_DTD : xmlParserInputState = 3 ; pub const xmlParserInputState_XML_PARSER_PROLOG : xmlParserInputState = 4 ; pub const xmlParserInputState_XML_PARSER_COMMENT : xmlParserInputState = 5 ; pub const xmlParserInputState_XML_PARSER_START_TAG : xmlParserInputState = 6 ; pub const xmlParserInputState_XML_PARSER_CONTENT : xmlParserInputState = 7 ; pub const xmlParserInputState_XML_PARSER_CDATA_SECTION : xmlParserInputState = 8 ; pub const xmlParserInputState_XML_PARSER_END_TAG : xmlParserInputState = 9 ; pub const xmlParserInputState_XML_PARSER_ENTITY_DECL : xmlParserInputState = 10 ; pub const xmlParserInputState_XML_PARSER_ENTITY_VALUE : xmlParserInputState = 11 ; pub const xmlParserInputState_XML_PARSER_ATTRIBUTE_VALUE : xmlParserInputState = 12 ; pub const xmlParserInputState_XML_PARSER_SYSTEM_LITERAL : xmlParserInputState = 13 ; pub const xmlParserInputState_XML_PARSER_EPILOG : xmlParserInputState = 14 ; pub const xmlParserInputState_XML_PARSER_IGNORE : xmlParserInputState = 15 ; pub const xmlParserInputState_XML_PARSER_PUBLIC_LITERAL : xmlParserInputState = 16 ; pub type xmlParserInputState = :: std :: os :: raw :: c_int ; pub const xmlParserMode_XML_PARSE_UNKNOWN : xmlParserMode = 0 ; pub const xmlParserMode_XML_PARSE_DOM : xmlParserMode = 1 ; pub const xmlParserMode_XML_PARSE_SAX : xmlParserMode = 2 ; pub const xmlParserMode_XML_PARSE_PUSH_DOM : xmlParserMode = 3 ; pub const xmlParserMode_XML_PARSE_PUSH_SAX : xmlParserMode = 4 ; pub const xmlParserMode_XML_PARSE_READER : xmlParserMode = 5 ; pub type xmlParserMode = :: std :: os :: raw :: c_uint ;
/// xmlParserCtxt:
///
/// The parser context.
/// NOTE This doesn't completely define the parser state, the (current ?)
/// design of the parser uses recursive function calls since this allow
/// and easy mapping from the production rules of the specification
/// to the actual code. The drawback is that the actual function call
/// also reflect the parser state. However most of the parsing routines
/// takes as the only argument the parser context pointer, so migrating
/// to a state based parser for progressive parsing shouldn't be too hard.
# [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlParserCtxt { pub sax : * mut _xmlSAXHandler , pub userData : * mut :: std :: os :: raw :: c_void , pub myDoc : xmlDocPtr , pub wellFormed : :: std :: os :: raw :: c_int , pub replaceEntities : :: std :: os :: raw :: c_int , pub version : * const xmlChar , pub encoding : * const xmlChar , pub standalone : :: std :: os :: raw :: c_int , pub html : :: std :: os :: raw :: c_int , pub input : xmlParserInputPtr , pub inputNr : :: std :: os :: raw :: c_int , pub inputMax : :: std :: os :: raw :: c_int , pub inputTab : * mut xmlParserInputPtr , pub node : xmlNodePtr , pub nodeNr : :: std :: os :: raw :: c_int , pub nodeMax : :: std :: os :: raw :: c_int , pub nodeTab : * mut xmlNodePtr , pub record_info : :: std :: os :: raw :: c_int , pub node_seq : xmlParserNodeInfoSeq , pub errNo : :: std :: os :: raw :: c_int , pub hasExternalSubset : :: std :: os :: raw :: c_int , pub hasPErefs : :: std :: os :: raw :: c_int , pub external : :: std :: os :: raw :: c_int , pub valid : :: std :: os :: raw :: c_int , pub validate : :: std :: os :: raw :: c_int , pub vctxt : xmlValidCtxt , pub instate : xmlParserInputState , pub token : :: std :: os :: raw :: c_int , pub directory : * mut :: std :: os :: raw :: c_char , pub name : * const xmlChar , pub nameNr : :: std :: os :: raw :: c_int , pub nameMax : :: std :: os :: raw :: c_int , pub nameTab : * mut * const xmlChar , pub nbChars : :: std :: os :: raw :: c_long , pub checkIndex : :: std :: os :: raw :: c_long , pub keepBlanks : :: std :: os :: raw :: c_int , pub disableSAX : :: std :: os :: raw :: c_int , pub inSubset : :: std :: os :: raw :: c_int , pub intSubName : * const xmlChar , pub extSubURI : * mut xmlChar , pub extSubSystem : * mut xmlChar , pub space : * mut :: std :: os :: raw :: c_int , pub spaceNr : :: std :: os :: raw :: c_int , pub spaceMax : :: std :: os :: raw :: c_int , pub spaceTab : * mut :: std :: os :: raw :: c_int , pub depth : :: std :: os :: raw :: c_int , pub entity : xmlParserInputPtr , pub charset : :: std :: os :: raw :: c_int , pub nodelen : :: std :: os :: raw :: c_int , pub nodemem : :: std :: os :: raw :: c_int , pub pedantic : :: std :: os :: raw :: c_int , pub _private : * mut :: std :: os :: raw :: c_void , pub loadsubset : :: std :: os :: raw :: c_int , pub linenumbers : :: std :: os :: raw :: c_int , pub catalogs : * mut :: std :: os :: raw :: c_void , pub recovery : :: std :: os :: raw :: c_int , pub progressive : :: std :: os :: raw :: c_int , pub dict : xmlDictPtr , pub atts : * mut * const xmlChar , pub maxatts : :: std :: os :: raw :: c_int , pub docdict : :: std :: os :: raw :: c_int , pub str_xml : * const xmlChar , pub str_xmlns : * const xmlChar , pub str_xml_ns : * const xmlChar , pub sax2 : :: std :: os :: raw :: c_int , pub nsNr : :: std :: os :: raw :: c_int , pub nsMax : :: std :: os :: raw :: c_int , pub nsTab : * mut * const xmlChar , pub attallocs : * mut :: std :: os :: raw :: c_int , pub pushTab : * mut * mut :: std :: os :: raw :: c_void , pub attsDefault : xmlHashTablePtr , pub attsSpecial : xmlHashTablePtr , pub nsWellFormed : :: std :: os :: raw :: c_int , pub options : :: std :: os :: raw :: c_int , pub dictNames : :: std :: os :: raw :: c_int , pub freeElemsNr : :: std :: os :: raw :: c_int , pub freeElems : xmlNodePtr , pub freeAttrsNr : :: std :: os :: raw :: c_int , pub freeAttrs : xmlAttrPtr , pub lastError : xmlError , pub parseMode : xmlParserMode , pub nbentities : :: std :: os :: raw :: c_ulong , pub sizeentities : :: std :: os :: raw :: c_ulong , pub nodeInfo : * mut xmlParserNodeInfo , pub nodeInfoNr : :: std :: os :: raw :: c_int , pub nodeInfoMax : :: std :: os :: raw :: c_int , pub nodeInfoTab : * mut xmlParserNodeInfo , pub input_id : :: std :: os :: raw :: c_int , pub sizeentcopy : :: std :: os :: raw :: c_ulong , } # [ test ] fn bindgen_test_layout__xmlParserCtxt ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlParserCtxt > ( ) , 752usize , concat ! ( "Size of: " , stringify ! ( _xmlParserCtxt ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlParserCtxt > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlParserCtxt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . sax as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( sax ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . userData as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( userData ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . myDoc as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( myDoc ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . wellFormed as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( wellFormed ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . replaceEntities as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( replaceEntities ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . version as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( version ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . encoding as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( encoding ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . standalone as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( standalone ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . html as * const _ as usize } , 52usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( html ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . input as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( input ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . inputNr as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( inputNr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . inputMax as * const _ as usize } , 68usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( inputMax ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . inputTab as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( inputTab ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . node as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( node ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . nodeNr as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( nodeNr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . nodeMax as * const _ as usize } , 92usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( nodeMax ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . nodeTab as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( nodeTab ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . record_info as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( record_info ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . node_seq as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( node_seq ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . errNo as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( errNo ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . hasExternalSubset as * const _ as usize } , 140usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( hasExternalSubset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . hasPErefs as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( hasPErefs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . external as * const _ as usize } , 148usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( external ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . valid as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( valid ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . validate as * const _ as usize } , 156usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( validate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . vctxt as * const _ as usize } , 160usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( vctxt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . instate as * const _ as usize } , 272usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( instate ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . token as * const _ as usize } , 276usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( token ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . directory as * const _ as usize } , 280usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( directory ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . name as * const _ as usize } , 288usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . nameNr as * const _ as usize } , 296usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( nameNr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . nameMax as * const _ as usize } , 300usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( nameMax ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . nameTab as * const _ as usize } , 304usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( nameTab ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . nbChars as * const _ as usize } , 312usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( nbChars ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . checkIndex as * const _ as usize } , 320usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( checkIndex ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . keepBlanks as * const _ as usize } , 328usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( keepBlanks ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . disableSAX as * const _ as usize } , 332usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( disableSAX ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . inSubset as * const _ as usize } , 336usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( inSubset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . intSubName as * const _ as usize } , 344usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( intSubName ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . extSubURI as * const _ as usize } , 352usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( extSubURI ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . extSubSystem as * const _ as usize } , 360usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( extSubSystem ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . space as * const _ as usize } , 368usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( space ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . spaceNr as * const _ as usize } , 376usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( spaceNr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . spaceMax as * const _ as usize } , 380usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( spaceMax ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . spaceTab as * const _ as usize } , 384usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( spaceTab ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . depth as * const _ as usize } , 392usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( depth ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . entity as * const _ as usize } , 400usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( entity ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . charset as * const _ as usize } , 408usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( charset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . nodelen as * const _ as usize } , 412usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( nodelen ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . nodemem as * const _ as usize } , 416usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( nodemem ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . pedantic as * const _ as usize } , 420usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( pedantic ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . _private as * const _ as usize } , 424usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( _private ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . loadsubset as * const _ as usize } , 432usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( loadsubset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . linenumbers as * const _ as usize } , 436usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( linenumbers ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . catalogs as * const _ as usize } , 440usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( catalogs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . recovery as * const _ as usize } , 448usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( recovery ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . progressive as * const _ as usize } , 452usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( progressive ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . dict as * const _ as usize } , 456usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( dict ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . atts as * const _ as usize } , 464usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( atts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . maxatts as * const _ as usize } , 472usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( maxatts ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . docdict as * const _ as usize } , 476usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( docdict ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . str_xml as * const _ as usize } , 480usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( str_xml ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . str_xmlns as * const _ as usize } , 488usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( str_xmlns ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . str_xml_ns as * const _ as usize } , 496usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( str_xml_ns ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . sax2 as * const _ as usize } , 504usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( sax2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . nsNr as * const _ as usize } , 508usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( nsNr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . nsMax as * const _ as usize } , 512usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( nsMax ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . nsTab as * const _ as usize } , 520usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( nsTab ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . attallocs as * const _ as usize } , 528usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( attallocs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . pushTab as * const _ as usize } , 536usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( pushTab ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . attsDefault as * const _ as usize } , 544usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( attsDefault ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . attsSpecial as * const _ as usize } , 552usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( attsSpecial ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . nsWellFormed as * const _ as usize } , 560usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( nsWellFormed ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . options as * const _ as usize } , 564usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( options ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . dictNames as * const _ as usize } , 568usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( dictNames ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . freeElemsNr as * const _ as usize } , 572usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( freeElemsNr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . freeElems as * const _ as usize } , 576usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( freeElems ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . freeAttrsNr as * const _ as usize } , 584usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( freeAttrsNr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . freeAttrs as * const _ as usize } , 592usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( freeAttrs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . lastError as * const _ as usize } , 600usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( lastError ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . parseMode as * const _ as usize } , 688usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( parseMode ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . nbentities as * const _ as usize } , 696usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( nbentities ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . sizeentities as * const _ as usize } , 704usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( sizeentities ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . nodeInfo as * const _ as usize } , 712usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( nodeInfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . nodeInfoNr as * const _ as usize } , 720usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( nodeInfoNr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . nodeInfoMax as * const _ as usize } , 724usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( nodeInfoMax ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . nodeInfoTab as * const _ as usize } , 728usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( nodeInfoTab ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . input_id as * const _ as usize } , 736usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( input_id ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserCtxt ) ) . sizeentcopy as * const _ as usize } , 744usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserCtxt ) , "::" , stringify ! ( sizeentcopy ) ) ) ; }
/// xmlSAXLocator:
///
/// A SAX Locator.
# [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlSAXLocator { pub getPublicId : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void ) -> * const xmlChar > , pub getSystemId : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void ) -> * const xmlChar > , pub getLineNumber : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > , pub getColumnNumber : :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > , } # [ test ] fn bindgen_test_layout__xmlSAXLocator ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlSAXLocator > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( _xmlSAXLocator ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlSAXLocator > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlSAXLocator ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXLocator ) ) . getPublicId as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXLocator ) , "::" , stringify ! ( getPublicId ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXLocator ) ) . getSystemId as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXLocator ) , "::" , stringify ! ( getSystemId ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXLocator ) ) . getLineNumber as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXLocator ) , "::" , stringify ! ( getLineNumber ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXLocator ) ) . getColumnNumber as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXLocator ) , "::" , stringify ! ( getColumnNumber ) ) ) ; }
/// resolveEntitySAXFunc:
/// @ctx:  the user data (XML parser context)
/// @publicId: The public ID of the entity
/// @systemId: The system ID of the entity
///
/// Callback:
/// The entity loader, to control the loading of external entities,
/// the application can either:
/// - override this resolveEntity() callback in the SAX block
/// - or better use the xmlSetExternalEntityLoader() function to
/// set up it's own entity resolution routine
///
/// Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.
pub type resolveEntitySAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , publicId : * const xmlChar , systemId : * const xmlChar ) -> xmlParserInputPtr > ;
/// internalSubsetSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name:  the root element name
/// @ExternalID:  the external ID
/// @SystemID:  the SYSTEM ID (e.g. filename or URL)
///
/// Callback on internal subset declaration.
pub type internalSubsetSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , ExternalID : * const xmlChar , SystemID : * const xmlChar ) > ;
/// externalSubsetSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name:  the root element name
/// @ExternalID:  the external ID
/// @SystemID:  the SYSTEM ID (e.g. filename or URL)
///
/// Callback on external subset declaration.
pub type externalSubsetSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , ExternalID : * const xmlChar , SystemID : * const xmlChar ) > ;
/// getEntitySAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name: The entity name
///
/// Get an entity by name.
///
/// Returns the xmlEntityPtr if found.
pub type getEntitySAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar ) -> xmlEntityPtr > ;
/// getParameterEntitySAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name: The entity name
///
/// Get a parameter entity by name.
///
/// Returns the xmlEntityPtr if found.
pub type getParameterEntitySAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar ) -> xmlEntityPtr > ;
/// entityDeclSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name:  the entity name
/// @type:  the entity type
/// @publicId: The public ID of the entity
/// @systemId: The system ID of the entity
/// @content: the entity value (without processing).
///
/// An entity definition has been parsed.
pub type entityDeclSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , type_ : :: std :: os :: raw :: c_int , publicId : * const xmlChar , systemId : * const xmlChar , content : * mut xmlChar ) > ;
/// notationDeclSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name: The name of the notation
/// @publicId: The public ID of the entity
/// @systemId: The system ID of the entity
///
/// What to do when a notation declaration has been parsed.
pub type notationDeclSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , publicId : * const xmlChar , systemId : * const xmlChar ) > ;
/// attributeDeclSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @elem:  the name of the element
/// @fullname:  the attribute name
/// @type:  the attribute type
/// @def:  the type of default value
/// @defaultValue: the attribute default value
/// @tree:  the tree of enumerated value set
///
/// An attribute definition has been parsed.
pub type attributeDeclSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , elem : * const xmlChar , fullname : * const xmlChar , type_ : :: std :: os :: raw :: c_int , def : :: std :: os :: raw :: c_int , defaultValue : * const xmlChar , tree : xmlEnumerationPtr ) > ;
/// elementDeclSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name:  the element name
/// @type:  the element type
/// @content: the element value tree
///
/// An element definition has been parsed.
pub type elementDeclSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , type_ : :: std :: os :: raw :: c_int , content : xmlElementContentPtr ) > ;
/// unparsedEntityDeclSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name: The name of the entity
/// @publicId: The public ID of the entity
/// @systemId: The system ID of the entity
/// @notationName: the name of the notation
///
/// What to do when an unparsed entity declaration is parsed.
pub type unparsedEntityDeclSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , publicId : * const xmlChar , systemId : * const xmlChar , notationName : * const xmlChar ) > ;
/// setDocumentLocatorSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @loc: A SAX Locator
///
/// Receive the document locator at startup, actually xmlDefaultSAXLocator.
/// Everything is available on the context, so this is useless in our case.
pub type setDocumentLocatorSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , loc : xmlSAXLocatorPtr ) > ;
/// startDocumentSAXFunc:
/// @ctx:  the user data (XML parser context)
///
/// Called when the document start being processed.
pub type startDocumentSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void ) > ;
/// endDocumentSAXFunc:
/// @ctx:  the user data (XML parser context)
///
/// Called when the document end has been detected.
pub type endDocumentSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void ) > ;
/// startElementSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name:  The element name, including namespace prefix
/// @atts:  An array of name/value attributes pairs, NULL terminated
///
/// Called when an opening tag has been processed.
pub type startElementSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , atts : * mut * const xmlChar ) > ;
/// endElementSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name:  The element name
///
/// Called when the end of an element has been detected.
pub type endElementSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar ) > ;
/// attributeSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name:  The attribute name, including namespace prefix
/// @value:  The attribute value
///
/// Handle an attribute that has been read by the parser.
/// The default handling is to convert the attribute into an
/// DOM subtree and past it in a new xmlAttr element added to
/// the element.
pub type attributeSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , value : * const xmlChar ) > ;
/// referenceSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @name:  The entity name
///
/// Called when an entity reference is detected.
pub type referenceSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar ) > ;
/// charactersSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @ch:  a xmlChar string
/// @len: the number of xmlChar
///
/// Receiving some chars from the parser.
pub type charactersSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , ch : * const xmlChar , len : :: std :: os :: raw :: c_int ) > ;
/// ignorableWhitespaceSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @ch:  a xmlChar string
/// @len: the number of xmlChar
///
/// Receiving some ignorable whitespaces from the parser.
/// UNUSED: by default the DOM building will use characters.
pub type ignorableWhitespaceSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , ch : * const xmlChar , len : :: std :: os :: raw :: c_int ) > ;
/// processingInstructionSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @target:  the target name
/// @data: the PI data's
///
/// A processing instruction has been parsed.
pub type processingInstructionSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , target : * const xmlChar , data : * const xmlChar ) > ;
/// commentSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @value:  the comment content
///
/// A comment has been parsed.
pub type commentSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , value : * const xmlChar ) > ;
/// cdataBlockSAXFunc:
/// @ctx:  the user data (XML parser context)
/// @value:  The pcdata content
/// @len:  the block length
///
/// Called when a pcdata block has been parsed.
pub type cdataBlockSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , value : * const xmlChar , len : :: std :: os :: raw :: c_int ) > ;
/// warningSAXFunc:
/// @ctx:  an XML parser context
/// @msg:  the message to display/transmit
/// @...:  extra parameters for the message display
///
/// Display and format a warning messages, callback.
pub type warningSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , msg : * const :: std :: os :: raw :: c_char ) > ;
/// errorSAXFunc:
/// @ctx:  an XML parser context
/// @msg:  the message to display/transmit
/// @...:  extra parameters for the message display
///
/// Display and format an error messages, callback.
pub type errorSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , msg : * const :: std :: os :: raw :: c_char ) > ;
/// fatalErrorSAXFunc:
/// @ctx:  an XML parser context
/// @msg:  the message to display/transmit
/// @...:  extra parameters for the message display
///
/// Display and format fatal error messages, callback.
/// Note: so far fatalError() SAX callbacks are not used, error()
/// get all the callbacks for errors.
pub type fatalErrorSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , msg : * const :: std :: os :: raw :: c_char ) > ;
/// isStandaloneSAXFunc:
/// @ctx:  the user data (XML parser context)
///
/// Is this document tagged standalone?
///
/// Returns 1 if true
pub type isStandaloneSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ;
/// hasInternalSubsetSAXFunc:
/// @ctx:  the user data (XML parser context)
///
/// Does this document has an internal subset.
///
/// Returns 1 if true
pub type hasInternalSubsetSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ;
/// hasExternalSubsetSAXFunc:
/// @ctx:  the user data (XML parser context)
///
/// Does this document has an external subset?
///
/// Returns 1 if true
pub type hasExternalSubsetSAXFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ;
/// startElementNsSAX2Func:
/// @ctx:  the user data (XML parser context)
/// @localname:  the local name of the element
/// @prefix:  the element namespace prefix if available
/// @URI:  the element namespace name if available
/// @nb_namespaces:  number of namespace definitions on that node
/// @namespaces:  pointer to the array of prefix/URI pairs namespace definitions
/// @nb_attributes:  the number of attributes on that node
/// @nb_defaulted:  the number of defaulted attributes. The defaulted
/// ones are at the end of the array
/// @attributes:  pointer to the array of (localname/prefix/URI/value/end)
/// attribute values.
///
/// SAX2 callback when an element start has been detected by the parser.
/// It provides the namespace informations for the element, as well as
/// the new namespace declarations on the element.
pub type startElementNsSAX2Func = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , localname : * const xmlChar , prefix : * const xmlChar , URI : * const xmlChar , nb_namespaces : :: std :: os :: raw :: c_int , namespaces : * mut * const xmlChar , nb_attributes : :: std :: os :: raw :: c_int , nb_defaulted : :: std :: os :: raw :: c_int , attributes : * mut * const xmlChar ) > ;
/// endElementNsSAX2Func:
/// @ctx:  the user data (XML parser context)
/// @localname:  the local name of the element
/// @prefix:  the element namespace prefix if available
/// @URI:  the element namespace name if available
///
/// SAX2 callback when an element end has been detected by the parser.
/// It provides the namespace informations for the element.
pub type endElementNsSAX2Func = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , localname : * const xmlChar , prefix : * const xmlChar , URI : * const xmlChar ) > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlSAXHandler { pub internalSubset : internalSubsetSAXFunc , pub isStandalone : isStandaloneSAXFunc , pub hasInternalSubset : hasInternalSubsetSAXFunc , pub hasExternalSubset : hasExternalSubsetSAXFunc , pub resolveEntity : resolveEntitySAXFunc , pub getEntity : getEntitySAXFunc , pub entityDecl : entityDeclSAXFunc , pub notationDecl : notationDeclSAXFunc , pub attributeDecl : attributeDeclSAXFunc , pub elementDecl : elementDeclSAXFunc , pub unparsedEntityDecl : unparsedEntityDeclSAXFunc , pub setDocumentLocator : setDocumentLocatorSAXFunc , pub startDocument : startDocumentSAXFunc , pub endDocument : endDocumentSAXFunc , pub startElement : startElementSAXFunc , pub endElement : endElementSAXFunc , pub reference : referenceSAXFunc , pub characters : charactersSAXFunc , pub ignorableWhitespace : ignorableWhitespaceSAXFunc , pub processingInstruction : processingInstructionSAXFunc , pub comment : commentSAXFunc , pub warning : warningSAXFunc , pub error : errorSAXFunc , pub fatalError : fatalErrorSAXFunc , pub getParameterEntity : getParameterEntitySAXFunc , pub cdataBlock : cdataBlockSAXFunc , pub externalSubset : externalSubsetSAXFunc , pub initialized : :: std :: os :: raw :: c_uint , pub _private : * mut :: std :: os :: raw :: c_void , pub startElementNs : startElementNsSAX2Func , pub endElementNs : endElementNsSAX2Func , pub serror : xmlStructuredErrorFunc , } # [ test ] fn bindgen_test_layout__xmlSAXHandler ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlSAXHandler > ( ) , 256usize , concat ! ( "Size of: " , stringify ! ( _xmlSAXHandler ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlSAXHandler > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlSAXHandler ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . internalSubset as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( internalSubset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . isStandalone as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( isStandalone ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . hasInternalSubset as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( hasInternalSubset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . hasExternalSubset as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( hasExternalSubset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . resolveEntity as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( resolveEntity ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . getEntity as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( getEntity ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . entityDecl as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( entityDecl ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . notationDecl as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( notationDecl ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . attributeDecl as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( attributeDecl ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . elementDecl as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( elementDecl ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . unparsedEntityDecl as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( unparsedEntityDecl ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . setDocumentLocator as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( setDocumentLocator ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . startDocument as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( startDocument ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . endDocument as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( endDocument ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . startElement as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( startElement ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . endElement as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( endElement ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . reference as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( reference ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . characters as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( characters ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . ignorableWhitespace as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( ignorableWhitespace ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . processingInstruction as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( processingInstruction ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . comment as * const _ as usize } , 160usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( comment ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . warning as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( warning ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . error as * const _ as usize } , 176usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( error ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . fatalError as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( fatalError ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . getParameterEntity as * const _ as usize } , 192usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( getParameterEntity ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . cdataBlock as * const _ as usize } , 200usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( cdataBlock ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . externalSubset as * const _ as usize } , 208usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( externalSubset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . initialized as * const _ as usize } , 216usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( initialized ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . _private as * const _ as usize } , 224usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( _private ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . startElementNs as * const _ as usize } , 232usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( startElementNs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . endElementNs as * const _ as usize } , 240usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( endElementNs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandler ) ) . serror as * const _ as usize } , 248usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandler ) , "::" , stringify ! ( serror ) ) ) ; } pub type xmlSAXHandlerV1 = _xmlSAXHandlerV1 ; pub type xmlSAXHandlerV1Ptr = * mut xmlSAXHandlerV1 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlSAXHandlerV1 { pub internalSubset : internalSubsetSAXFunc , pub isStandalone : isStandaloneSAXFunc , pub hasInternalSubset : hasInternalSubsetSAXFunc , pub hasExternalSubset : hasExternalSubsetSAXFunc , pub resolveEntity : resolveEntitySAXFunc , pub getEntity : getEntitySAXFunc , pub entityDecl : entityDeclSAXFunc , pub notationDecl : notationDeclSAXFunc , pub attributeDecl : attributeDeclSAXFunc , pub elementDecl : elementDeclSAXFunc , pub unparsedEntityDecl : unparsedEntityDeclSAXFunc , pub setDocumentLocator : setDocumentLocatorSAXFunc , pub startDocument : startDocumentSAXFunc , pub endDocument : endDocumentSAXFunc , pub startElement : startElementSAXFunc , pub endElement : endElementSAXFunc , pub reference : referenceSAXFunc , pub characters : charactersSAXFunc , pub ignorableWhitespace : ignorableWhitespaceSAXFunc , pub processingInstruction : processingInstructionSAXFunc , pub comment : commentSAXFunc , pub warning : warningSAXFunc , pub error : errorSAXFunc , pub fatalError : fatalErrorSAXFunc , pub getParameterEntity : getParameterEntitySAXFunc , pub cdataBlock : cdataBlockSAXFunc , pub externalSubset : externalSubsetSAXFunc , pub initialized : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout__xmlSAXHandlerV1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlSAXHandlerV1 > ( ) , 224usize , concat ! ( "Size of: " , stringify ! ( _xmlSAXHandlerV1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlSAXHandlerV1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlSAXHandlerV1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . internalSubset as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( internalSubset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . isStandalone as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( isStandalone ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . hasInternalSubset as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( hasInternalSubset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . hasExternalSubset as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( hasExternalSubset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . resolveEntity as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( resolveEntity ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . getEntity as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( getEntity ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . entityDecl as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( entityDecl ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . notationDecl as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( notationDecl ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . attributeDecl as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( attributeDecl ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . elementDecl as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( elementDecl ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . unparsedEntityDecl as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( unparsedEntityDecl ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . setDocumentLocator as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( setDocumentLocator ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . startDocument as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( startDocument ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . endDocument as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( endDocument ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . startElement as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( startElement ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . endElement as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( endElement ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . reference as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( reference ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . characters as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( characters ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . ignorableWhitespace as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( ignorableWhitespace ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . processingInstruction as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( processingInstruction ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . comment as * const _ as usize } , 160usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( comment ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . warning as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( warning ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . error as * const _ as usize } , 176usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( error ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . fatalError as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( fatalError ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . getParameterEntity as * const _ as usize } , 192usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( getParameterEntity ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . cdataBlock as * const _ as usize } , 200usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( cdataBlock ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . externalSubset as * const _ as usize } , 208usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( externalSubset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlSAXHandlerV1 ) ) . initialized as * const _ as usize } , 216usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlSAXHandlerV1 ) , "::" , stringify ! ( initialized ) ) ) ; }
/// xmlExternalEntityLoader:
/// @URL: The System ID of the resource requested
/// @ID: The Public ID of the resource requested
/// @context: the XML parser context
///
/// External entity loaders types.
///
/// Returns the entity input parser.
pub type xmlExternalEntityLoader = :: std :: option :: Option < unsafe extern "C" fn ( URL : * const :: std :: os :: raw :: c_char , ID : * const :: std :: os :: raw :: c_char , context : xmlParserCtxtPtr ) -> xmlParserInputPtr > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct UConverter { _unused : [ u8 ; 0 ] } pub const xmlCharEncoding_XML_CHAR_ENCODING_ERROR : xmlCharEncoding = -1 ; pub const xmlCharEncoding_XML_CHAR_ENCODING_NONE : xmlCharEncoding = 0 ; pub const xmlCharEncoding_XML_CHAR_ENCODING_UTF8 : xmlCharEncoding = 1 ; pub const xmlCharEncoding_XML_CHAR_ENCODING_UTF16LE : xmlCharEncoding = 2 ; pub const xmlCharEncoding_XML_CHAR_ENCODING_UTF16BE : xmlCharEncoding = 3 ; pub const xmlCharEncoding_XML_CHAR_ENCODING_UCS4LE : xmlCharEncoding = 4 ; pub const xmlCharEncoding_XML_CHAR_ENCODING_UCS4BE : xmlCharEncoding = 5 ; pub const xmlCharEncoding_XML_CHAR_ENCODING_EBCDIC : xmlCharEncoding = 6 ; pub const xmlCharEncoding_XML_CHAR_ENCODING_UCS4_2143 : xmlCharEncoding = 7 ; pub const xmlCharEncoding_XML_CHAR_ENCODING_UCS4_3412 : xmlCharEncoding = 8 ; pub const xmlCharEncoding_XML_CHAR_ENCODING_UCS2 : xmlCharEncoding = 9 ; pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_1 : xmlCharEncoding = 10 ; pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_2 : xmlCharEncoding = 11 ; pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_3 : xmlCharEncoding = 12 ; pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_4 : xmlCharEncoding = 13 ; pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_5 : xmlCharEncoding = 14 ; pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_6 : xmlCharEncoding = 15 ; pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_7 : xmlCharEncoding = 16 ; pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_8 : xmlCharEncoding = 17 ; pub const xmlCharEncoding_XML_CHAR_ENCODING_8859_9 : xmlCharEncoding = 18 ; pub const xmlCharEncoding_XML_CHAR_ENCODING_2022_JP : xmlCharEncoding = 19 ; pub const xmlCharEncoding_XML_CHAR_ENCODING_SHIFT_JIS : xmlCharEncoding = 20 ; pub const xmlCharEncoding_XML_CHAR_ENCODING_EUC_JP : xmlCharEncoding = 21 ; pub const xmlCharEncoding_XML_CHAR_ENCODING_ASCII : xmlCharEncoding = 22 ; pub type xmlCharEncoding = :: std :: os :: raw :: c_int ;
/// xmlCharEncodingInputFunc:
/// @out:  a pointer to an array of bytes to store the UTF-8 result
/// @outlen:  the length of @out
/// @in:  a pointer to an array of chars in the original encoding
/// @inlen:  the length of @in
///
/// Take a block of chars in the original encoding and try to convert
/// it to an UTF-8 block of chars out.
///
/// Returns the number of bytes written, -1 if lack of space, or -2
/// if the transcoding failed.
/// The value of @inlen after return is the number of octets consumed
/// if the return value is positive, else unpredictiable.
/// The value of @outlen after return is the number of octets consumed.
pub type xmlCharEncodingInputFunc = :: std :: option :: Option < unsafe extern "C" fn ( out : * mut :: std :: os :: raw :: c_uchar , outlen : * mut :: std :: os :: raw :: c_int , in_ : * const :: std :: os :: raw :: c_uchar , inlen : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > ;
/// xmlCharEncodingOutputFunc:
/// @out:  a pointer to an array of bytes to store the result
/// @outlen:  the length of @out
/// @in:  a pointer to an array of UTF-8 chars
/// @inlen:  the length of @in
///
/// Take a block of UTF-8 chars in and try to convert it to another
/// encoding.
/// Note: a first call designed to produce heading info is called with
/// in = NULL. If stateful this should also initialize the encoder state.
///
/// Returns the number of bytes written, -1 if lack of space, or -2
/// if the transcoding failed.
/// The value of @inlen after return is the number of octets consumed
/// if the return value is positive, else unpredictiable.
/// The value of @outlen after return is the number of octets produced.
pub type xmlCharEncodingOutputFunc = :: std :: option :: Option < unsafe extern "C" fn ( out : * mut :: std :: os :: raw :: c_uchar , outlen : * mut :: std :: os :: raw :: c_int , in_ : * const :: std :: os :: raw :: c_uchar , inlen : * mut :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _uconv_t { pub uconv : * mut UConverter , pub utf8 : * mut UConverter , } # [ test ] fn bindgen_test_layout__uconv_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _uconv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( _uconv_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _uconv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _uconv_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _uconv_t ) ) . uconv as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _uconv_t ) , "::" , stringify ! ( uconv ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _uconv_t ) ) . utf8 as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _uconv_t ) , "::" , stringify ! ( utf8 ) ) ) ; } pub type uconv_t = _uconv_t ; pub type xmlCharEncodingHandler = _xmlCharEncodingHandler ; pub type xmlCharEncodingHandlerPtr = * mut xmlCharEncodingHandler ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlCharEncodingHandler { pub name : * mut :: std :: os :: raw :: c_char , pub input : xmlCharEncodingInputFunc , pub output : xmlCharEncodingOutputFunc , pub uconv_in : * mut uconv_t , pub uconv_out : * mut uconv_t , } # [ test ] fn bindgen_test_layout__xmlCharEncodingHandler ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlCharEncodingHandler > ( ) , 40usize , concat ! ( "Size of: " , stringify ! ( _xmlCharEncodingHandler ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlCharEncodingHandler > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlCharEncodingHandler ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlCharEncodingHandler ) ) . name as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlCharEncodingHandler ) , "::" , stringify ! ( name ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlCharEncodingHandler ) ) . input as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlCharEncodingHandler ) , "::" , stringify ! ( input ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlCharEncodingHandler ) ) . output as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlCharEncodingHandler ) , "::" , stringify ! ( output ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlCharEncodingHandler ) ) . uconv_in as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlCharEncodingHandler ) , "::" , stringify ! ( uconv_in ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlCharEncodingHandler ) ) . uconv_out as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlCharEncodingHandler ) , "::" , stringify ! ( uconv_out ) ) ) ; } extern "C" {
    # [ link_name = "\u{1}_xmlInitCharEncodingHandlers" ]
    pub fn xmlInitCharEncodingHandlers ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCleanupCharEncodingHandlers" ]
    pub fn xmlCleanupCharEncodingHandlers ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRegisterCharEncodingHandler" ]
    pub fn xmlRegisterCharEncodingHandler ( handler : xmlCharEncodingHandlerPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetCharEncodingHandler" ]
    pub fn xmlGetCharEncodingHandler ( enc : xmlCharEncoding , ) -> xmlCharEncodingHandlerPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFindCharEncodingHandler" ]
    pub fn xmlFindCharEncodingHandler ( name : * const :: std :: os :: raw :: c_char , ) -> xmlCharEncodingHandlerPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewCharEncodingHandler" ]
    pub fn xmlNewCharEncodingHandler ( name : * const :: std :: os :: raw :: c_char , input : xmlCharEncodingInputFunc , output : xmlCharEncodingOutputFunc , ) -> xmlCharEncodingHandlerPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAddEncodingAlias" ]
    pub fn xmlAddEncodingAlias ( name : * const :: std :: os :: raw :: c_char , alias : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDelEncodingAlias" ]
    pub fn xmlDelEncodingAlias ( alias : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetEncodingAlias" ]
    pub fn xmlGetEncodingAlias ( alias : * const :: std :: os :: raw :: c_char , ) -> * const :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCleanupEncodingAliases" ]
    pub fn xmlCleanupEncodingAliases ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParseCharEncoding" ]
    pub fn xmlParseCharEncoding ( name : * const :: std :: os :: raw :: c_char , ) -> xmlCharEncoding ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetCharEncodingName" ]
    pub fn xmlGetCharEncodingName ( enc : xmlCharEncoding , ) -> * const :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDetectCharEncoding" ]
    pub fn xmlDetectCharEncoding ( in_ : * const :: std :: os :: raw :: c_uchar , len : :: std :: os :: raw :: c_int , ) -> xmlCharEncoding ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCharEncOutFunc" ]
    pub fn xmlCharEncOutFunc ( handler : * mut xmlCharEncodingHandler , out : xmlBufferPtr , in_ : xmlBufferPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCharEncInFunc" ]
    pub fn xmlCharEncInFunc ( handler : * mut xmlCharEncodingHandler , out : xmlBufferPtr , in_ : xmlBufferPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCharEncFirstLine" ]
    pub fn xmlCharEncFirstLine ( handler : * mut xmlCharEncodingHandler , out : xmlBufferPtr , in_ : xmlBufferPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCharEncCloseFunc" ]
    pub fn xmlCharEncCloseFunc ( handler : * mut xmlCharEncodingHandler , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_UTF8Toisolat1" ]
    pub fn UTF8Toisolat1 ( out : * mut :: std :: os :: raw :: c_uchar , outlen : * mut :: std :: os :: raw :: c_int , in_ : * const :: std :: os :: raw :: c_uchar , inlen : * mut :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_isolat1ToUTF8" ]
    pub fn isolat1ToUTF8 ( out : * mut :: std :: os :: raw :: c_uchar , outlen : * mut :: std :: os :: raw :: c_int , in_ : * const :: std :: os :: raw :: c_uchar , inlen : * mut :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
}
/// xmlInputMatchCallback:
/// @filename: the filename or URI
///
/// Callback used in the I/O Input API to detect if the current handler
/// can provide input fonctionnalities for this resource.
///
/// Returns 1 if yes and 0 if another Input module should be used
pub type xmlInputMatchCallback = :: std :: option :: Option < unsafe extern "C" fn ( filename : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int > ;
/// xmlInputOpenCallback:
/// @filename: the filename or URI
///
/// Callback used in the I/O Input API to open the resource
///
/// Returns an Input context or NULL in case or error
pub type xmlInputOpenCallback = :: std :: option :: Option < unsafe extern "C" fn ( filename : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_void > ;
/// xmlInputReadCallback:
/// @context:  an Input context
/// @buffer:  the buffer to store data read
/// @len:  the length of the buffer in bytes
///
/// Callback used in the I/O Input API to read the resource
///
/// Returns the number of bytes read or -1 in case of error
pub type xmlInputReadCallback = :: std :: option :: Option < unsafe extern "C" fn ( context : * mut :: std :: os :: raw :: c_void , buffer : * mut :: std :: os :: raw :: c_char , len : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > ;
/// xmlInputCloseCallback:
/// @context:  an Input context
///
/// Callback used in the I/O Input API to close the resource
///
/// Returns 0 or -1 in case of error
pub type xmlInputCloseCallback = :: std :: option :: Option < unsafe extern "C" fn ( context : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ;
/// xmlOutputMatchCallback:
/// @filename: the filename or URI
///
/// Callback used in the I/O Output API to detect if the current handler
/// can provide output fonctionnalities for this resource.
///
/// Returns 1 if yes and 0 if another Output module should be used
pub type xmlOutputMatchCallback = :: std :: option :: Option < unsafe extern "C" fn ( filename : * const :: std :: os :: raw :: c_char ) -> :: std :: os :: raw :: c_int > ;
/// xmlOutputOpenCallback:
/// @filename: the filename or URI
///
/// Callback used in the I/O Output API to open the resource
///
/// Returns an Output context or NULL in case or error
pub type xmlOutputOpenCallback = :: std :: option :: Option < unsafe extern "C" fn ( filename : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_void > ;
/// xmlOutputWriteCallback:
/// @context:  an Output context
/// @buffer:  the buffer of data to write
/// @len:  the length of the buffer in bytes
///
/// Callback used in the I/O Output API to write to the resource
///
/// Returns the number of bytes written or -1 in case of error
pub type xmlOutputWriteCallback = :: std :: option :: Option < unsafe extern "C" fn ( context : * mut :: std :: os :: raw :: c_void , buffer : * const :: std :: os :: raw :: c_char , len : :: std :: os :: raw :: c_int ) -> :: std :: os :: raw :: c_int > ;
/// xmlOutputCloseCallback:
/// @context:  an Output context
///
/// Callback used in the I/O Output API to close the resource
///
/// Returns 0 or -1 in case of error
pub type xmlOutputCloseCallback = :: std :: option :: Option < unsafe extern "C" fn ( context : * mut :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > ; pub const idtype_t_P_ALL : idtype_t = 0 ; pub const idtype_t_P_PID : idtype_t = 1 ; pub const idtype_t_P_PGID : idtype_t = 2 ; pub type idtype_t = :: std :: os :: raw :: c_uint ; pub type pid_t = __darwin_pid_t ; pub type id_t = __darwin_id_t ; pub type sig_atomic_t = :: std :: os :: raw :: c_int ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __darwin_i386_thread_state { pub __eax : :: std :: os :: raw :: c_uint , pub __ebx : :: std :: os :: raw :: c_uint , pub __ecx : :: std :: os :: raw :: c_uint , pub __edx : :: std :: os :: raw :: c_uint , pub __edi : :: std :: os :: raw :: c_uint , pub __esi : :: std :: os :: raw :: c_uint , pub __ebp : :: std :: os :: raw :: c_uint , pub __esp : :: std :: os :: raw :: c_uint , pub __ss : :: std :: os :: raw :: c_uint , pub __eflags : :: std :: os :: raw :: c_uint , pub __eip : :: std :: os :: raw :: c_uint , pub __cs : :: std :: os :: raw :: c_uint , pub __ds : :: std :: os :: raw :: c_uint , pub __es : :: std :: os :: raw :: c_uint , pub __fs : :: std :: os :: raw :: c_uint , pub __gs : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout___darwin_i386_thread_state ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_i386_thread_state > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( __darwin_i386_thread_state ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_i386_thread_state > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __darwin_i386_thread_state ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __eax as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_thread_state ) , "::" , stringify ! ( __eax ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ebx as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_thread_state ) , "::" , stringify ! ( __ebx ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ecx as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_thread_state ) , "::" , stringify ! ( __ecx ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __edx as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_thread_state ) , "::" , stringify ! ( __edx ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __edi as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_thread_state ) , "::" , stringify ! ( __edi ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __esi as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_thread_state ) , "::" , stringify ! ( __esi ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ebp as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_thread_state ) , "::" , stringify ! ( __ebp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __esp as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_thread_state ) , "::" , stringify ! ( __esp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ss as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_thread_state ) , "::" , stringify ! ( __ss ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __eflags as * const _ as usize } , 36usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_thread_state ) , "::" , stringify ! ( __eflags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __eip as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_thread_state ) , "::" , stringify ! ( __eip ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __cs as * const _ as usize } , 44usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_thread_state ) , "::" , stringify ! ( __cs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __ds as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_thread_state ) , "::" , stringify ! ( __ds ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __es as * const _ as usize } , 52usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_thread_state ) , "::" , stringify ! ( __es ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __fs as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_thread_state ) , "::" , stringify ! ( __fs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_thread_state ) ) . __gs as * const _ as usize } , 60usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_thread_state ) , "::" , stringify ! ( __gs ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __darwin_fp_control { pub _bitfield_1 : [ u8 ; 2usize ] , pub __bindgen_align : [ u16 ; 0usize ] , } # [ test ] fn bindgen_test_layout___darwin_fp_control ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_fp_control > ( ) , 2usize , concat ! ( "Size of: " , stringify ! ( __darwin_fp_control ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_fp_control > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( __darwin_fp_control ) ) ) ; } impl __darwin_fp_control { # [ inline ] pub fn __invalid ( & self ) -> :: std :: os :: raw :: c_ushort { let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0x1 as u16 ; let val = ( unit_field_val & mask ) >> 0usize ; unsafe { :: std :: mem :: transmute ( val as u16 ) } } # [ inline ] pub fn set___invalid ( & mut self , val : :: std :: os :: raw :: c_ushort ) { let mask = 0x1 as u16 ; let val = val as u16 as u16 ; let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 0usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn __denorm ( & self ) -> :: std :: os :: raw :: c_ushort { let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0x2 as u16 ; let val = ( unit_field_val & mask ) >> 1usize ; unsafe { :: std :: mem :: transmute ( val as u16 ) } } # [ inline ] pub fn set___denorm ( & mut self , val : :: std :: os :: raw :: c_ushort ) { let mask = 0x2 as u16 ; let val = val as u16 as u16 ; let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 1usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn __zdiv ( & self ) -> :: std :: os :: raw :: c_ushort { let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0x4 as u16 ; let val = ( unit_field_val & mask ) >> 2usize ; unsafe { :: std :: mem :: transmute ( val as u16 ) } } # [ inline ] pub fn set___zdiv ( & mut self , val : :: std :: os :: raw :: c_ushort ) { let mask = 0x4 as u16 ; let val = val as u16 as u16 ; let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 2usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn __ovrfl ( & self ) -> :: std :: os :: raw :: c_ushort { let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0x8 as u16 ; let val = ( unit_field_val & mask ) >> 3usize ; unsafe { :: std :: mem :: transmute ( val as u16 ) } } # [ inline ] pub fn set___ovrfl ( & mut self , val : :: std :: os :: raw :: c_ushort ) { let mask = 0x8 as u16 ; let val = val as u16 as u16 ; let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 3usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn __undfl ( & self ) -> :: std :: os :: raw :: c_ushort { let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0x10 as u16 ; let val = ( unit_field_val & mask ) >> 4usize ; unsafe { :: std :: mem :: transmute ( val as u16 ) } } # [ inline ] pub fn set___undfl ( & mut self , val : :: std :: os :: raw :: c_ushort ) { let mask = 0x10 as u16 ; let val = val as u16 as u16 ; let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 4usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn __precis ( & self ) -> :: std :: os :: raw :: c_ushort { let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0x20 as u16 ; let val = ( unit_field_val & mask ) >> 5usize ; unsafe { :: std :: mem :: transmute ( val as u16 ) } } # [ inline ] pub fn set___precis ( & mut self , val : :: std :: os :: raw :: c_ushort ) { let mask = 0x20 as u16 ; let val = val as u16 as u16 ; let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 5usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn __pc ( & self ) -> :: std :: os :: raw :: c_ushort { let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0x300 as u16 ; let val = ( unit_field_val & mask ) >> 8usize ; unsafe { :: std :: mem :: transmute ( val as u16 ) } } # [ inline ] pub fn set___pc ( & mut self , val : :: std :: os :: raw :: c_ushort ) { let mask = 0x300 as u16 ; let val = val as u16 as u16 ; let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 8usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn __rc ( & self ) -> :: std :: os :: raw :: c_ushort { let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0xc00 as u16 ; let val = ( unit_field_val & mask ) >> 10usize ; unsafe { :: std :: mem :: transmute ( val as u16 ) } } # [ inline ] pub fn set___rc ( & mut self , val : :: std :: os :: raw :: c_ushort ) { let mask = 0xc00 as u16 ; let val = val as u16 as u16 ; let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 10usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn new_bitfield_1 ( __invalid : :: std :: os :: raw :: c_ushort , __denorm : :: std :: os :: raw :: c_ushort , __zdiv : :: std :: os :: raw :: c_ushort , __ovrfl : :: std :: os :: raw :: c_ushort , __undfl : :: std :: os :: raw :: c_ushort , __precis : :: std :: os :: raw :: c_ushort , __pc : :: std :: os :: raw :: c_ushort , __rc : :: std :: os :: raw :: c_ushort ) -> u16 { ( ( ( ( ( ( ( ( 0 | ( ( __invalid as u16 as u16 ) << 0usize ) & ( 0x1 as u16 ) ) | ( ( __denorm as u16 as u16 ) << 1usize ) & ( 0x2 as u16 ) ) | ( ( __zdiv as u16 as u16 ) << 2usize ) & ( 0x4 as u16 ) ) | ( ( __ovrfl as u16 as u16 ) << 3usize ) & ( 0x8 as u16 ) ) | ( ( __undfl as u16 as u16 ) << 4usize ) & ( 0x10 as u16 ) ) | ( ( __precis as u16 as u16 ) << 5usize ) & ( 0x20 as u16 ) ) | ( ( __pc as u16 as u16 ) << 8usize ) & ( 0x300 as u16 ) ) | ( ( __rc as u16 as u16 ) << 10usize ) & ( 0xc00 as u16 ) ) } } pub type __darwin_fp_control_t = __darwin_fp_control ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __darwin_fp_status { pub _bitfield_1 : [ u8 ; 2usize ] , pub __bindgen_align : [ u16 ; 0usize ] , } # [ test ] fn bindgen_test_layout___darwin_fp_status ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_fp_status > ( ) , 2usize , concat ! ( "Size of: " , stringify ! ( __darwin_fp_status ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_fp_status > ( ) , 2usize , concat ! ( "Alignment of " , stringify ! ( __darwin_fp_status ) ) ) ; } impl __darwin_fp_status { # [ inline ] pub fn __invalid ( & self ) -> :: std :: os :: raw :: c_ushort { let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0x1 as u16 ; let val = ( unit_field_val & mask ) >> 0usize ; unsafe { :: std :: mem :: transmute ( val as u16 ) } } # [ inline ] pub fn set___invalid ( & mut self , val : :: std :: os :: raw :: c_ushort ) { let mask = 0x1 as u16 ; let val = val as u16 as u16 ; let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 0usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn __denorm ( & self ) -> :: std :: os :: raw :: c_ushort { let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0x2 as u16 ; let val = ( unit_field_val & mask ) >> 1usize ; unsafe { :: std :: mem :: transmute ( val as u16 ) } } # [ inline ] pub fn set___denorm ( & mut self , val : :: std :: os :: raw :: c_ushort ) { let mask = 0x2 as u16 ; let val = val as u16 as u16 ; let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 1usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn __zdiv ( & self ) -> :: std :: os :: raw :: c_ushort { let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0x4 as u16 ; let val = ( unit_field_val & mask ) >> 2usize ; unsafe { :: std :: mem :: transmute ( val as u16 ) } } # [ inline ] pub fn set___zdiv ( & mut self , val : :: std :: os :: raw :: c_ushort ) { let mask = 0x4 as u16 ; let val = val as u16 as u16 ; let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 2usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn __ovrfl ( & self ) -> :: std :: os :: raw :: c_ushort { let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0x8 as u16 ; let val = ( unit_field_val & mask ) >> 3usize ; unsafe { :: std :: mem :: transmute ( val as u16 ) } } # [ inline ] pub fn set___ovrfl ( & mut self , val : :: std :: os :: raw :: c_ushort ) { let mask = 0x8 as u16 ; let val = val as u16 as u16 ; let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 3usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn __undfl ( & self ) -> :: std :: os :: raw :: c_ushort { let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0x10 as u16 ; let val = ( unit_field_val & mask ) >> 4usize ; unsafe { :: std :: mem :: transmute ( val as u16 ) } } # [ inline ] pub fn set___undfl ( & mut self , val : :: std :: os :: raw :: c_ushort ) { let mask = 0x10 as u16 ; let val = val as u16 as u16 ; let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 4usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn __precis ( & self ) -> :: std :: os :: raw :: c_ushort { let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0x20 as u16 ; let val = ( unit_field_val & mask ) >> 5usize ; unsafe { :: std :: mem :: transmute ( val as u16 ) } } # [ inline ] pub fn set___precis ( & mut self , val : :: std :: os :: raw :: c_ushort ) { let mask = 0x20 as u16 ; let val = val as u16 as u16 ; let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 5usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn __stkflt ( & self ) -> :: std :: os :: raw :: c_ushort { let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0x40 as u16 ; let val = ( unit_field_val & mask ) >> 6usize ; unsafe { :: std :: mem :: transmute ( val as u16 ) } } # [ inline ] pub fn set___stkflt ( & mut self , val : :: std :: os :: raw :: c_ushort ) { let mask = 0x40 as u16 ; let val = val as u16 as u16 ; let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 6usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn __errsumm ( & self ) -> :: std :: os :: raw :: c_ushort { let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0x80 as u16 ; let val = ( unit_field_val & mask ) >> 7usize ; unsafe { :: std :: mem :: transmute ( val as u16 ) } } # [ inline ] pub fn set___errsumm ( & mut self , val : :: std :: os :: raw :: c_ushort ) { let mask = 0x80 as u16 ; let val = val as u16 as u16 ; let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 7usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn __c0 ( & self ) -> :: std :: os :: raw :: c_ushort { let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0x100 as u16 ; let val = ( unit_field_val & mask ) >> 8usize ; unsafe { :: std :: mem :: transmute ( val as u16 ) } } # [ inline ] pub fn set___c0 ( & mut self , val : :: std :: os :: raw :: c_ushort ) { let mask = 0x100 as u16 ; let val = val as u16 as u16 ; let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 8usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn __c1 ( & self ) -> :: std :: os :: raw :: c_ushort { let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0x200 as u16 ; let val = ( unit_field_val & mask ) >> 9usize ; unsafe { :: std :: mem :: transmute ( val as u16 ) } } # [ inline ] pub fn set___c1 ( & mut self , val : :: std :: os :: raw :: c_ushort ) { let mask = 0x200 as u16 ; let val = val as u16 as u16 ; let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 9usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn __c2 ( & self ) -> :: std :: os :: raw :: c_ushort { let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0x400 as u16 ; let val = ( unit_field_val & mask ) >> 10usize ; unsafe { :: std :: mem :: transmute ( val as u16 ) } } # [ inline ] pub fn set___c2 ( & mut self , val : :: std :: os :: raw :: c_ushort ) { let mask = 0x400 as u16 ; let val = val as u16 as u16 ; let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 10usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn __tos ( & self ) -> :: std :: os :: raw :: c_ushort { let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0x3800 as u16 ; let val = ( unit_field_val & mask ) >> 11usize ; unsafe { :: std :: mem :: transmute ( val as u16 ) } } # [ inline ] pub fn set___tos ( & mut self , val : :: std :: os :: raw :: c_ushort ) { let mask = 0x3800 as u16 ; let val = val as u16 as u16 ; let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 11usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn __c3 ( & self ) -> :: std :: os :: raw :: c_ushort { let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0x4000 as u16 ; let val = ( unit_field_val & mask ) >> 14usize ; unsafe { :: std :: mem :: transmute ( val as u16 ) } } # [ inline ] pub fn set___c3 ( & mut self , val : :: std :: os :: raw :: c_ushort ) { let mask = 0x4000 as u16 ; let val = val as u16 as u16 ; let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 14usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn __busy ( & self ) -> :: std :: os :: raw :: c_ushort { let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0x8000 as u16 ; let val = ( unit_field_val & mask ) >> 15usize ; unsafe { :: std :: mem :: transmute ( val as u16 ) } } # [ inline ] pub fn set___busy ( & mut self , val : :: std :: os :: raw :: c_ushort ) { let mask = 0x8000 as u16 ; let val = val as u16 as u16 ; let mut unit_field_val : u16 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 15usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn new_bitfield_1 ( __invalid : :: std :: os :: raw :: c_ushort , __denorm : :: std :: os :: raw :: c_ushort , __zdiv : :: std :: os :: raw :: c_ushort , __ovrfl : :: std :: os :: raw :: c_ushort , __undfl : :: std :: os :: raw :: c_ushort , __precis : :: std :: os :: raw :: c_ushort , __stkflt : :: std :: os :: raw :: c_ushort , __errsumm : :: std :: os :: raw :: c_ushort , __c0 : :: std :: os :: raw :: c_ushort , __c1 : :: std :: os :: raw :: c_ushort , __c2 : :: std :: os :: raw :: c_ushort , __tos : :: std :: os :: raw :: c_ushort , __c3 : :: std :: os :: raw :: c_ushort , __busy : :: std :: os :: raw :: c_ushort ) -> u16 { ( ( ( ( ( ( ( ( ( ( ( ( ( ( 0 | ( ( __invalid as u16 as u16 ) << 0usize ) & ( 0x1 as u16 ) ) | ( ( __denorm as u16 as u16 ) << 1usize ) & ( 0x2 as u16 ) ) | ( ( __zdiv as u16 as u16 ) << 2usize ) & ( 0x4 as u16 ) ) | ( ( __ovrfl as u16 as u16 ) << 3usize ) & ( 0x8 as u16 ) ) | ( ( __undfl as u16 as u16 ) << 4usize ) & ( 0x10 as u16 ) ) | ( ( __precis as u16 as u16 ) << 5usize ) & ( 0x20 as u16 ) ) | ( ( __stkflt as u16 as u16 ) << 6usize ) & ( 0x40 as u16 ) ) | ( ( __errsumm as u16 as u16 ) << 7usize ) & ( 0x80 as u16 ) ) | ( ( __c0 as u16 as u16 ) << 8usize ) & ( 0x100 as u16 ) ) | ( ( __c1 as u16 as u16 ) << 9usize ) & ( 0x200 as u16 ) ) | ( ( __c2 as u16 as u16 ) << 10usize ) & ( 0x400 as u16 ) ) | ( ( __tos as u16 as u16 ) << 11usize ) & ( 0x3800 as u16 ) ) | ( ( __c3 as u16 as u16 ) << 14usize ) & ( 0x4000 as u16 ) ) | ( ( __busy as u16 as u16 ) << 15usize ) & ( 0x8000 as u16 ) ) } } pub type __darwin_fp_status_t = __darwin_fp_status ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __darwin_mmst_reg { pub __mmst_reg : [ :: std :: os :: raw :: c_char ; 10usize ] , pub __mmst_rsrv : [ :: std :: os :: raw :: c_char ; 6usize ] , } # [ test ] fn bindgen_test_layout___darwin_mmst_reg ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_mmst_reg > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( __darwin_mmst_reg ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_mmst_reg > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( __darwin_mmst_reg ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_mmst_reg ) ) . __mmst_reg as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_mmst_reg ) , "::" , stringify ! ( __mmst_reg ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_mmst_reg ) ) . __mmst_rsrv as * const _ as usize } , 10usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_mmst_reg ) , "::" , stringify ! ( __mmst_rsrv ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __darwin_xmm_reg { pub __xmm_reg : [ :: std :: os :: raw :: c_char ; 16usize ] , } # [ test ] fn bindgen_test_layout___darwin_xmm_reg ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_xmm_reg > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( __darwin_xmm_reg ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_xmm_reg > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( __darwin_xmm_reg ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_xmm_reg ) ) . __xmm_reg as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_xmm_reg ) , "::" , stringify ! ( __xmm_reg ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __darwin_ymm_reg { pub __ymm_reg : [ :: std :: os :: raw :: c_char ; 32usize ] , } # [ test ] fn bindgen_test_layout___darwin_ymm_reg ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_ymm_reg > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( __darwin_ymm_reg ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_ymm_reg > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( __darwin_ymm_reg ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_ymm_reg ) ) . __ymm_reg as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_ymm_reg ) , "::" , stringify ! ( __ymm_reg ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __darwin_zmm_reg { pub __zmm_reg : [ :: std :: os :: raw :: c_char ; 64usize ] , } # [ test ] fn bindgen_test_layout___darwin_zmm_reg ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_zmm_reg > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( __darwin_zmm_reg ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_zmm_reg > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( __darwin_zmm_reg ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_zmm_reg ) ) . __zmm_reg as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_zmm_reg ) , "::" , stringify ! ( __zmm_reg ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __darwin_opmask_reg { pub __opmask_reg : [ :: std :: os :: raw :: c_char ; 8usize ] , } # [ test ] fn bindgen_test_layout___darwin_opmask_reg ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_opmask_reg > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __darwin_opmask_reg ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_opmask_reg > ( ) , 1usize , concat ! ( "Alignment of " , stringify ! ( __darwin_opmask_reg ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_opmask_reg ) ) . __opmask_reg as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_opmask_reg ) , "::" , stringify ! ( __opmask_reg ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __darwin_i386_float_state { pub __fpu_reserved : [ :: std :: os :: raw :: c_int ; 2usize ] , pub __fpu_fcw : __darwin_fp_control , pub __fpu_fsw : __darwin_fp_status , pub __fpu_ftw : __uint8_t , pub __fpu_rsrv1 : __uint8_t , pub __fpu_fop : __uint16_t , pub __fpu_ip : __uint32_t , pub __fpu_cs : __uint16_t , pub __fpu_rsrv2 : __uint16_t , pub __fpu_dp : __uint32_t , pub __fpu_ds : __uint16_t , pub __fpu_rsrv3 : __uint16_t , pub __fpu_mxcsr : __uint32_t , pub __fpu_mxcsrmask : __uint32_t , pub __fpu_stmm0 : __darwin_mmst_reg , pub __fpu_stmm1 : __darwin_mmst_reg , pub __fpu_stmm2 : __darwin_mmst_reg , pub __fpu_stmm3 : __darwin_mmst_reg , pub __fpu_stmm4 : __darwin_mmst_reg , pub __fpu_stmm5 : __darwin_mmst_reg , pub __fpu_stmm6 : __darwin_mmst_reg , pub __fpu_stmm7 : __darwin_mmst_reg , pub __fpu_xmm0 : __darwin_xmm_reg , pub __fpu_xmm1 : __darwin_xmm_reg , pub __fpu_xmm2 : __darwin_xmm_reg , pub __fpu_xmm3 : __darwin_xmm_reg , pub __fpu_xmm4 : __darwin_xmm_reg , pub __fpu_xmm5 : __darwin_xmm_reg , pub __fpu_xmm6 : __darwin_xmm_reg , pub __fpu_xmm7 : __darwin_xmm_reg , pub __fpu_rsrv4 : [ :: std :: os :: raw :: c_char ; 224usize ] , pub __fpu_reserved1 : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout___darwin_i386_float_state ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_i386_float_state > ( ) , 524usize , concat ! ( "Size of: " , stringify ! ( __darwin_i386_float_state ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_i386_float_state > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __darwin_i386_float_state ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_reserved as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_reserved ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_fcw as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_fcw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_fsw as * const _ as usize } , 10usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_fsw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_ftw as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_ftw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_rsrv1 as * const _ as usize } , 13usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_rsrv1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_fop as * const _ as usize } , 14usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_fop ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_ip as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_ip ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_cs as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_cs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_rsrv2 as * const _ as usize } , 22usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_rsrv2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_dp as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_dp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_ds as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_ds ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_rsrv3 as * const _ as usize } , 30usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_rsrv3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_mxcsr as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_mxcsr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_mxcsrmask ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_stmm0 as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_stmm1 as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_stmm2 as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_stmm3 as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_stmm4 as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_stmm5 as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_stmm6 as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_stmm7 as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_stmm7 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_xmm0 as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_xmm1 as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_xmm2 as * const _ as usize } , 200usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_xmm3 as * const _ as usize } , 216usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_xmm4 as * const _ as usize } , 232usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_xmm5 as * const _ as usize } , 248usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_xmm6 as * const _ as usize } , 264usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_xmm7 as * const _ as usize } , 280usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_xmm7 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_rsrv4 as * const _ as usize } , 296usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_rsrv4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_float_state ) ) . __fpu_reserved1 as * const _ as usize } , 520usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_float_state ) , "::" , stringify ! ( __fpu_reserved1 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __darwin_i386_avx_state { pub __fpu_reserved : [ :: std :: os :: raw :: c_int ; 2usize ] , pub __fpu_fcw : __darwin_fp_control , pub __fpu_fsw : __darwin_fp_status , pub __fpu_ftw : __uint8_t , pub __fpu_rsrv1 : __uint8_t , pub __fpu_fop : __uint16_t , pub __fpu_ip : __uint32_t , pub __fpu_cs : __uint16_t , pub __fpu_rsrv2 : __uint16_t , pub __fpu_dp : __uint32_t , pub __fpu_ds : __uint16_t , pub __fpu_rsrv3 : __uint16_t , pub __fpu_mxcsr : __uint32_t , pub __fpu_mxcsrmask : __uint32_t , pub __fpu_stmm0 : __darwin_mmst_reg , pub __fpu_stmm1 : __darwin_mmst_reg , pub __fpu_stmm2 : __darwin_mmst_reg , pub __fpu_stmm3 : __darwin_mmst_reg , pub __fpu_stmm4 : __darwin_mmst_reg , pub __fpu_stmm5 : __darwin_mmst_reg , pub __fpu_stmm6 : __darwin_mmst_reg , pub __fpu_stmm7 : __darwin_mmst_reg , pub __fpu_xmm0 : __darwin_xmm_reg , pub __fpu_xmm1 : __darwin_xmm_reg , pub __fpu_xmm2 : __darwin_xmm_reg , pub __fpu_xmm3 : __darwin_xmm_reg , pub __fpu_xmm4 : __darwin_xmm_reg , pub __fpu_xmm5 : __darwin_xmm_reg , pub __fpu_xmm6 : __darwin_xmm_reg , pub __fpu_xmm7 : __darwin_xmm_reg , pub __fpu_rsrv4 : [ :: std :: os :: raw :: c_char ; 224usize ] , pub __fpu_reserved1 : :: std :: os :: raw :: c_int , pub __avx_reserved1 : [ :: std :: os :: raw :: c_char ; 64usize ] , pub __fpu_ymmh0 : __darwin_xmm_reg , pub __fpu_ymmh1 : __darwin_xmm_reg , pub __fpu_ymmh2 : __darwin_xmm_reg , pub __fpu_ymmh3 : __darwin_xmm_reg , pub __fpu_ymmh4 : __darwin_xmm_reg , pub __fpu_ymmh5 : __darwin_xmm_reg , pub __fpu_ymmh6 : __darwin_xmm_reg , pub __fpu_ymmh7 : __darwin_xmm_reg , } # [ test ] fn bindgen_test_layout___darwin_i386_avx_state ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_i386_avx_state > ( ) , 716usize , concat ! ( "Size of: " , stringify ! ( __darwin_i386_avx_state ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_i386_avx_state > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __darwin_i386_avx_state ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_reserved as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_reserved ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_fcw as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_fcw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_fsw as * const _ as usize } , 10usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_fsw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ftw as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_ftw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_rsrv1 as * const _ as usize } , 13usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_rsrv1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_fop as * const _ as usize } , 14usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_fop ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ip as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_ip ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_cs as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_cs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_rsrv2 as * const _ as usize } , 22usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_rsrv2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_dp as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_dp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ds as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_ds ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_rsrv3 as * const _ as usize } , 30usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_rsrv3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_mxcsr as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_mxcsr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_mxcsrmask ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm0 as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_stmm0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm1 as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_stmm1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm2 as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_stmm2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm3 as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_stmm3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm4 as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_stmm4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm5 as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_stmm5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm6 as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_stmm6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_stmm7 as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_stmm7 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm0 as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_xmm0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm1 as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_xmm1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm2 as * const _ as usize } , 200usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_xmm2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm3 as * const _ as usize } , 216usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_xmm3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm4 as * const _ as usize } , 232usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_xmm4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm5 as * const _ as usize } , 248usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_xmm5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm6 as * const _ as usize } , 264usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_xmm6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_xmm7 as * const _ as usize } , 280usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_xmm7 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_rsrv4 as * const _ as usize } , 296usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_rsrv4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_reserved1 as * const _ as usize } , 520usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_reserved1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __avx_reserved1 as * const _ as usize } , 524usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __avx_reserved1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh0 as * const _ as usize } , 588usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_ymmh0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh1 as * const _ as usize } , 604usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_ymmh1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh2 as * const _ as usize } , 620usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_ymmh2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh3 as * const _ as usize } , 636usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_ymmh3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh4 as * const _ as usize } , 652usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_ymmh4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh5 as * const _ as usize } , 668usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_ymmh5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh6 as * const _ as usize } , 684usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_ymmh6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx_state ) ) . __fpu_ymmh7 as * const _ as usize } , 700usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx_state ) , "::" , stringify ! ( __fpu_ymmh7 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __darwin_i386_avx512_state { pub __fpu_reserved : [ :: std :: os :: raw :: c_int ; 2usize ] , pub __fpu_fcw : __darwin_fp_control , pub __fpu_fsw : __darwin_fp_status , pub __fpu_ftw : __uint8_t , pub __fpu_rsrv1 : __uint8_t , pub __fpu_fop : __uint16_t , pub __fpu_ip : __uint32_t , pub __fpu_cs : __uint16_t , pub __fpu_rsrv2 : __uint16_t , pub __fpu_dp : __uint32_t , pub __fpu_ds : __uint16_t , pub __fpu_rsrv3 : __uint16_t , pub __fpu_mxcsr : __uint32_t , pub __fpu_mxcsrmask : __uint32_t , pub __fpu_stmm0 : __darwin_mmst_reg , pub __fpu_stmm1 : __darwin_mmst_reg , pub __fpu_stmm2 : __darwin_mmst_reg , pub __fpu_stmm3 : __darwin_mmst_reg , pub __fpu_stmm4 : __darwin_mmst_reg , pub __fpu_stmm5 : __darwin_mmst_reg , pub __fpu_stmm6 : __darwin_mmst_reg , pub __fpu_stmm7 : __darwin_mmst_reg , pub __fpu_xmm0 : __darwin_xmm_reg , pub __fpu_xmm1 : __darwin_xmm_reg , pub __fpu_xmm2 : __darwin_xmm_reg , pub __fpu_xmm3 : __darwin_xmm_reg , pub __fpu_xmm4 : __darwin_xmm_reg , pub __fpu_xmm5 : __darwin_xmm_reg , pub __fpu_xmm6 : __darwin_xmm_reg , pub __fpu_xmm7 : __darwin_xmm_reg , pub __fpu_rsrv4 : [ :: std :: os :: raw :: c_char ; 224usize ] , pub __fpu_reserved1 : :: std :: os :: raw :: c_int , pub __avx_reserved1 : [ :: std :: os :: raw :: c_char ; 64usize ] , pub __fpu_ymmh0 : __darwin_xmm_reg , pub __fpu_ymmh1 : __darwin_xmm_reg , pub __fpu_ymmh2 : __darwin_xmm_reg , pub __fpu_ymmh3 : __darwin_xmm_reg , pub __fpu_ymmh4 : __darwin_xmm_reg , pub __fpu_ymmh5 : __darwin_xmm_reg , pub __fpu_ymmh6 : __darwin_xmm_reg , pub __fpu_ymmh7 : __darwin_xmm_reg , pub __fpu_k0 : __darwin_opmask_reg , pub __fpu_k1 : __darwin_opmask_reg , pub __fpu_k2 : __darwin_opmask_reg , pub __fpu_k3 : __darwin_opmask_reg , pub __fpu_k4 : __darwin_opmask_reg , pub __fpu_k5 : __darwin_opmask_reg , pub __fpu_k6 : __darwin_opmask_reg , pub __fpu_k7 : __darwin_opmask_reg , pub __fpu_zmmh0 : __darwin_ymm_reg , pub __fpu_zmmh1 : __darwin_ymm_reg , pub __fpu_zmmh2 : __darwin_ymm_reg , pub __fpu_zmmh3 : __darwin_ymm_reg , pub __fpu_zmmh4 : __darwin_ymm_reg , pub __fpu_zmmh5 : __darwin_ymm_reg , pub __fpu_zmmh6 : __darwin_ymm_reg , pub __fpu_zmmh7 : __darwin_ymm_reg , } # [ test ] fn bindgen_test_layout___darwin_i386_avx512_state ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_i386_avx512_state > ( ) , 1036usize , concat ! ( "Size of: " , stringify ! ( __darwin_i386_avx512_state ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_i386_avx512_state > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __darwin_i386_avx512_state ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_reserved as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_reserved ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_fcw as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_fcw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_fsw as * const _ as usize } , 10usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_fsw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_ftw as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_ftw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_rsrv1 as * const _ as usize } , 13usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_rsrv1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_fop as * const _ as usize } , 14usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_fop ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_ip as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_ip ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_cs as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_cs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_rsrv2 as * const _ as usize } , 22usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_rsrv2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_dp as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_dp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_ds as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_ds ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_rsrv3 as * const _ as usize } , 30usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_rsrv3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_mxcsr as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_mxcsr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_mxcsrmask ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_stmm0 as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_stmm0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_stmm1 as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_stmm1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_stmm2 as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_stmm2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_stmm3 as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_stmm3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_stmm4 as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_stmm4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_stmm5 as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_stmm5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_stmm6 as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_stmm6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_stmm7 as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_stmm7 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_xmm0 as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_xmm0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_xmm1 as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_xmm1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_xmm2 as * const _ as usize } , 200usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_xmm2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_xmm3 as * const _ as usize } , 216usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_xmm3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_xmm4 as * const _ as usize } , 232usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_xmm4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_xmm5 as * const _ as usize } , 248usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_xmm5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_xmm6 as * const _ as usize } , 264usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_xmm6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_xmm7 as * const _ as usize } , 280usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_xmm7 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_rsrv4 as * const _ as usize } , 296usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_rsrv4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_reserved1 as * const _ as usize } , 520usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_reserved1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __avx_reserved1 as * const _ as usize } , 524usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __avx_reserved1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_ymmh0 as * const _ as usize } , 588usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_ymmh0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_ymmh1 as * const _ as usize } , 604usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_ymmh1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_ymmh2 as * const _ as usize } , 620usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_ymmh2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_ymmh3 as * const _ as usize } , 636usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_ymmh3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_ymmh4 as * const _ as usize } , 652usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_ymmh4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_ymmh5 as * const _ as usize } , 668usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_ymmh5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_ymmh6 as * const _ as usize } , 684usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_ymmh6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_ymmh7 as * const _ as usize } , 700usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_ymmh7 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_k0 as * const _ as usize } , 716usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_k0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_k1 as * const _ as usize } , 724usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_k1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_k2 as * const _ as usize } , 732usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_k2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_k3 as * const _ as usize } , 740usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_k3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_k4 as * const _ as usize } , 748usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_k4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_k5 as * const _ as usize } , 756usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_k5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_k6 as * const _ as usize } , 764usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_k6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_k7 as * const _ as usize } , 772usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_k7 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_zmmh0 as * const _ as usize } , 780usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_zmmh0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_zmmh1 as * const _ as usize } , 812usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_zmmh1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_zmmh2 as * const _ as usize } , 844usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_zmmh2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_zmmh3 as * const _ as usize } , 876usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_zmmh3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_zmmh4 as * const _ as usize } , 908usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_zmmh4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_zmmh5 as * const _ as usize } , 940usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_zmmh5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_zmmh6 as * const _ as usize } , 972usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_zmmh6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_avx512_state ) ) . __fpu_zmmh7 as * const _ as usize } , 1004usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_avx512_state ) , "::" , stringify ! ( __fpu_zmmh7 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __darwin_i386_exception_state { pub __trapno : __uint16_t , pub __cpu : __uint16_t , pub __err : __uint32_t , pub __faultvaddr : __uint32_t , } # [ test ] fn bindgen_test_layout___darwin_i386_exception_state ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_i386_exception_state > ( ) , 12usize , concat ! ( "Size of: " , stringify ! ( __darwin_i386_exception_state ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_i386_exception_state > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __darwin_i386_exception_state ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_exception_state ) ) . __trapno as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_exception_state ) , "::" , stringify ! ( __trapno ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_exception_state ) ) . __cpu as * const _ as usize } , 2usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_exception_state ) , "::" , stringify ! ( __cpu ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_exception_state ) ) . __err as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_exception_state ) , "::" , stringify ! ( __err ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_i386_exception_state ) ) . __faultvaddr as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_i386_exception_state ) , "::" , stringify ! ( __faultvaddr ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __darwin_x86_debug_state32 { pub __dr0 : :: std :: os :: raw :: c_uint , pub __dr1 : :: std :: os :: raw :: c_uint , pub __dr2 : :: std :: os :: raw :: c_uint , pub __dr3 : :: std :: os :: raw :: c_uint , pub __dr4 : :: std :: os :: raw :: c_uint , pub __dr5 : :: std :: os :: raw :: c_uint , pub __dr6 : :: std :: os :: raw :: c_uint , pub __dr7 : :: std :: os :: raw :: c_uint , } # [ test ] fn bindgen_test_layout___darwin_x86_debug_state32 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_x86_debug_state32 > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( __darwin_x86_debug_state32 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_x86_debug_state32 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __darwin_x86_debug_state32 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr0 as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr1 as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr2 as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr3 as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr4 as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr5 as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr6 as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_debug_state32 ) ) . __dr7 as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_debug_state32 ) , "::" , stringify ! ( __dr7 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __darwin_x86_thread_state64 { pub __rax : __uint64_t , pub __rbx : __uint64_t , pub __rcx : __uint64_t , pub __rdx : __uint64_t , pub __rdi : __uint64_t , pub __rsi : __uint64_t , pub __rbp : __uint64_t , pub __rsp : __uint64_t , pub __r8 : __uint64_t , pub __r9 : __uint64_t , pub __r10 : __uint64_t , pub __r11 : __uint64_t , pub __r12 : __uint64_t , pub __r13 : __uint64_t , pub __r14 : __uint64_t , pub __r15 : __uint64_t , pub __rip : __uint64_t , pub __rflags : __uint64_t , pub __cs : __uint64_t , pub __fs : __uint64_t , pub __gs : __uint64_t , } # [ test ] fn bindgen_test_layout___darwin_x86_thread_state64 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_x86_thread_state64 > ( ) , 168usize , concat ! ( "Size of: " , stringify ! ( __darwin_x86_thread_state64 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_x86_thread_state64 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __darwin_x86_thread_state64 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rax as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rax ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rbx as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rbx ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rcx as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rcx ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rdx as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rdx ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rdi as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rdi ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rsi as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rsi ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rbp as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rbp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rsp as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rsp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r8 as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r8 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r9 as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r9 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r10 as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r10 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r11 as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r11 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r12 as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r12 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r13 as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r13 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r14 as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r14 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __r15 as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_thread_state64 ) , "::" , stringify ! ( __r15 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rip as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rip ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __rflags as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_thread_state64 ) , "::" , stringify ! ( __rflags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __cs as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_thread_state64 ) , "::" , stringify ! ( __cs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __fs as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_thread_state64 ) , "::" , stringify ! ( __fs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_thread_state64 ) ) . __gs as * const _ as usize } , 160usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_thread_state64 ) , "::" , stringify ! ( __gs ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __darwin_x86_float_state64 { pub __fpu_reserved : [ :: std :: os :: raw :: c_int ; 2usize ] , pub __fpu_fcw : __darwin_fp_control , pub __fpu_fsw : __darwin_fp_status , pub __fpu_ftw : __uint8_t , pub __fpu_rsrv1 : __uint8_t , pub __fpu_fop : __uint16_t , pub __fpu_ip : __uint32_t , pub __fpu_cs : __uint16_t , pub __fpu_rsrv2 : __uint16_t , pub __fpu_dp : __uint32_t , pub __fpu_ds : __uint16_t , pub __fpu_rsrv3 : __uint16_t , pub __fpu_mxcsr : __uint32_t , pub __fpu_mxcsrmask : __uint32_t , pub __fpu_stmm0 : __darwin_mmst_reg , pub __fpu_stmm1 : __darwin_mmst_reg , pub __fpu_stmm2 : __darwin_mmst_reg , pub __fpu_stmm3 : __darwin_mmst_reg , pub __fpu_stmm4 : __darwin_mmst_reg , pub __fpu_stmm5 : __darwin_mmst_reg , pub __fpu_stmm6 : __darwin_mmst_reg , pub __fpu_stmm7 : __darwin_mmst_reg , pub __fpu_xmm0 : __darwin_xmm_reg , pub __fpu_xmm1 : __darwin_xmm_reg , pub __fpu_xmm2 : __darwin_xmm_reg , pub __fpu_xmm3 : __darwin_xmm_reg , pub __fpu_xmm4 : __darwin_xmm_reg , pub __fpu_xmm5 : __darwin_xmm_reg , pub __fpu_xmm6 : __darwin_xmm_reg , pub __fpu_xmm7 : __darwin_xmm_reg , pub __fpu_xmm8 : __darwin_xmm_reg , pub __fpu_xmm9 : __darwin_xmm_reg , pub __fpu_xmm10 : __darwin_xmm_reg , pub __fpu_xmm11 : __darwin_xmm_reg , pub __fpu_xmm12 : __darwin_xmm_reg , pub __fpu_xmm13 : __darwin_xmm_reg , pub __fpu_xmm14 : __darwin_xmm_reg , pub __fpu_xmm15 : __darwin_xmm_reg , pub __fpu_rsrv4 : [ :: std :: os :: raw :: c_char ; 96usize ] , pub __fpu_reserved1 : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout___darwin_x86_float_state64 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_x86_float_state64 > ( ) , 524usize , concat ! ( "Size of: " , stringify ! ( __darwin_x86_float_state64 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_x86_float_state64 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __darwin_x86_float_state64 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_reserved as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_reserved ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_fcw as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_fcw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_fsw as * const _ as usize } , 10usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_fsw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_ftw as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_ftw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_rsrv1 as * const _ as usize } , 13usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_rsrv1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_fop as * const _ as usize } , 14usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_fop ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_ip as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_ip ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_cs as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_cs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_rsrv2 as * const _ as usize } , 22usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_rsrv2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_dp as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_dp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_ds as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_ds ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_rsrv3 as * const _ as usize } , 30usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_rsrv3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_mxcsr as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_mxcsr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_mxcsrmask ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_stmm0 as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_stmm0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_stmm1 as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_stmm1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_stmm2 as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_stmm2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_stmm3 as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_stmm3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_stmm4 as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_stmm4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_stmm5 as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_stmm5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_stmm6 as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_stmm6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_stmm7 as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_stmm7 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_xmm0 as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_xmm1 as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_xmm2 as * const _ as usize } , 200usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_xmm3 as * const _ as usize } , 216usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_xmm4 as * const _ as usize } , 232usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_xmm5 as * const _ as usize } , 248usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_xmm6 as * const _ as usize } , 264usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_xmm7 as * const _ as usize } , 280usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm7 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_xmm8 as * const _ as usize } , 296usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm8 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_xmm9 as * const _ as usize } , 312usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm9 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_xmm10 as * const _ as usize } , 328usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm10 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_xmm11 as * const _ as usize } , 344usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm11 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_xmm12 as * const _ as usize } , 360usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm12 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_xmm13 as * const _ as usize } , 376usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm13 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_xmm14 as * const _ as usize } , 392usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm14 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_xmm15 as * const _ as usize } , 408usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_xmm15 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_rsrv4 as * const _ as usize } , 424usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_rsrv4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_float_state64 ) ) . __fpu_reserved1 as * const _ as usize } , 520usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_float_state64 ) , "::" , stringify ! ( __fpu_reserved1 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __darwin_x86_avx_state64 { pub __fpu_reserved : [ :: std :: os :: raw :: c_int ; 2usize ] , pub __fpu_fcw : __darwin_fp_control , pub __fpu_fsw : __darwin_fp_status , pub __fpu_ftw : __uint8_t , pub __fpu_rsrv1 : __uint8_t , pub __fpu_fop : __uint16_t , pub __fpu_ip : __uint32_t , pub __fpu_cs : __uint16_t , pub __fpu_rsrv2 : __uint16_t , pub __fpu_dp : __uint32_t , pub __fpu_ds : __uint16_t , pub __fpu_rsrv3 : __uint16_t , pub __fpu_mxcsr : __uint32_t , pub __fpu_mxcsrmask : __uint32_t , pub __fpu_stmm0 : __darwin_mmst_reg , pub __fpu_stmm1 : __darwin_mmst_reg , pub __fpu_stmm2 : __darwin_mmst_reg , pub __fpu_stmm3 : __darwin_mmst_reg , pub __fpu_stmm4 : __darwin_mmst_reg , pub __fpu_stmm5 : __darwin_mmst_reg , pub __fpu_stmm6 : __darwin_mmst_reg , pub __fpu_stmm7 : __darwin_mmst_reg , pub __fpu_xmm0 : __darwin_xmm_reg , pub __fpu_xmm1 : __darwin_xmm_reg , pub __fpu_xmm2 : __darwin_xmm_reg , pub __fpu_xmm3 : __darwin_xmm_reg , pub __fpu_xmm4 : __darwin_xmm_reg , pub __fpu_xmm5 : __darwin_xmm_reg , pub __fpu_xmm6 : __darwin_xmm_reg , pub __fpu_xmm7 : __darwin_xmm_reg , pub __fpu_xmm8 : __darwin_xmm_reg , pub __fpu_xmm9 : __darwin_xmm_reg , pub __fpu_xmm10 : __darwin_xmm_reg , pub __fpu_xmm11 : __darwin_xmm_reg , pub __fpu_xmm12 : __darwin_xmm_reg , pub __fpu_xmm13 : __darwin_xmm_reg , pub __fpu_xmm14 : __darwin_xmm_reg , pub __fpu_xmm15 : __darwin_xmm_reg , pub __fpu_rsrv4 : [ :: std :: os :: raw :: c_char ; 96usize ] , pub __fpu_reserved1 : :: std :: os :: raw :: c_int , pub __avx_reserved1 : [ :: std :: os :: raw :: c_char ; 64usize ] , pub __fpu_ymmh0 : __darwin_xmm_reg , pub __fpu_ymmh1 : __darwin_xmm_reg , pub __fpu_ymmh2 : __darwin_xmm_reg , pub __fpu_ymmh3 : __darwin_xmm_reg , pub __fpu_ymmh4 : __darwin_xmm_reg , pub __fpu_ymmh5 : __darwin_xmm_reg , pub __fpu_ymmh6 : __darwin_xmm_reg , pub __fpu_ymmh7 : __darwin_xmm_reg , pub __fpu_ymmh8 : __darwin_xmm_reg , pub __fpu_ymmh9 : __darwin_xmm_reg , pub __fpu_ymmh10 : __darwin_xmm_reg , pub __fpu_ymmh11 : __darwin_xmm_reg , pub __fpu_ymmh12 : __darwin_xmm_reg , pub __fpu_ymmh13 : __darwin_xmm_reg , pub __fpu_ymmh14 : __darwin_xmm_reg , pub __fpu_ymmh15 : __darwin_xmm_reg , } # [ test ] fn bindgen_test_layout___darwin_x86_avx_state64 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_x86_avx_state64 > ( ) , 844usize , concat ! ( "Size of: " , stringify ! ( __darwin_x86_avx_state64 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_x86_avx_state64 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __darwin_x86_avx_state64 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_reserved as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_reserved ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_fcw as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_fcw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_fsw as * const _ as usize } , 10usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_fsw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ftw as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ftw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_rsrv1 as * const _ as usize } , 13usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_rsrv1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_fop as * const _ as usize } , 14usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_fop ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ip as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ip ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_cs as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_cs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_rsrv2 as * const _ as usize } , 22usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_rsrv2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_dp as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_dp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ds as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ds ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_rsrv3 as * const _ as usize } , 30usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_rsrv3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_mxcsr as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_mxcsr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_mxcsrmask ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_stmm0 as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_stmm1 as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_stmm2 as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_stmm3 as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_stmm4 as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_stmm5 as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_stmm6 as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_stmm7 as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_stmm7 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm0 as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm1 as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm2 as * const _ as usize } , 200usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm3 as * const _ as usize } , 216usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm4 as * const _ as usize } , 232usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm5 as * const _ as usize } , 248usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm6 as * const _ as usize } , 264usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm7 as * const _ as usize } , 280usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm7 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm8 as * const _ as usize } , 296usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm8 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm9 as * const _ as usize } , 312usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm9 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm10 as * const _ as usize } , 328usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm10 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm11 as * const _ as usize } , 344usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm11 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm12 as * const _ as usize } , 360usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm12 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm13 as * const _ as usize } , 376usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm13 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm14 as * const _ as usize } , 392usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm14 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_xmm15 as * const _ as usize } , 408usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_xmm15 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_rsrv4 as * const _ as usize } , 424usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_rsrv4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_reserved1 as * const _ as usize } , 520usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_reserved1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __avx_reserved1 as * const _ as usize } , 524usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __avx_reserved1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ymmh0 as * const _ as usize } , 588usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ymmh1 as * const _ as usize } , 604usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ymmh2 as * const _ as usize } , 620usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ymmh3 as * const _ as usize } , 636usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ymmh4 as * const _ as usize } , 652usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ymmh5 as * const _ as usize } , 668usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ymmh6 as * const _ as usize } , 684usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ymmh7 as * const _ as usize } , 700usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh7 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ymmh8 as * const _ as usize } , 716usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh8 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ymmh9 as * const _ as usize } , 732usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh9 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ymmh10 as * const _ as usize } , 748usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh10 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ymmh11 as * const _ as usize } , 764usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh11 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ymmh12 as * const _ as usize } , 780usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh12 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ymmh13 as * const _ as usize } , 796usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh13 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ymmh14 as * const _ as usize } , 812usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh14 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx_state64 ) ) . __fpu_ymmh15 as * const _ as usize } , 828usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx_state64 ) , "::" , stringify ! ( __fpu_ymmh15 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __darwin_x86_avx512_state64 { pub __fpu_reserved : [ :: std :: os :: raw :: c_int ; 2usize ] , pub __fpu_fcw : __darwin_fp_control , pub __fpu_fsw : __darwin_fp_status , pub __fpu_ftw : __uint8_t , pub __fpu_rsrv1 : __uint8_t , pub __fpu_fop : __uint16_t , pub __fpu_ip : __uint32_t , pub __fpu_cs : __uint16_t , pub __fpu_rsrv2 : __uint16_t , pub __fpu_dp : __uint32_t , pub __fpu_ds : __uint16_t , pub __fpu_rsrv3 : __uint16_t , pub __fpu_mxcsr : __uint32_t , pub __fpu_mxcsrmask : __uint32_t , pub __fpu_stmm0 : __darwin_mmst_reg , pub __fpu_stmm1 : __darwin_mmst_reg , pub __fpu_stmm2 : __darwin_mmst_reg , pub __fpu_stmm3 : __darwin_mmst_reg , pub __fpu_stmm4 : __darwin_mmst_reg , pub __fpu_stmm5 : __darwin_mmst_reg , pub __fpu_stmm6 : __darwin_mmst_reg , pub __fpu_stmm7 : __darwin_mmst_reg , pub __fpu_xmm0 : __darwin_xmm_reg , pub __fpu_xmm1 : __darwin_xmm_reg , pub __fpu_xmm2 : __darwin_xmm_reg , pub __fpu_xmm3 : __darwin_xmm_reg , pub __fpu_xmm4 : __darwin_xmm_reg , pub __fpu_xmm5 : __darwin_xmm_reg , pub __fpu_xmm6 : __darwin_xmm_reg , pub __fpu_xmm7 : __darwin_xmm_reg , pub __fpu_xmm8 : __darwin_xmm_reg , pub __fpu_xmm9 : __darwin_xmm_reg , pub __fpu_xmm10 : __darwin_xmm_reg , pub __fpu_xmm11 : __darwin_xmm_reg , pub __fpu_xmm12 : __darwin_xmm_reg , pub __fpu_xmm13 : __darwin_xmm_reg , pub __fpu_xmm14 : __darwin_xmm_reg , pub __fpu_xmm15 : __darwin_xmm_reg , pub __fpu_rsrv4 : [ :: std :: os :: raw :: c_char ; 96usize ] , pub __fpu_reserved1 : :: std :: os :: raw :: c_int , pub __avx_reserved1 : [ :: std :: os :: raw :: c_char ; 64usize ] , pub __fpu_ymmh0 : __darwin_xmm_reg , pub __fpu_ymmh1 : __darwin_xmm_reg , pub __fpu_ymmh2 : __darwin_xmm_reg , pub __fpu_ymmh3 : __darwin_xmm_reg , pub __fpu_ymmh4 : __darwin_xmm_reg , pub __fpu_ymmh5 : __darwin_xmm_reg , pub __fpu_ymmh6 : __darwin_xmm_reg , pub __fpu_ymmh7 : __darwin_xmm_reg , pub __fpu_ymmh8 : __darwin_xmm_reg , pub __fpu_ymmh9 : __darwin_xmm_reg , pub __fpu_ymmh10 : __darwin_xmm_reg , pub __fpu_ymmh11 : __darwin_xmm_reg , pub __fpu_ymmh12 : __darwin_xmm_reg , pub __fpu_ymmh13 : __darwin_xmm_reg , pub __fpu_ymmh14 : __darwin_xmm_reg , pub __fpu_ymmh15 : __darwin_xmm_reg , pub __fpu_k0 : __darwin_opmask_reg , pub __fpu_k1 : __darwin_opmask_reg , pub __fpu_k2 : __darwin_opmask_reg , pub __fpu_k3 : __darwin_opmask_reg , pub __fpu_k4 : __darwin_opmask_reg , pub __fpu_k5 : __darwin_opmask_reg , pub __fpu_k6 : __darwin_opmask_reg , pub __fpu_k7 : __darwin_opmask_reg , pub __fpu_zmmh0 : __darwin_ymm_reg , pub __fpu_zmmh1 : __darwin_ymm_reg , pub __fpu_zmmh2 : __darwin_ymm_reg , pub __fpu_zmmh3 : __darwin_ymm_reg , pub __fpu_zmmh4 : __darwin_ymm_reg , pub __fpu_zmmh5 : __darwin_ymm_reg , pub __fpu_zmmh6 : __darwin_ymm_reg , pub __fpu_zmmh7 : __darwin_ymm_reg , pub __fpu_zmmh8 : __darwin_ymm_reg , pub __fpu_zmmh9 : __darwin_ymm_reg , pub __fpu_zmmh10 : __darwin_ymm_reg , pub __fpu_zmmh11 : __darwin_ymm_reg , pub __fpu_zmmh12 : __darwin_ymm_reg , pub __fpu_zmmh13 : __darwin_ymm_reg , pub __fpu_zmmh14 : __darwin_ymm_reg , pub __fpu_zmmh15 : __darwin_ymm_reg , pub __fpu_zmm16 : __darwin_zmm_reg , pub __fpu_zmm17 : __darwin_zmm_reg , pub __fpu_zmm18 : __darwin_zmm_reg , pub __fpu_zmm19 : __darwin_zmm_reg , pub __fpu_zmm20 : __darwin_zmm_reg , pub __fpu_zmm21 : __darwin_zmm_reg , pub __fpu_zmm22 : __darwin_zmm_reg , pub __fpu_zmm23 : __darwin_zmm_reg , pub __fpu_zmm24 : __darwin_zmm_reg , pub __fpu_zmm25 : __darwin_zmm_reg , pub __fpu_zmm26 : __darwin_zmm_reg , pub __fpu_zmm27 : __darwin_zmm_reg , pub __fpu_zmm28 : __darwin_zmm_reg , pub __fpu_zmm29 : __darwin_zmm_reg , pub __fpu_zmm30 : __darwin_zmm_reg , pub __fpu_zmm31 : __darwin_zmm_reg , } # [ test ] fn bindgen_test_layout___darwin_x86_avx512_state64 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_x86_avx512_state64 > ( ) , 2444usize , concat ! ( "Size of: " , stringify ! ( __darwin_x86_avx512_state64 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_x86_avx512_state64 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __darwin_x86_avx512_state64 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_reserved as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_reserved ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_fcw as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_fcw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_fsw as * const _ as usize } , 10usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_fsw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_ftw as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_ftw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_rsrv1 as * const _ as usize } , 13usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_rsrv1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_fop as * const _ as usize } , 14usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_fop ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_ip as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_ip ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_cs as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_cs ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_rsrv2 as * const _ as usize } , 22usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_rsrv2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_dp as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_dp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_ds as * const _ as usize } , 28usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_ds ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_rsrv3 as * const _ as usize } , 30usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_rsrv3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_mxcsr as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_mxcsr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_mxcsrmask as * const _ as usize } , 36usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_mxcsrmask ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_stmm0 as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_stmm0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_stmm1 as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_stmm1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_stmm2 as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_stmm2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_stmm3 as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_stmm3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_stmm4 as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_stmm4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_stmm5 as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_stmm5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_stmm6 as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_stmm6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_stmm7 as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_stmm7 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_xmm0 as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_xmm0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_xmm1 as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_xmm1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_xmm2 as * const _ as usize } , 200usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_xmm2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_xmm3 as * const _ as usize } , 216usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_xmm3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_xmm4 as * const _ as usize } , 232usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_xmm4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_xmm5 as * const _ as usize } , 248usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_xmm5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_xmm6 as * const _ as usize } , 264usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_xmm6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_xmm7 as * const _ as usize } , 280usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_xmm7 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_xmm8 as * const _ as usize } , 296usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_xmm8 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_xmm9 as * const _ as usize } , 312usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_xmm9 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_xmm10 as * const _ as usize } , 328usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_xmm10 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_xmm11 as * const _ as usize } , 344usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_xmm11 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_xmm12 as * const _ as usize } , 360usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_xmm12 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_xmm13 as * const _ as usize } , 376usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_xmm13 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_xmm14 as * const _ as usize } , 392usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_xmm14 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_xmm15 as * const _ as usize } , 408usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_xmm15 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_rsrv4 as * const _ as usize } , 424usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_rsrv4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_reserved1 as * const _ as usize } , 520usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_reserved1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __avx_reserved1 as * const _ as usize } , 524usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __avx_reserved1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_ymmh0 as * const _ as usize } , 588usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_ymmh0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_ymmh1 as * const _ as usize } , 604usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_ymmh1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_ymmh2 as * const _ as usize } , 620usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_ymmh2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_ymmh3 as * const _ as usize } , 636usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_ymmh3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_ymmh4 as * const _ as usize } , 652usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_ymmh4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_ymmh5 as * const _ as usize } , 668usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_ymmh5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_ymmh6 as * const _ as usize } , 684usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_ymmh6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_ymmh7 as * const _ as usize } , 700usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_ymmh7 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_ymmh8 as * const _ as usize } , 716usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_ymmh8 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_ymmh9 as * const _ as usize } , 732usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_ymmh9 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_ymmh10 as * const _ as usize } , 748usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_ymmh10 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_ymmh11 as * const _ as usize } , 764usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_ymmh11 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_ymmh12 as * const _ as usize } , 780usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_ymmh12 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_ymmh13 as * const _ as usize } , 796usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_ymmh13 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_ymmh14 as * const _ as usize } , 812usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_ymmh14 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_ymmh15 as * const _ as usize } , 828usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_ymmh15 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_k0 as * const _ as usize } , 844usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_k0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_k1 as * const _ as usize } , 852usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_k1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_k2 as * const _ as usize } , 860usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_k2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_k3 as * const _ as usize } , 868usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_k3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_k4 as * const _ as usize } , 876usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_k4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_k5 as * const _ as usize } , 884usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_k5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_k6 as * const _ as usize } , 892usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_k6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_k7 as * const _ as usize } , 900usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_k7 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmmh0 as * const _ as usize } , 908usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmmh0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmmh1 as * const _ as usize } , 940usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmmh1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmmh2 as * const _ as usize } , 972usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmmh2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmmh3 as * const _ as usize } , 1004usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmmh3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmmh4 as * const _ as usize } , 1036usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmmh4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmmh5 as * const _ as usize } , 1068usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmmh5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmmh6 as * const _ as usize } , 1100usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmmh6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmmh7 as * const _ as usize } , 1132usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmmh7 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmmh8 as * const _ as usize } , 1164usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmmh8 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmmh9 as * const _ as usize } , 1196usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmmh9 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmmh10 as * const _ as usize } , 1228usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmmh10 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmmh11 as * const _ as usize } , 1260usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmmh11 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmmh12 as * const _ as usize } , 1292usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmmh12 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmmh13 as * const _ as usize } , 1324usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmmh13 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmmh14 as * const _ as usize } , 1356usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmmh14 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmmh15 as * const _ as usize } , 1388usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmmh15 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmm16 as * const _ as usize } , 1420usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmm16 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmm17 as * const _ as usize } , 1484usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmm17 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmm18 as * const _ as usize } , 1548usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmm18 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmm19 as * const _ as usize } , 1612usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmm19 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmm20 as * const _ as usize } , 1676usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmm20 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmm21 as * const _ as usize } , 1740usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmm21 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmm22 as * const _ as usize } , 1804usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmm22 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmm23 as * const _ as usize } , 1868usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmm23 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmm24 as * const _ as usize } , 1932usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmm24 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmm25 as * const _ as usize } , 1996usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmm25 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmm26 as * const _ as usize } , 2060usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmm26 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmm27 as * const _ as usize } , 2124usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmm27 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmm28 as * const _ as usize } , 2188usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmm28 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmm29 as * const _ as usize } , 2252usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmm29 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmm30 as * const _ as usize } , 2316usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmm30 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_avx512_state64 ) ) . __fpu_zmm31 as * const _ as usize } , 2380usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_avx512_state64 ) , "::" , stringify ! ( __fpu_zmm31 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __darwin_x86_exception_state64 { pub __trapno : __uint16_t , pub __cpu : __uint16_t , pub __err : __uint32_t , pub __faultvaddr : __uint64_t , } # [ test ] fn bindgen_test_layout___darwin_x86_exception_state64 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_x86_exception_state64 > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( __darwin_x86_exception_state64 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_x86_exception_state64 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __darwin_x86_exception_state64 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_exception_state64 ) ) . __trapno as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_exception_state64 ) , "::" , stringify ! ( __trapno ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_exception_state64 ) ) . __cpu as * const _ as usize } , 2usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_exception_state64 ) , "::" , stringify ! ( __cpu ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_exception_state64 ) ) . __err as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_exception_state64 ) , "::" , stringify ! ( __err ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_exception_state64 ) ) . __faultvaddr as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_exception_state64 ) , "::" , stringify ! ( __faultvaddr ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __darwin_x86_debug_state64 { pub __dr0 : __uint64_t , pub __dr1 : __uint64_t , pub __dr2 : __uint64_t , pub __dr3 : __uint64_t , pub __dr4 : __uint64_t , pub __dr5 : __uint64_t , pub __dr6 : __uint64_t , pub __dr7 : __uint64_t , } # [ test ] fn bindgen_test_layout___darwin_x86_debug_state64 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_x86_debug_state64 > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( __darwin_x86_debug_state64 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_x86_debug_state64 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __darwin_x86_debug_state64 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr0 as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr1 as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr2 as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr3 as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr4 as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr5 as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr5 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr6 as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr6 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_debug_state64 ) ) . __dr7 as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_debug_state64 ) , "::" , stringify ! ( __dr7 ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __darwin_x86_cpmu_state64 { pub __ctrs : [ __uint64_t ; 16usize ] , } # [ test ] fn bindgen_test_layout___darwin_x86_cpmu_state64 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_x86_cpmu_state64 > ( ) , 128usize , concat ! ( "Size of: " , stringify ! ( __darwin_x86_cpmu_state64 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_x86_cpmu_state64 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __darwin_x86_cpmu_state64 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_x86_cpmu_state64 ) ) . __ctrs as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_x86_cpmu_state64 ) , "::" , stringify ! ( __ctrs ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __darwin_mcontext32 { pub __es : __darwin_i386_exception_state , pub __ss : __darwin_i386_thread_state , pub __fs : __darwin_i386_float_state , } # [ test ] fn bindgen_test_layout___darwin_mcontext32 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_mcontext32 > ( ) , 600usize , concat ! ( "Size of: " , stringify ! ( __darwin_mcontext32 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_mcontext32 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __darwin_mcontext32 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_mcontext32 ) ) . __es as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_mcontext32 ) , "::" , stringify ! ( __es ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_mcontext32 ) ) . __ss as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_mcontext32 ) , "::" , stringify ! ( __ss ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_mcontext32 ) ) . __fs as * const _ as usize } , 76usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_mcontext32 ) , "::" , stringify ! ( __fs ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __darwin_mcontext_avx32 { pub __es : __darwin_i386_exception_state , pub __ss : __darwin_i386_thread_state , pub __fs : __darwin_i386_avx_state , } # [ test ] fn bindgen_test_layout___darwin_mcontext_avx32 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_mcontext_avx32 > ( ) , 792usize , concat ! ( "Size of: " , stringify ! ( __darwin_mcontext_avx32 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_mcontext_avx32 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __darwin_mcontext_avx32 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_mcontext_avx32 ) ) . __es as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_mcontext_avx32 ) , "::" , stringify ! ( __es ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_mcontext_avx32 ) ) . __ss as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_mcontext_avx32 ) , "::" , stringify ! ( __ss ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_mcontext_avx32 ) ) . __fs as * const _ as usize } , 76usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_mcontext_avx32 ) , "::" , stringify ! ( __fs ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __darwin_mcontext_avx512_32 { pub __es : __darwin_i386_exception_state , pub __ss : __darwin_i386_thread_state , pub __fs : __darwin_i386_avx512_state , } # [ test ] fn bindgen_test_layout___darwin_mcontext_avx512_32 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_mcontext_avx512_32 > ( ) , 1112usize , concat ! ( "Size of: " , stringify ! ( __darwin_mcontext_avx512_32 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_mcontext_avx512_32 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( __darwin_mcontext_avx512_32 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_mcontext_avx512_32 ) ) . __es as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_mcontext_avx512_32 ) , "::" , stringify ! ( __es ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_mcontext_avx512_32 ) ) . __ss as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_mcontext_avx512_32 ) , "::" , stringify ! ( __ss ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_mcontext_avx512_32 ) ) . __fs as * const _ as usize } , 76usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_mcontext_avx512_32 ) , "::" , stringify ! ( __fs ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __darwin_mcontext64 { pub __es : __darwin_x86_exception_state64 , pub __ss : __darwin_x86_thread_state64 , pub __fs : __darwin_x86_float_state64 , } # [ test ] fn bindgen_test_layout___darwin_mcontext64 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_mcontext64 > ( ) , 712usize , concat ! ( "Size of: " , stringify ! ( __darwin_mcontext64 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_mcontext64 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __darwin_mcontext64 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_mcontext64 ) ) . __es as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_mcontext64 ) , "::" , stringify ! ( __es ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_mcontext64 ) ) . __ss as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_mcontext64 ) , "::" , stringify ! ( __ss ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_mcontext64 ) ) . __fs as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_mcontext64 ) , "::" , stringify ! ( __fs ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __darwin_mcontext_avx64 { pub __es : __darwin_x86_exception_state64 , pub __ss : __darwin_x86_thread_state64 , pub __fs : __darwin_x86_avx_state64 , } # [ test ] fn bindgen_test_layout___darwin_mcontext_avx64 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_mcontext_avx64 > ( ) , 1032usize , concat ! ( "Size of: " , stringify ! ( __darwin_mcontext_avx64 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_mcontext_avx64 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __darwin_mcontext_avx64 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_mcontext_avx64 ) ) . __es as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_mcontext_avx64 ) , "::" , stringify ! ( __es ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_mcontext_avx64 ) ) . __ss as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_mcontext_avx64 ) , "::" , stringify ! ( __ss ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_mcontext_avx64 ) ) . __fs as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_mcontext_avx64 ) , "::" , stringify ! ( __fs ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __darwin_mcontext_avx512_64 { pub __es : __darwin_x86_exception_state64 , pub __ss : __darwin_x86_thread_state64 , pub __fs : __darwin_x86_avx512_state64 , } # [ test ] fn bindgen_test_layout___darwin_mcontext_avx512_64 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_mcontext_avx512_64 > ( ) , 2632usize , concat ! ( "Size of: " , stringify ! ( __darwin_mcontext_avx512_64 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_mcontext_avx512_64 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __darwin_mcontext_avx512_64 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_mcontext_avx512_64 ) ) . __es as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_mcontext_avx512_64 ) , "::" , stringify ! ( __es ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_mcontext_avx512_64 ) ) . __ss as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_mcontext_avx512_64 ) , "::" , stringify ! ( __ss ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_mcontext_avx512_64 ) ) . __fs as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_mcontext_avx512_64 ) , "::" , stringify ! ( __fs ) ) ) ; } pub type mcontext_t = * mut __darwin_mcontext64 ; pub type pthread_attr_t = __darwin_pthread_attr_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __darwin_sigaltstack { pub ss_sp : * mut :: std :: os :: raw :: c_void , pub ss_size : __darwin_size_t , pub ss_flags : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout___darwin_sigaltstack ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_sigaltstack > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( __darwin_sigaltstack ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_sigaltstack > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __darwin_sigaltstack ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_sigaltstack ) ) . ss_sp as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_sigaltstack ) , "::" , stringify ! ( ss_sp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_sigaltstack ) ) . ss_size as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_sigaltstack ) , "::" , stringify ! ( ss_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_sigaltstack ) ) . ss_flags as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_sigaltstack ) , "::" , stringify ! ( ss_flags ) ) ) ; } pub type stack_t = __darwin_sigaltstack ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __darwin_ucontext { pub uc_onstack : :: std :: os :: raw :: c_int , pub uc_sigmask : __darwin_sigset_t , pub uc_stack : __darwin_sigaltstack , pub uc_link : * mut __darwin_ucontext , pub uc_mcsize : __darwin_size_t , pub uc_mcontext : * mut __darwin_mcontext64 , } # [ test ] fn bindgen_test_layout___darwin_ucontext ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __darwin_ucontext > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( __darwin_ucontext ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __darwin_ucontext > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __darwin_ucontext ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_ucontext ) ) . uc_onstack as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_ucontext ) , "::" , stringify ! ( uc_onstack ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_ucontext ) ) . uc_sigmask as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_ucontext ) , "::" , stringify ! ( uc_sigmask ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_ucontext ) ) . uc_stack as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_ucontext ) , "::" , stringify ! ( uc_stack ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_ucontext ) ) . uc_link as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_ucontext ) , "::" , stringify ! ( uc_link ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_ucontext ) ) . uc_mcsize as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_ucontext ) , "::" , stringify ! ( uc_mcsize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __darwin_ucontext ) ) . uc_mcontext as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( __darwin_ucontext ) , "::" , stringify ! ( uc_mcontext ) ) ) ; } pub type ucontext_t = __darwin_ucontext ; pub type sigset_t = __darwin_sigset_t ; pub type uid_t = __darwin_uid_t ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union sigval { pub sival_int : :: std :: os :: raw :: c_int , pub sival_ptr : * mut :: std :: os :: raw :: c_void , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout_sigval ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigval > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( sigval ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigval > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigval ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigval ) ) . sival_int as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( sigval ) , "::" , stringify ! ( sival_int ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigval ) ) . sival_ptr as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( sigval ) , "::" , stringify ! ( sival_ptr ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sigevent { pub sigev_notify : :: std :: os :: raw :: c_int , pub sigev_signo : :: std :: os :: raw :: c_int , pub sigev_value : sigval , pub sigev_notify_function : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : sigval ) > , pub sigev_notify_attributes : * mut pthread_attr_t , } # [ test ] fn bindgen_test_layout_sigevent ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigevent > ( ) , 32usize , concat ! ( "Size of: " , stringify ! ( sigevent ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigevent > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigevent ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigevent ) ) . sigev_notify as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( sigevent ) , "::" , stringify ! ( sigev_notify ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigevent ) ) . sigev_signo as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( sigevent ) , "::" , stringify ! ( sigev_signo ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigevent ) ) . sigev_value as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( sigevent ) , "::" , stringify ! ( sigev_value ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigevent ) ) . sigev_notify_function as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( sigevent ) , "::" , stringify ! ( sigev_notify_function ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigevent ) ) . sigev_notify_attributes as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( sigevent ) , "::" , stringify ! ( sigev_notify_attributes ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __siginfo { pub si_signo : :: std :: os :: raw :: c_int , pub si_errno : :: std :: os :: raw :: c_int , pub si_code : :: std :: os :: raw :: c_int , pub si_pid : pid_t , pub si_uid : uid_t , pub si_status : :: std :: os :: raw :: c_int , pub si_addr : * mut :: std :: os :: raw :: c_void , pub si_value : sigval , pub si_band : :: std :: os :: raw :: c_long , pub __pad : [ :: std :: os :: raw :: c_ulong ; 7usize ] , } # [ test ] fn bindgen_test_layout___siginfo ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __siginfo > ( ) , 104usize , concat ! ( "Size of: " , stringify ! ( __siginfo ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __siginfo > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __siginfo ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __siginfo ) ) . si_signo as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __siginfo ) , "::" , stringify ! ( si_signo ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __siginfo ) ) . si_errno as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( __siginfo ) , "::" , stringify ! ( si_errno ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __siginfo ) ) . si_code as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __siginfo ) , "::" , stringify ! ( si_code ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __siginfo ) ) . si_pid as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( __siginfo ) , "::" , stringify ! ( si_pid ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __siginfo ) ) . si_uid as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __siginfo ) , "::" , stringify ! ( si_uid ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __siginfo ) ) . si_status as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( __siginfo ) , "::" , stringify ! ( si_status ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __siginfo ) ) . si_addr as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( __siginfo ) , "::" , stringify ! ( si_addr ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __siginfo ) ) . si_value as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( __siginfo ) , "::" , stringify ! ( si_value ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __siginfo ) ) . si_band as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( __siginfo ) , "::" , stringify ! ( si_band ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __siginfo ) ) . __pad as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( __siginfo ) , "::" , stringify ! ( __pad ) ) ) ; } pub type siginfo_t = __siginfo ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union __sigaction_u { pub __sa_handler : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : :: std :: os :: raw :: c_int ) > , pub __sa_sigaction : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : :: std :: os :: raw :: c_int , arg2 : * mut __siginfo , arg3 : * mut :: std :: os :: raw :: c_void ) > , _bindgen_union_align : u64 , } # [ test ] fn bindgen_test_layout___sigaction_u ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __sigaction_u > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( __sigaction_u ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __sigaction_u > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __sigaction_u ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sigaction_u ) ) . __sa_handler as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __sigaction_u ) , "::" , stringify ! ( __sa_handler ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sigaction_u ) ) . __sa_sigaction as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __sigaction_u ) , "::" , stringify ! ( __sa_sigaction ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct __sigaction { pub __sigaction_u : __sigaction_u , pub sa_tramp : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void , arg2 : :: std :: os :: raw :: c_int , arg3 : :: std :: os :: raw :: c_int , arg4 : * mut siginfo_t , arg5 : * mut :: std :: os :: raw :: c_void ) > , pub sa_mask : sigset_t , pub sa_flags : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout___sigaction ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __sigaction > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( __sigaction ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __sigaction > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __sigaction ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sigaction ) ) . __sigaction_u as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __sigaction ) , "::" , stringify ! ( __sigaction_u ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sigaction ) ) . sa_tramp as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __sigaction ) , "::" , stringify ! ( sa_tramp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sigaction ) ) . sa_mask as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __sigaction ) , "::" , stringify ! ( sa_mask ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __sigaction ) ) . sa_flags as * const _ as usize } , 20usize , concat ! ( "Alignment of field: " , stringify ! ( __sigaction ) , "::" , stringify ! ( sa_flags ) ) ) ; } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct sigaction { pub __sigaction_u : __sigaction_u , pub sa_mask : sigset_t , pub sa_flags : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_sigaction ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigaction > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( sigaction ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigaction > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigaction ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigaction ) ) . __sigaction_u as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( sigaction ) , "::" , stringify ! ( __sigaction_u ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigaction ) ) . sa_mask as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( sigaction ) , "::" , stringify ! ( sa_mask ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigaction ) ) . sa_flags as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( sigaction ) , "::" , stringify ! ( sa_flags ) ) ) ; } pub type sig_t = :: std :: option :: Option < unsafe extern "C" fn ( arg1 : :: std :: os :: raw :: c_int ) > ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct sigvec { pub sv_handler : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : :: std :: os :: raw :: c_int ) > , pub sv_mask : :: std :: os :: raw :: c_int , pub sv_flags : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_sigvec ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigvec > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( sigvec ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigvec > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigvec ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigvec ) ) . sv_handler as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( sigvec ) , "::" , stringify ! ( sv_handler ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigvec ) ) . sv_mask as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( sigvec ) , "::" , stringify ! ( sv_mask ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigvec ) ) . sv_flags as * const _ as usize } , 12usize , concat ! ( "Alignment of field: " , stringify ! ( sigvec ) , "::" , stringify ! ( sv_flags ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct sigstack { pub ss_sp : * mut :: std :: os :: raw :: c_char , pub ss_onstack : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_sigstack ( ) { assert_eq ! ( :: std :: mem :: size_of :: < sigstack > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( sigstack ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < sigstack > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( sigstack ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigstack ) ) . ss_sp as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( sigstack ) , "::" , stringify ! ( ss_sp ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const sigstack ) ) . ss_onstack as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( sigstack ) , "::" , stringify ! ( ss_onstack ) ) ) ; } extern "C" {
    # [ link_name = "\u{1}_signal" ]
    pub fn signal ( arg1 : :: std :: os :: raw :: c_int , arg2 : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : :: std :: os :: raw :: c_int ) > , ) -> :: std :: option :: Option < unsafe extern "C" fn ( arg1 : :: std :: os :: raw :: c_int , arg2 : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : :: std :: os :: raw :: c_int ) > ) > ;
} pub type int_least8_t = i8 ; pub type int_least16_t = i16 ; pub type int_least32_t = i32 ; pub type int_least64_t = i64 ; pub type uint_least8_t = u8 ; pub type uint_least16_t = u16 ; pub type uint_least32_t = u32 ; pub type uint_least64_t = u64 ; pub type int_fast8_t = i8 ; pub type int_fast16_t = i16 ; pub type int_fast32_t = i32 ; pub type int_fast64_t = i64 ; pub type uint_fast8_t = u8 ; pub type uint_fast16_t = u16 ; pub type uint_fast32_t = u32 ; pub type uint_fast64_t = u64 ; pub type intmax_t = :: std :: os :: raw :: c_long ; pub type uintmax_t = :: std :: os :: raw :: c_ulong ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct timeval { pub tv_sec : __darwin_time_t , pub tv_usec : __darwin_suseconds_t , } # [ test ] fn bindgen_test_layout_timeval ( ) { assert_eq ! ( :: std :: mem :: size_of :: < timeval > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( timeval ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < timeval > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( timeval ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( timeval ) , "::" , stringify ! ( tv_sec ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( timeval ) , "::" , stringify ! ( tv_usec ) ) ) ; } pub type rlim_t = __uint64_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct rusage { pub ru_utime : timeval , pub ru_stime : timeval , pub ru_maxrss : :: std :: os :: raw :: c_long , pub ru_ixrss : :: std :: os :: raw :: c_long , pub ru_idrss : :: std :: os :: raw :: c_long , pub ru_isrss : :: std :: os :: raw :: c_long , pub ru_minflt : :: std :: os :: raw :: c_long , pub ru_majflt : :: std :: os :: raw :: c_long , pub ru_nswap : :: std :: os :: raw :: c_long , pub ru_inblock : :: std :: os :: raw :: c_long , pub ru_oublock : :: std :: os :: raw :: c_long , pub ru_msgsnd : :: std :: os :: raw :: c_long , pub ru_msgrcv : :: std :: os :: raw :: c_long , pub ru_nsignals : :: std :: os :: raw :: c_long , pub ru_nvcsw : :: std :: os :: raw :: c_long , pub ru_nivcsw : :: std :: os :: raw :: c_long , } # [ test ] fn bindgen_test_layout_rusage ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage > ( ) , 144usize , concat ! ( "Size of: " , stringify ! ( rusage ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage ) ) . ru_utime as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( rusage ) , "::" , stringify ! ( ru_utime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage ) ) . ru_stime as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( rusage ) , "::" , stringify ! ( ru_stime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage ) ) . ru_maxrss as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( rusage ) , "::" , stringify ! ( ru_maxrss ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage ) ) . ru_ixrss as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( rusage ) , "::" , stringify ! ( ru_ixrss ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage ) ) . ru_idrss as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( rusage ) , "::" , stringify ! ( ru_idrss ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage ) ) . ru_isrss as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( rusage ) , "::" , stringify ! ( ru_isrss ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage ) ) . ru_minflt as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( rusage ) , "::" , stringify ! ( ru_minflt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage ) ) . ru_majflt as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( rusage ) , "::" , stringify ! ( ru_majflt ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage ) ) . ru_nswap as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( rusage ) , "::" , stringify ! ( ru_nswap ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage ) ) . ru_inblock as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( rusage ) , "::" , stringify ! ( ru_inblock ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage ) ) . ru_oublock as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( rusage ) , "::" , stringify ! ( ru_oublock ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage ) ) . ru_msgsnd as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( rusage ) , "::" , stringify ! ( ru_msgsnd ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage ) ) . ru_msgrcv as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( rusage ) , "::" , stringify ! ( ru_msgrcv ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage ) ) . ru_nsignals as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( rusage ) , "::" , stringify ! ( ru_nsignals ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage ) ) . ru_nvcsw as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( rusage ) , "::" , stringify ! ( ru_nvcsw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage ) ) . ru_nivcsw as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( rusage ) , "::" , stringify ! ( ru_nivcsw ) ) ) ; } pub type rusage_info_t = * mut :: std :: os :: raw :: c_void ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct rusage_info_v0 { pub ri_uuid : [ u8 ; 16usize ] , pub ri_user_time : u64 , pub ri_system_time : u64 , pub ri_pkg_idle_wkups : u64 , pub ri_interrupt_wkups : u64 , pub ri_pageins : u64 , pub ri_wired_size : u64 , pub ri_resident_size : u64 , pub ri_phys_footprint : u64 , pub ri_proc_start_abstime : u64 , pub ri_proc_exit_abstime : u64 , } # [ test ] fn bindgen_test_layout_rusage_info_v0 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage_info_v0 > ( ) , 96usize , concat ! ( "Size of: " , stringify ! ( rusage_info_v0 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage_info_v0 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage_info_v0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v0 ) ) . ri_uuid as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::" , stringify ! ( ri_uuid ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v0 ) ) . ri_user_time as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::" , stringify ! ( ri_user_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v0 ) ) . ri_system_time as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::" , stringify ! ( ri_system_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v0 ) ) . ri_pkg_idle_wkups as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::" , stringify ! ( ri_pkg_idle_wkups ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v0 ) ) . ri_interrupt_wkups as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::" , stringify ! ( ri_interrupt_wkups ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v0 ) ) . ri_pageins as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::" , stringify ! ( ri_pageins ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v0 ) ) . ri_wired_size as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::" , stringify ! ( ri_wired_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v0 ) ) . ri_resident_size as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::" , stringify ! ( ri_resident_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v0 ) ) . ri_phys_footprint as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::" , stringify ! ( ri_phys_footprint ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v0 ) ) . ri_proc_start_abstime as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::" , stringify ! ( ri_proc_start_abstime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v0 ) ) . ri_proc_exit_abstime as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v0 ) , "::" , stringify ! ( ri_proc_exit_abstime ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct rusage_info_v1 { pub ri_uuid : [ u8 ; 16usize ] , pub ri_user_time : u64 , pub ri_system_time : u64 , pub ri_pkg_idle_wkups : u64 , pub ri_interrupt_wkups : u64 , pub ri_pageins : u64 , pub ri_wired_size : u64 , pub ri_resident_size : u64 , pub ri_phys_footprint : u64 , pub ri_proc_start_abstime : u64 , pub ri_proc_exit_abstime : u64 , pub ri_child_user_time : u64 , pub ri_child_system_time : u64 , pub ri_child_pkg_idle_wkups : u64 , pub ri_child_interrupt_wkups : u64 , pub ri_child_pageins : u64 , pub ri_child_elapsed_abstime : u64 , } # [ test ] fn bindgen_test_layout_rusage_info_v1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage_info_v1 > ( ) , 144usize , concat ! ( "Size of: " , stringify ! ( rusage_info_v1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage_info_v1 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage_info_v1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v1 ) ) . ri_uuid as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::" , stringify ! ( ri_uuid ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v1 ) ) . ri_user_time as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::" , stringify ! ( ri_user_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v1 ) ) . ri_system_time as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::" , stringify ! ( ri_system_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v1 ) ) . ri_pkg_idle_wkups as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::" , stringify ! ( ri_pkg_idle_wkups ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v1 ) ) . ri_interrupt_wkups as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::" , stringify ! ( ri_interrupt_wkups ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v1 ) ) . ri_pageins as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::" , stringify ! ( ri_pageins ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v1 ) ) . ri_wired_size as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::" , stringify ! ( ri_wired_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v1 ) ) . ri_resident_size as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::" , stringify ! ( ri_resident_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v1 ) ) . ri_phys_footprint as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::" , stringify ! ( ri_phys_footprint ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v1 ) ) . ri_proc_start_abstime as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::" , stringify ! ( ri_proc_start_abstime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v1 ) ) . ri_proc_exit_abstime as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::" , stringify ! ( ri_proc_exit_abstime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v1 ) ) . ri_child_user_time as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::" , stringify ! ( ri_child_user_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v1 ) ) . ri_child_system_time as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::" , stringify ! ( ri_child_system_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v1 ) ) . ri_child_pkg_idle_wkups as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::" , stringify ! ( ri_child_pkg_idle_wkups ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v1 ) ) . ri_child_interrupt_wkups as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::" , stringify ! ( ri_child_interrupt_wkups ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v1 ) ) . ri_child_pageins as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::" , stringify ! ( ri_child_pageins ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v1 ) ) . ri_child_elapsed_abstime as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v1 ) , "::" , stringify ! ( ri_child_elapsed_abstime ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct rusage_info_v2 { pub ri_uuid : [ u8 ; 16usize ] , pub ri_user_time : u64 , pub ri_system_time : u64 , pub ri_pkg_idle_wkups : u64 , pub ri_interrupt_wkups : u64 , pub ri_pageins : u64 , pub ri_wired_size : u64 , pub ri_resident_size : u64 , pub ri_phys_footprint : u64 , pub ri_proc_start_abstime : u64 , pub ri_proc_exit_abstime : u64 , pub ri_child_user_time : u64 , pub ri_child_system_time : u64 , pub ri_child_pkg_idle_wkups : u64 , pub ri_child_interrupt_wkups : u64 , pub ri_child_pageins : u64 , pub ri_child_elapsed_abstime : u64 , pub ri_diskio_bytesread : u64 , pub ri_diskio_byteswritten : u64 , } # [ test ] fn bindgen_test_layout_rusage_info_v2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage_info_v2 > ( ) , 160usize , concat ! ( "Size of: " , stringify ! ( rusage_info_v2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage_info_v2 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage_info_v2 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v2 ) ) . ri_uuid as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::" , stringify ! ( ri_uuid ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v2 ) ) . ri_user_time as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::" , stringify ! ( ri_user_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v2 ) ) . ri_system_time as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::" , stringify ! ( ri_system_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v2 ) ) . ri_pkg_idle_wkups as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::" , stringify ! ( ri_pkg_idle_wkups ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v2 ) ) . ri_interrupt_wkups as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::" , stringify ! ( ri_interrupt_wkups ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v2 ) ) . ri_pageins as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::" , stringify ! ( ri_pageins ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v2 ) ) . ri_wired_size as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::" , stringify ! ( ri_wired_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v2 ) ) . ri_resident_size as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::" , stringify ! ( ri_resident_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v2 ) ) . ri_phys_footprint as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::" , stringify ! ( ri_phys_footprint ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v2 ) ) . ri_proc_start_abstime as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::" , stringify ! ( ri_proc_start_abstime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v2 ) ) . ri_proc_exit_abstime as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::" , stringify ! ( ri_proc_exit_abstime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v2 ) ) . ri_child_user_time as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::" , stringify ! ( ri_child_user_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v2 ) ) . ri_child_system_time as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::" , stringify ! ( ri_child_system_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v2 ) ) . ri_child_pkg_idle_wkups as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::" , stringify ! ( ri_child_pkg_idle_wkups ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v2 ) ) . ri_child_interrupt_wkups as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::" , stringify ! ( ri_child_interrupt_wkups ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v2 ) ) . ri_child_pageins as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::" , stringify ! ( ri_child_pageins ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v2 ) ) . ri_child_elapsed_abstime as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::" , stringify ! ( ri_child_elapsed_abstime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v2 ) ) . ri_diskio_bytesread as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::" , stringify ! ( ri_diskio_bytesread ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v2 ) ) . ri_diskio_byteswritten as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v2 ) , "::" , stringify ! ( ri_diskio_byteswritten ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct rusage_info_v3 { pub ri_uuid : [ u8 ; 16usize ] , pub ri_user_time : u64 , pub ri_system_time : u64 , pub ri_pkg_idle_wkups : u64 , pub ri_interrupt_wkups : u64 , pub ri_pageins : u64 , pub ri_wired_size : u64 , pub ri_resident_size : u64 , pub ri_phys_footprint : u64 , pub ri_proc_start_abstime : u64 , pub ri_proc_exit_abstime : u64 , pub ri_child_user_time : u64 , pub ri_child_system_time : u64 , pub ri_child_pkg_idle_wkups : u64 , pub ri_child_interrupt_wkups : u64 , pub ri_child_pageins : u64 , pub ri_child_elapsed_abstime : u64 , pub ri_diskio_bytesread : u64 , pub ri_diskio_byteswritten : u64 , pub ri_cpu_time_qos_default : u64 , pub ri_cpu_time_qos_maintenance : u64 , pub ri_cpu_time_qos_background : u64 , pub ri_cpu_time_qos_utility : u64 , pub ri_cpu_time_qos_legacy : u64 , pub ri_cpu_time_qos_user_initiated : u64 , pub ri_cpu_time_qos_user_interactive : u64 , pub ri_billed_system_time : u64 , pub ri_serviced_system_time : u64 , } # [ test ] fn bindgen_test_layout_rusage_info_v3 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage_info_v3 > ( ) , 232usize , concat ! ( "Size of: " , stringify ! ( rusage_info_v3 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage_info_v3 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage_info_v3 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_uuid as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_uuid ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_user_time as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_user_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_system_time as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_system_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_pkg_idle_wkups as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_pkg_idle_wkups ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_interrupt_wkups as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_interrupt_wkups ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_pageins as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_pageins ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_wired_size as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_wired_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_resident_size as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_resident_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_phys_footprint as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_phys_footprint ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_proc_start_abstime as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_proc_start_abstime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_proc_exit_abstime as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_proc_exit_abstime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_child_user_time as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_child_user_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_child_system_time as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_child_system_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_child_pkg_idle_wkups as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_child_pkg_idle_wkups ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_child_interrupt_wkups as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_child_interrupt_wkups ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_child_pageins as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_child_pageins ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_child_elapsed_abstime as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_child_elapsed_abstime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_diskio_bytesread as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_diskio_bytesread ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_diskio_byteswritten as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_diskio_byteswritten ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_cpu_time_qos_default as * const _ as usize } , 160usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_cpu_time_qos_default ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_cpu_time_qos_maintenance as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_cpu_time_qos_maintenance ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_cpu_time_qos_background as * const _ as usize } , 176usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_cpu_time_qos_background ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_cpu_time_qos_utility as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_cpu_time_qos_utility ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_cpu_time_qos_legacy as * const _ as usize } , 192usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_cpu_time_qos_legacy ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_cpu_time_qos_user_initiated as * const _ as usize } , 200usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_cpu_time_qos_user_initiated ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_cpu_time_qos_user_interactive as * const _ as usize } , 208usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_cpu_time_qos_user_interactive ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_billed_system_time as * const _ as usize } , 216usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_billed_system_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v3 ) ) . ri_serviced_system_time as * const _ as usize } , 224usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v3 ) , "::" , stringify ! ( ri_serviced_system_time ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct rusage_info_v4 { pub ri_uuid : [ u8 ; 16usize ] , pub ri_user_time : u64 , pub ri_system_time : u64 , pub ri_pkg_idle_wkups : u64 , pub ri_interrupt_wkups : u64 , pub ri_pageins : u64 , pub ri_wired_size : u64 , pub ri_resident_size : u64 , pub ri_phys_footprint : u64 , pub ri_proc_start_abstime : u64 , pub ri_proc_exit_abstime : u64 , pub ri_child_user_time : u64 , pub ri_child_system_time : u64 , pub ri_child_pkg_idle_wkups : u64 , pub ri_child_interrupt_wkups : u64 , pub ri_child_pageins : u64 , pub ri_child_elapsed_abstime : u64 , pub ri_diskio_bytesread : u64 , pub ri_diskio_byteswritten : u64 , pub ri_cpu_time_qos_default : u64 , pub ri_cpu_time_qos_maintenance : u64 , pub ri_cpu_time_qos_background : u64 , pub ri_cpu_time_qos_utility : u64 , pub ri_cpu_time_qos_legacy : u64 , pub ri_cpu_time_qos_user_initiated : u64 , pub ri_cpu_time_qos_user_interactive : u64 , pub ri_billed_system_time : u64 , pub ri_serviced_system_time : u64 , pub ri_logical_writes : u64 , pub ri_lifetime_max_phys_footprint : u64 , pub ri_instructions : u64 , pub ri_cycles : u64 , pub ri_billed_energy : u64 , pub ri_serviced_energy : u64 , pub ri_unused : [ u64 ; 2usize ] , } # [ test ] fn bindgen_test_layout_rusage_info_v4 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rusage_info_v4 > ( ) , 296usize , concat ! ( "Size of: " , stringify ! ( rusage_info_v4 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rusage_info_v4 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rusage_info_v4 ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_uuid as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_uuid ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_user_time as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_user_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_system_time as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_system_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_pkg_idle_wkups as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_pkg_idle_wkups ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_interrupt_wkups as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_interrupt_wkups ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_pageins as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_pageins ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_wired_size as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_wired_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_resident_size as * const _ as usize } , 64usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_resident_size ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_phys_footprint as * const _ as usize } , 72usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_phys_footprint ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_proc_start_abstime as * const _ as usize } , 80usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_proc_start_abstime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_proc_exit_abstime as * const _ as usize } , 88usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_proc_exit_abstime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_child_user_time as * const _ as usize } , 96usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_child_user_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_child_system_time as * const _ as usize } , 104usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_child_system_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_child_pkg_idle_wkups as * const _ as usize } , 112usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_child_pkg_idle_wkups ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_child_interrupt_wkups as * const _ as usize } , 120usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_child_interrupt_wkups ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_child_pageins as * const _ as usize } , 128usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_child_pageins ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_child_elapsed_abstime as * const _ as usize } , 136usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_child_elapsed_abstime ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_diskio_bytesread as * const _ as usize } , 144usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_diskio_bytesread ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_diskio_byteswritten as * const _ as usize } , 152usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_diskio_byteswritten ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_cpu_time_qos_default as * const _ as usize } , 160usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_cpu_time_qos_default ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_cpu_time_qos_maintenance as * const _ as usize } , 168usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_cpu_time_qos_maintenance ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_cpu_time_qos_background as * const _ as usize } , 176usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_cpu_time_qos_background ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_cpu_time_qos_utility as * const _ as usize } , 184usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_cpu_time_qos_utility ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_cpu_time_qos_legacy as * const _ as usize } , 192usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_cpu_time_qos_legacy ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_cpu_time_qos_user_initiated as * const _ as usize } , 200usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_cpu_time_qos_user_initiated ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_cpu_time_qos_user_interactive as * const _ as usize } , 208usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_cpu_time_qos_user_interactive ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_billed_system_time as * const _ as usize } , 216usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_billed_system_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_serviced_system_time as * const _ as usize } , 224usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_serviced_system_time ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_logical_writes as * const _ as usize } , 232usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_logical_writes ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_lifetime_max_phys_footprint as * const _ as usize } , 240usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_lifetime_max_phys_footprint ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_instructions as * const _ as usize } , 248usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_instructions ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_cycles as * const _ as usize } , 256usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_cycles ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_billed_energy as * const _ as usize } , 264usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_billed_energy ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_serviced_energy as * const _ as usize } , 272usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_serviced_energy ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rusage_info_v4 ) ) . ri_unused as * const _ as usize } , 280usize , concat ! ( "Alignment of field: " , stringify ! ( rusage_info_v4 ) , "::" , stringify ! ( ri_unused ) ) ) ; } pub type rusage_info_current = rusage_info_v4 ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct rlimit { pub rlim_cur : rlim_t , pub rlim_max : rlim_t , } # [ test ] fn bindgen_test_layout_rlimit ( ) { assert_eq ! ( :: std :: mem :: size_of :: < rlimit > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( rlimit ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < rlimit > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( rlimit ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rlimit ) ) . rlim_cur as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( rlimit ) , "::" , stringify ! ( rlim_cur ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const rlimit ) ) . rlim_max as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( rlimit ) , "::" , stringify ! ( rlim_max ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct proc_rlimit_control_wakeupmon { pub wm_flags : u32 , pub wm_rate : i32 , } # [ test ] fn bindgen_test_layout_proc_rlimit_control_wakeupmon ( ) { assert_eq ! ( :: std :: mem :: size_of :: < proc_rlimit_control_wakeupmon > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( proc_rlimit_control_wakeupmon ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < proc_rlimit_control_wakeupmon > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( proc_rlimit_control_wakeupmon ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const proc_rlimit_control_wakeupmon ) ) . wm_flags as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( proc_rlimit_control_wakeupmon ) , "::" , stringify ! ( wm_flags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const proc_rlimit_control_wakeupmon ) ) . wm_rate as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( proc_rlimit_control_wakeupmon ) , "::" , stringify ! ( wm_rate ) ) ) ; } extern "C" {
    # [ link_name = "\u{1}_getpriority" ]
    pub fn getpriority ( arg1 : :: std :: os :: raw :: c_int , arg2 : id_t , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_getiopolicy_np" ]
    pub fn getiopolicy_np ( arg1 : :: std :: os :: raw :: c_int , arg2 : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_getrlimit" ]
    pub fn getrlimit ( arg1 : :: std :: os :: raw :: c_int , arg2 : * mut rlimit , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_getrusage" ]
    pub fn getrusage ( arg1 : :: std :: os :: raw :: c_int , arg2 : * mut rusage , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_setpriority" ]
    pub fn setpriority ( arg1 : :: std :: os :: raw :: c_int , arg2 : id_t , arg3 : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_setiopolicy_np" ]
    pub fn setiopolicy_np ( arg1 : :: std :: os :: raw :: c_int , arg2 : :: std :: os :: raw :: c_int , arg3 : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_setrlimit" ]
    pub fn setrlimit ( arg1 : :: std :: os :: raw :: c_int , arg2 : * const rlimit , ) -> :: std :: os :: raw :: c_int ;
} # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union wait { pub w_status : :: std :: os :: raw :: c_int , pub w_T : wait__bindgen_ty_1 , pub w_S : wait__bindgen_ty_2 , _bindgen_union_align : u32 , } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct wait__bindgen_ty_1 { pub _bitfield_1 : [ u16 ; 2usize ] , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_wait__bindgen_ty_1 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < wait__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( wait__bindgen_ty_1 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < wait__bindgen_ty_1 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_1 ) ) ) ; } impl wait__bindgen_ty_1 { # [ inline ] pub fn w_Termsig ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x7f as u32 ; let val = ( unit_field_val & mask ) >> 0usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_w_Termsig ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x7f as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 0usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn w_Coredump ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x80 as u32 ; let val = ( unit_field_val & mask ) >> 7usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_w_Coredump ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0x80 as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 7usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn w_Retcode ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0xff00 as u32 ; let val = ( unit_field_val & mask ) >> 8usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_w_Retcode ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0xff00 as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 8usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn w_Filler ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0xffff0000 as u32 ; let val = ( unit_field_val & mask ) >> 16usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_w_Filler ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0xffff0000 as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 16usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn new_bitfield_1 ( w_Termsig : :: std :: os :: raw :: c_uint , w_Coredump : :: std :: os :: raw :: c_uint , w_Retcode : :: std :: os :: raw :: c_uint , w_Filler : :: std :: os :: raw :: c_uint ) -> u32 { ( ( ( ( 0 | ( ( w_Termsig as u32 as u32 ) << 0usize ) & ( 0x7f as u32 ) ) | ( ( w_Coredump as u32 as u32 ) << 7usize ) & ( 0x80 as u32 ) ) | ( ( w_Retcode as u32 as u32 ) << 8usize ) & ( 0xff00 as u32 ) ) | ( ( w_Filler as u32 as u32 ) << 16usize ) & ( 0xffff0000 as u32 ) ) } } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct wait__bindgen_ty_2 { pub _bitfield_1 : [ u16 ; 2usize ] , pub __bindgen_align : [ u32 ; 0usize ] , } # [ test ] fn bindgen_test_layout_wait__bindgen_ty_2 ( ) { assert_eq ! ( :: std :: mem :: size_of :: < wait__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( wait__bindgen_ty_2 ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < wait__bindgen_ty_2 > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_2 ) ) ) ; } impl wait__bindgen_ty_2 { # [ inline ] pub fn w_Stopval ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0xff as u32 ; let val = ( unit_field_val & mask ) >> 0usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_w_Stopval ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0xff as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 0usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn w_Stopsig ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0xff00 as u32 ; let val = ( unit_field_val & mask ) >> 8usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_w_Stopsig ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0xff00 as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 8usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn w_Filler ( & self ) -> :: std :: os :: raw :: c_uint { let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0xffff0000 as u32 ; let val = ( unit_field_val & mask ) >> 16usize ; unsafe { :: std :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_w_Filler ( & mut self , val : :: std :: os :: raw :: c_uint ) { let mask = 0xffff0000 as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: std :: mem :: uninitialized ( ) } ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 16usize ) & mask ; unsafe { :: std :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: std :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn new_bitfield_1 ( w_Stopval : :: std :: os :: raw :: c_uint , w_Stopsig : :: std :: os :: raw :: c_uint , w_Filler : :: std :: os :: raw :: c_uint ) -> u32 { ( ( ( 0 | ( ( w_Stopval as u32 as u32 ) << 0usize ) & ( 0xff as u32 ) ) | ( ( w_Stopsig as u32 as u32 ) << 8usize ) & ( 0xff00 as u32 ) ) | ( ( w_Filler as u32 as u32 ) << 16usize ) & ( 0xffff0000 as u32 ) ) } } # [ test ] fn bindgen_test_layout_wait ( ) { assert_eq ! ( :: std :: mem :: size_of :: < wait > ( ) , 4usize , concat ! ( "Size of: " , stringify ! ( wait ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < wait > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( wait ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const wait ) ) . w_status as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( wait ) , "::" , stringify ! ( w_status ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const wait ) ) . w_T as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( wait ) , "::" , stringify ! ( w_T ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const wait ) ) . w_S as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( wait ) , "::" , stringify ! ( w_S ) ) ) ; } extern "C" {
    # [ link_name = "\u{1}_wait" ]
    pub fn wait ( arg1 : * mut :: std :: os :: raw :: c_int , ) -> pid_t ;
} extern "C" {
    # [ link_name = "\u{1}_waitpid" ]
    pub fn waitpid ( arg1 : pid_t , arg2 : * mut :: std :: os :: raw :: c_int , arg3 : :: std :: os :: raw :: c_int , ) -> pid_t ;
} extern "C" {
    # [ link_name = "\u{1}_waitid" ]
    pub fn waitid ( arg1 : idtype_t , arg2 : id_t , arg3 : * mut siginfo_t , arg4 : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_wait3" ]
    pub fn wait3 ( arg1 : * mut :: std :: os :: raw :: c_int , arg2 : :: std :: os :: raw :: c_int , arg3 : * mut rusage , ) -> pid_t ;
} extern "C" {
    # [ link_name = "\u{1}_wait4" ]
    pub fn wait4 ( arg1 : pid_t , arg2 : * mut :: std :: os :: raw :: c_int , arg3 : :: std :: os :: raw :: c_int , arg4 : * mut rusage , ) -> pid_t ;
} extern "C" {
    # [ link_name = "\u{1}_alloca" ]
    pub fn alloca ( arg1 : usize , ) -> * mut :: std :: os :: raw :: c_void ;
} pub type ct_rune_t = __darwin_ct_rune_t ; pub type rune_t = __darwin_rune_t ; pub type wchar_t = __darwin_wchar_t ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct div_t { pub quot : :: std :: os :: raw :: c_int , pub rem : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout_div_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < div_t > ( ) , 8usize , concat ! ( "Size of: " , stringify ! ( div_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < div_t > ( ) , 4usize , concat ! ( "Alignment of " , stringify ! ( div_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const div_t ) ) . quot as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( div_t ) , "::" , stringify ! ( quot ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const div_t ) ) . rem as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( div_t ) , "::" , stringify ! ( rem ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct ldiv_t { pub quot : :: std :: os :: raw :: c_long , pub rem : :: std :: os :: raw :: c_long , } # [ test ] fn bindgen_test_layout_ldiv_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < ldiv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( ldiv_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < ldiv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ldiv_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ldiv_t ) ) . quot as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( ldiv_t ) , "::" , stringify ! ( quot ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const ldiv_t ) ) . rem as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( ldiv_t ) , "::" , stringify ! ( rem ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct lldiv_t { pub quot : :: std :: os :: raw :: c_longlong , pub rem : :: std :: os :: raw :: c_longlong , } # [ test ] fn bindgen_test_layout_lldiv_t ( ) { assert_eq ! ( :: std :: mem :: size_of :: < lldiv_t > ( ) , 16usize , concat ! ( "Size of: " , stringify ! ( lldiv_t ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < lldiv_t > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( lldiv_t ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( lldiv_t ) , "::" , stringify ! ( quot ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( lldiv_t ) , "::" , stringify ! ( rem ) ) ) ; } extern "C" {
    # [ link_name = "\u{1}___mb_cur_max" ]
    pub static mut  __mb_cur_max  :  :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_abort" ]
    pub fn abort ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_abs" ]
    pub fn abs ( arg1 : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_atexit" ]
    pub fn atexit ( arg1 : :: std :: option :: Option < unsafe extern "C" fn ( ) > , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_atof" ]
    pub fn atof ( arg1 : * const :: std :: os :: raw :: c_char , ) -> f64 ;
} extern "C" {
    # [ link_name = "\u{1}_atoi" ]
    pub fn atoi ( arg1 : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_atol" ]
    pub fn atol ( arg1 : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_long ;
} extern "C" {
    # [ link_name = "\u{1}_atoll" ]
    pub fn atoll ( arg1 : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_longlong ;
} extern "C" {
    # [ link_name = "\u{1}_bsearch" ]
    pub fn bsearch ( __key : * const :: std :: os :: raw :: c_void , __base : * const :: std :: os :: raw :: c_void , __nel : usize , __width : usize , __compar : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_calloc" ]
    pub fn calloc ( __count : usize , __size : usize , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_div" ]
    pub fn div ( arg1 : :: std :: os :: raw :: c_int , arg2 : :: std :: os :: raw :: c_int , ) -> div_t ;
} extern "C" {
    # [ link_name = "\u{1}_exit" ]
    pub fn exit ( arg1 : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
    # [ link_name = "\u{1}_free" ]
    pub fn free ( arg1 : * mut :: std :: os :: raw :: c_void , ) ;
} extern "C" {
    # [ link_name = "\u{1}_getenv" ]
    pub fn getenv ( arg1 : * const :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_labs" ]
    pub fn labs ( arg1 : :: std :: os :: raw :: c_long , ) -> :: std :: os :: raw :: c_long ;
} extern "C" {
    # [ link_name = "\u{1}_ldiv" ]
    pub fn ldiv ( arg1 : :: std :: os :: raw :: c_long , arg2 : :: std :: os :: raw :: c_long , ) -> ldiv_t ;
} extern "C" {
    # [ link_name = "\u{1}_llabs" ]
    pub fn llabs ( arg1 : :: std :: os :: raw :: c_longlong , ) -> :: std :: os :: raw :: c_longlong ;
} extern "C" {
    # [ link_name = "\u{1}_lldiv" ]
    pub fn lldiv ( arg1 : :: std :: os :: raw :: c_longlong , arg2 : :: std :: os :: raw :: c_longlong , ) -> lldiv_t ;
} extern "C" {
    # [ link_name = "\u{1}_malloc" ]
    pub fn malloc ( __size : usize , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_mblen" ]
    pub fn mblen ( __s : * const :: std :: os :: raw :: c_char , __n : usize , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_mbstowcs" ]
    pub fn mbstowcs ( arg1 : * mut wchar_t , arg2 : * const :: std :: os :: raw :: c_char , arg3 : usize , ) -> usize ;
} extern "C" {
    # [ link_name = "\u{1}_mbtowc" ]
    pub fn mbtowc ( arg1 : * mut wchar_t , arg2 : * const :: std :: os :: raw :: c_char , arg3 : usize , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_posix_memalign" ]
    pub fn posix_memalign ( __memptr : * mut * mut :: std :: os :: raw :: c_void , __alignment : usize , __size : usize , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_qsort" ]
    pub fn qsort ( __base : * mut :: std :: os :: raw :: c_void , __nel : usize , __width : usize , __compar : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > , ) ;
} extern "C" {
    # [ link_name = "\u{1}_rand" ]
    pub fn rand ( ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_realloc" ]
    pub fn realloc ( __ptr : * mut :: std :: os :: raw :: c_void , __size : usize , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_srand" ]
    pub fn srand ( arg1 : :: std :: os :: raw :: c_uint , ) ;
} extern "C" {
    # [ link_name = "\u{1}_strtod" ]
    pub fn strtod ( arg1 : * const :: std :: os :: raw :: c_char , arg2 : * mut * mut :: std :: os :: raw :: c_char , ) -> f64 ;
} extern "C" {
    # [ link_name = "\u{1}_strtof" ]
    pub fn strtof ( arg1 : * const :: std :: os :: raw :: c_char , arg2 : * mut * mut :: std :: os :: raw :: c_char , ) -> f32 ;
} extern "C" {
    # [ link_name = "\u{1}_strtol" ]
    pub fn strtol ( __str : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_long ;
} extern "C" {
    # [ link_name = "\u{1}_strtold" ]
    pub fn strtold ( arg1 : * const :: std :: os :: raw :: c_char , arg2 : * mut * mut :: std :: os :: raw :: c_char , ) -> f64 ;
} extern "C" {
    # [ link_name = "\u{1}_strtoll" ]
    pub fn strtoll ( __str : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_longlong ;
} extern "C" {
    # [ link_name = "\u{1}_strtoul" ]
    pub fn strtoul ( __str : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_ulong ;
} extern "C" {
    # [ link_name = "\u{1}_strtoull" ]
    pub fn strtoull ( __str : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_ulonglong ;
} extern "C" {
    # [ link_name = "\u{1}_system" ]
    pub fn system ( arg1 : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_wcstombs" ]
    pub fn wcstombs ( arg1 : * mut :: std :: os :: raw :: c_char , arg2 : * const wchar_t , arg3 : usize , ) -> usize ;
} extern "C" {
    # [ link_name = "\u{1}_wctomb" ]
    pub fn wctomb ( arg1 : * mut :: std :: os :: raw :: c_char , arg2 : wchar_t , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}__Exit" ]
    pub fn _Exit ( arg1 : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
    # [ link_name = "\u{1}_a64l" ]
    pub fn a64l ( arg1 : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_long ;
} extern "C" {
    # [ link_name = "\u{1}_drand48" ]
    pub fn drand48 ( ) -> f64 ;
} extern "C" {
    # [ link_name = "\u{1}_ecvt" ]
    pub fn ecvt ( arg1 : f64 , arg2 : :: std :: os :: raw :: c_int , arg3 : * mut :: std :: os :: raw :: c_int , arg4 : * mut :: std :: os :: raw :: c_int , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_erand48" ]
    pub fn erand48 ( arg1 : * mut :: std :: os :: raw :: c_ushort , ) -> f64 ;
} extern "C" {
    # [ link_name = "\u{1}_fcvt" ]
    pub fn fcvt ( arg1 : f64 , arg2 : :: std :: os :: raw :: c_int , arg3 : * mut :: std :: os :: raw :: c_int , arg4 : * mut :: std :: os :: raw :: c_int , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_gcvt" ]
    pub fn gcvt ( arg1 : f64 , arg2 : :: std :: os :: raw :: c_int , arg3 : * mut :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_getsubopt" ]
    pub fn getsubopt ( arg1 : * mut * mut :: std :: os :: raw :: c_char , arg2 : * const * const :: std :: os :: raw :: c_char , arg3 : * mut * mut :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_grantpt" ]
    pub fn grantpt ( arg1 : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_initstate" ]
    pub fn initstate ( arg1 : :: std :: os :: raw :: c_uint , arg2 : * mut :: std :: os :: raw :: c_char , arg3 : usize , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_jrand48" ]
    pub fn jrand48 ( arg1 : * mut :: std :: os :: raw :: c_ushort , ) -> :: std :: os :: raw :: c_long ;
} extern "C" {
    # [ link_name = "\u{1}_l64a" ]
    pub fn l64a ( arg1 : :: std :: os :: raw :: c_long , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_lcong48" ]
    pub fn lcong48 ( arg1 : * mut :: std :: os :: raw :: c_ushort , ) ;
} extern "C" {
    # [ link_name = "\u{1}_lrand48" ]
    pub fn lrand48 ( ) -> :: std :: os :: raw :: c_long ;
} extern "C" {
    # [ link_name = "\u{1}_mktemp" ]
    pub fn mktemp ( arg1 : * mut :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_mkstemp" ]
    pub fn mkstemp ( arg1 : * mut :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_mrand48" ]
    pub fn mrand48 ( ) -> :: std :: os :: raw :: c_long ;
} extern "C" {
    # [ link_name = "\u{1}_nrand48" ]
    pub fn nrand48 ( arg1 : * mut :: std :: os :: raw :: c_ushort , ) -> :: std :: os :: raw :: c_long ;
} extern "C" {
    # [ link_name = "\u{1}_posix_openpt" ]
    pub fn posix_openpt ( arg1 : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_ptsname" ]
    pub fn ptsname ( arg1 : :: std :: os :: raw :: c_int , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_putenv" ]
    pub fn putenv ( arg1 : * mut :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_random" ]
    pub fn random ( ) -> :: std :: os :: raw :: c_long ;
} extern "C" {
    # [ link_name = "\u{1}_rand_r" ]
    pub fn rand_r ( arg1 : * mut :: std :: os :: raw :: c_uint , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_realpath$DARWIN_EXTSN" ]
    pub fn realpath ( arg1 : * const :: std :: os :: raw :: c_char , arg2 : * mut :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_seed48" ]
    pub fn seed48 ( arg1 : * mut :: std :: os :: raw :: c_ushort , ) -> * mut :: std :: os :: raw :: c_ushort ;
} extern "C" {
    # [ link_name = "\u{1}_setenv" ]
    pub fn setenv ( __name : * const :: std :: os :: raw :: c_char , __value : * const :: std :: os :: raw :: c_char , __overwrite : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_setkey" ]
    pub fn setkey ( arg1 : * const :: std :: os :: raw :: c_char , ) ;
} extern "C" {
    # [ link_name = "\u{1}_setstate" ]
    pub fn setstate ( arg1 : * const :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_srand48" ]
    pub fn srand48 ( arg1 : :: std :: os :: raw :: c_long , ) ;
} extern "C" {
    # [ link_name = "\u{1}_srandom" ]
    pub fn srandom ( arg1 : :: std :: os :: raw :: c_uint , ) ;
} extern "C" {
    # [ link_name = "\u{1}_unlockpt" ]
    pub fn unlockpt ( arg1 : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_unsetenv" ]
    pub fn unsetenv ( arg1 : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} pub type dev_t = __darwin_dev_t ; pub type mode_t = __darwin_mode_t ; extern "C" {
    # [ link_name = "\u{1}_arc4random" ]
    pub fn arc4random ( ) -> u32 ;
} extern "C" {
    # [ link_name = "\u{1}_arc4random_addrandom" ]
    pub fn arc4random_addrandom ( arg1 : * mut :: std :: os :: raw :: c_uchar , arg2 : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
    # [ link_name = "\u{1}_arc4random_buf" ]
    pub fn arc4random_buf ( __buf : * mut :: std :: os :: raw :: c_void , __nbytes : usize , ) ;
} extern "C" {
    # [ link_name = "\u{1}_arc4random_stir" ]
    pub fn arc4random_stir ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_arc4random_uniform" ]
    pub fn arc4random_uniform ( __upper_bound : u32 , ) -> u32 ;
} extern "C" {
    # [ link_name = "\u{1}_atexit_b" ]
    pub fn atexit_b ( arg1 : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_bsearch_b" ]
    pub fn bsearch_b ( __key : * const :: std :: os :: raw :: c_void , __base : * const :: std :: os :: raw :: c_void , __nel : usize , __width : usize , __compar : * mut :: std :: os :: raw :: c_void , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_cgetcap" ]
    pub fn cgetcap ( arg1 : * mut :: std :: os :: raw :: c_char , arg2 : * const :: std :: os :: raw :: c_char , arg3 : :: std :: os :: raw :: c_int , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_cgetclose" ]
    pub fn cgetclose ( ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_cgetent" ]
    pub fn cgetent ( arg1 : * mut * mut :: std :: os :: raw :: c_char , arg2 : * mut * mut :: std :: os :: raw :: c_char , arg3 : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_cgetfirst" ]
    pub fn cgetfirst ( arg1 : * mut * mut :: std :: os :: raw :: c_char , arg2 : * mut * mut :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_cgetmatch" ]
    pub fn cgetmatch ( arg1 : * const :: std :: os :: raw :: c_char , arg2 : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_cgetnext" ]
    pub fn cgetnext ( arg1 : * mut * mut :: std :: os :: raw :: c_char , arg2 : * mut * mut :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_cgetnum" ]
    pub fn cgetnum ( arg1 : * mut :: std :: os :: raw :: c_char , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * mut :: std :: os :: raw :: c_long , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_cgetset" ]
    pub fn cgetset ( arg1 : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_cgetstr" ]
    pub fn cgetstr ( arg1 : * mut :: std :: os :: raw :: c_char , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * mut * mut :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_cgetustr" ]
    pub fn cgetustr ( arg1 : * mut :: std :: os :: raw :: c_char , arg2 : * const :: std :: os :: raw :: c_char , arg3 : * mut * mut :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_daemon" ]
    pub fn daemon ( arg1 : :: std :: os :: raw :: c_int , arg2 : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_devname" ]
    pub fn devname ( arg1 : dev_t , arg2 : mode_t , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_devname_r" ]
    pub fn devname_r ( arg1 : dev_t , arg2 : mode_t , buf : * mut :: std :: os :: raw :: c_char , len : :: std :: os :: raw :: c_int , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_getbsize" ]
    pub fn getbsize ( arg1 : * mut :: std :: os :: raw :: c_int , arg2 : * mut :: std :: os :: raw :: c_long , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_getloadavg" ]
    pub fn getloadavg ( arg1 : * mut f64 , arg2 : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_getprogname" ]
    pub fn getprogname ( ) -> * const :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_heapsort" ]
    pub fn heapsort ( __base : * mut :: std :: os :: raw :: c_void , __nel : usize , __width : usize , __compar : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_heapsort_b" ]
    pub fn heapsort_b ( __base : * mut :: std :: os :: raw :: c_void , __nel : usize , __width : usize , __compar : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_mergesort" ]
    pub fn mergesort ( __base : * mut :: std :: os :: raw :: c_void , __nel : usize , __width : usize , __compar : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_mergesort_b" ]
    pub fn mergesort_b ( __base : * mut :: std :: os :: raw :: c_void , __nel : usize , __width : usize , __compar : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_psort" ]
    pub fn psort ( __base : * mut :: std :: os :: raw :: c_void , __nel : usize , __width : usize , __compar : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * const :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > , ) ;
} extern "C" {
    # [ link_name = "\u{1}_psort_b" ]
    pub fn psort_b ( __base : * mut :: std :: os :: raw :: c_void , __nel : usize , __width : usize , __compar : * mut :: std :: os :: raw :: c_void , ) ;
} extern "C" {
    # [ link_name = "\u{1}_psort_r" ]
    pub fn psort_r ( __base : * mut :: std :: os :: raw :: c_void , __nel : usize , __width : usize , arg1 : * mut :: std :: os :: raw :: c_void , __compar : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void , arg3 : * const :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > , ) ;
} extern "C" {
    # [ link_name = "\u{1}_qsort_b" ]
    pub fn qsort_b ( __base : * mut :: std :: os :: raw :: c_void , __nel : usize , __width : usize , __compar : * mut :: std :: os :: raw :: c_void , ) ;
} extern "C" {
    # [ link_name = "\u{1}_qsort_r" ]
    pub fn qsort_r ( __base : * mut :: std :: os :: raw :: c_void , __nel : usize , __width : usize , arg1 : * mut :: std :: os :: raw :: c_void , __compar : :: std :: option :: Option < unsafe extern "C" fn ( arg1 : * mut :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_void , arg3 : * const :: std :: os :: raw :: c_void ) -> :: std :: os :: raw :: c_int > , ) ;
} extern "C" {
    # [ link_name = "\u{1}_radixsort" ]
    pub fn radixsort ( __base : * mut * const :: std :: os :: raw :: c_uchar , __nel : :: std :: os :: raw :: c_int , __table : * const :: std :: os :: raw :: c_uchar , __endbyte : :: std :: os :: raw :: c_uint , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_setprogname" ]
    pub fn setprogname ( arg1 : * const :: std :: os :: raw :: c_char , ) ;
} extern "C" {
    # [ link_name = "\u{1}_sradixsort" ]
    pub fn sradixsort ( __base : * mut * const :: std :: os :: raw :: c_uchar , __nel : :: std :: os :: raw :: c_int , __table : * const :: std :: os :: raw :: c_uchar , __endbyte : :: std :: os :: raw :: c_uint , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_sranddev" ]
    pub fn sranddev ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_srandomdev" ]
    pub fn srandomdev ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_reallocf" ]
    pub fn reallocf ( __ptr : * mut :: std :: os :: raw :: c_void , __size : usize , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_strtoq" ]
    pub fn strtoq ( __str : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_longlong ;
} extern "C" {
    # [ link_name = "\u{1}_strtouq" ]
    pub fn strtouq ( __str : * const :: std :: os :: raw :: c_char , __endptr : * mut * mut :: std :: os :: raw :: c_char , __base : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_ulonglong ;
} extern "C" {
    # [ link_name = "\u{1}_suboptarg" ]
    pub static mut  suboptarg  :  * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_valloc" ]
    pub fn valloc ( arg1 : usize , ) -> * mut :: std :: os :: raw :: c_void ;
}
/// Various defines for the various Link properties.
///
/// NOTE: the link detection layer will try to resolve QName expansion
/// of namespaces. If "foo" is the prefix for "http://foo.com/"
/// then the link detection layer will expand role="foo:myrole"
/// to "http://foo.com/:myrole".
/// NOTE: the link detection layer will expand URI-Refences found on
/// href attributes by using the base mechanism if found.
pub type xlinkHRef = * mut xmlChar ; pub type xlinkRole = * mut xmlChar ; pub type xlinkTitle = * mut xmlChar ; pub const xlinkType_XLINK_TYPE_NONE : xlinkType = 0 ; pub const xlinkType_XLINK_TYPE_SIMPLE : xlinkType = 1 ; pub const xlinkType_XLINK_TYPE_EXTENDED : xlinkType = 2 ; pub const xlinkType_XLINK_TYPE_EXTENDED_SET : xlinkType = 3 ; pub type xlinkType = :: std :: os :: raw :: c_uint ; pub const xlinkShow_XLINK_SHOW_NONE : xlinkShow = 0 ; pub const xlinkShow_XLINK_SHOW_NEW : xlinkShow = 1 ; pub const xlinkShow_XLINK_SHOW_EMBED : xlinkShow = 2 ; pub const xlinkShow_XLINK_SHOW_REPLACE : xlinkShow = 3 ; pub type xlinkShow = :: std :: os :: raw :: c_uint ; pub const xlinkActuate_XLINK_ACTUATE_NONE : xlinkActuate = 0 ; pub const xlinkActuate_XLINK_ACTUATE_AUTO : xlinkActuate = 1 ; pub const xlinkActuate_XLINK_ACTUATE_ONREQUEST : xlinkActuate = 2 ; pub type xlinkActuate = :: std :: os :: raw :: c_uint ;
/// xlinkNodeDetectFunc:
/// @ctx:  user data pointer
/// @node:  the node to check
///
/// This is the prototype for the link detection routine.
/// It calls the default link detection callbacks upon link detection.
pub type xlinkNodeDetectFunc = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , node : xmlNodePtr ) > ;
/// xlinkSimpleLinkFunk:
/// @ctx:  user data pointer
/// @node:  the node carrying the link
/// @href:  the target of the link
/// @role:  the role string
/// @title:  the link title
///
/// This is the prototype for a simple link detection callback.
pub type xlinkSimpleLinkFunk = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , node : xmlNodePtr , href : xlinkHRef , role : xlinkRole , title : xlinkTitle ) > ;
/// xlinkExtendedLinkFunk:
/// @ctx:  user data pointer
/// @node:  the node carrying the link
/// @nbLocators: the number of locators detected on the link
/// @hrefs:  pointer to the array of locator hrefs
/// @roles:  pointer to the array of locator roles
/// @nbArcs: the number of arcs detected on the link
/// @from:  pointer to the array of source roles found on the arcs
/// @to:  pointer to the array of target roles found on the arcs
/// @show:  array of values for the show attributes found on the arcs
/// @actuate:  array of values for the actuate attributes found on the arcs
/// @nbTitles: the number of titles detected on the link
/// @title:  array of titles detected on the link
/// @langs:  array of xml:lang values for the titles
///
/// This is the prototype for a extended link detection callback.
pub type xlinkExtendedLinkFunk = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , node : xmlNodePtr , nbLocators : :: std :: os :: raw :: c_int , hrefs : * const xlinkHRef , roles : * const xlinkRole , nbArcs : :: std :: os :: raw :: c_int , from : * const xlinkRole , to : * const xlinkRole , show : * mut xlinkShow , actuate : * mut xlinkActuate , nbTitles : :: std :: os :: raw :: c_int , titles : * const xlinkTitle , langs : * mut * const xmlChar ) > ;
/// xlinkExtendedLinkSetFunk:
/// @ctx:  user data pointer
/// @node:  the node carrying the link
/// @nbLocators: the number of locators detected on the link
/// @hrefs:  pointer to the array of locator hrefs
/// @roles:  pointer to the array of locator roles
/// @nbTitles: the number of titles detected on the link
/// @title:  array of titles detected on the link
/// @langs:  array of xml:lang values for the titles
///
/// This is the prototype for a extended link set detection callback.
pub type xlinkExtendedLinkSetFunk = :: std :: option :: Option < unsafe extern "C" fn ( ctx : * mut :: std :: os :: raw :: c_void , node : xmlNodePtr , nbLocators : :: std :: os :: raw :: c_int , hrefs : * const xlinkHRef , roles : * const xlinkRole , nbTitles : :: std :: os :: raw :: c_int , titles : * const xlinkTitle , langs : * mut * const xmlChar ) > ;
/// This is the structure containing a set of Links detection callbacks.
///
/// There is no default xlink callbacks, if one want to get link
/// recognition activated, those call backs must be provided before parsing.
pub type xlinkHandler = _xlinkHandler ; pub type xlinkHandlerPtr = * mut xlinkHandler ; # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub struct _xlinkHandler { pub simple : xlinkSimpleLinkFunk , pub extended : xlinkExtendedLinkFunk , pub set : xlinkExtendedLinkSetFunk , } # [ test ] fn bindgen_test_layout__xlinkHandler ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xlinkHandler > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( _xlinkHandler ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xlinkHandler > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xlinkHandler ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xlinkHandler ) ) . simple as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xlinkHandler ) , "::" , stringify ! ( simple ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xlinkHandler ) ) . extended as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xlinkHandler ) , "::" , stringify ! ( extended ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xlinkHandler ) ) . set as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xlinkHandler ) , "::" , stringify ! ( set ) ) ) ; } extern "C" {
    # [ link_name = "\u{1}_xlinkGetDefaultDetect" ]
    pub fn xlinkGetDefaultDetect ( ) -> xlinkNodeDetectFunc ;
} extern "C" {
    # [ link_name = "\u{1}_xlinkSetDefaultDetect" ]
    pub fn xlinkSetDefaultDetect ( func : xlinkNodeDetectFunc , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xlinkGetDefaultHandler" ]
    pub fn xlinkGetDefaultHandler ( ) -> xlinkHandlerPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xlinkSetDefaultHandler" ]
    pub fn xlinkSetDefaultHandler ( handler : xlinkHandlerPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xlinkIsLink" ]
    pub fn xlinkIsLink ( doc : xmlDocPtr , node : xmlNodePtr , ) -> xlinkType ;
} extern "C" {
    # [ link_name = "\u{1}_getPublicId" ]
    pub fn getPublicId ( ctx : * mut :: std :: os :: raw :: c_void , ) -> * const xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_getSystemId" ]
    pub fn getSystemId ( ctx : * mut :: std :: os :: raw :: c_void , ) -> * const xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_setDocumentLocator" ]
    pub fn setDocumentLocator ( ctx : * mut :: std :: os :: raw :: c_void , loc : xmlSAXLocatorPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_getLineNumber" ]
    pub fn getLineNumber ( ctx : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_getColumnNumber" ]
    pub fn getColumnNumber ( ctx : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_isStandalone" ]
    pub fn isStandalone ( ctx : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_hasInternalSubset" ]
    pub fn hasInternalSubset ( ctx : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_hasExternalSubset" ]
    pub fn hasExternalSubset ( ctx : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_internalSubset" ]
    pub fn internalSubset ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , ExternalID : * const xmlChar , SystemID : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_externalSubset" ]
    pub fn externalSubset ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , ExternalID : * const xmlChar , SystemID : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_getEntity" ]
    pub fn getEntity ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , ) -> xmlEntityPtr ;
} extern "C" {
    # [ link_name = "\u{1}_getParameterEntity" ]
    pub fn getParameterEntity ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , ) -> xmlEntityPtr ;
} extern "C" {
    # [ link_name = "\u{1}_resolveEntity" ]
    pub fn resolveEntity ( ctx : * mut :: std :: os :: raw :: c_void , publicId : * const xmlChar , systemId : * const xmlChar , ) -> xmlParserInputPtr ;
} extern "C" {
    # [ link_name = "\u{1}_entityDecl" ]
    pub fn entityDecl ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , type_ : :: std :: os :: raw :: c_int , publicId : * const xmlChar , systemId : * const xmlChar , content : * mut xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_attributeDecl" ]
    pub fn attributeDecl ( ctx : * mut :: std :: os :: raw :: c_void , elem : * const xmlChar , fullname : * const xmlChar , type_ : :: std :: os :: raw :: c_int , def : :: std :: os :: raw :: c_int , defaultValue : * const xmlChar , tree : xmlEnumerationPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_elementDecl" ]
    pub fn elementDecl ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , type_ : :: std :: os :: raw :: c_int , content : xmlElementContentPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_notationDecl" ]
    pub fn notationDecl ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , publicId : * const xmlChar , systemId : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_unparsedEntityDecl" ]
    pub fn unparsedEntityDecl ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , publicId : * const xmlChar , systemId : * const xmlChar , notationName : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_startDocument" ]
    pub fn startDocument ( ctx : * mut :: std :: os :: raw :: c_void , ) ;
} extern "C" {
    # [ link_name = "\u{1}_endDocument" ]
    pub fn endDocument ( ctx : * mut :: std :: os :: raw :: c_void , ) ;
} extern "C" {
    # [ link_name = "\u{1}_attribute" ]
    pub fn attribute ( ctx : * mut :: std :: os :: raw :: c_void , fullname : * const xmlChar , value : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_startElement" ]
    pub fn startElement ( ctx : * mut :: std :: os :: raw :: c_void , fullname : * const xmlChar , atts : * mut * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_endElement" ]
    pub fn endElement ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_reference" ]
    pub fn reference ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_characters" ]
    pub fn characters ( ctx : * mut :: std :: os :: raw :: c_void , ch : * const xmlChar , len : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
    # [ link_name = "\u{1}_ignorableWhitespace" ]
    pub fn ignorableWhitespace ( ctx : * mut :: std :: os :: raw :: c_void , ch : * const xmlChar , len : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
    # [ link_name = "\u{1}_processingInstruction" ]
    pub fn processingInstruction ( ctx : * mut :: std :: os :: raw :: c_void , target : * const xmlChar , data : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_globalNamespace" ]
    pub fn globalNamespace ( ctx : * mut :: std :: os :: raw :: c_void , href : * const xmlChar , prefix : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_setNamespace" ]
    pub fn setNamespace ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_getNamespace" ]
    pub fn getNamespace ( ctx : * mut :: std :: os :: raw :: c_void , ) -> xmlNsPtr ;
} extern "C" {
    # [ link_name = "\u{1}_checkNamespace" ]
    pub fn checkNamespace ( ctx : * mut :: std :: os :: raw :: c_void , nameSpace : * mut xmlChar , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_namespaceDecl" ]
    pub fn namespaceDecl ( ctx : * mut :: std :: os :: raw :: c_void , href : * const xmlChar , prefix : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_comment" ]
    pub fn comment ( ctx : * mut :: std :: os :: raw :: c_void , value : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_cdataBlock" ]
    pub fn cdataBlock ( ctx : * mut :: std :: os :: raw :: c_void , value : * const xmlChar , len : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
    # [ link_name = "\u{1}_initxmlDefaultSAXHandler" ]
    pub fn initxmlDefaultSAXHandler ( hdlr : * mut xmlSAXHandlerV1 , warning : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
    # [ link_name = "\u{1}_inithtmlDefaultSAXHandler" ]
    pub fn inithtmlDefaultSAXHandler ( hdlr : * mut xmlSAXHandlerV1 , ) ;
} extern "C" {
    # [ link_name = "\u{1}_initdocbDefaultSAXHandler" ]
    pub fn initdocbDefaultSAXHandler ( hdlr : * mut xmlSAXHandlerV1 , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2GetPublicId" ]
    pub fn xmlSAX2GetPublicId ( ctx : * mut :: std :: os :: raw :: c_void , ) -> * const xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2GetSystemId" ]
    pub fn xmlSAX2GetSystemId ( ctx : * mut :: std :: os :: raw :: c_void , ) -> * const xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2SetDocumentLocator" ]
    pub fn xmlSAX2SetDocumentLocator ( ctx : * mut :: std :: os :: raw :: c_void , loc : xmlSAXLocatorPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2GetLineNumber" ]
    pub fn xmlSAX2GetLineNumber ( ctx : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2GetColumnNumber" ]
    pub fn xmlSAX2GetColumnNumber ( ctx : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2IsStandalone" ]
    pub fn xmlSAX2IsStandalone ( ctx : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2HasInternalSubset" ]
    pub fn xmlSAX2HasInternalSubset ( ctx : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2HasExternalSubset" ]
    pub fn xmlSAX2HasExternalSubset ( ctx : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2InternalSubset" ]
    pub fn xmlSAX2InternalSubset ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , ExternalID : * const xmlChar , SystemID : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2ExternalSubset" ]
    pub fn xmlSAX2ExternalSubset ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , ExternalID : * const xmlChar , SystemID : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2GetEntity" ]
    pub fn xmlSAX2GetEntity ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , ) -> xmlEntityPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2GetParameterEntity" ]
    pub fn xmlSAX2GetParameterEntity ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , ) -> xmlEntityPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2ResolveEntity" ]
    pub fn xmlSAX2ResolveEntity ( ctx : * mut :: std :: os :: raw :: c_void , publicId : * const xmlChar , systemId : * const xmlChar , ) -> xmlParserInputPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2EntityDecl" ]
    pub fn xmlSAX2EntityDecl ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , type_ : :: std :: os :: raw :: c_int , publicId : * const xmlChar , systemId : * const xmlChar , content : * mut xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2AttributeDecl" ]
    pub fn xmlSAX2AttributeDecl ( ctx : * mut :: std :: os :: raw :: c_void , elem : * const xmlChar , fullname : * const xmlChar , type_ : :: std :: os :: raw :: c_int , def : :: std :: os :: raw :: c_int , defaultValue : * const xmlChar , tree : xmlEnumerationPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2ElementDecl" ]
    pub fn xmlSAX2ElementDecl ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , type_ : :: std :: os :: raw :: c_int , content : xmlElementContentPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2NotationDecl" ]
    pub fn xmlSAX2NotationDecl ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , publicId : * const xmlChar , systemId : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2UnparsedEntityDecl" ]
    pub fn xmlSAX2UnparsedEntityDecl ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , publicId : * const xmlChar , systemId : * const xmlChar , notationName : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2StartDocument" ]
    pub fn xmlSAX2StartDocument ( ctx : * mut :: std :: os :: raw :: c_void , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2EndDocument" ]
    pub fn xmlSAX2EndDocument ( ctx : * mut :: std :: os :: raw :: c_void , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2StartElement" ]
    pub fn xmlSAX2StartElement ( ctx : * mut :: std :: os :: raw :: c_void , fullname : * const xmlChar , atts : * mut * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2EndElement" ]
    pub fn xmlSAX2EndElement ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2StartElementNs" ]
    pub fn xmlSAX2StartElementNs ( ctx : * mut :: std :: os :: raw :: c_void , localname : * const xmlChar , prefix : * const xmlChar , URI : * const xmlChar , nb_namespaces : :: std :: os :: raw :: c_int , namespaces : * mut * const xmlChar , nb_attributes : :: std :: os :: raw :: c_int , nb_defaulted : :: std :: os :: raw :: c_int , attributes : * mut * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2EndElementNs" ]
    pub fn xmlSAX2EndElementNs ( ctx : * mut :: std :: os :: raw :: c_void , localname : * const xmlChar , prefix : * const xmlChar , URI : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2Reference" ]
    pub fn xmlSAX2Reference ( ctx : * mut :: std :: os :: raw :: c_void , name : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2Characters" ]
    pub fn xmlSAX2Characters ( ctx : * mut :: std :: os :: raw :: c_void , ch : * const xmlChar , len : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2IgnorableWhitespace" ]
    pub fn xmlSAX2IgnorableWhitespace ( ctx : * mut :: std :: os :: raw :: c_void , ch : * const xmlChar , len : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2ProcessingInstruction" ]
    pub fn xmlSAX2ProcessingInstruction ( ctx : * mut :: std :: os :: raw :: c_void , target : * const xmlChar , data : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2Comment" ]
    pub fn xmlSAX2Comment ( ctx : * mut :: std :: os :: raw :: c_void , value : * const xmlChar , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2CDataBlock" ]
    pub fn xmlSAX2CDataBlock ( ctx : * mut :: std :: os :: raw :: c_void , value : * const xmlChar , len : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAXDefaultVersion" ]
    pub fn xmlSAXDefaultVersion ( version : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAXVersion" ]
    pub fn xmlSAXVersion ( hdlr : * mut xmlSAXHandler , version : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2InitDefaultSAXHandler" ]
    pub fn xmlSAX2InitDefaultSAXHandler ( hdlr : * mut xmlSAXHandler , warning : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2InitHtmlDefaultSAXHandler" ]
    pub fn xmlSAX2InitHtmlDefaultSAXHandler ( hdlr : * mut xmlSAXHandler , ) ;
} extern "C" {
    # [ link_name = "\u{1}_htmlDefaultSAXHandlerInit" ]
    pub fn htmlDefaultSAXHandlerInit ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAX2InitDocbDefaultSAXHandler" ]
    pub fn xmlSAX2InitDocbDefaultSAXHandler ( hdlr : * mut xmlSAXHandler , ) ;
} extern "C" {
    # [ link_name = "\u{1}_docbDefaultSAXHandlerInit" ]
    pub fn docbDefaultSAXHandlerInit ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDefaultSAXHandlerInit" ]
    pub fn xmlDefaultSAXHandlerInit ( ) ;
}
/// xmlFreeFunc:
/// @mem: an already allocated block of memory
///
/// Signature for a free() implementation.
pub type xmlFreeFunc = :: std :: option :: Option < unsafe extern "C" fn ( mem : * mut :: std :: os :: raw :: c_void ) > ;
/// xmlMallocFunc:
/// @size:  the size requested in bytes
///
/// Signature for a malloc() implementation.
///
/// Returns a pointer to the newly allocated block or NULL in case of error.
pub type xmlMallocFunc = :: std :: option :: Option < unsafe extern "C" fn ( size : usize ) -> * mut :: std :: os :: raw :: c_void > ;
/// xmlReallocFunc:
/// @mem: an already allocated block of memory
/// @size:  the new size requested in bytes
///
/// Signature for a realloc() implementation.
///
/// Returns a pointer to the newly reallocated block or NULL in case of error.
pub type xmlReallocFunc = :: std :: option :: Option < unsafe extern "C" fn ( mem : * mut :: std :: os :: raw :: c_void , size : usize ) -> * mut :: std :: os :: raw :: c_void > ;
/// xmlStrdupFunc:
/// @str: a zero terminated string
///
/// Signature for an strdup() implementation.
///
/// Returns the copy of the string or NULL in case of error.
pub type xmlStrdupFunc = :: std :: option :: Option < unsafe extern "C" fn ( str : * const :: std :: os :: raw :: c_char ) -> * mut :: std :: os :: raw :: c_char > ; extern "C" {
    # [ link_name = "\u{1}_xmlMemSetup" ]
    pub fn xmlMemSetup ( freeFunc : xmlFreeFunc , mallocFunc : xmlMallocFunc , reallocFunc : xmlReallocFunc , strdupFunc : xmlStrdupFunc , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlMemGet" ]
    pub fn xmlMemGet ( freeFunc : * mut xmlFreeFunc , mallocFunc : * mut xmlMallocFunc , reallocFunc : * mut xmlReallocFunc , strdupFunc : * mut xmlStrdupFunc , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGcMemSetup" ]
    pub fn xmlGcMemSetup ( freeFunc : xmlFreeFunc , mallocFunc : xmlMallocFunc , mallocAtomicFunc : xmlMallocFunc , reallocFunc : xmlReallocFunc , strdupFunc : xmlStrdupFunc , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGcMemGet" ]
    pub fn xmlGcMemGet ( freeFunc : * mut xmlFreeFunc , mallocFunc : * mut xmlMallocFunc , mallocAtomicFunc : * mut xmlMallocFunc , reallocFunc : * mut xmlReallocFunc , strdupFunc : * mut xmlStrdupFunc , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlInitMemory" ]
    pub fn xmlInitMemory ( ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCleanupMemory" ]
    pub fn xmlCleanupMemory ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlMemUsed" ]
    pub fn xmlMemUsed ( ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlMemBlocks" ]
    pub fn xmlMemBlocks ( ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlMemDisplay" ]
    pub fn xmlMemDisplay ( fp : * mut FILE , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlMemDisplayLast" ]
    pub fn xmlMemDisplayLast ( fp : * mut FILE , nbBytes : :: std :: os :: raw :: c_long , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlMemShow" ]
    pub fn xmlMemShow ( fp : * mut FILE , nr : :: std :: os :: raw :: c_int , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlMemoryDump" ]
    pub fn xmlMemoryDump ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlMemMalloc" ]
    pub fn xmlMemMalloc ( size : usize , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_xmlMemRealloc" ]
    pub fn xmlMemRealloc ( ptr : * mut :: std :: os :: raw :: c_void , size : usize , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_xmlMemFree" ]
    pub fn xmlMemFree ( ptr : * mut :: std :: os :: raw :: c_void , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlMemoryStrdup" ]
    pub fn xmlMemoryStrdup ( str : * const :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_xmlMallocLoc" ]
    pub fn xmlMallocLoc ( size : usize , file : * const :: std :: os :: raw :: c_char , line : :: std :: os :: raw :: c_int , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_xmlReallocLoc" ]
    pub fn xmlReallocLoc ( ptr : * mut :: std :: os :: raw :: c_void , size : usize , file : * const :: std :: os :: raw :: c_char , line : :: std :: os :: raw :: c_int , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_xmlMallocAtomicLoc" ]
    pub fn xmlMallocAtomicLoc ( size : usize , file : * const :: std :: os :: raw :: c_char , line : :: std :: os :: raw :: c_int , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_xmlMemStrdupLoc" ]
    pub fn xmlMemStrdupLoc ( str : * const :: std :: os :: raw :: c_char , file : * const :: std :: os :: raw :: c_char , line : :: std :: os :: raw :: c_int , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_xmlInitGlobals" ]
    pub fn xmlInitGlobals ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCleanupGlobals" ]
    pub fn xmlCleanupGlobals ( ) ;
}
/// xmlParserInputBufferCreateFilenameFunc:
/// @URI: the URI to read from
/// @enc: the requested source encoding
///
/// Signature for the function doing the lookup for a suitable input method
/// corresponding to an URI.
///
/// Returns the new xmlParserInputBufferPtr in case of success or NULL if no
/// method was found.
pub type xmlParserInputBufferCreateFilenameFunc = :: std :: option :: Option < unsafe extern "C" fn ( URI : * const :: std :: os :: raw :: c_char , enc : xmlCharEncoding ) -> xmlParserInputBufferPtr > ;
/// xmlOutputBufferCreateFilenameFunc:
/// @URI: the URI to write to
/// @enc: the requested target encoding
///
/// Signature for the function doing the lookup for a suitable output method
/// corresponding to an URI.
///
/// Returns the new xmlOutputBufferPtr in case of success or NULL if no
/// method was found.
pub type xmlOutputBufferCreateFilenameFunc = :: std :: option :: Option < unsafe extern "C" fn ( URI : * const :: std :: os :: raw :: c_char , encoder : xmlCharEncodingHandlerPtr , compression : :: std :: os :: raw :: c_int ) -> xmlOutputBufferPtr > ; extern "C" {
    # [ link_name = "\u{1}_xmlParserInputBufferCreateFilenameDefault" ]
    pub fn xmlParserInputBufferCreateFilenameDefault ( func : xmlParserInputBufferCreateFilenameFunc , ) -> xmlParserInputBufferCreateFilenameFunc ;
} extern "C" {
    # [ link_name = "\u{1}_xmlOutputBufferCreateFilenameDefault" ]
    pub fn xmlOutputBufferCreateFilenameDefault ( func : xmlOutputBufferCreateFilenameFunc , ) -> xmlOutputBufferCreateFilenameFunc ;
}
/// xmlRegisterNodeFunc:
/// @node: the current node
///
/// Signature for the registration callback of a created node
pub type xmlRegisterNodeFunc = :: std :: option :: Option < unsafe extern "C" fn ( node : xmlNodePtr ) > ;
/// xmlDeregisterNodeFunc:
/// @node: the current node
///
/// Signature for the deregistration callback of a discarded node
pub type xmlDeregisterNodeFunc = :: std :: option :: Option < unsafe extern "C" fn ( node : xmlNodePtr ) > ; pub type xmlGlobalState = _xmlGlobalState ; pub type xmlGlobalStatePtr = * mut xmlGlobalState ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlGlobalState { pub xmlParserVersion : * const :: std :: os :: raw :: c_char , pub xmlDefaultSAXLocator : xmlSAXLocator , pub xmlDefaultSAXHandler : xmlSAXHandlerV1 , pub docbDefaultSAXHandler : xmlSAXHandlerV1 , pub htmlDefaultSAXHandler : xmlSAXHandlerV1 , pub xmlFree : xmlFreeFunc , pub xmlMalloc : xmlMallocFunc , pub xmlMemStrdup : xmlStrdupFunc , pub xmlRealloc : xmlReallocFunc , pub xmlGenericError : xmlGenericErrorFunc , pub xmlStructuredError : xmlStructuredErrorFunc , pub xmlGenericErrorContext : * mut :: std :: os :: raw :: c_void , pub oldXMLWDcompatibility : :: std :: os :: raw :: c_int , pub xmlBufferAllocScheme : xmlBufferAllocationScheme , pub xmlDefaultBufferSize : :: std :: os :: raw :: c_int , pub xmlSubstituteEntitiesDefaultValue : :: std :: os :: raw :: c_int , pub xmlDoValidityCheckingDefaultValue : :: std :: os :: raw :: c_int , pub xmlGetWarningsDefaultValue : :: std :: os :: raw :: c_int , pub xmlKeepBlanksDefaultValue : :: std :: os :: raw :: c_int , pub xmlLineNumbersDefaultValue : :: std :: os :: raw :: c_int , pub xmlLoadExtDtdDefaultValue : :: std :: os :: raw :: c_int , pub xmlParserDebugEntities : :: std :: os :: raw :: c_int , pub xmlPedanticParserDefaultValue : :: std :: os :: raw :: c_int , pub xmlSaveNoEmptyTags : :: std :: os :: raw :: c_int , pub xmlIndentTreeOutput : :: std :: os :: raw :: c_int , pub xmlTreeIndentString : * const :: std :: os :: raw :: c_char , pub xmlRegisterNodeDefaultValue : xmlRegisterNodeFunc , pub xmlDeregisterNodeDefaultValue : xmlDeregisterNodeFunc , pub xmlMallocAtomic : xmlMallocFunc , pub xmlLastError : xmlError , pub xmlParserInputBufferCreateFilenameValue : xmlParserInputBufferCreateFilenameFunc , pub xmlOutputBufferCreateFilenameValue : xmlOutputBufferCreateFilenameFunc , pub xmlStructuredErrorContext : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout__xmlGlobalState ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlGlobalState > ( ) , 968usize , concat ! ( "Size of: " , stringify ! ( _xmlGlobalState ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlGlobalState > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlGlobalState ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlParserVersion as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlParserVersion ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlDefaultSAXLocator as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlDefaultSAXLocator ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlDefaultSAXHandler as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlDefaultSAXHandler ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . docbDefaultSAXHandler as * const _ as usize } , 264usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( docbDefaultSAXHandler ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . htmlDefaultSAXHandler as * const _ as usize } , 488usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( htmlDefaultSAXHandler ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlFree as * const _ as usize } , 712usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlFree ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlMalloc as * const _ as usize } , 720usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlMalloc ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlMemStrdup as * const _ as usize } , 728usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlMemStrdup ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlRealloc as * const _ as usize } , 736usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlRealloc ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlGenericError as * const _ as usize } , 744usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlGenericError ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlStructuredError as * const _ as usize } , 752usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlStructuredError ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlGenericErrorContext as * const _ as usize } , 760usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlGenericErrorContext ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . oldXMLWDcompatibility as * const _ as usize } , 768usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( oldXMLWDcompatibility ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlBufferAllocScheme as * const _ as usize } , 772usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlBufferAllocScheme ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlDefaultBufferSize as * const _ as usize } , 776usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlDefaultBufferSize ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlSubstituteEntitiesDefaultValue as * const _ as usize } , 780usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlSubstituteEntitiesDefaultValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlDoValidityCheckingDefaultValue as * const _ as usize } , 784usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlDoValidityCheckingDefaultValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlGetWarningsDefaultValue as * const _ as usize } , 788usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlGetWarningsDefaultValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlKeepBlanksDefaultValue as * const _ as usize } , 792usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlKeepBlanksDefaultValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlLineNumbersDefaultValue as * const _ as usize } , 796usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlLineNumbersDefaultValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlLoadExtDtdDefaultValue as * const _ as usize } , 800usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlLoadExtDtdDefaultValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlParserDebugEntities as * const _ as usize } , 804usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlParserDebugEntities ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlPedanticParserDefaultValue as * const _ as usize } , 808usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlPedanticParserDefaultValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlSaveNoEmptyTags as * const _ as usize } , 812usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlSaveNoEmptyTags ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlIndentTreeOutput as * const _ as usize } , 816usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlIndentTreeOutput ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlTreeIndentString as * const _ as usize } , 824usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlTreeIndentString ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlRegisterNodeDefaultValue as * const _ as usize } , 832usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlRegisterNodeDefaultValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlDeregisterNodeDefaultValue as * const _ as usize } , 840usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlDeregisterNodeDefaultValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlMallocAtomic as * const _ as usize } , 848usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlMallocAtomic ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlLastError as * const _ as usize } , 856usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlLastError ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlParserInputBufferCreateFilenameValue as * const _ as usize } , 944usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlParserInputBufferCreateFilenameValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlOutputBufferCreateFilenameValue as * const _ as usize } , 952usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlOutputBufferCreateFilenameValue ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlGlobalState ) ) . xmlStructuredErrorContext as * const _ as usize } , 960usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlGlobalState ) , "::" , stringify ! ( xmlStructuredErrorContext ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlMutex { _unused : [ u8 ; 0 ] } pub type xmlMutex = _xmlMutex ; pub type xmlMutexPtr = * mut xmlMutex ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlRMutex { _unused : [ u8 ; 0 ] } pub type xmlRMutex = _xmlRMutex ; pub type xmlRMutexPtr = * mut xmlRMutex ; extern "C" {
    # [ link_name = "\u{1}_xmlNewMutex" ]
    pub fn xmlNewMutex ( ) -> xmlMutexPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlMutexLock" ]
    pub fn xmlMutexLock ( tok : xmlMutexPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlMutexUnlock" ]
    pub fn xmlMutexUnlock ( tok : xmlMutexPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFreeMutex" ]
    pub fn xmlFreeMutex ( tok : xmlMutexPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewRMutex" ]
    pub fn xmlNewRMutex ( ) -> xmlRMutexPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRMutexLock" ]
    pub fn xmlRMutexLock ( tok : xmlRMutexPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRMutexUnlock" ]
    pub fn xmlRMutexUnlock ( tok : xmlRMutexPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFreeRMutex" ]
    pub fn xmlFreeRMutex ( tok : xmlRMutexPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlInitThreads" ]
    pub fn xmlInitThreads ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlLockLibrary" ]
    pub fn xmlLockLibrary ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlUnlockLibrary" ]
    pub fn xmlUnlockLibrary ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetThreadId" ]
    pub fn xmlGetThreadId ( ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlIsMainThread" ]
    pub fn xmlIsMainThread ( ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCleanupThreads" ]
    pub fn xmlCleanupThreads ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetGlobalState" ]
    pub fn xmlGetGlobalState ( ) -> xmlGlobalStatePtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlInitializeGlobalState" ]
    pub fn xmlInitializeGlobalState ( gs : xmlGlobalStatePtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlThrDefSetGenericErrorFunc" ]
    pub fn xmlThrDefSetGenericErrorFunc ( ctx : * mut :: std :: os :: raw :: c_void , handler : xmlGenericErrorFunc , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlThrDefSetStructuredErrorFunc" ]
    pub fn xmlThrDefSetStructuredErrorFunc ( ctx : * mut :: std :: os :: raw :: c_void , handler : xmlStructuredErrorFunc , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRegisterNodeDefault" ]
    pub fn xmlRegisterNodeDefault ( func : xmlRegisterNodeFunc , ) -> xmlRegisterNodeFunc ;
} extern "C" {
    # [ link_name = "\u{1}_xmlThrDefRegisterNodeDefault" ]
    pub fn xmlThrDefRegisterNodeDefault ( func : xmlRegisterNodeFunc , ) -> xmlRegisterNodeFunc ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDeregisterNodeDefault" ]
    pub fn xmlDeregisterNodeDefault ( func : xmlDeregisterNodeFunc , ) -> xmlDeregisterNodeFunc ;
} extern "C" {
    # [ link_name = "\u{1}_xmlThrDefDeregisterNodeDefault" ]
    pub fn xmlThrDefDeregisterNodeDefault ( func : xmlDeregisterNodeFunc , ) -> xmlDeregisterNodeFunc ;
} extern "C" {
    # [ link_name = "\u{1}_xmlThrDefOutputBufferCreateFilenameDefault" ]
    pub fn xmlThrDefOutputBufferCreateFilenameDefault ( func : xmlOutputBufferCreateFilenameFunc , ) -> xmlOutputBufferCreateFilenameFunc ;
} extern "C" {
    # [ link_name = "\u{1}_xmlThrDefParserInputBufferCreateFilenameDefault" ]
    pub fn xmlThrDefParserInputBufferCreateFilenameDefault ( func : xmlParserInputBufferCreateFilenameFunc , ) -> xmlParserInputBufferCreateFilenameFunc ;
} extern "C" {
    # [ link_name = "\u{1}_xmlMalloc" ]
    pub static mut  xmlMalloc  :  xmlMallocFunc ;
} extern "C" {
    # [ link_name = "\u{1}_xmlMallocAtomic" ]
    pub static mut  xmlMallocAtomic  :  xmlMallocFunc ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRealloc" ]
    pub static mut  xmlRealloc  :  xmlReallocFunc ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFree" ]
    pub static mut  xmlFree  :  xmlFreeFunc ;
} extern "C" {
    # [ link_name = "\u{1}_xmlMemStrdup" ]
    pub static mut  xmlMemStrdup  :  xmlStrdupFunc ;
} extern "C" {
    # [ link_name = "\u{1}___docbDefaultSAXHandler" ]
    pub fn __docbDefaultSAXHandler ( ) -> * mut xmlSAXHandlerV1 ;
} extern "C" {
    # [ link_name = "\u{1}_docbDefaultSAXHandler" ]
    pub static mut  docbDefaultSAXHandler  :  xmlSAXHandlerV1 ;
} extern "C" {
    # [ link_name = "\u{1}___htmlDefaultSAXHandler" ]
    pub fn __htmlDefaultSAXHandler ( ) -> * mut xmlSAXHandlerV1 ;
} extern "C" {
    # [ link_name = "\u{1}_htmlDefaultSAXHandler" ]
    pub static mut  htmlDefaultSAXHandler  :  xmlSAXHandlerV1 ;
} extern "C" {
    # [ link_name = "\u{1}___xmlLastError" ]
    pub fn __xmlLastError ( ) -> * mut xmlError ;
} extern "C" {
    # [ link_name = "\u{1}_xmlLastError" ]
    pub static mut  xmlLastError  :  xmlError ;
} extern "C" {
    # [ link_name = "\u{1}___oldXMLWDcompatibility" ]
    pub fn __oldXMLWDcompatibility ( ) -> * mut :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_oldXMLWDcompatibility" ]
    pub static mut  oldXMLWDcompatibility  :  :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}___xmlBufferAllocScheme" ]
    pub fn __xmlBufferAllocScheme ( ) -> * mut xmlBufferAllocationScheme ;
} extern "C" {
    # [ link_name = "\u{1}_xmlBufferAllocScheme" ]
    pub static mut  xmlBufferAllocScheme  :  xmlBufferAllocationScheme ;
} extern "C" {
    # [ link_name = "\u{1}_xmlThrDefBufferAllocScheme" ]
    pub fn xmlThrDefBufferAllocScheme ( v : xmlBufferAllocationScheme , ) -> xmlBufferAllocationScheme ;
} extern "C" {
    # [ link_name = "\u{1}___xmlDefaultBufferSize" ]
    pub fn __xmlDefaultBufferSize ( ) -> * mut :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDefaultBufferSize" ]
    pub static mut  xmlDefaultBufferSize  :  :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlThrDefDefaultBufferSize" ]
    pub fn xmlThrDefDefaultBufferSize ( v : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}___xmlDefaultSAXHandler" ]
    pub fn __xmlDefaultSAXHandler ( ) -> * mut xmlSAXHandlerV1 ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDefaultSAXHandler" ]
    pub static mut  xmlDefaultSAXHandler  :  xmlSAXHandlerV1 ;
} extern "C" {
    # [ link_name = "\u{1}___xmlDefaultSAXLocator" ]
    pub fn __xmlDefaultSAXLocator ( ) -> * mut xmlSAXLocator ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDefaultSAXLocator" ]
    pub static mut  xmlDefaultSAXLocator  :  xmlSAXLocator ;
} extern "C" {
    # [ link_name = "\u{1}___xmlDoValidityCheckingDefaultValue" ]
    pub fn __xmlDoValidityCheckingDefaultValue ( ) -> * mut :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDoValidityCheckingDefaultValue" ]
    pub static mut  xmlDoValidityCheckingDefaultValue  :  :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlThrDefDoValidityCheckingDefaultValue" ]
    pub fn xmlThrDefDoValidityCheckingDefaultValue ( v : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}___xmlGenericError" ]
    pub fn __xmlGenericError ( ) -> * mut xmlGenericErrorFunc ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGenericError" ]
    pub static mut  xmlGenericError  :  xmlGenericErrorFunc ;
} extern "C" {
    # [ link_name = "\u{1}___xmlStructuredError" ]
    pub fn __xmlStructuredError ( ) -> * mut xmlStructuredErrorFunc ;
} extern "C" {
    # [ link_name = "\u{1}_xmlStructuredError" ]
    pub static mut  xmlStructuredError  :  xmlStructuredErrorFunc ;
} extern "C" {
    # [ link_name = "\u{1}___xmlGenericErrorContext" ]
    pub fn __xmlGenericErrorContext ( ) -> * mut * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGenericErrorContext" ]
    pub static mut  xmlGenericErrorContext  :  * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}___xmlStructuredErrorContext" ]
    pub fn __xmlStructuredErrorContext ( ) -> * mut * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_xmlStructuredErrorContext" ]
    pub static mut  xmlStructuredErrorContext  :  * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}___xmlGetWarningsDefaultValue" ]
    pub fn __xmlGetWarningsDefaultValue ( ) -> * mut :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetWarningsDefaultValue" ]
    pub static mut  xmlGetWarningsDefaultValue  :  :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlThrDefGetWarningsDefaultValue" ]
    pub fn xmlThrDefGetWarningsDefaultValue ( v : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}___xmlIndentTreeOutput" ]
    pub fn __xmlIndentTreeOutput ( ) -> * mut :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlIndentTreeOutput" ]
    pub static mut  xmlIndentTreeOutput  :  :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlThrDefIndentTreeOutput" ]
    pub fn xmlThrDefIndentTreeOutput ( v : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}___xmlTreeIndentString" ]
    pub fn __xmlTreeIndentString ( ) -> * mut * const :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_xmlTreeIndentString" ]
    pub static mut  xmlTreeIndentString  :  * const :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_xmlThrDefTreeIndentString" ]
    pub fn xmlThrDefTreeIndentString ( v : * const :: std :: os :: raw :: c_char , ) -> * const :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}___xmlKeepBlanksDefaultValue" ]
    pub fn __xmlKeepBlanksDefaultValue ( ) -> * mut :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlKeepBlanksDefaultValue" ]
    pub static mut  xmlKeepBlanksDefaultValue  :  :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlThrDefKeepBlanksDefaultValue" ]
    pub fn xmlThrDefKeepBlanksDefaultValue ( v : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}___xmlLineNumbersDefaultValue" ]
    pub fn __xmlLineNumbersDefaultValue ( ) -> * mut :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlLineNumbersDefaultValue" ]
    pub static mut  xmlLineNumbersDefaultValue  :  :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlThrDefLineNumbersDefaultValue" ]
    pub fn xmlThrDefLineNumbersDefaultValue ( v : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}___xmlLoadExtDtdDefaultValue" ]
    pub fn __xmlLoadExtDtdDefaultValue ( ) -> * mut :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlLoadExtDtdDefaultValue" ]
    pub static mut  xmlLoadExtDtdDefaultValue  :  :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlThrDefLoadExtDtdDefaultValue" ]
    pub fn xmlThrDefLoadExtDtdDefaultValue ( v : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}___xmlParserDebugEntities" ]
    pub fn __xmlParserDebugEntities ( ) -> * mut :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserDebugEntities" ]
    pub static mut  xmlParserDebugEntities  :  :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlThrDefParserDebugEntities" ]
    pub fn xmlThrDefParserDebugEntities ( v : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}___xmlParserVersion" ]
    pub fn __xmlParserVersion ( ) -> * mut * const :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserVersion" ]
    pub static mut  xmlParserVersion  :  * const :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}___xmlPedanticParserDefaultValue" ]
    pub fn __xmlPedanticParserDefaultValue ( ) -> * mut :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlPedanticParserDefaultValue" ]
    pub static mut  xmlPedanticParserDefaultValue  :  :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlThrDefPedanticParserDefaultValue" ]
    pub fn xmlThrDefPedanticParserDefaultValue ( v : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}___xmlSaveNoEmptyTags" ]
    pub fn __xmlSaveNoEmptyTags ( ) -> * mut :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSaveNoEmptyTags" ]
    pub static mut  xmlSaveNoEmptyTags  :  :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlThrDefSaveNoEmptyTags" ]
    pub fn xmlThrDefSaveNoEmptyTags ( v : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}___xmlSubstituteEntitiesDefaultValue" ]
    pub fn __xmlSubstituteEntitiesDefaultValue ( ) -> * mut :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSubstituteEntitiesDefaultValue" ]
    pub static mut  xmlSubstituteEntitiesDefaultValue  :  :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlThrDefSubstituteEntitiesDefaultValue" ]
    pub fn xmlThrDefSubstituteEntitiesDefaultValue ( v : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}___xmlRegisterNodeDefaultValue" ]
    pub fn __xmlRegisterNodeDefaultValue ( ) -> * mut xmlRegisterNodeFunc ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRegisterNodeDefaultValue" ]
    pub static mut  xmlRegisterNodeDefaultValue  :  xmlRegisterNodeFunc ;
} extern "C" {
    # [ link_name = "\u{1}___xmlDeregisterNodeDefaultValue" ]
    pub fn __xmlDeregisterNodeDefaultValue ( ) -> * mut xmlDeregisterNodeFunc ;
} extern "C" {
    # [ link_name = "\u{1}_xmlDeregisterNodeDefaultValue" ]
    pub static mut  xmlDeregisterNodeDefaultValue  :  xmlDeregisterNodeFunc ;
} extern "C" {
    # [ link_name = "\u{1}___xmlParserInputBufferCreateFilenameValue" ]
    pub fn __xmlParserInputBufferCreateFilenameValue ( ) -> * mut xmlParserInputBufferCreateFilenameFunc ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserInputBufferCreateFilenameValue" ]
    pub static mut  xmlParserInputBufferCreateFilenameValue  :  xmlParserInputBufferCreateFilenameFunc ;
} extern "C" {
    # [ link_name = "\u{1}___xmlOutputBufferCreateFilenameValue" ]
    pub fn __xmlOutputBufferCreateFilenameValue ( ) -> * mut xmlOutputBufferCreateFilenameFunc ;
} extern "C" {
    # [ link_name = "\u{1}_xmlOutputBufferCreateFilenameValue" ]
    pub static mut  xmlOutputBufferCreateFilenameValue  :  xmlOutputBufferCreateFilenameFunc ;
} # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlParserInputBuffer { pub context : * mut :: std :: os :: raw :: c_void , pub readcallback : xmlInputReadCallback , pub closecallback : xmlInputCloseCallback , pub encoder : xmlCharEncodingHandlerPtr , pub buffer : xmlBufPtr , pub raw : xmlBufPtr , pub compressed : :: std :: os :: raw :: c_int , pub error : :: std :: os :: raw :: c_int , pub rawconsumed : :: std :: os :: raw :: c_ulong , } # [ test ] fn bindgen_test_layout__xmlParserInputBuffer ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlParserInputBuffer > ( ) , 64usize , concat ! ( "Size of: " , stringify ! ( _xmlParserInputBuffer ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlParserInputBuffer > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlParserInputBuffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInputBuffer ) ) . context as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInputBuffer ) , "::" , stringify ! ( context ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInputBuffer ) ) . readcallback as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInputBuffer ) , "::" , stringify ! ( readcallback ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInputBuffer ) ) . closecallback as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInputBuffer ) , "::" , stringify ! ( closecallback ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInputBuffer ) ) . encoder as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInputBuffer ) , "::" , stringify ! ( encoder ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInputBuffer ) ) . buffer as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInputBuffer ) , "::" , stringify ! ( buffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInputBuffer ) ) . raw as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInputBuffer ) , "::" , stringify ! ( raw ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInputBuffer ) ) . compressed as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInputBuffer ) , "::" , stringify ! ( compressed ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInputBuffer ) ) . error as * const _ as usize } , 52usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInputBuffer ) , "::" , stringify ! ( error ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlParserInputBuffer ) ) . rawconsumed as * const _ as usize } , 56usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlParserInputBuffer ) , "::" , stringify ! ( rawconsumed ) ) ) ; } # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct _xmlOutputBuffer { pub context : * mut :: std :: os :: raw :: c_void , pub writecallback : xmlOutputWriteCallback , pub closecallback : xmlOutputCloseCallback , pub encoder : xmlCharEncodingHandlerPtr , pub buffer : xmlBufPtr , pub conv : xmlBufPtr , pub written : :: std :: os :: raw :: c_int , pub error : :: std :: os :: raw :: c_int , } # [ test ] fn bindgen_test_layout__xmlOutputBuffer ( ) { assert_eq ! ( :: std :: mem :: size_of :: < _xmlOutputBuffer > ( ) , 56usize , concat ! ( "Size of: " , stringify ! ( _xmlOutputBuffer ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < _xmlOutputBuffer > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( _xmlOutputBuffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlOutputBuffer ) ) . context as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlOutputBuffer ) , "::" , stringify ! ( context ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlOutputBuffer ) ) . writecallback as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlOutputBuffer ) , "::" , stringify ! ( writecallback ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlOutputBuffer ) ) . closecallback as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlOutputBuffer ) , "::" , stringify ! ( closecallback ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlOutputBuffer ) ) . encoder as * const _ as usize } , 24usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlOutputBuffer ) , "::" , stringify ! ( encoder ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlOutputBuffer ) ) . buffer as * const _ as usize } , 32usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlOutputBuffer ) , "::" , stringify ! ( buffer ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlOutputBuffer ) ) . conv as * const _ as usize } , 40usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlOutputBuffer ) , "::" , stringify ! ( conv ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlOutputBuffer ) ) . written as * const _ as usize } , 48usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlOutputBuffer ) , "::" , stringify ! ( written ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const _xmlOutputBuffer ) ) . error as * const _ as usize } , 52usize , concat ! ( "Alignment of field: " , stringify ! ( _xmlOutputBuffer ) , "::" , stringify ! ( error ) ) ) ; } extern "C" {
    # [ link_name = "\u{1}_xmlCleanupInputCallbacks" ]
    pub fn xmlCleanupInputCallbacks ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlPopInputCallbacks" ]
    pub fn xmlPopInputCallbacks ( ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRegisterDefaultInputCallbacks" ]
    pub fn xmlRegisterDefaultInputCallbacks ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAllocParserInputBuffer" ]
    pub fn xmlAllocParserInputBuffer ( enc : xmlCharEncoding , ) -> xmlParserInputBufferPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserInputBufferCreateFilename" ]
    pub fn xmlParserInputBufferCreateFilename ( URI : * const :: std :: os :: raw :: c_char , enc : xmlCharEncoding , ) -> xmlParserInputBufferPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserInputBufferCreateFile" ]
    pub fn xmlParserInputBufferCreateFile ( file : * mut FILE , enc : xmlCharEncoding , ) -> xmlParserInputBufferPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserInputBufferCreateFd" ]
    pub fn xmlParserInputBufferCreateFd ( fd : :: std :: os :: raw :: c_int , enc : xmlCharEncoding , ) -> xmlParserInputBufferPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserInputBufferCreateMem" ]
    pub fn xmlParserInputBufferCreateMem ( mem : * const :: std :: os :: raw :: c_char , size : :: std :: os :: raw :: c_int , enc : xmlCharEncoding , ) -> xmlParserInputBufferPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserInputBufferCreateStatic" ]
    pub fn xmlParserInputBufferCreateStatic ( mem : * const :: std :: os :: raw :: c_char , size : :: std :: os :: raw :: c_int , enc : xmlCharEncoding , ) -> xmlParserInputBufferPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserInputBufferCreateIO" ]
    pub fn xmlParserInputBufferCreateIO ( ioread : xmlInputReadCallback , ioclose : xmlInputCloseCallback , ioctx : * mut :: std :: os :: raw :: c_void , enc : xmlCharEncoding , ) -> xmlParserInputBufferPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserInputBufferRead" ]
    pub fn xmlParserInputBufferRead ( in_ : xmlParserInputBufferPtr , len : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserInputBufferGrow" ]
    pub fn xmlParserInputBufferGrow ( in_ : xmlParserInputBufferPtr , len : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserInputBufferPush" ]
    pub fn xmlParserInputBufferPush ( in_ : xmlParserInputBufferPtr , len : :: std :: os :: raw :: c_int , buf : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFreeParserInputBuffer" ]
    pub fn xmlFreeParserInputBuffer ( in_ : xmlParserInputBufferPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserGetDirectory" ]
    pub fn xmlParserGetDirectory ( filename : * const :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_char ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRegisterInputCallbacks" ]
    pub fn xmlRegisterInputCallbacks ( matchFunc : xmlInputMatchCallback , openFunc : xmlInputOpenCallback , readFunc : xmlInputReadCallback , closeFunc : xmlInputCloseCallback , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}___xmlParserInputBufferCreateFilename" ]
    pub fn __xmlParserInputBufferCreateFilename ( URI : * const :: std :: os :: raw :: c_char , enc : xmlCharEncoding , ) -> xmlParserInputBufferPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCleanupOutputCallbacks" ]
    pub fn xmlCleanupOutputCallbacks ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRegisterDefaultOutputCallbacks" ]
    pub fn xmlRegisterDefaultOutputCallbacks ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlAllocOutputBuffer" ]
    pub fn xmlAllocOutputBuffer ( encoder : xmlCharEncodingHandlerPtr , ) -> xmlOutputBufferPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlOutputBufferCreateFilename" ]
    pub fn xmlOutputBufferCreateFilename ( URI : * const :: std :: os :: raw :: c_char , encoder : xmlCharEncodingHandlerPtr , compression : :: std :: os :: raw :: c_int , ) -> xmlOutputBufferPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlOutputBufferCreateFile" ]
    pub fn xmlOutputBufferCreateFile ( file : * mut FILE , encoder : xmlCharEncodingHandlerPtr , ) -> xmlOutputBufferPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlOutputBufferCreateBuffer" ]
    pub fn xmlOutputBufferCreateBuffer ( buffer : xmlBufferPtr , encoder : xmlCharEncodingHandlerPtr , ) -> xmlOutputBufferPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlOutputBufferCreateFd" ]
    pub fn xmlOutputBufferCreateFd ( fd : :: std :: os :: raw :: c_int , encoder : xmlCharEncodingHandlerPtr , ) -> xmlOutputBufferPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlOutputBufferCreateIO" ]
    pub fn xmlOutputBufferCreateIO ( iowrite : xmlOutputWriteCallback , ioclose : xmlOutputCloseCallback , ioctx : * mut :: std :: os :: raw :: c_void , encoder : xmlCharEncodingHandlerPtr , ) -> xmlOutputBufferPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlOutputBufferGetContent" ]
    pub fn xmlOutputBufferGetContent ( out : xmlOutputBufferPtr , ) -> * const xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlOutputBufferGetSize" ]
    pub fn xmlOutputBufferGetSize ( out : xmlOutputBufferPtr , ) -> usize ;
} extern "C" {
    # [ link_name = "\u{1}_xmlOutputBufferWrite" ]
    pub fn xmlOutputBufferWrite ( out : xmlOutputBufferPtr , len : :: std :: os :: raw :: c_int , buf : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlOutputBufferWriteString" ]
    pub fn xmlOutputBufferWriteString ( out : xmlOutputBufferPtr , str : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlOutputBufferWriteEscape" ]
    pub fn xmlOutputBufferWriteEscape ( out : xmlOutputBufferPtr , str : * const xmlChar , escaping : xmlCharEncodingOutputFunc , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlOutputBufferFlush" ]
    pub fn xmlOutputBufferFlush ( out : xmlOutputBufferPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlOutputBufferClose" ]
    pub fn xmlOutputBufferClose ( out : xmlOutputBufferPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRegisterOutputCallbacks" ]
    pub fn xmlRegisterOutputCallbacks ( matchFunc : xmlOutputMatchCallback , openFunc : xmlOutputOpenCallback , writeFunc : xmlOutputWriteCallback , closeFunc : xmlOutputCloseCallback , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}___xmlOutputBufferCreateFilename" ]
    pub fn __xmlOutputBufferCreateFilename ( URI : * const :: std :: os :: raw :: c_char , encoder : xmlCharEncodingHandlerPtr , compression : :: std :: os :: raw :: c_int , ) -> xmlOutputBufferPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRegisterHTTPPostCallbacks" ]
    pub fn xmlRegisterHTTPPostCallbacks ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCheckHTTPInput" ]
    pub fn xmlCheckHTTPInput ( ctxt : xmlParserCtxtPtr , ret : xmlParserInputPtr , ) -> xmlParserInputPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNoNetExternalEntityLoader" ]
    pub fn xmlNoNetExternalEntityLoader ( URL : * const :: std :: os :: raw :: c_char , ID : * const :: std :: os :: raw :: c_char , ctxt : xmlParserCtxtPtr , ) -> xmlParserInputPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNormalizeWindowsPath" ]
    pub fn xmlNormalizeWindowsPath ( path : * const xmlChar , ) -> * mut xmlChar ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCheckFilename" ]
    pub fn xmlCheckFilename ( path : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {

    /// Default 'file://' protocol callbacks

    # [ link_name = "\u{1}_xmlFileMatch" ]
    pub fn xmlFileMatch ( filename : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFileOpen" ]
    pub fn xmlFileOpen ( filename : * const :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFileRead" ]
    pub fn xmlFileRead ( context : * mut :: std :: os :: raw :: c_void , buffer : * mut :: std :: os :: raw :: c_char , len : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFileClose" ]
    pub fn xmlFileClose ( context : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlIOHTTPMatch" ]
    pub fn xmlIOHTTPMatch ( filename : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlIOHTTPOpen" ]
    pub fn xmlIOHTTPOpen ( filename : * const :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_xmlIOHTTPOpenW" ]
    pub fn xmlIOHTTPOpenW ( post_uri : * const :: std :: os :: raw :: c_char , compression : :: std :: os :: raw :: c_int , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_xmlIOHTTPRead" ]
    pub fn xmlIOHTTPRead ( context : * mut :: std :: os :: raw :: c_void , buffer : * mut :: std :: os :: raw :: c_char , len : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlIOHTTPClose" ]
    pub fn xmlIOHTTPClose ( context : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlIOFTPMatch" ]
    pub fn xmlIOFTPMatch ( filename : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlIOFTPOpen" ]
    pub fn xmlIOFTPOpen ( filename : * const :: std :: os :: raw :: c_char , ) -> * mut :: std :: os :: raw :: c_void ;
} extern "C" {
    # [ link_name = "\u{1}_xmlIOFTPRead" ]
    pub fn xmlIOFTPRead ( context : * mut :: std :: os :: raw :: c_void , buffer : * mut :: std :: os :: raw :: c_char , len : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlIOFTPClose" ]
    pub fn xmlIOFTPClose ( context : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlInitParser" ]
    pub fn xmlInitParser ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCleanupParser" ]
    pub fn xmlCleanupParser ( ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserInputRead" ]
    pub fn xmlParserInputRead ( in_ : xmlParserInputPtr , len : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserInputGrow" ]
    pub fn xmlParserInputGrow ( in_ : xmlParserInputPtr , len : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParseDoc" ]
    pub fn xmlParseDoc ( cur : * const xmlChar , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParseFile" ]
    pub fn xmlParseFile ( filename : * const :: std :: os :: raw :: c_char , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParseMemory" ]
    pub fn xmlParseMemory ( buffer : * const :: std :: os :: raw :: c_char , size : :: std :: os :: raw :: c_int , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSubstituteEntitiesDefault" ]
    pub fn xmlSubstituteEntitiesDefault ( val : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlKeepBlanksDefault" ]
    pub fn xmlKeepBlanksDefault ( val : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlStopParser" ]
    pub fn xmlStopParser ( ctxt : xmlParserCtxtPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlPedanticParserDefault" ]
    pub fn xmlPedanticParserDefault ( val : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlLineNumbersDefault" ]
    pub fn xmlLineNumbersDefault ( val : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRecoverDoc" ]
    pub fn xmlRecoverDoc ( cur : * const xmlChar , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRecoverMemory" ]
    pub fn xmlRecoverMemory ( buffer : * const :: std :: os :: raw :: c_char , size : :: std :: os :: raw :: c_int , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlRecoverFile" ]
    pub fn xmlRecoverFile ( filename : * const :: std :: os :: raw :: c_char , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParseDocument" ]
    pub fn xmlParseDocument ( ctxt : xmlParserCtxtPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParseExtParsedEnt" ]
    pub fn xmlParseExtParsedEnt ( ctxt : xmlParserCtxtPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAXUserParseFile" ]
    pub fn xmlSAXUserParseFile ( sax : xmlSAXHandlerPtr , user_data : * mut :: std :: os :: raw :: c_void , filename : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAXUserParseMemory" ]
    pub fn xmlSAXUserParseMemory ( sax : xmlSAXHandlerPtr , user_data : * mut :: std :: os :: raw :: c_void , buffer : * const :: std :: os :: raw :: c_char , size : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAXParseDoc" ]
    pub fn xmlSAXParseDoc ( sax : xmlSAXHandlerPtr , cur : * const xmlChar , recovery : :: std :: os :: raw :: c_int , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAXParseMemory" ]
    pub fn xmlSAXParseMemory ( sax : xmlSAXHandlerPtr , buffer : * const :: std :: os :: raw :: c_char , size : :: std :: os :: raw :: c_int , recovery : :: std :: os :: raw :: c_int , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAXParseMemoryWithData" ]
    pub fn xmlSAXParseMemoryWithData ( sax : xmlSAXHandlerPtr , buffer : * const :: std :: os :: raw :: c_char , size : :: std :: os :: raw :: c_int , recovery : :: std :: os :: raw :: c_int , data : * mut :: std :: os :: raw :: c_void , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAXParseFile" ]
    pub fn xmlSAXParseFile ( sax : xmlSAXHandlerPtr , filename : * const :: std :: os :: raw :: c_char , recovery : :: std :: os :: raw :: c_int , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAXParseFileWithData" ]
    pub fn xmlSAXParseFileWithData ( sax : xmlSAXHandlerPtr , filename : * const :: std :: os :: raw :: c_char , recovery : :: std :: os :: raw :: c_int , data : * mut :: std :: os :: raw :: c_void , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAXParseEntity" ]
    pub fn xmlSAXParseEntity ( sax : xmlSAXHandlerPtr , filename : * const :: std :: os :: raw :: c_char , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParseEntity" ]
    pub fn xmlParseEntity ( filename : * const :: std :: os :: raw :: c_char , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSAXParseDTD" ]
    pub fn xmlSAXParseDTD ( sax : xmlSAXHandlerPtr , ExternalID : * const xmlChar , SystemID : * const xmlChar , ) -> xmlDtdPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParseDTD" ]
    pub fn xmlParseDTD ( ExternalID : * const xmlChar , SystemID : * const xmlChar , ) -> xmlDtdPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlIOParseDTD" ]
    pub fn xmlIOParseDTD ( sax : xmlSAXHandlerPtr , input : xmlParserInputBufferPtr , enc : xmlCharEncoding , ) -> xmlDtdPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParseBalancedChunkMemory" ]
    pub fn xmlParseBalancedChunkMemory ( doc : xmlDocPtr , sax : xmlSAXHandlerPtr , user_data : * mut :: std :: os :: raw :: c_void , depth : :: std :: os :: raw :: c_int , string : * const xmlChar , lst : * mut xmlNodePtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParseInNodeContext" ]
    pub fn xmlParseInNodeContext ( node : xmlNodePtr , data : * const :: std :: os :: raw :: c_char , datalen : :: std :: os :: raw :: c_int , options : :: std :: os :: raw :: c_int , lst : * mut xmlNodePtr , ) -> xmlParserErrors ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParseBalancedChunkMemoryRecover" ]
    pub fn xmlParseBalancedChunkMemoryRecover ( doc : xmlDocPtr , sax : xmlSAXHandlerPtr , user_data : * mut :: std :: os :: raw :: c_void , depth : :: std :: os :: raw :: c_int , string : * const xmlChar , lst : * mut xmlNodePtr , recover : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParseExternalEntity" ]
    pub fn xmlParseExternalEntity ( doc : xmlDocPtr , sax : xmlSAXHandlerPtr , user_data : * mut :: std :: os :: raw :: c_void , depth : :: std :: os :: raw :: c_int , URL : * const xmlChar , ID : * const xmlChar , lst : * mut xmlNodePtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParseCtxtExternalEntity" ]
    pub fn xmlParseCtxtExternalEntity ( ctx : xmlParserCtxtPtr , URL : * const xmlChar , ID : * const xmlChar , lst : * mut xmlNodePtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewParserCtxt" ]
    pub fn xmlNewParserCtxt ( ) -> xmlParserCtxtPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlInitParserCtxt" ]
    pub fn xmlInitParserCtxt ( ctxt : xmlParserCtxtPtr , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlClearParserCtxt" ]
    pub fn xmlClearParserCtxt ( ctxt : xmlParserCtxtPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlFreeParserCtxt" ]
    pub fn xmlFreeParserCtxt ( ctxt : xmlParserCtxtPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSetupParserForBuffer" ]
    pub fn xmlSetupParserForBuffer ( ctxt : xmlParserCtxtPtr , buffer : * const xmlChar , filename : * const :: std :: os :: raw :: c_char , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCreateDocParserCtxt" ]
    pub fn xmlCreateDocParserCtxt ( cur : * const xmlChar , ) -> xmlParserCtxtPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetFeaturesList" ]
    pub fn xmlGetFeaturesList ( len : * mut :: std :: os :: raw :: c_int , result : * mut * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetFeature" ]
    pub fn xmlGetFeature ( ctxt : xmlParserCtxtPtr , name : * const :: std :: os :: raw :: c_char , result : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSetFeature" ]
    pub fn xmlSetFeature ( ctxt : xmlParserCtxtPtr , name : * const :: std :: os :: raw :: c_char , value : * mut :: std :: os :: raw :: c_void , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCreatePushParserCtxt" ]
    pub fn xmlCreatePushParserCtxt ( sax : xmlSAXHandlerPtr , user_data : * mut :: std :: os :: raw :: c_void , chunk : * const :: std :: os :: raw :: c_char , size : :: std :: os :: raw :: c_int , filename : * const :: std :: os :: raw :: c_char , ) -> xmlParserCtxtPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParseChunk" ]
    pub fn xmlParseChunk ( ctxt : xmlParserCtxtPtr , chunk : * const :: std :: os :: raw :: c_char , size : :: std :: os :: raw :: c_int , terminate : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCreateIOParserCtxt" ]
    pub fn xmlCreateIOParserCtxt ( sax : xmlSAXHandlerPtr , user_data : * mut :: std :: os :: raw :: c_void , ioread : xmlInputReadCallback , ioclose : xmlInputCloseCallback , ioctx : * mut :: std :: os :: raw :: c_void , enc : xmlCharEncoding , ) -> xmlParserCtxtPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlNewIOInputStream" ]
    pub fn xmlNewIOInputStream ( ctxt : xmlParserCtxtPtr , input : xmlParserInputBufferPtr , enc : xmlCharEncoding , ) -> xmlParserInputPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserFindNodeInfo" ]
    pub fn xmlParserFindNodeInfo ( ctxt : xmlParserCtxtPtr , node : xmlNodePtr , ) -> * const xmlParserNodeInfo ;
} extern "C" {
    # [ link_name = "\u{1}_xmlInitNodeInfoSeq" ]
    pub fn xmlInitNodeInfoSeq ( seq : xmlParserNodeInfoSeqPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlClearNodeInfoSeq" ]
    pub fn xmlClearNodeInfoSeq ( seq : xmlParserNodeInfoSeqPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserFindNodeInfoIndex" ]
    pub fn xmlParserFindNodeInfoIndex ( seq : xmlParserNodeInfoSeqPtr , node : xmlNodePtr , ) -> :: std :: os :: raw :: c_ulong ;
} extern "C" {
    # [ link_name = "\u{1}_xmlParserAddNodeInfo" ]
    pub fn xmlParserAddNodeInfo ( ctxt : xmlParserCtxtPtr , info : xmlParserNodeInfoPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlSetExternalEntityLoader" ]
    pub fn xmlSetExternalEntityLoader ( f : xmlExternalEntityLoader , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlGetExternalEntityLoader" ]
    pub fn xmlGetExternalEntityLoader ( ) -> xmlExternalEntityLoader ;
} extern "C" {
    # [ link_name = "\u{1}_xmlLoadExternalEntity" ]
    pub fn xmlLoadExternalEntity ( URL : * const :: std :: os :: raw :: c_char , ID : * const :: std :: os :: raw :: c_char , ctxt : xmlParserCtxtPtr , ) -> xmlParserInputPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlByteConsumed" ]
    pub fn xmlByteConsumed ( ctxt : xmlParserCtxtPtr , ) -> :: std :: os :: raw :: c_long ;
} pub const xmlParserOption_XML_PARSE_RECOVER : xmlParserOption = 1 ; pub const xmlParserOption_XML_PARSE_NOENT : xmlParserOption = 2 ; pub const xmlParserOption_XML_PARSE_DTDLOAD : xmlParserOption = 4 ; pub const xmlParserOption_XML_PARSE_DTDATTR : xmlParserOption = 8 ; pub const xmlParserOption_XML_PARSE_DTDVALID : xmlParserOption = 16 ; pub const xmlParserOption_XML_PARSE_NOERROR : xmlParserOption = 32 ; pub const xmlParserOption_XML_PARSE_NOWARNING : xmlParserOption = 64 ; pub const xmlParserOption_XML_PARSE_PEDANTIC : xmlParserOption = 128 ; pub const xmlParserOption_XML_PARSE_NOBLANKS : xmlParserOption = 256 ; pub const xmlParserOption_XML_PARSE_SAX1 : xmlParserOption = 512 ; pub const xmlParserOption_XML_PARSE_XINCLUDE : xmlParserOption = 1024 ; pub const xmlParserOption_XML_PARSE_NONET : xmlParserOption = 2048 ; pub const xmlParserOption_XML_PARSE_NODICT : xmlParserOption = 4096 ; pub const xmlParserOption_XML_PARSE_NSCLEAN : xmlParserOption = 8192 ; pub const xmlParserOption_XML_PARSE_NOCDATA : xmlParserOption = 16384 ; pub const xmlParserOption_XML_PARSE_NOXINCNODE : xmlParserOption = 32768 ; pub const xmlParserOption_XML_PARSE_COMPACT : xmlParserOption = 65536 ; pub const xmlParserOption_XML_PARSE_OLD10 : xmlParserOption = 131072 ; pub const xmlParserOption_XML_PARSE_NOBASEFIX : xmlParserOption = 262144 ; pub const xmlParserOption_XML_PARSE_HUGE : xmlParserOption = 524288 ; pub const xmlParserOption_XML_PARSE_OLDSAX : xmlParserOption = 1048576 ; pub const xmlParserOption_XML_PARSE_IGNORE_ENC : xmlParserOption = 2097152 ; pub const xmlParserOption_XML_PARSE_BIG_LINES : xmlParserOption = 4194304 ; pub type xmlParserOption = :: std :: os :: raw :: c_uint ; extern "C" {
    # [ link_name = "\u{1}_xmlCtxtReset" ]
    pub fn xmlCtxtReset ( ctxt : xmlParserCtxtPtr , ) ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCtxtResetPush" ]
    pub fn xmlCtxtResetPush ( ctxt : xmlParserCtxtPtr , chunk : * const :: std :: os :: raw :: c_char , size : :: std :: os :: raw :: c_int , filename : * const :: std :: os :: raw :: c_char , encoding : * const :: std :: os :: raw :: c_char , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCtxtUseOptions" ]
    pub fn xmlCtxtUseOptions ( ctxt : xmlParserCtxtPtr , options : :: std :: os :: raw :: c_int , ) -> :: std :: os :: raw :: c_int ;
} extern "C" {
    # [ link_name = "\u{1}_xmlReadDoc" ]
    pub fn xmlReadDoc ( cur : * const xmlChar , URL : * const :: std :: os :: raw :: c_char , encoding : * const :: std :: os :: raw :: c_char , options : :: std :: os :: raw :: c_int , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlReadFile" ]
    pub fn xmlReadFile ( URL : * const :: std :: os :: raw :: c_char , encoding : * const :: std :: os :: raw :: c_char , options : :: std :: os :: raw :: c_int , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlReadMemory" ]
    pub fn xmlReadMemory ( buffer : * const :: std :: os :: raw :: c_char , size : :: std :: os :: raw :: c_int , URL : * const :: std :: os :: raw :: c_char , encoding : * const :: std :: os :: raw :: c_char , options : :: std :: os :: raw :: c_int , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlReadFd" ]
    pub fn xmlReadFd ( fd : :: std :: os :: raw :: c_int , URL : * const :: std :: os :: raw :: c_char , encoding : * const :: std :: os :: raw :: c_char , options : :: std :: os :: raw :: c_int , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlReadIO" ]
    pub fn xmlReadIO ( ioread : xmlInputReadCallback , ioclose : xmlInputCloseCallback , ioctx : * mut :: std :: os :: raw :: c_void , URL : * const :: std :: os :: raw :: c_char , encoding : * const :: std :: os :: raw :: c_char , options : :: std :: os :: raw :: c_int , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCtxtReadDoc" ]
    pub fn xmlCtxtReadDoc ( ctxt : xmlParserCtxtPtr , cur : * const xmlChar , URL : * const :: std :: os :: raw :: c_char , encoding : * const :: std :: os :: raw :: c_char , options : :: std :: os :: raw :: c_int , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCtxtReadFile" ]
    pub fn xmlCtxtReadFile ( ctxt : xmlParserCtxtPtr , filename : * const :: std :: os :: raw :: c_char , encoding : * const :: std :: os :: raw :: c_char , options : :: std :: os :: raw :: c_int , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCtxtReadMemory" ]
    pub fn xmlCtxtReadMemory ( ctxt : xmlParserCtxtPtr , buffer : * const :: std :: os :: raw :: c_char , size : :: std :: os :: raw :: c_int , URL : * const :: std :: os :: raw :: c_char , encoding : * const :: std :: os :: raw :: c_char , options : :: std :: os :: raw :: c_int , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCtxtReadFd" ]
    pub fn xmlCtxtReadFd ( ctxt : xmlParserCtxtPtr , fd : :: std :: os :: raw :: c_int , URL : * const :: std :: os :: raw :: c_char , encoding : * const :: std :: os :: raw :: c_char , options : :: std :: os :: raw :: c_int , ) -> xmlDocPtr ;
} extern "C" {
    # [ link_name = "\u{1}_xmlCtxtReadIO" ]
    pub fn xmlCtxtReadIO ( ctxt : xmlParserCtxtPtr , ioread : xmlInputReadCallback , ioclose : xmlInputCloseCallback , ioctx : * mut :: std :: os :: raw :: c_void , URL : * const :: std :: os :: raw :: c_char , encoding : * const :: std :: os :: raw :: c_char , options : :: std :: os :: raw :: c_int , ) -> xmlDocPtr ;
} pub const xmlFeature_XML_WITH_THREAD : xmlFeature = 1 ; pub const xmlFeature_XML_WITH_TREE : xmlFeature = 2 ; pub const xmlFeature_XML_WITH_OUTPUT : xmlFeature = 3 ; pub const xmlFeature_XML_WITH_PUSH : xmlFeature = 4 ; pub const xmlFeature_XML_WITH_READER : xmlFeature = 5 ; pub const xmlFeature_XML_WITH_PATTERN : xmlFeature = 6 ; pub const xmlFeature_XML_WITH_WRITER : xmlFeature = 7 ; pub const xmlFeature_XML_WITH_SAX1 : xmlFeature = 8 ; pub const xmlFeature_XML_WITH_FTP : xmlFeature = 9 ; pub const xmlFeature_XML_WITH_HTTP : xmlFeature = 10 ; pub const xmlFeature_XML_WITH_VALID : xmlFeature = 11 ; pub const xmlFeature_XML_WITH_HTML : xmlFeature = 12 ; pub const xmlFeature_XML_WITH_LEGACY : xmlFeature = 13 ; pub const xmlFeature_XML_WITH_C14N : xmlFeature = 14 ; pub const xmlFeature_XML_WITH_CATALOG : xmlFeature = 15 ; pub const xmlFeature_XML_WITH_XPATH : xmlFeature = 16 ; pub const xmlFeature_XML_WITH_XPTR : xmlFeature = 17 ; pub const xmlFeature_XML_WITH_XINCLUDE : xmlFeature = 18 ; pub const xmlFeature_XML_WITH_ICONV : xmlFeature = 19 ; pub const xmlFeature_XML_WITH_ISO8859X : xmlFeature = 20 ; pub const xmlFeature_XML_WITH_UNICODE : xmlFeature = 21 ; pub const xmlFeature_XML_WITH_REGEXP : xmlFeature = 22 ; pub const xmlFeature_XML_WITH_AUTOMATA : xmlFeature = 23 ; pub const xmlFeature_XML_WITH_EXPR : xmlFeature = 24 ; pub const xmlFeature_XML_WITH_SCHEMAS : xmlFeature = 25 ; pub const xmlFeature_XML_WITH_SCHEMATRON : xmlFeature = 26 ; pub const xmlFeature_XML_WITH_MODULES : xmlFeature = 27 ; pub const xmlFeature_XML_WITH_DEBUG : xmlFeature = 28 ; pub const xmlFeature_XML_WITH_DEBUG_MEM : xmlFeature = 29 ; pub const xmlFeature_XML_WITH_DEBUG_RUN : xmlFeature = 30 ; pub const xmlFeature_XML_WITH_ZLIB : xmlFeature = 31 ; pub const xmlFeature_XML_WITH_ICU : xmlFeature = 32 ; pub const xmlFeature_XML_WITH_LZMA : xmlFeature = 33 ; pub const xmlFeature_XML_WITH_NONE : xmlFeature = 99999 ; pub type xmlFeature = :: std :: os :: raw :: c_uint ; extern "C" {
    # [ link_name = "\u{1}_xmlHasFeature" ]
    pub fn xmlHasFeature ( feature : xmlFeature , ) -> :: std :: os :: raw :: c_int ;
} pub type __builtin_va_list = [ __va_list_tag ; 1usize ] ; # [ repr ( C ) ] # [ derive ( Debug , Copy , Clone ) ] pub struct __va_list_tag { pub gp_offset : :: std :: os :: raw :: c_uint , pub fp_offset : :: std :: os :: raw :: c_uint , pub overflow_arg_area : * mut :: std :: os :: raw :: c_void , pub reg_save_area : * mut :: std :: os :: raw :: c_void , } # [ test ] fn bindgen_test_layout___va_list_tag ( ) { assert_eq ! ( :: std :: mem :: size_of :: < __va_list_tag > ( ) , 24usize , concat ! ( "Size of: " , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( :: std :: mem :: align_of :: < __va_list_tag > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( __va_list_tag ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const _ as usize } , 0usize , concat ! ( "Alignment of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( gp_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const _ as usize } , 4usize , concat ! ( "Alignment of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( fp_offset ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as * const _ as usize } , 8usize , concat ! ( "Alignment of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( overflow_arg_area ) ) ) ; assert_eq ! ( unsafe { & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as * const _ as usize } , 16usize , concat ! ( "Alignment of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( reg_save_area ) ) ) ; }